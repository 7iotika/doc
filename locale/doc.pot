# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 2.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-03 12:08+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../doc/2.2/book/admin/backups.rst:39
msgid "Backups"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:41
msgid "Tarantool has an append-only storage architecture: it appends data to files but it never overwrites earlier data. The :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` removes old files after a checkpoint. You can prevent or delay the garbage collector's action by configuring the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with minimal overhead on database performance."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:54
msgid "backup.start() and backup.stop()"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:56
msgid "Two functions are helpful for backups in certain situations."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:58
msgid "``box.backup.start()`` informs the server that activities related to the removal of outdated backups must be suspended and returns a table with the names of snapshot and vinyl files that should be copied. Example:"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:62
msgid "tarantool> box.backup.start()\n"
"---\n"
"- - ./00000000000000000015.snap\n"
"  - ./00000000000000000000.vylog\n"
"  - ./513/0/00000000000000000002.index\n"
"  - ./513/0/00000000000000000002.run\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:74
msgid "To guarantee an opportunity to copy these files Tarantool will not delete them. But there will be no read-only mode and checkpoints will continue by schedule as usual."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:78
msgid "Later ``box.backup.stop()`` informs the server that normal operations may resume. Starting with Tarantool 1.10.1 there is a new optional argument, ``box.backup.start(n)``, where ``n`` indicates the checkpoint to use relative to the latest checkpoint -- for example ``n = 0`` means \"backup will be based on the latest checkpoint\", ``n = 1`` means \"backup will be based on the first checkpoint before the latest checkpoint (counting backwards)\", and so on, and the default value for ``n`` is zero."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:91
msgid "Hot backup (memtx)"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:93
msgid "This is a special case when there are only in-memory tables."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:95
msgid "The last :ref:`snapshot file <index-box_persistence>` is a backup of the entire database; and the :ref:`WAL <internals-wal>` files that are made after the last snapshot are incremental backups. Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:100
msgid "Use ``tar`` to make a (possibly compressed) copy of the latest .snap and .xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and :ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:104
msgid "If there is a security policy, encrypt the .tar file."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:106
msgid "Copy the .tar file to a safe place."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:108
msgid "Later, restoring the database is a matter of taking the .tar file and putting its contents back in the ``memtx_dir`` and ``wal_dir`` directories."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:115
msgid "Hot backup (vinyl/memtx)"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:117
msgid "Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and creates a folder for each database space. Dump and compaction processes are append-only and create new files. The Tarantool garbage collector may remove old files after each checkpoint."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:122
msgid "To take a mixed backup:"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:124
msgid "Issue :ref:`box.backup.start() <admin-backups-backup_start>` on the :ref:`administrative console <admin-security>`. This will suspend garbage collection till the next ``box.backup.stop()`` and will return a list of files to back up."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:129
msgid "Copy the files from the list to a safe location. This will include memtx snapshot files, vinyl run and index files, at a state consistent with the last checkpoint."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:133
msgid "Issue ``box.backup.stop()`` so the garbage collector can continue."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:139
msgid "Continuous remote backup (memtx)"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:141
msgid "The :ref:`replication <replication>` feature is useful for backup as well as for load balancing."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:144
msgid "Therefore taking a backup is a matter of ensuring that any given replica is up to date, and doing a cold backup on it. Since all the other replicas continue to operate, this is not a cold backup from the end user’s point of view. This could be done on a regular basis, with a ``cron`` job or with a Tarantool fiber."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:153
msgid "Continuous backup (memtx)"
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:155
msgid "The logged changes done since the last cold backup must be secured, while the system is running."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:158
msgid "For this purpose, you need a file copy utility that will do the copying remotely and continuously, copying only the parts of a write ahead log file that are changing. One such utility is `rsync <https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""

#: ../doc/2.2/book/admin/backups.rst:163
msgid "Alternatively, you need an ordinary file copy utility, but there should be frequent production of new snapshot files or new WAL files as changes occur, so that only the new files need to be copied."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:39
msgid "Bug reports"
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:41
msgid "If you found a bug in Tarantool, you’re doing us a favor by taking the time to tell us about it."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:44
msgid "Please create an issue at Tarantool repository at GitHub. We encourage you to include the following information:"
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:47
msgid "Steps needed to reproduce the bug, and an explanation why this differs from the expected behavior according to our manual. Please provide specific unique information. For example, instead of \"I can’t get certain information\", say \"box.space.x:delete() didn’t report what was deleted\"."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:52
msgid "Your operating system name and version, the Tarantool name and version, and any unusual details about your machine and its configuration."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:55
msgid "Related files like a :ref:`stack trace <admin-stack_traces>` or a Tarantool :ref:`log file <admin-logs>`."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:58
msgid "If this is a feature request or if it affects a special category of users, be sure to mention that."
msgstr ""

#: ../doc/2.2/book/admin/bug_reports.rst:61
msgid "Usually within one or two workdays a Tarantool team member will write an acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:39
msgid "Daemon supervision"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:45
msgid "Server signals"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:47
msgid "Tarantool processes these signals during the event loop in the transaction processor thread:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:56
msgid "Signal"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:56
#: ../doc/2.2/book/box/box_schema.rst:165
#: ../doc/2.2/book/box/box_space.rst:329
#: ../doc/2.2/book/box/data_model.rst:944
msgid "Effect"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:58
msgid "SIGHUP"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:58
msgid "May cause log file rotation. See the :ref:`example <cfg_logging-logging_example>` in reference on Tarantool logging parameters."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:62
msgid "SIGUSR1"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:62
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:65
msgid "SIGTERM"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:65
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:68
msgid "SIGINT (also known as keyboard interrupt)"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:68
msgid "May cause graceful shutdown."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:72
msgid "SIGKILL"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:72
msgid "Causes an immediate shutdown."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:75
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if Tarantool is executing a long-running procedure which prevents return to the event loop in the transaction processor thread."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:84
msgid "Automatic instance restart"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:86
msgid "On ``systemd``-enabled platforms, ``systemd`` automatically restarts all Tarantool instances in case of failure. To demonstrate it, let’s try to destroy an instance:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:90
msgid "$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:101
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:103
msgid "$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:108
msgid "Finally, let’s check the boot logs:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:110
msgid "$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:127
msgid "Core dumps"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:129
msgid "Tarantool makes a core dump if it receives any of the following signals: SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool crashes."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:132
msgid "On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves core dumps and stack traces in case of a crash. Here is a general \"how to\" for how to enable core dumps on a Unix system:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:136
msgid "Ensure session limits are configured to enable core dumps, i.e. say ``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a core dump may not be produced."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:140
msgid "Set a directory for writing core dumps to, and make sure that the directory is writable. On Linux, the directory path is set in a kernel parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:144
msgid "Make sure that core dumps include stack trace information. If you use a binary Tarantool distribution, this is automatic. If you build Tarantool from source, you will not get detailed information if you pass ``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:149
msgid "To simulate a crash, you can execute an illegal command against a Tarantool instance:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:152
msgid "$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed connection"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:159
msgid "Alternatively, if you know the process ID of the instance (here we refer to it as $PID), you can abort a Tarantool instance by running ``gdb`` debugger:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:162
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:166
msgid "or manually sending a SIGABRT signal:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:168
msgid "$ kill -SIGABRT $PID"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:174
msgid "To find out the process id of the instance ($PID), you can:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:176
msgid "look it up in the instance's :ref:`box.info.pid <box_introspection-box_info>`,"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:178
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:180
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:182
msgid "On a ``systemd-enabled`` system, to see the latest crashes of the Tarantool daemon, say:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:185
msgid "$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:192
msgid "To save a core dump into a file, say:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:194
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:202
msgid "Stack traces"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:204
msgid "Since Tarantool stores tuples in memory, core files may be large. For investigation, you normally don't need the whole file, but only a \"stack trace\" or \"backtrace\"."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:208
msgid "To save a stack trace into a file, say:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:210
msgid "$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c core> /tmp/tarantool_trace.txt"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:214
#: ../doc/2.2/book/admin/instance_config.rst:154
#: ../doc/2.2/book/replication/repl_bootstrap.rst:73
#: ../doc/2.2/dev_guide/developer_guidelines.rst:194
#: ../doc/2.2/reference/tarantoolctl.rst:58
msgid "where:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:216
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:217
msgid "\"core\" is the path to the core file, and"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:218
msgid "\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the stack trace."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:222
msgid "Occasionally, you may find that the trace file contains output without debug symbols – the lines will contain ”??” instead of names. If this happens, check the instructions on these Tarantool wiki pages: `How to debug core dump of stripped tarantool <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-stripped-tarantool>`_ and `How to debug core from different OS <https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-different-OS>`_."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:229
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:231
msgid "$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:270
msgid "Debugger"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:272
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:274
msgid "$ coredumpctl gdb <pid>"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:278
msgid "It is highly recommended to install ``tarantool-debuginfo`` package to improve ``gdb`` experience, for example:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:281
msgid "$ dnf debuginfo-install tarantool"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:285
msgid "``gdb`` also provides information about the debuginfo packages you need to install:"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:288
msgid "$ gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""

#: ../doc/2.2/book/admin/daemon_supervision.rst:299
msgid "Symbolic names are present in stack traces even if you don’t have ``tarantool-debuginfo`` package installed."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:39
msgid "Disaster recovery"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:41
msgid "The minimal fault-tolerant Tarantool configuration would be a :ref:`replication cluster<replication-topologies>` that includes a master and a replica, or two masters."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:45
msgid "The basic recommendation is to configure all Tarantool instances in a cluster to create :ref:`snapshot files <index-box_persistence>` at a regular basis."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:48
msgid "Here follow action plans for typical crash scenarios."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:54
msgid "Master-replica"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:56
msgid "Configuration: One master and one replica."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:58
msgid "Problem: The master has crashed."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:60
#: ../doc/2.2/book/admin/disaster_recovery.rst:127
msgid "Your actions:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:62
msgid "Ensure the master is stopped for good. For example, log in to the master machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:65
msgid "Switch the replica to master mode by setting :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter to *false* and let the load be handled by the replica (effective master)."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:69
msgid "Set up a replacement for the crashed master on a spare host, with :ref:`replication <cfg_replication-replication>` parameter set to replica (effective master), so it begins to catch up with the new master’s state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter set to *true*."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:75
msgid "You lose the few transactions in the master :ref:`write ahead log file <index-box_persistence>`, which it may have not transferred to the replica before crash. If you were able to salvage the master .xlog file, you may be able to recover these. In order to do it:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:80
msgid "Find out the position of the crashed master, as reflected on the new master."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:82
msgid "Find out instance UUID from the crashed master :ref:`xlog <internals-wal>`:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:84
msgid "$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:89
msgid "On the new master, use the UUID to find the position:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:91
msgid "tarantool> box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:98
msgid "Play the records from the crashed .xlog to the new master, starting from the new master position:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:101
msgid "Issue this request locally at the new master's machine to find out instance ID of the new master:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:104
#: ../doc/2.2/book/replication/repl_architecture.rst:126
msgid "tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:111
msgid "Play the records to the new master:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:113
msgid "$ tarantoolctl <new_master_uri> <xlog_file> play --from 23425 --replica 1"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:121
msgid "Master-master"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:123
msgid "Configuration: Two masters."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:125
msgid "Problem: Master#1 has crashed."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:129
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:131
msgid "2. Follow the same steps as in the :ref:`master-replica <admin-disaster_recovery-master_replica>` recovery scenario to create a new master and salvage lost data."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:139
msgid "Data loss"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:141
msgid "Configuration: Master-master or master-replica."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:143
msgid "Problem: Data was deleted at one master and this data loss was propagated to the other node (master or replica)."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:146
msgid "The following steps are applicable only to data in memtx storage engine. Your actions:"
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:149
msgid "Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable checkpointing with :ref:`box.backup.start() <admin-backups-backup_start>`. Disabling the checkpointing is necessary to prevent the Tarantool garbage collector from removing files made with older checkpoints."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:155
msgid "Get the latest valid :ref:`.snap file <internals-snapshot>` and use ``tarantoolctl cat`` command to calculate at which lsn the data loss occurred."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:158
msgid "Start a new instance (instance#1) and use ``tarantoolctl play`` command to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""

#: ../doc/2.2/book/admin/disaster_recovery.rst:161
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""

#: ../doc/2.2/book/admin/index.rst:39
msgid "Server administration"
msgstr ""

#: ../doc/2.2/book/admin/index.rst:41
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""

#: ../doc/2.2/book/admin/index.rst:43
msgid "Here we show how to administer Tarantool instances using any of the following utilities:"
msgstr ""

#: ../doc/2.2/book/admin/index.rst:46
msgid "``systemd`` native utilities, or"
msgstr ""

#: ../doc/2.2/book/admin/index.rst:47
msgid ":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/2.2/book/admin/index.rst:52
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""

#: ../doc/2.2/book/admin/index.rst:53
msgid "Console examples here are for Fedora."
msgstr ""

#: ../doc/2.2/book/admin/index.rst:55
#: ../doc/2.2/book/replication/index.rst:45
msgid "This chapter includes the following sections:"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:39
msgid "Instance configuration"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:41
msgid "For each Tarantool instance, you need two files:"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:43
msgid "[Optional] An :ref:`application file <app_server-launching_app>` with instance-specific logic. Put this file into the ``/usr/share/tarantool/`` directory."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:47
msgid "For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as a :ref:`Lua module <app_server-modules>` that bootstraps the database and exports ``start()`` function for API calls):"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:51
msgid "local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:63
msgid "An :ref:`instance file <admin-instance_file>` with instance-specific initialization logic and parameters. Put this file, or a symlink to it, into the **instance directory** (see :ref:`instance_dir <admin-instance_dir>` parameter in ``tarantoolctl`` configuration file)."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:69
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we load ``my_app.lua`` module and make a call to ``start()`` function from that module):"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:73
msgid "#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:89
msgid "Instance file"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:91
msgid "After this short introduction, you may wonder what an instance file is, what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is an application server, so why not start the application stored in ``/usr/share/tarantool`` directly?"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:96
msgid "A typical Tarantool application is not a script, but a daemon running in background mode and processing requests, usually sent to it over a TCP/IP socket. This daemon needs to be started automatically when the operating system starts, and managed with the operating system standard tools for service management -- such as ``systemd`` or ``init.d``. To serve this very purpose, we created **instance files**."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:103
msgid "You can have more than one instance file. For example, a single application in ``/usr/share/tarantool`` can run in multiple instances, each of them having its own instance file. Or you can have multiple applications in ``/usr/share/tarantool`` -- again, each of them having its own instance file."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:108
msgid "An instance file is typically created by a system administrator. An application file is often provided by a developer, in a Lua rock or an rpm/deb package."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:111
msgid "An instance file is designed to not differ in any way from a Lua application. It must, however, configure the database, i.e. contain a call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, because it’s the only way to turn a Tarantool script into a background process, and ``tarantoolctl`` is a tool to manage background processes. Other than that, an instance file may contain arbitrary Lua code, and, in theory, even include the entire application business logic in it. We, however, do not recommend this, since it clutters the instance file and leads to unnecessary copy-paste when you need to run multiple instances of an application."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:125
msgid "`tarantoolctl` configuration file"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:127
msgid "While instance files contain instance configuration, the ``tarantoolctl`` configuration file contains the configuration that ``tarantoolctl`` uses to override instance configuration. In other words, it contains system-wide configuration defaults. If ``tarantoolctl`` fails to find this file with the method described in section :ref:`Starting/stopping an instance <admin-start_stop_instance>`, it uses default settings."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:135
msgid "Most of the parameters are similar to those used by :ref:`box.cfg{} <box_introspection-box_cfg>`. Here are the default settings (possibly installed in ``/etc/default/tarantool`` or ``/etc/sysconfig/tarantool`` as part of Tarantool distribution -- see OS-specific default paths in :ref:`Notes for operating systems <admin-os_notes>`):"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:141
msgid "default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"    language  = \"Lua\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``pid_file``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "Directory for the pid file and control-socket file; ``tarantoolctl`` will add “/instance_name” to the directory name."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``wal_dir``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "Directory for write-ahead .xlog files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``memtx_dir``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "Directory for snapshot .snap files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``vinyl_dir``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" to the directory name."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``log``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "The place where the application log will go; ``tarantoolctl`` will add \"/instance_name.log\" to the name."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``username``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "The user that runs the Tarantool instance. This is the operating-system user name rather than the Tarantool-client user name. Tarantool will change its effective user to this user after becoming a daemon."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``language``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "The :ref:`interactive console <interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "``instance_dir``"
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:0
msgid "The directory where all instance files for this host are stored. Put instance files in this directory, or create symbolic links."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:190
msgid "The default instance directory depends on Tarantool's ``WITH_SYSVINIT`` build option: when ON, it is ``/etc/tarantool/instances.enabled``, otherwise (OFF or not set) it is ``/etc/tarantool/instances.available``. The latter case is typical for Tarantool builds for Linux distros with ``systemd``."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:196
msgid "To check the build options, say ``tarantool --version``."
msgstr ""

#: ../doc/2.2/book/admin/instance_config.rst:198
msgid "As a full-featured example, you can take `example.lua <https://github.com/tarantool/tarantool/blob/2.1/extra/dist/example.lua>`_ script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:39
msgid "Logs"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:41
msgid "Tarantool logs important events to a file, e.g. ``/var/log/tarantool/my_app.log``. To build the log file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends “.log” extension."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:45
msgid "Let’s write something to the log file:"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:47
msgid "$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the manual readers\")\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:55
msgid "Then check the logs:"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:57
msgid "$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set 'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual readers"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:73
msgid "When logging to a file, the system administrator must ensure logs are rotated timely and do not take up all the available disk space. With ``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` program, which you must have installed."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:78
msgid "File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool distribution, and you can modify it to change the default behavior. This is what this file is usually like:"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:82
msgid "/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:97
msgid "If you use a different log rotation program, you can invoke ``tarantoolctl logrotate`` command to request instances to reopen their log files after they were moved by the program of your choice."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:101
msgid "Tarantool can write its logs to a log file, ``syslog`` or a program specified in the configuration file (see :ref:`log <cfg_logging-log>` parameter)."
msgstr ""

#: ../doc/2.2/book/admin/logs.rst:104
msgid "By default, logs are written to a file as defined in ``tarantoolctl`` defaults. ``tarantoolctl`` automatically detects if an instance is using ``syslog`` or an external program for logging, and does not override the log destination in this case. In such configurations, log rotation is usually handled by the external program used for logging. So, ``tarantoolctl logrotate`` command works only if logging-into-file is enabled in the instance file."
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:39
msgid "Notes for operating systems"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:45
msgid "Mac OS"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:47
msgid "On Mac OS, you can administer Tarantool instances only with ``tarantoolctl``. No native system tools are supported."
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:54
msgid "FreeBSD"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:56
msgid "To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD, use paths other than those suggested in :ref:`Instance configuration <admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory, use ``/usr/local/etc/tarantool/`` and create the following subdirectories:"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:62
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:63
msgid "``instances.available`` for all available instance files, and"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:64
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:66
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:68
msgid "default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:87
msgid "Gentoo Linux"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:89
msgid "The section below is about a dev-db/tarantool package installed from the official layman overlay (named ``tarantool``)."
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:92
msgid "The default instance directory is ``/etc/tarantool/instances.available``, can be redefined in ``/etc/default/tarantool``."
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:95
msgid "Tarantool instances can be managed (start/stop/reload/status/...) using OpenRC. Consider the example how to create an OpenRC-managed instance:"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:98
msgid "$ cd /etc/init.d\n"
"$ ln -s tarantool your_service_name\n"
"$ ln -s /usr/share/tarantool/your_service_name.lua /etc/tarantool/instances.available/your_service_name.lua"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:104
msgid "Checking that it works:"
msgstr ""

#: ../doc/2.2/book/admin/os_notes.rst:106
msgid "$ /etc/init.d/your_service_name start\n"
"$ tail -f -n 100 /var/log/tarantool/your_service_name.log"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:39
msgid "Security"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:41
msgid "Tarantool allows for two types of connections:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:43
msgid "With :ref:`console.listen() <console-listen>` function from ``console`` module, you can set up a port which can be used to open an administrative console to the server. This is for administrators to connect to a running instance and make requests. ``tarantoolctl`` invokes ``console.listen()`` to create a control socket for each started instance."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:49
msgid "With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box`` module, you can set up a binary port for connections which read and write to the database or invoke stored procedures."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:53
msgid "When you connect to an admin console:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:55
msgid "The client-server protocol is plain text."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:56
msgid "No password is necessary."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:57
msgid "The user is automatically 'admin'."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:58
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:60
msgid "Therefore you must set up ports for the admin console very cautiously. If it is a TCP port, it should only be opened for a specific IP. Ideally, it should not be a TCP port at all, it should be a Unix domain socket, so that access to the server machine is required. Thus a typical port setup for admin console is:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:65
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:69
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:71
msgid "/var/lib/tarantool/socket_name.sock"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:75
msgid "if the listener has the privilege to write on ``/var/lib/tarantool`` and the connector has the privilege to read on ``/var/lib/tarantool``. Alternatively, to connect to an admin console of an instance started with ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:80
msgid "To find out whether a TCP port is a port for admin console, use ``telnet``. For example:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:83
msgid "$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 2.1.0 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:92
msgid "In this example, the response does not include the word \"binary\" and does include the words \"Lua console\". Therefore it is clear that this is a successful connection to a port for admin console, and you can now enter admin requests on this terminal."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:97
msgid "When you connect to a binary port:"
msgstr ""

#: ../doc/2.2/book/admin/security.rst:99
msgid "The client-server protocol is :ref:`binary <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:100
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:101
msgid "To change the user, it’s necessary to authenticate."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:103
msgid "For ease of use, ``tarantoolctl connect`` command automatically detects the type of connection during handshake and uses :ref:`EVAL <box_protocol-eval>` binary protocol command when it’s necessary to execute Lua commands over a binary connection. To execute EVAL, the authenticated user must have global \"EXECUTE\" privilege."
msgstr ""

#: ../doc/2.2/book/admin/security.rst:109
msgid "Therefore, when ``ssh`` access to the machine is not available, creating a Tarantool user with global \"EXECUTE\" privilege and non-empty password can be used to provide a system administrator **remote** access to an instance."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:39
msgid "Server introspection"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:45
msgid "Using Tarantool as a client"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:47
msgid "Tarantool enters the interactive mode if:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:49
msgid "you start Tarantool without an :ref:`instance file <admin-instance_file>`, or"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:52
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:54
msgid "Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter requests. When used this way, Tarantool can be a client for a remote server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:58
msgid "The interactive mode is used by ``tarantoolctl`` to implement \"enter\" and \"connect\" commands."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:65
msgid "Executing code on an instance"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:67
msgid "You can attach to an instance's :ref:`admin console <admin-security>` and execute some Lua code using ``tarantoolctl``:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:70
msgid "$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:86
msgid "You can also use ``tarantoolctl`` to execute Lua code on an instance without attaching to its admin console. For example:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:89
msgid "$ # executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"\n"
"$ # - OR -\n"
"\n"
"$ # executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:103
msgid "Alternatively, you can use the :ref:`console <console-module>` module or the :ref:`net.box <net_box-module>` module from a Tarantool server. Also, you can write your client programs with any of the :ref:`connectors <index-box_connectors>`. However, most of the examples in this manual illustrate usage with either ``tarantoolctl connect`` or :ref:`using the Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:114
msgid "Health checks"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:116
msgid "To check the instance status, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:118
msgid "$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"\n"
"$ # - OR -\n"
"\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:136
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:138
msgid "$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:148
msgid "For more details, use the reports provided by functions in the following submodules:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:150
msgid ":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:153
msgid ":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:156
msgid ":ref:`box.info <box_introspection-box_info>` submodule (introspect Tarantool server variables, primarily those related to replication)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:159
msgid ":ref:`box.stat <box_introspection-box_stat>` submodule (introspect Tarantool request and network statistics)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:162
msgid "You can also try `tarantool/prometheus <https://github.com/tarantool/prometheus>`_, a Lua module that makes it easy to collect metrics (e.g. memory usage or number of requests) from Tarantool applications and databases and expose them via the Prometheus protocol."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:167
#: ../doc/2.2/book/admin/server_introspection.rst:677
#: ../doc/2.2/book/box/authentication.rst:334
#: ../doc/2.2/book/box/box_schema.rst:220
#: ../doc/2.2/book/box/box_session.rst:216
#: ../doc/2.2/book/box/box_session.rst:274
#: ../doc/2.2/book/box/box_session.rst:304
#: ../doc/2.2/book/box/box_session.rst:350
#: ../doc/2.2/book/box/box_session.rst:591
#: ../doc/2.2/book/box/triggers.rst:123
msgid "**Example**"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:169
msgid "A very popular administrator request is :ref:`box.slab.info() <box_slab_info>`, which displays detailed memory usage statistics for a Tarantool instance."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:172
msgid "tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:187
msgid "Tarantool takes memory from the operating system, for example when a user does many insertions. You can see how much it has taken by saying (on Linux):"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:191
msgid "ps -eo args,%mem | grep \"tarantool\""
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:195
msgid "Tarantool almost never releases this memory, even if the user deletes everything that was inserted, or reduces fragmentation by calling the Lua garbage collector via the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:200
msgid "Ordinarily this does not affect performance. But, to force Tarantool to release memory, you can call :ref:`box.snapshot <box-snapshot>`, stop the server instance, and restart it."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:209
msgid "Profiling performance issues"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:211
msgid "Tarantool can at times work slower than usual. There can be multiple reasons, such as disk issues, CPU-intensive Lua scripts or misconfiguration. Tarantool’s log may lack details in such cases, so the only indications that something goes wrong are log entries like this: ``W> too long DELETE: 8.546 sec``. Here are tools and techniques that can help you collect Tarantool’s performance profile, which is helpful in troubleshooting slowdowns."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:220
msgid "Most of these tools -- except ``fiber.info()`` -- are intended for generic GNU/Linux distributions, but not FreeBSD or Mac OS."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:225
msgid "fiber.info()"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:227
msgid "The simplest profiling method is to take advantage of Tarantool’s built-in functionality. :ref:`fiber.info() <fiber-info>` returns information about all running fibers with their corresponding C stack traces. You can use this data to see how many fibers are running and which C functions are executed more often than others."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:233
msgid "First, enter your instance’s interactive administrator console:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:235
#: ../doc/2.2/book/admin/server_introspection.rst:513
msgid "$ tarantoolctl enter NAME"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:239
msgid "Once there, load the ``fiber`` module:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:241
msgid "tarantool> fiber = require('fiber')"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:245
msgid "After that you can get the required information with ``fiber.info()``."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:247
msgid "At this point, your console output should look something like this:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:249
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 360:\n"
"    csw: 2098165\n"
"    backtrace:\n"
"    - '#0 0x4d1b77 in wal_write(journal*, journal_entry*)+487'\n"
"    - '#1 0x4bbf68 in txn_commit(txn*)+152'\n"
"    - '#2 0x4bd5d8 in process_rw(request*, space*, tuple**)+136'\n"
"    - '#3 0x4bed48 in box_process1+104'\n"
"    - '#4 0x4d72f8 in lbox_replace+120'\n"
"    - '#5 0x50f317 in lj_BC_FUNCC+52'\n"
"    fid: 360\n"
"    memory:\n"
"      total: 61744\n"
"      used: 480\n"
"    name: main\n"
"  129:\n"
"    csw: 113\n"
"    backtrace: []\n"
"    fid: 129\n"
"    memory:\n"
"      total: 57648\n"
"      used: 0\n"
"    name: 'console/unix/:'\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:280
msgid "We highly recommend to assign meaningful names to fibers you create so that you can find them in the ``fiber.info()`` list. In the example below, we create a fiber named ``myworker``:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:284
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> f = fiber.create(function() while true do fiber.sleep(0.5) end end)\n"
"---\n"
"...\n"
"tarantool> f:name('myworker') <!-- assigning the name to a fiber\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 102:\n"
"    csw: 14\n"
"    backtrace:\n"
"    - '#0 0x501a1a in fiber_yield_timeout+90'\n"
"    - '#1 0x4f2008 in lbox_fiber_sleep+72'\n"
"    - '#2 0x5112a7 in lj_BC_FUNCC+52'\n"
"    fid: 102\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: myworker <!-- newly created background fiber\n"
"  101:\n"
"    csw: 284\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:318
msgid "You can kill any fiber with :ref:`fiber.kill(fid) <fiber-kill>`:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:320
msgid "tarantool> fiber.kill(102)\n"
"---\n"
"...\n"
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 324\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 57656\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:337
msgid "If you want to dynamically obtain information with ``fiber.info()``, the shell script below may come in handy. It connects to a Tarantool instance specified by ``NAME`` every 0.5 seconds, grabs the ``fiber.info()`` output and writes it to the ``fiber-info.txt`` file:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:342
msgid "$ rm -f fiber.info.txt\n"
"$ watch -n 0.5 \"echo 'require(\\\"fiber\\\").info()' | tarantoolctl enter NAME | tee -a fiber-info.txt\""
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:347
msgid "If you can't understand which fiber causes performance issues, collect the metrics of the ``fiber.info()`` output for 10-15 seconds using the script above and contact the Tarantool team at support@tarantool.org."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:353
msgid "Poor man’s profilers"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:355
msgid "**pstack <pid>**"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:357
msgid "To use this tool, first install it with a package manager that comes with your Linux distribution. This command prints an execution stack trace of a running process specified by the PID. You might want to run this command several times in a row to pinpoint the bottleneck that causes the slowdown."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:362
msgid "Once installed, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:364
msgid "$ pstack $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:368
#: ../doc/2.2/book/admin/server_introspection.rst:415
msgid "Next, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:370
#: ../doc/2.2/book/admin/server_introspection.rst:417
msgid "$ echo $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:374
#: ../doc/2.2/book/admin/server_introspection.rst:421
msgid "to show the PID of the Tarantool instance that runs the ``INSTANCENAME.lua`` file."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:376
msgid "You should get similar output:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:378
msgid "Thread 19 (Thread 0x7f09d1bff700 (LWP 24173)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"Thread 18 (Thread 0x7f09d13fe700 (LWP 24174)):\n"
"#0 0x00007f0a1a5423f2 in ?? () from /lib64/libgomp.so.1\n"
"#1 0x00007f0a1a53fdc0 in ?? () from /lib64/libgomp.so.1\n"
"#2 0x00007f0a1ad5adc5 in start_thread () from /lib64/libpthread.so.0\n"
"#3 0x00007f0a1a050ced in clone () from /lib64/libc.so.6\n"
"<...>\n"
"Thread 2 (Thread 0x7f09c8bfe700 (LWP 24191)):\n"
"#0 0x00007f0a1ad5e6d5 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0\n"
"#1 0x000000000045d901 in wal_writer_pop(wal_writer*) ()\n"
"#2 0x000000000045db01 in wal_writer_f(__va_list_tag*) ()\n"
"#3 0x0000000000429abc in fiber_cxx_invoke(int (*)(__va_list_tag*), __va_list_tag*) ()\n"
"#4 0x00000000004b52a0 in fiber_loop ()\n"
"#5 0x00000000006099cf in coro_init ()\n"
"Thread 1 (Thread 0x7f0a1c47fd80 (LWP 24172)):\n"
"#0 0x00007f0a1a0512c3 in epoll_wait () from /lib64/libc.so.6\n"
"#1 0x00000000006051c8 in epoll_poll ()\n"
"#2 0x0000000000607533 in ev_run ()\n"
"#3 0x0000000000428e13 in main ()"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:404
msgid "**gdb -ex \"bt\" -p <pid>**"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:406
msgid "As with ``pstack``, the GNU debugger (also known as ``gdb``) needs to be installed before you can start using it. Your Linux package manager can help you with that."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:409
msgid "Once the debugger is installed, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:411
msgid "$ gdb -ex \"set pagination 0\" -ex \"thread apply all bt\" --batch -p $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:423
msgid "After using the debugger, your console output should look like this:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:425
msgid "[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"
"\n"
"[CUT]\n"
"\n"
"Thread 1 (Thread 0x7f72289ba940 (LWP 20535)):\n"
"#0 _int_malloc (av=av@entry=0x7f7226e0eb20 <main_arena>, bytes=bytes@entry=504) at malloc.c:3697\n"
"#1 0x00007f7226acf21a in __libc_calloc (n=<optimized out>, elem_size=<optimized out>) at malloc.c:3234\n"
"#2 0x00000000004631f8 in vy_merge_iterator_reserve (capacity=3, itr=0x7f72264af9e0) at /usr/src/tarantool/src/box/vinyl.c:7629\n"
"#3 vy_merge_iterator_add (itr=itr@entry=0x7f72264af9e0, is_mutable=is_mutable@entry=true, belong_range=belong_range@entry=false) at /usr/src/tarantool/src/box/vinyl.c:7660\n"
"#4 0x00000000004703df in vy_read_iterator_add_mem (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8387\n"
"#5 vy_read_iterator_use_range (itr=0x7f72264af990) at /usr/src/tarantool/src/box/vinyl.c:8453\n"
"#6 0x000000000047657d in vy_read_iterator_start (itr=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:8501\n"
"#7 0x00000000004766b5 in vy_read_iterator_next (itr=itr@entry=0x7f72264af990, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:8592\n"
"#8 0x000000000047689d in vy_index_get (tx=tx@entry=0x7f7226468158, index=index@entry=0x2563860, key=<optimized out>, part_count=<optimized out>, result=result@entry=0x7f72264afad8) at /usr/src/tarantool/src/box/vinyl.c:5705\n"
"#9 0x0000000000477601 in vy_replace_impl (request=<optimized out>, request=<optimized out>, stmt=0x7f72265a7150, space=0x2567ea0, tx=0x7f7226468158) at /usr/src/tarantool/src/box/vinyl.c:5920\n"
"#10 vy_replace (tx=0x7f7226468158, stmt=stmt@entry=0x7f72265a7150, space=0x2567ea0, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl.c:6608\n"
"#11 0x00000000004615a9 in VinylSpace::executeReplace (this=<optimized out>, txn=<optimized out>, space=<optimized out>, request=<optimized out>) at /usr/src/tarantool/src/box/vinyl_space.cc:108\n"
"#12 0x00000000004bd723 in process_rw (request=request@entry=0x7f72265a70f8, space=space@entry=0x2567ea0, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:182\n"
"#13 0x00000000004bed48 in box_process1 (request=0x7f72265a70f8, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:700\n"
"#14 0x00000000004bf389 in box_replace (space_id=space_id@entry=513, tuple=<optimized out>, tuple_end=<optimized out>, result=result@entry=0x7f72264afbc8) at /usr/src/tarantool/src/box/box.cc:754\n"
"#15 0x00000000004d72f8 in lbox_replace (L=0x413c5780) at /usr/src/tarantool/src/box/lua/index.c:72\n"
"#16 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#17 0x00000000004d37c7 in execute_lua_call (L=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:282\n"
"#18 0x000000000050f317 in lj_BC_FUNCC ()\n"
"#19 0x0000000000529c7b in lua_cpcall ()\n"
"#20 0x00000000004f6aa3 in luaT_cpcall (L=L@entry=0x413c5780, func=func@entry=0x4d36d0 <execute_lua_call>, ud=ud@entry=0x7f72264afde0) at /usr/src/tarantool/src/lua/utils.c:962\n"
"#21 0x00000000004d3fe7 in box_process_lua (handler=0x4d36d0 <execute_lua_call>, out=out@entry=0x7f7213020600, request=request@entry=0x413c5780) at /usr/src/tarantool/src/box/lua/call.c:382\n"
"#22 box_lua_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/lua/call.c:405\n"
"#23 0x00000000004c0f27 in box_process_call (request=request@entry=0x7f72130401d8, out=out@entry=0x7f7213020600) at /usr/src/tarantool/src/box/box.cc:1074\n"
"#24 0x000000000041326c in tx_process_misc (m=0x7f7213040170) at /usr/src/tarantool/src/box/iproto.cc:942\n"
"#25 0x0000000000504554 in cmsg_deliver (msg=0x7f7213040170) at /usr/src/tarantool/src/cbus.c:302\n"
"#26 0x0000000000504c2e in fiber_pool_f (ap=<error reading variable: value has been optimized out>) at /usr/src/tarantool/src/fiber_pool.c:64\n"
"#27 0x000000000041122c in fiber_cxx_invoke(fiber_func, typedef __va_list_tag __va_list_tag *) (f=<optimized out>, ap=<optimized out>) at /usr/src/tarantool/src/fiber.h:645\n"
"#28 0x00000000005011a0 in fiber_loop (data=<optimized out>) at /usr/src/tarantool/src/fiber.c:641\n"
"#29 0x0000000000688fbf in coro_init () at /usr/src/tarantool/third_party/coro/coro.c:110"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:464
msgid "Run the debugger in a loop a few times to collect enough samples for making conclusions about why Tarantool demonstrates suboptimal performance. Use the following script:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:468
msgid "$ rm -f stack-trace.txt\n"
"$ watch -n 0.5 \"gdb -ex 'set pagination 0' -ex 'thread apply all bt' --batch -p $(pidof tarantool INSTANCENAME.lua) | tee -a stack-trace.txt\""
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:473
msgid "Structurally and functionally, this script is very similar to the one used with ``fiber.info()`` above."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:476
msgid "If you have any difficulties troubleshooting, let the script run for 10-15 seconds and then send the resulting ``stack-trace.txt`` file to the Tarantool team at support@tarantool.org."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:482
msgid "Use the poor man’s profilers with caution: each time they attach to a running process, this stops the process execution for about a second, which may leave a serious footprint in high-load services."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:488
msgid "gperftools"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:490
msgid "To use the CPU profiler from the Google Performance Tools suite with Tarantool, first take care of the prerequisites:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:493
msgid "For Debian/Ubuntu, run:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:495
msgid "$ apt-get install libgoogle-perftools4"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:499
msgid "For RHEL/CentOS/Fedora, run:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:501
msgid "$ yum install gperftools-libs"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:505
msgid "Once you do this, install Lua bindings:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:507
msgid "$ tarantoolctl rocks install gperftools"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:511
msgid "Now you're ready to go. Enter your instance’s interactive administrator console:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:517
msgid "To start profiling, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:519
msgid "tarantool> cpuprof = require('gperftools.cpu')\n"
"tarantool> cpuprof.start('/home/<username>/tarantool-on-production.prof')"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:524
msgid "It takes at least a couple of minutes for the profiler to gather performance metrics. After that, save the results to disk (you can do that as many times as you need):"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:528
msgid "tarantool> cpuprof.flush()"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:532
msgid "To stop profiling, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:534
msgid "tarantool> cpuprof.stop()"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:538
msgid "You can now analyze the output with the ``pprof`` utility that comes with the ``gperftools`` package:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:541
msgid "$ pprof --text /usr/bin/tarantool /home/<username>/tarantool-on-production.prof"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:547
msgid "On Debian/Ubuntu, the ``pprof`` utility is called ``google-pprof``."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:549
msgid "Your output should look similar to this:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:551
msgid "Total: 598 samples\n"
"      83 13.9% 13.9% 83 13.9% epoll_wait\n"
"      54 9.0% 22.9% 102 17.1%\n"
"vy_mem_tree_insert.constprop.35\n"
"      32 5.4% 28.3% 34 5.7% __write_nocancel\n"
"      28 4.7% 32.9% 42 7.0% vy_mem_iterator_start_from\n"
"      26 4.3% 37.3% 26 4.3% _IO_str_seekoff\n"
"      21 3.5% 40.8% 21 3.5% tuple_compare_field\n"
"      19 3.2% 44.0% 19 3.2%\n"
"::TupleCompareWithKey::compare\n"
"      19 3.2% 47.2% 38 6.4% tuple_compare_slowpath\n"
"      12 2.0% 49.2% 23 3.8% __libc_calloc\n"
"       9 1.5% 50.7% 9 1.5%\n"
"::TupleCompare::compare@42efc0\n"
"       9 1.5% 52.2% 9 1.5% vy_cache_on_write\n"
"       9 1.5% 53.7% 57 9.5% vy_merge_iterator_next_key\n"
"       8 1.3% 55.0% 8 1.3% __nss_passwd_lookup\n"
"       6 1.0% 56.0% 25 4.2% gc_onestep\n"
"       6 1.0% 57.0% 6 1.0% lj_tab_next\n"
"       5 0.8% 57.9% 5 0.8% lj_alloc_malloc\n"
"       5 0.8% 58.7% 131 21.9% vy_prepare"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:577
msgid "perf"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:579
msgid "This tool for performance monitoring and analysis is installed separately via your package manager. Try running the ``perf`` command in the terminal and follow the prompts to install the necessary package(s)."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:585
msgid "By default, some ``perf`` commands are restricted to **root**, so, to be on the safe side, either run all commands as **root** or prepend them with ``sudo``."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:589
msgid "To start gathering performance statistics, say:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:591
msgid "$ perf record -g -p $(pidof tarantool INSTANCENAME.lua)"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:595
msgid "This command saves the gathered data to a file named ``perf.data`` inside the current working directory. To stop this process (usually, after 10-15 seconds), press **ctrl+C**. In your console, you’ll see:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:599
msgid "^C[ perf record: Woken up 1 times to write data ]\n"
"[ perf record: Captured and wrote 0.225 MB perf.data (1573 samples) ]"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:604
msgid "Now run the following command:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:606
msgid "$ perf report -n -g --stdio | tee perf-report.txt"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:610
msgid "It formats the statistical data in the ``perf.data`` file into a performance report and writes it to the ``perf-report.txt`` file."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:613
msgid "The resulting output should look similar to this:"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:615
msgid "# Samples: 14K of event 'cycles'\n"
"# Event count (approx.): 9927346847\n"
"#\n"
"# Children Self Samples Command Shared Object Symbol\n"
"# ........ ........ ............ ......... .................. .......................................\n"
"#\n"
"    35.50% 0.55% 79 tarantool tarantool [.] lj_gc_step\n"
"            |\n"
"             --34.95%--lj_gc_step\n"
"                       |\n"
"                       |--29.26%--gc_onestep\n"
"                       | |\n"
"                       | |--13.85%--gc_sweep\n"
"                       | | |\n"
"                       | | |--5.59%--lj_alloc_free\n"
"                       | | |\n"
"                       | | |--1.33%--lj_tab_free\n"
"                       | | | |\n"
"                       | | | --1.01%--lj_alloc_free\n"
"                       | | |\n"
"                       | | --1.17%--lj_cdata_free\n"
"                       | |\n"
"                       | |--5.41%--gc_finalize\n"
"                       | | |\n"
"                       | | |--1.06%--lj_obj_equal\n"
"                       | | |\n"
"                       | | --0.95%--lj_tab_set\n"
"                       | |\n"
"                       | |--4.97%--rehashtab\n"
"                       | | |\n"
"                       | | --3.65%--lj_tab_resize\n"
"                       | | |\n"
"                       | | |--0.74%--lj_tab_set\n"
"                       | | |\n"
"                       | | --0.72%--lj_tab_newkey\n"
"                       | |\n"
"                       | |--0.91%--propagatemark\n"
"                       | |\n"
"                       | --0.67%--lj_cdata_free\n"
"                       |\n"
"                        --5.43%--propagatemark\n"
"                                  |\n"
"                                   --0.73%--gc_mark"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:661
msgid "Unlike the poor man’s profilers, ``gperftools`` and ``perf`` have low overhead (almost negligible as compared with ``pstack`` and ``gdb``): they don’t result in long delays when attaching to a process and therefore can be used without serious consequences."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:668
msgid "jit.p"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:671
msgid "The jit.p profiler comes with the Tarantool application server, to load it one only needs to say ``require('jit.p')`` or ``require('jit.profile')``. There are many options for sampling and display, they are described in the documentation for `The LuaJIT Profiler <http://www.luatex.org/svn/trunk/source/libs/luajit/LuaJIT-src/doc/ext_profiler.html>`_."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:679
msgid "Make a function that calls a function named f1 that does 500,000 inserts and deletes in a Tarantool space. Start the profiler, execute the function, stop the profiler, and show what the profiler sampled."
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:684
msgid "box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"function f1() for i = 1,500000 do\n"
"  box.space.t:insert{i}\n"
"  box.space.t:delete{i}\n"
"  end\n"
"return 1\n"
"end\n"
"function f3() f1() end\n"
"jit_p = require(\"jit.profile\")\n"
"sampletable = {}\n"
"jit_p.start(\"f\", function(thread, samples, vmstate)\n"
"  local dump=jit_p.dumpstack(thread, \"f\", 1)\n"
"  sampletable[dump] = (sampletable[dump] or 0) + samples\n"
"end)\n"
"f3()\n"
"jit_p.stop()\n"
"for d,v in pairs(sampletable) do print(v, d) end"
msgstr ""

#: ../doc/2.2/book/admin/server_introspection.rst:706
msgid "Typically the result will show that the sampling happened within f1() many times, but also within internal Tarantool functions, whose names may change with each new version."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:39
msgid "Starting/stopping an instance"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:41
msgid "While a Lua application is executed by Tarantool, an instance file is executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:44
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:46
msgid "$ tarantoolctl start <instance_name>"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:50
msgid "Read and parse the command line arguments. The last argument, in our case, contains an instance name."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:53
msgid "Read and parse its own configuration file. This file contains ``tarantoolctl`` defaults, like the path to the directory where instances should be searched for."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:57
msgid "When ``tarantool`` is invoked by root, it looks for a configuration file in ``/etc/default/tarantool``. When ``tarantool`` is invoked by a local (non-root) user, it looks for a configuration file first in the current directory (``$PWD/.tarantoolctl``), and then in the current user's home directory (``$HOME/.config/tarantool/tarantool``). If no configuration file is found there, or in the ``/usr/local/etc/default/tarantool`` file, then ``tarantoolctl`` falls back to :ref:`built-in defaults <admin-tarantoolctl_config_file>`."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:66
msgid "Look up the instance file in the instance directory, for example ``/etc/tarantool/instances.enabled``. To build the instance file path, ``tarantoolctl`` takes the instance name, prepends the instance directory and appends \".lua\" extension to the instance file."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:71
msgid "Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-process its parameters and ensure that instance paths are pointing to the paths defined in the ``tarantoolctl`` configuration file. For example, if the configuration file specifies that instance work directory must be in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in ``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of what the path is set to in the instance file itself."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:80
msgid "Create a so-called \"instance control file\". This is a Unix socket with Lua console attached to it. This file is used later by ``tarantoolctl`` to query the instance state, send commands to the instance and so on."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:84
msgid "Set the TARANTOOLCTL environment variable to 'true'. This allows the user to know that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:87
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:89
msgid "If you start an instance using ``systemd`` tools, like this (the instance name is ``my_app``):"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:92
msgid "$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool my_app.lua <running>"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:98
msgid "... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl start my_app``."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:101
msgid "To check the instance file for syntax errors prior to starting ``my_app`` instance, say:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:104
msgid "$ tarantoolctl check my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:108
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:110
msgid "$ systemctl enable tarantool@my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:114
msgid "To stop a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:116
msgid "$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:122
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:124
msgid "$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:134
msgid "Running Tarantool locally"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:136
msgid "Sometimes you may need to run a Tarantool instance locally, e.g. for test purposes. Let's configure a local instance, then start and monitor it with ``tarantoolctl``."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:140
msgid "First, we create a sandbox directory on the user's path:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:142
msgid "$ mkdir ~/tarantool_test"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:146
msgid "... and set default ``tarantoolctl`` configuration in ``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:149
msgid "default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:162
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:164
msgid "Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have permissions to switch current user when invoked by a local user. The instance will be running under 'admin'."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:168
msgid "Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let the file contents be:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:171
msgid "box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:187
msgid "Let’s verify our instance file by starting it without ``tarantoolctl`` first:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:189
msgid "$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:207
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:209
msgid "$ tarantoolctl start my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:213
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:215
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:219
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:221
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:225
msgid "Expect to see the contents of ``my_app``‘s log, including error messages, if any. Then:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:228
msgid "$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:236
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:238
msgid "Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus we say:"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:240
msgid "$ tarantoolctl stop my_app"
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:244
msgid "Finally, we make a cleanup."
msgstr ""

#: ../doc/2.2/book/admin/start_stop_instance.rst:246
msgid "$ rm -R tarantool_test"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:39
msgid "Troubleshooting guide"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:41
msgid "For this guide, you need to install Tarantool `stat <https://github.com/tarantool/stat>`_ module:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:44
msgid "$ sudo yum install tarantool-stat\n"
"$ # -- OR --\n"
"$ sudo apt-get install tarantool-stat"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:54
msgid "Problem: INSERT/UPDATE-requests result in ER_MEMORY_ISSUE error"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:56
#: ../doc/2.2/book/admin/troubleshoot.rst:114
#: ../doc/2.2/book/admin/troubleshoot.rst:160
#: ../doc/2.2/book/admin/troubleshoot.rst:222
#: ../doc/2.2/book/admin/troubleshoot.rst:245
#: ../doc/2.2/book/admin/troubleshoot.rst:270
#: ../doc/2.2/book/admin/troubleshoot.rst:287
#: ../doc/2.2/book/admin/troubleshoot.rst:322
msgid "**Possible reasons**"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:58
msgid "Lack of RAM (parameters ``arena_used_ratio`` and ``quota_used_ratio`` in :ref:`box.slab.info() <box_slab_info>` report are getting close to 100%)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:61
msgid "To check these parameters, say:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:63
#: ../doc/2.2/book/admin/troubleshoot.rst:125
#: ../doc/2.2/book/admin/troubleshoot.rst:182
#: ../doc/2.2/book/admin/troubleshoot.rst:299
#: ../doc/2.2/book/admin/troubleshoot.rst:335
msgid "$ # attaching to a Tarantool instance\n"
"$ tarantoolctl enter <instance_name>\n"
"$ # -- OR --\n"
"$ tarantoolctl connect <URI>"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:70
msgid "-- requesting arena_used_ratio value\n"
"tarantool> require('stat').stat()['slab.arena_used_ratio']\n"
"\n"
"-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:78
#: ../doc/2.2/book/admin/troubleshoot.rst:119
#: ../doc/2.2/book/admin/troubleshoot.rst:170
#: ../doc/2.2/book/admin/troubleshoot.rst:203
#: ../doc/2.2/book/admin/troubleshoot.rst:227
#: ../doc/2.2/book/admin/troubleshoot.rst:250
#: ../doc/2.2/book/admin/troubleshoot.rst:274
#: ../doc/2.2/book/admin/troubleshoot.rst:295
#: ../doc/2.2/book/admin/troubleshoot.rst:326
msgid "**Solution**"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:80
#: ../doc/2.2/book/admin/troubleshoot.rst:172
msgid "Try either of the following measures:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:82
msgid "In Tarantool's :ref:`instance file <admin-instance_config>`, increase the value of :ref:`box.cfg{memtx_memory} <cfg_storage-memtx_memory>` (if memory resources are available)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:86
msgid "In versions of Tarantool before 1.10, the server needs to be restarted to change this parameter. The Tarantool server will be unavailable while restarting from .xlog files, unless you restart it using :ref:`hot standby <index-hot_standby>` mode. In the latter case, nearly 100% server availability is guaranteed."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:92
msgid "Clean up the database."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:94
msgid "Check the indicators of memory fragmentation:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:96
msgid "-- requesting quota_used_ratio value\n"
"tarantool> require('stat').stat()['slab.quota_used_ratio']\n"
"\n"
"-- requesting items_used_ratio value\n"
"tarantool> require('stat').stat()['slab.items_used_ratio']"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:104
msgid "In case of heavy memory fragmentation (``quota_used_ratio`` is getting close to 100%, ``items_used_ratio`` is about 50%), we recommend restarting Tarantool in the :ref:`hot standby <index-hot_standby>` mode."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:112
msgid "Problem: Tarantool generates too heavy CPU load"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:116
msgid "The :ref:`transaction processor thread <atomic-threads_fibers_yields>` consumes over 60% CPU."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:121
msgid "Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility, analyze the query statistics with :ref:`box.stat() <box_introspection-box_stat>` and spot the CPU consumption leader. The following commands can help:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:132
msgid "-- checking the RPS of calling stored procedures\n"
"tarantool> require('stat').stat()['stat.op.call.rps']"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:137
msgid "The critical RPS value is 75 000, boiling down to 10 000 - 20 000 for a rich Lua application (a Lua module of 200+ lines)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:140
msgid "-- checking RPS per query type\n"
"tarantool> require('stat').stat()['stat.op.<query_type>.rps']"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:145
msgid "The critical RPS value for SELECT/INSERT/UPDATE/DELETE requests is 100 000."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:147
msgid "If the load is mostly generated by SELECT requests, we recommend adding a :ref:`slave server <replication-bootstrap>` and let it process part of the queries."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:151
msgid "If the load is mostly generated by INSERT/UPDATE/DELETE requests, we recommend :ref:`sharding the database <shard-module>`."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:158
msgid "Problem: Query processing times out"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:164
msgid "All reasons that we discuss here can be identified by messages in Tarantool's log file, all starting with the words ``'Too long...'``."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:167
msgid "Both fast and slow queries are processed within a single connection, so the readahead buffer is cluttered with slow queries."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:174
msgid "Increase the readahead buffer size (:ref:`box.cfg{readahead} <cfg_networking-readahead>` parameter)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:177
msgid "This parameter can be changed on the fly, so you don't need to restart Tarantool. Attach to the Tarantool instance with :ref:`tarantoolctl <tarantoolctl>` utility and call ``box.cfg{}`` with a new ``readahead`` value:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:189
msgid "-- changing the readahead value\n"
"tarantool> box.cfg{readahead = 10 * 1024 * 1024}"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:194
msgid "**Example:** Given 1000 RPS, 1 Кbyte of query size, and 10 seconds of maximal query processing time, the minimal readahead buffer size must be 10 Mbytes."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:198
msgid "On the business logic level, split fast and slow queries processing by different connections."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:201
msgid "Slow disks."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:205
msgid "Check disk performance (use `iostat <https://linux.die.net/man/1/iostat>`_, `iotop <https://linux.die.net/man/1/iotop>`_ or `strace <https://linux.die.net/man/1/strace>`_ utility to check ``iowait`` parameter) and try to put .xlog files and snapshot files on different physical disks (i.e. use different locations for :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>`)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:216
msgid "Problem: Replication \"lag\" and \"idle\" contain negative values"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:218
msgid "This is about ``box.info.replication.(upstream.)lag`` and ``box.info.replication.(upstream.)idle`` values in :ref:`box.info.replication <box_info_replication>` section."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:224
msgid "Operating system clock on the hosts is not synchronized, or the NTP server is faulty."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:229
msgid "Check NTP server settings."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:231
msgid "If you found no problems with the NTP server, just do nothing then. Lag calculation uses operating system clock from two different machines. If they get out of sync, the remote master clock can get consistently behind the local instance’s clock."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:240
msgid "Problem: Replication \"idle\" keeps growing, but no related log messages appear"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:242
msgid "This is about ``box.info.replication.(upstream.)idle`` value in :ref:`box.info.replication <box_info_replication>` section."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:247
msgid "Some server was assigned different IP addresses, or some server was specified twice in ``box.cfg{}``, so duplicate connections were established."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:252
msgid ":ref:`Upgrade Tarantool 1.6 to 1.7 <admin-upgrades_instance>`, where this error is fixed: in case of duplicate connections, replication is stopped and the following message is added to the log: ``'Incorrect value for option ''replication_source'': duplicate connection with the same replica UUID'``."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:262
msgid "Problem: Replication statistics differ on replicas within a replica set"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:264
msgid "This is about a replica set that consists of one master and several replicas. In a replica set of this type, values in :ref:`box.info.replication <box_info_replication>` section, like ``box.info.replication.lsn``, come from the master and must be the same on all replicas within the replica set. The problem is that they get different."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:272
msgid "Replication is broken."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:276
msgid ":ref:`Restart replication <replication-recover>`."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:282
msgid "Problem: Master-master replication is stopped"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:284
msgid "This is about :ref:`box.info.replication(.upstream).status <box_info_replication>` = stopped."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:289
msgid "In a master-master replica set of two Tarantool instances, one of the masters has tried to perform an action already performed by the other server, for example re-insert a tuple with the same unique key. This would cause an error message like ``'Duplicate key exists in unique index 'primary' in space <space_name>'``."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:297
msgid "Restart replication with the following commands (at each master instance):"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:306
msgid "-- restarting replication\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:313
msgid "We also recommend using text primary keys or setting up :ref:`master-slave replication <replication-master_replica_bootstrap>`."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:320
msgid "Problem: Tarantool works much slower than before"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:324
msgid "Inefficient memory usage (RAM is cluttered with a huge amount of unused objects)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:328
msgid "Call the Lua garbage collector with the `collectgarbage('count') function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_ and measure its execution time with the Tarantool functions :ref:`clock.bench() <clock-bench>` or :ref:`clock.proc() <clock-proc>`."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:333
msgid "Example of calculating memory usage statistics:"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:342
msgid "-- loading Tarantool's \"clock\" module with time-related routines\n"
"tarantool> local clock = require 'clock'\n"
"-- starting the timer\n"
"tarantool> local b = clock.proc()\n"
"-- launching garbage collection\n"
"tarantool> local c = collectgarbage('count')\n"
"-- stopping the timer after garbage collection is completed\n"
"tarantool> return c, clock.proc() - b"
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:353
msgid "If the returned ``clock.proc()`` value is greater than 0.001, this may be an indicator of inefficient memory usage (no active measures are required, but we recommend to optimize your Tarantool application code)."
msgstr ""

#: ../doc/2.2/book/admin/troubleshoot.rst:357
msgid "If the value is greater than 0.01, your application definitely needs thorough code analysis aimed at optimizing memory usage."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:39
msgid "Upgrades"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:45
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:47
msgid "If you created a database with an older Tarantool version and have now installed a newer version, make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:51
msgid "For example, here is what happens when you run ``box.schema.upgrade()`` with a database created with Tarantool version 1.6.4 to version 1.7.2 (only a small part of the output is shown):"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:55
msgid "tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:70
msgid "Upgrading a Tarantool instance"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:72
msgid "Tarantool is backward compatible between two adjacent versions. For example, you should have no or little trouble when upgrading from Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 2.x. Meanwhile Tarantool 2.x may have incompatible changes when migrating from Tarantool 1.6. to 2.x directly."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:81
msgid "How to upgrade from Tarantool 1.7 to 2.x"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:83
#: ../doc/2.2/book/admin/upgrades.rst:126
msgid "Stop the Tarantool server."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:85
#: ../doc/2.2/book/admin/upgrades.rst:128
msgid "Make a copy of all data (see an appropriate hot backup procedure in :ref:`Backups <admin-backups>`) and the package from which the current (old) version was installed (for rollback purposes)."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:89
#: ../doc/2.2/book/admin/upgrades.rst:132
msgid "Update the Tarantool server. See installation instructions at Tarantool `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:92
#: ../doc/2.2/book/admin/upgrades.rst:143
msgid "Launch the updated Tarantool server using ``tarantoolctl`` or ``systemctl``."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:98
msgid "How to upgrade from Tarantool 1.6 to 2.x"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:100
msgid "The procedure is fully analogous to :ref:`upgrading from 1.7 to 2.x <admin-upgrades_instance_17_to_20>`."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:107
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:109
msgid "This procedure is for upgrading a standalone Tarantool instance in production from 1.6.x to 1.7.x. Notice that this will **always imply a downtime**. To upgrade **without downtime**, you need several Tarantool servers running in a replication cluster (see :ref:`below <admin-upgrades_replication_cluster>`)."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:114
msgid "Tarantool 1.7 has an incompatible :ref:`.snap <internals-snapshot>` and :ref:`.xlog <internals-wal>` file format: 1.6 files are supported during upgrade, but you won’t be able to return to 1.6 after running under 1.7 for a while. It also renames a few configuration parameters, but old parameters are supported. The full list of breaking changes is available in `release notes for Tarantool 1.7 <https://github.com/tarantool/tarantool/releases>`_."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:121
msgid "Check with application developers whether application files need to be updated due to incompatible changes (see `1.7 release notes <https://github.com/tarantool/tarantool/releases>`_). If yes, back up the old application files."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:135
msgid "Update the Tarantool database. Put the request ``box.schema.upgrade()`` inside a :ref:`box.once() <box-once>` function in your Tarantool :ref:`initialization file <index-init_label>`. On startup, this will create new system spaces, update data type names (e.g. num -> unsigned, str -> string) and options in Tarantool system spaces."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:141
msgid "Update application files, if needed."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:149
msgid "Upgrading Tarantool in a replication cluster"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:151
msgid "Tarantool 1.7 can work as a :ref:`replica <replication-architecture>` for Tarantool 1.6 and vice versa. Replicas perform capability negotiation on handshake, and new 1.7 replication features are not used with 1.6 replicas. This allows upgrading clustered configurations."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:156
msgid "This procedure allows for a rolling upgrade **without downtime** and works for any cluster configuration: master-master or master-replica."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:159
msgid "Upgrade Tarantool at all replicas (or at any master in a master-master cluster). See details in :ref:`Upgrading a Tarantool instance <admin-upgrades_instance>`."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:163
msgid "Verify installation on the replicas:"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:165
msgid "Start Tarantool."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:167
msgid "Attach to the master and start working as before."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:169
msgid "The master runs the old Tarantool version, which is always compatible with the next major version."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:172
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:174
msgid "Verify master installation:"
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:176
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:178
msgid "Switch to master mode."
msgstr ""

#: ../doc/2.2/book/admin/upgrades.rst:180
msgid "Upgrade the database on any master node in the cluster. Make the request ``box.schema.upgrade()``. This updates Tarantool system spaces to match the currently installed version of Tarantool. Changes are propagated to other nodes via the regular replication mechanism."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:39
msgid "Contributing a module"
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:41
msgid "We have already discussed :ref:`how to create a simple module in Lua for local usage <app_server-modules>`. Now let's discuss how to create a more advanced Tarantool module and then get it published on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and included in `official Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:48
msgid "To help our contributors, we have created `modulekit <http://github.com/tarantool/modulekit>`_, a set of templates for creating Tarantool modules in Lua and C."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:54
msgid "As a prerequisite for using ``modulekit``, install ``tarantool-dev`` package first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:57
#: ../doc/2.2/reference/reference_rock/dbms.rst:95
#: ../doc/2.2/reference/reference_rock/dbms.rst:448
#: ../doc/2.2/tutorials/c_tutorial.rst:82
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:65
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:67
msgid "See `README in \"luakit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for detailed instructions and examples."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:75
msgid "Contributing a module in C"
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:77
msgid "In some cases, you may want to create a Tarantool module in C rather than in Lua. For example, to work with specific hardware or low-level system interfaces."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:80
msgid "See `README in \"ckit\" branch of tarantool/modulekit repository <http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for detailed instructions and examples."
msgstr ""

#: ../doc/2.2/book/app_server/contributing_module.rst:86
msgid "You can also create modules with C++, provided that the code does not throw exceptions."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:39
msgid "Cookbook recipes"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:41
msgid "Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:43
msgid "You can execute any of these programs by copying the code into a ``.lua`` file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-name}.lua` on the terminal."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:47
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:49
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:53
msgid "This runs  Tarantool Lua application server, which should be on the execution path."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:56
msgid "This section contains the following recipes:"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:61
msgid "Use freely."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:67
msgid "hello_world.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:69
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:71
msgid "#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:81
msgid "console_start.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:83
msgid "Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if this is the first time the server has been run. Then use :ref:`console.start() <console-start>` to start interactive mode."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:87
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:108
msgid "fio_read.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:110
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:112
#: ../doc/2.2/reference/reference_lua/errcodes.rst:147
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:130
msgid "fio_write.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:132
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:134
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:152
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:154
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-in function: printf(). (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:157
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:172
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:174
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C function: gettimeofday(). This delivers time with millisecond precision, unlike the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:178
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:202
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:204
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C library function. (For help understanding ffi, see the `FFI tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:207
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:252
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:254
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:258
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:288
msgid "ffi_varbinary_insert.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:290
msgid "Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to insert a tuple which has a VARBINARY field. Lua does not have direct support for VARBINARY, so using C is one way to put in data which in MessagePack is stored as bin (MP_BIN). If the tuple is retrieved later, field \"b\" will have type = 'cdata'."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:296
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- box.cfg{} should be here\n"
"\n"
"s = box.schema.space.create('withdata')\n"
"s:format({{\"b\", \"varbinary\"}})\n"
"s:create_index('pk', {parts = {1, \"varbinary\"}})\n"
"\n"
"buffer = require('buffer')\n"
"ffi = require('ffi')\n"
"\n"
"function varbinary_insert(space, bytes)\n"
"    local tmpbuf = buffer.IBUF_SHARED\n"
"    tmpbuf:reset()\n"
"    local p = tmpbuf:alloc(3 + #bytes)\n"
"    p[0] = 0x91 -- MsgPack code for \"array-1\"\n"
"    p[1] = 0xC4 -- MsgPack code for \"bin-8\" so up to 256 bytes\n"
"    p[2] = #bytes\n"
"    for i, c in pairs(bytes) do p[i + 3 - 1] = c end\n"
"    ffi.cdef[[int box_insert(uint32_t space_id,\n"
"                             const char *tuple,\n"
"                             const char *tuple_end,\n"
"                             box_tuple_t **result);]]\n"
"    ffi.C.box_insert(space.id, tmpbuf.rpos, tmpbuf.wpos, nil)\n"
"end\n"
"\n"
"varbinary_insert(s, {0xDE, 0xAD, 0xBE, 0xAF})\n"
"varbinary_insert(s, {0xFE, 0xED, 0xFA, 0xCE})\n"
"\n"
"-- if successful, Tarantool enters the event loop now"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:334
msgid "print_arrays.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:336
msgid "Create Lua tables, and print them. Notice that for the 'array' table the iterator function is ipairs(), while for the 'map' table the iterator function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:344
msgid "#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:358
msgid "count_array.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:360
msgid "Use the '#' operator to get the number of items in an array-like Lua table. This operation has O(log(N)) complexity."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:363
msgid "#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:374
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:376
msgid "Missing elements in arrays, which Lua treats as \"nil\"s, cause the simple \"#\" operator to deliver improper results. The \"print(#t)\" instruction will print \"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" instruction will print \"10\". Other table functions, such as table.sort(), will also misbehave when \"nils\" are present."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:384
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:404
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:406
msgid "Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:411
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:434
msgid "count_map.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:436
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:438
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:451
msgid "swap.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:453
msgid "Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:455
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:468
msgid "class.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:470
msgid "Create a class, create a metatable for the class, create an instance of the class. Another illustration is at `http://lua-users.org/wiki/LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:474
msgid "#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:508
msgid "garbage.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:510
msgid "Activate the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:513
msgid "#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:523
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:525
msgid "Start one fiber for producer and one fiber for consumer. Use :ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak the channel size (:code:`ch_size` in the program code) to control the number of simultaneous tasks waiting for processing."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:530
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:584
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:586
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:590
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:608
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:610
msgid "Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP server, by creating a function that handles requests and echos them, and passing the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has been used to test with 100,000 clients, with each client getting a separate fiber."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:618
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:641
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:643
msgid "Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. This technique is not always necessary for tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the hood, before trying to connect to the first available address."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:651
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = 'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:671
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:673
msgid "Tarantool does not currently have a `udp_server` function, therefore socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be implemented with sockets and fibers."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:678
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:727
msgid "A function for a client that connects to this server could look something like this ..."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:730
msgid "local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:751
msgid "http_get.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:753
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:756
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:774
msgid "http_send.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:776
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:779
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:796
msgid "http_server.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:798
msgid "Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a web server."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:801
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:818
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:820
msgid "Use the `http`_ `rock` (which must first be installed) to generate HTML pages from templates. The `http`_ `rock`_ has a fairly simple template engine which allows execution of regular Lua code inside text blocks (like PHP). Therefore there is no need to learn new languages in order to write templates."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:826
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:839
msgid "An \"HTML\" file for this server, including Lua, could look like this (it would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/2.2/book/app_server/cookbook.rst:842
msgid "<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:39
msgid "Creating an application"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:41
msgid "Further we walk you through key programming practices that will give you a good start in writing Lua applications for Tarantool. For an adventure, this is a story of implementing... a real microservice based on Tarantool! We implement a backend for a simplified version of `Pokémon Go <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented reality game released in mid-2016. In this game, players use a mobile device's GPS capability to locate, capture, battle and train virtual monsters called \"pokémon\", who appear on the screen as if they were in the same real-world location as the player."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:51
msgid "To stay within the walk-through format, let's narrow the original gameplay as follows. We have a map with pokémon spawn locations. Next, we have multiple players who can send catch-a-pokémon requests to the server (which runs our Tarantool microservice). The server replies whether the pokémon is caught or not, increases the player's pokémon counter if yes, and triggers the respawn-a-pokémon method that spawns a new pokémon at the same location in a while."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:59
msgid "We leave client-side applications outside the scope of this story. Yet we promise a mini-demo in the end to simulate real users and give us some fun. :-)"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:65
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:71
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:73
msgid "To make our game logic available to other developers and Lua applications, let's put it into a Lua module."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:76
msgid "A **module** (called \"rock\" in Lua) is an optional library which enhances Tarantool functionality. So, we can install our logic as a module in Tarantool and use it from any Tarantool application or module. Like applications, modules in Tarantool can be written in Lua (rocks), C or C++."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:81
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:83
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:84
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:86
msgid "Technically, a module is a file with source code that exports its functions in an API. For example, here is a Lua module named ``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:90
msgid "local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:98
msgid "To launch the function ``myfun()`` -- from another module, from a Lua application, or from Tarantool itself, -- we need to save this module as a file, then load this module with the ``require()`` directive and call the exported function."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:102
msgid "For example, here's a Lua application that uses ``myfun()`` function from ``mymodule.lua`` module:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:105
msgid "-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:115
msgid "A thing to remember here is that the ``require()`` directive takes load paths to Lua modules from the ``package.path`` variable. This is a semicolon-separated string, where a question mark is used to interpolate the module name. By default, this variable contains system-wide Lua paths and the working directory. But if we put our modules inside a specific folder (e.g. ``scripts/``), we need to add this folder to ``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:122
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:126
msgid "For our microservice, a simple and convenient solution would be to put all methods in a Lua module (say ``pokemon.lua``) and to write a Lua application (say ``game.lua``) that initializes the gaming environment and starts the game loop."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:134
msgid "Now let's get down to implementation details. In our game, we need three entities:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:136
msgid "**map**, which is an array of pokémons with coordinates of respawn locations; in this version of the game, let a location be a rectangle identified with two points, upper-left and lower-right;"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:139
msgid "**player**, which has an ID, a name, and coordinates of the player's location point;"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:141
msgid "**pokémon**, which has the same fields as the player, plus a status (active/inactive, that is present on the map or not) and a catch probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:145
msgid "We'll store these entities as tuples in Tarantool spaces. But to deliver our backend application as a microservice, the good practice would be to send/receive our data in the universal JSON format, thus using Tarantool as a document storage."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:153
msgid "Avro schemas"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:155
msgid "To store JSON data as tuples, we will apply a savvy practice which reduces data footprint and ensures all stored documents are valid. We will use Tarantool module `avro-schema <https://github.com/tarantool/avro-schema>`_ which checks the schema of a JSON document and converts it to a Tarantool tuple. The tuple will contain only field values, and thus take a lot less space than the original document. In avro-schema terms, converting JSON documents to tuples is \"flattening\", and restoring the original documents is \"unflattening\". The usage is quite straightforward:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:164
msgid "For each entity, we need to define a schema in `Apache Avro schema <https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the entity's fields with their names and `Avro data types <http://avro.apache.org/docs/current/spec.html#schema_primitive>`_."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:168
msgid "At initialization, we call ``avro-schema.create()`` that creates objects in memory for all schema entities, and ``compile()`` that generates flatten/unflatten methods for each entity."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:171
msgid "Further on, we just call flatten/unflatten methods for a respective entity on receiving/sending the entity's data."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:174
msgid "Here's what our schema definitions for the player and pokémon entities look like:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:176
msgid "local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:221
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:223
msgid "-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:246
msgid "As for the map entity, it would be an overkill to introduce a schema for it, because we have only one map in the game, it has very few fields, and -- which is most important -- we use the map only inside our logic, never exposing it to external users."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:254
msgid "Next, we need methods to implement the game logic. To simulate object-oriented programming in our Lua code, let's store all Lua functions and shared variables in a single local variable (let's name it as ``game``). This will allow us to address functions or variables from within our module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:260
msgid "local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:279
msgid "In OOP terms, we can now regard local variables inside ``game`` as object fields, and local functions as object methods."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:284
msgid "In this manual, Lua examples use **local** variables. Use **global** variables with caution, since the module’s users may be unaware of them."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:287
msgid "To enable/disable the use of undeclared global variables in your Lua code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:290
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:292
msgid "``catch()`` to calculate whether the pokémon was caught (besides the coordinates of both the player and pokémon, this method will apply a probability factor, so not every pokémon within the player's reach will be caught);"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:296
msgid "``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we assume that a frightened pokémon runs away, so we remove a pokémon from the map on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:299
msgid "``notify()`` to log information about caught pokémons (like \"Player 1 caught pokémon A\");"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:301
msgid "``start()`` to initialize the game (it will create database spaces, create and compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:304
msgid "Besides, it would be convenient to have methods for working with Tarantool storage. For example:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:307
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:308
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:310
msgid "We'll need these two methods primarily when initializing our game, but we can also call them later, for example to test our code."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:317
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:319
msgid "Let's discuss game initialization. In ``start()`` method, we need to populate Tarantool spaces with pokémon data. Why not keep all game data in memory? Why use a database? The answer is: :ref:`persistence <index-box_persistence>`. Without a database, we risk losing data on power outage, for example. But if we store our data in an in-memory database, Tarantool takes care to persist it on disk whenever it's changed. This gives us one more benefit: quick startup in case of failure. Tarantool has a :ref:`smart algorithm <internals-recovery_process>` that quickly loads all data from disk into memory on startup, so the warm-up takes little time."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:329
msgid "We'll be using functions from Tarantool built-in :ref:`box <box-module>` module:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:331
msgid "``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` for storing information about pokémons (we don't create a similar space for players, because we intend to only send/receive player information via API calls, so we needn't store it);"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:335
msgid "``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:337
msgid "``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, 'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:340
msgid "Notice the ``parts =`` argument in the index specification. The pokémon ID is the first field in a Tarantool tuple since it’s the first member of the respective Avro type. So does the pokémon status. The actual JSON document may have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:345
msgid "The implementation of ``start()`` method looks like this:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:347
msgid "-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:385
msgid "GIS"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:387
msgid "Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:389
msgid "Here we receive the player's coordinates and the target pokémon's ID number, and we need to answer whether the player has actually caught the pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:393
msgid "First thing, we validate the received player data against its :ref:`Avro schema <app_server-avro_schemas>`. And we check whether such a pokémon exists in our database and is displayed on the map (the pokémon must have the active status):"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:398
msgid "catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:422
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:424
msgid "To work with geographical coordinates, we use Tarantool `gis <https://github.com/tarantool/gis>`_ module."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:427
msgid "To keep things simple, we don't load any specific map, assuming that we deal with a world map. And we do not validate incoming coordinates, assuming again that all received locations are within the planet Earth."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:431
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:433
msgid "``wgs84``, which stands for the latest revision of the World Geodetic System standard, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically, it comprises a standard coordinate system for the Earth and represents the Earth as an ellipsoid."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:437
msgid "``nationalmap``, which stands for the `US National Atlas Equal Area <https://epsg.io/2163>`_. This is a projected coordinates system based on WGS84. It gives us a zero base for location projection and allows positioning our players and pokémons in meters."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:442
msgid "Both these systems are listed in the EPSG Geodetic Parameter Registry, where each system has a unique number. In our code, we assign these listing numbers to respective variables:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:446
msgid "wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:451
msgid "For our game logic, we need one more variable, ``catch_distance``, which defines how close a player must get to a pokémon before trying to catch it. Let's set the distance to 100 meters."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:455
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:459
msgid "Now we're ready to calculate the answer. We need to project the current location of both player (``p_pos``) and pokémon (``m_pos``) on the map, check whether the player is close enough to the pokémon (using ``catch_distance``), and calculate whether the player has caught the pokémon (here we generate some random value and let the pokémon escape if the random value happens to be less than 100 minus pokémon's chance value):"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:466
msgid "-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:495
msgid "Index iterators"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:497
msgid "By our gameplay, all caught pokémons are returned back to the map. We do this for all pokémons on the map every 60 seconds using ``respawn()`` method. We iterate through pokémons by status using Tarantool index iterator function :ref:`index:pairs <box_index-index_pairs>` and reset the statuses of all \"caught\" pokémons back to \"active\" using ``box.space.pokemons:update()``."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:503
msgid "respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:516
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:518
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:521
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:523
msgid "-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:563
#: ../doc/2.2/reference/reference_lua/fiber.rst:176
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:969
msgid "Fibers"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:565
msgid "But wait! If we launch it as shown above -- ``self.respawn()`` -- the function will be executed only once, just like all the other methods. But we need to execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber <fiber-module>` is the Tarantool way of making application logic work in the background at all times."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:571
msgid "A **fiber** exists for executing instruction sequences but it is not a thread. The key difference is that threads use preemptive multitasking, while fibers use cooperative multitasking. This gives fibers the following two advantages over threads:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:576
msgid "Better controllability. Threads often depend on the kernel's thread scheduler to preempt a busy thread and resume another thread, so preemption may occur unpredictably. Fibers yield themselves to run another fiber while executing, so yields are controlled by application logic."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:580
msgid "Higher performance. Threads require more resources to preempt as they need to address the system kernel. Fibers are lighter and faster as they don't need to address the kernel to yield."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:584
msgid "Yet fibers have some limitations as compared with threads, the main limitation being no multi-core mode. All fibers in an application belong to a single thread, so they all use the same CPU core as the parent thread. Meanwhile, this limitation is not really serious for Tarantool applications, because a typical bottleneck for Tarantool is the HDD, not the CPU."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:590
msgid "A fiber has all the features of a Lua `coroutine <http://www.lua.org/pil/contents.html#9>`_ and all programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:597
msgid "Well, performance or controllability are of little importance in our case. We'll launch ``respawn()`` in a fiber to make it work in the background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:601
msgid "respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:619
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:621
msgid "start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:641
#: ../doc/2.2/reference/configuration/index.rst:270
msgid "Logging"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:643
msgid "One more helpful function that we used in ``start()`` was ``log.infо()`` from Tarantool :ref:`log <log-module>` module. We also need this function in ``notify()`` to add a record to the log file on every successful catch:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:647
msgid "-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:654
msgid "We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the log output in console when we launch our application in script mode."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:660
msgid "Great! We've discussed all programming practices used in our Lua module (see `pokemon.lua <https://github.com/tarantool/pokemon/blob/1.9/src/pokemon.lua>`_)."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:663
msgid "Now let's prepare the test environment. As planned, we write a Lua application (see `game.lua <https://github.com/tarantool/pokemon/blob/1.9/game.lua>`_) to initialize Tarantool's database module, initialize our game, call the game loop and simulate a couple of player requests."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:668
msgid "To launch our microservice, we put both ``pokemon.lua`` module and ``game.lua`` application in the current directory, install all external modules, and launch the Tarantool instance running our ``game.lua`` application (this example is for Ubuntu):"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:673
msgid "$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:681
msgid "Tarantool starts and initializes the database. Then Tarantool executes the demo logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be caught is very high, 99.1), displays the current map (it contains one active pokémon, Pikachu) and processes catch requests from two players. Player1 is located just near the lonely Pikachu pokémon and Player2 is located far away from it. As expected, the catch results in this output are \"true\" for Player1 and \"false\" for Player2. Finally, Tarantool displays the current map which is empty, because Pikachu is caught and temporarily inactive:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:690
msgid "$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot `./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:715
msgid "nginx"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:717
msgid "In the real life, this microservice would work over HTTP. Let's add `nginx <https://nginx.org/en/>`_ web server to our environment and make a similar demo. But how do we make Tarantool methods callable via REST API? We use nginx with `Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ module and create one more Lua script (`app.lua <https://github.com/tarantool/pokemon/blob/1.9/src/app.lua>`_) that exports three of our game methods -- ``add_pokemon()``, ``map()`` and ``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:726
msgid "local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:755
msgid "An easy way to configure and launch nginx would be to create a Docker container based on a `Docker image <https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ with nginx and the upstream module already installed (see `http/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/http/Dockerfile>`_). We take a standard `nginx.conf <https://github.com/tarantool/pokemon/blob/1.9/http/nginx.conf>`_, where we define an upstream with our Tarantool backend running (this is another Docker container, see details below):"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:764
msgid "upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:771
msgid "and add some Tarantool-specific parameters (see descriptions in the upstream module's `README <https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:775
msgid "server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:801
msgid "Likewise, we put Tarantool server and all our game logic in a second Docker container based on the `official Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see `src/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/src/Dockerfile>`_) and set the container's default command to ``tarantool app.lua``. This is the backend."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:810
msgid "Non-blocking IO"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:812
msgid "To test the REST API, we create a new script (`client.lua <https://github.com/tarantool/pokemon/blob/1.9/client/client.lua>`_), which is similar to our ``game.lua`` application, but makes HTTP POST and GET requests rather than calling Lua functions:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:817
msgid "local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:892
msgid "When you run this script, you’ll notice that both players have equal chances to make the first attempt at catching the pokémon. In a classical Lua script, a networked call blocks the script until it’s finished, so the first catch attempt can only be done by the player who entered the game first. In Tarantool, both players play concurrently, since all modules are integrated with Tarantool :ref:`cooperative multitasking <atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:900
msgid "Indeed, when Player1 makes its first REST call, the script doesn’t block. The fiber running ``catch()`` function on behalf of Player1 issues a non-blocking call to the operating system and yields control to the next fiber, which happens to be the fiber of Player2. Player2’s fiber does the same. When the network response is received, Player1's fiber is activated by Tarantool cooperative scheduler, and resumes its work. All Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are integrated with Tarantool cooperative scheduler. For module developers, Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:909
msgid "For our HTTP test, we create a third container based on the `official Tarantool 1.9 image <https://github.com/tarantool/docker>`_ (see `client/Dockerfile <https://github.com/tarantool/pokemon/blob/1.9/client/Dockerfile>`_) and set the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:917
msgid "To run this test locally, download our `pokemon <https://github.com/tarantool/pokemon>`_ project from GitHub and say:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:920
msgid "$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:925
msgid "Docker Compose builds and runs all the three containers: ``pserver`` (Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You can see log messages from all these containers in the console, pclient saying that it made an HTTP request to create a pokémon, made two catch requests, requested the map (empty since the pokémon is caught and temporarily inactive) and exited:"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:931
msgid "pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:944
msgid "Congratulations! Here's the end point of our walk-through. As further reading, see more about :ref:`installing <app_server-installing_module>` and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/2.2/book/app_server/creating_app.rst:948
msgid "See also reference on :ref:`Tarantool modules <built_in_modules>` and :ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook recipes <cookbook>`."
msgstr ""

#: ../doc/2.2/book/app_server/index.rst:39
msgid "Application server"
msgstr ""

#: ../doc/2.2/book/app_server/index.rst:41
msgid "In this chapter, we introduce the basics of working with Tarantool as a Lua application server."
msgstr ""

#: ../doc/2.2/book/app_server/index.rst:44
#: ../doc/2.2/book/box/index.rst:44
#: ../doc/2.2/book/getting_started/index.rst:44
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:39
msgid "Installing a module"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:41
msgid "Modules in Lua and C that come from Tarantool developers and community contributors are available in the following locations:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:44
msgid "Tarantool modules repository, and"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:45
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:51
msgid "Installing a module from a repository"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:53
msgid "See `README in tarantool/rocks repository <https://github.com/tarantool/rocks#managing-modules-with-tarantool-174>`_ for detailed instructions."
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:61
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:63
msgid "Follow these steps:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:65
msgid "Install Tarantool as recommended on the `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:68
msgid "Install the module you need. Look up the module's name on `Tarantool rocks page <http://tarantool.org/rocks.html>`_ and put the prefix \"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:72
msgid "$ # for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"$ # for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:80
msgid "For example, to install the module `shard <http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:83
#: ../doc/2.2/reference/reference_rock/shard.rst:120
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:87
msgid "Once these steps are complete, you can:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:89
msgid "load any module with"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:91
msgid "tarantool> name = require('module-name')"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:95
msgid "for example:"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:97
msgid "tarantool> shard = require('shard')"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:101
msgid "search locally for installed modules using ``package.path`` (Lua) or ``package.cpath`` (C):"
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:104
msgid "tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/2.2/book/app_server/installing_module.rst:124
msgid "Question-marks stand for the module name that was specified earlier when saying ``require('module-name')``."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:39
msgid "Launching an application"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:41
msgid "Using Tarantool as an application server, you can write your own applications. Tarantool’s native language for writing applications is `Lua <http://www.lua.org/about.html>`_, so a typical application would be a file that contains your Lua script. But you can also write applications in C or C++."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:49
msgid "If you're new to Lua, we recommend going over the interactive Tarantool tutorial before proceeding with this chapter. To launch the tutorial, say ``tutorial()`` in Tarantool console:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:53
msgid "tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:68
msgid "Let's create and launch our first Lua application for Tarantool. Here's a simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:71
msgid "#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:76
msgid "We save it in a file. Let it be ``myapp.lua`` in the current directory."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:78
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:84
msgid "Launching in Docker"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:86
msgid "If we run Tarantool in a :ref:`Docker container <getting_started-using_docker>`, the following command will start Tarantool 1.9 without any application:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:89
msgid "$ # create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool:1"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:94
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:96
msgid "$ # create a temporary container and\n"
"$ # launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool:1 tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:105
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:107
msgid "our application file (myapp.lua) and"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:108
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:110
msgid "By convention, the directory for Tarantool application code inside a container is ``/opt/tarantool``, and the directory for data is ``/var/lib/tarantool``."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:117
msgid "Launching a binary program"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:119
msgid "If we run Tarantool from a :ref:`binary package <getting_started-using_binary>` or from a :ref:`source build <building_from_source>`, we can launch our application:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:123
msgid "in the script mode,"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:124
msgid "as a server application, or"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:125
msgid "as a daemon service."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:127
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:129
#: ../doc/2.2/book/app_server/launching_app.rst:220
msgid "$ tarantool myapp.lua\n"
"Hello, world!\n"
"$"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:135
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:137
msgid "Now let’s turn this script into a **server application**. We use :ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua module to:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:141
msgid "launch the database (a database has a persistent on-disk state, which needs to be restored after we start an application) and"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:143
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:145
msgid "We also add some simple database logic, using :ref:`space.create() <box_schema-space_create>` and :ref:`create_index() <box_space-create_index>` to create a space with a primary index. We use the function :ref:`box.once() <box-once>` to make sure that our logic will be executed only once when the database is initialized for the first time, so we don't try to create an existing space or index on each invocation of the script:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:153
msgid "#!/usr/bin/env tarantool\n"
"-- Configure database\n"
"box.cfg {\n"
"   listen = 3301\n"
"}\n"
"box.once(\"bootstrap\", function()\n"
"   box.schema.space.create('tweedledum')\n"
"   box.space.tweedledum:create_index('primary',\n"
"       { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:166
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:168
msgid "$ tarantool myapp.lua\n"
"Hello, world!\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> version 2.1.0-429-g4e5231702\n"
"2017-08-11 16:07:14.250 [41436] main/101/myapp.lua C> log level 5\n"
"2017-08-11 16:07:14.251 [41436] main/101/myapp.lua I> mapping 1073741824 bytes for tuple arena...\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovery start\n"
"2017-08-11 16:07:14.255 [41436] main/101/myapp.lua I> recovering from `./00000000000000000000.snap'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> recover from `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.271 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.272 [41436] main/102/hot_standby I> recover from `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.274 [41436] iproto/102/iproto I> binary: started\n"
"2017-08-11 16:07:14.275 [41436] iproto/102/iproto I> binary: bound to [::]:3301\n"
"2017-08-11 16:07:14.275 [41436] main/101/myapp.lua I> done `./00000000000000000000.xlog'\n"
"2017-08-11 16:07:14.278 [41436] main/101/myapp.lua I> ready to accept requests"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:185
msgid "This time, Tarantool executes our script and keeps working as a server, accepting TCP requests on port 3301. We can see Tarantool in the current session’s process list:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:189
msgid "$ ps | grep \"tarantool\"\n"
"  PID TTY           TIME CMD\n"
"41608 ttys001       0:00.47 tarantool myapp.lua <running>"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:195
msgid "But the Tarantool instance will stop if we close the current terminal window. To detach Tarantool and our application from the terminal window, we can launch it in the **daemon mode**. To do so, we add some parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:199
msgid ":ref:`background <cfg_basic-background>` = ``true`` that actually tells Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:201
msgid ":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool daemon where to store its log file (other log settings are available in Tarantool :ref:`log <log-module>` module), and"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:204
msgid ":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the Tarantool daemon where to store its pid file."
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:207
#: ../doc/2.2/book/box/engines/vinyl.rst:548
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:60
#: ../doc/2.2/reference/reference_lua/box_error.rst:104
#: ../doc/2.2/reference/reference_lua/digest.rst:261
#: ../doc/2.2/reference/reference_rock/dbms.rst:116
#: ../doc/2.2/reference/reference_rock/dbms.rst:469
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:877
#: ../doc/2.2/reference/reference_sql/sql.rst:1159
#: ../doc/2.2/reference/reference_sql/sql.rst:2190
msgid "For example:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:209
msgid "box.cfg {\n"
"   listen = 3301\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:218
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:226
msgid "Tarantool executes our script, gets detached from the current shell session (you won't see it with ``ps | grep \"tarantool\"``) and continues working in the background as a daemon attached to the global session (with SID = 0):"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:230
msgid "$ ps -ef | grep \"tarantool\"\n"
"  PID SID     TIME  CMD\n"
"42178   0  0:00.72 tarantool myapp.lua <running>"
msgstr ""

#: ../doc/2.2/book/app_server/launching_app.rst:236
msgid "Now that we have discussed how to create and launch a Lua application for Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:39
msgid "Reloading a module"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:41
msgid "You can reload any Tarantool application or module with zero downtime."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:47
msgid "Reloading a module in Lua"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:49
msgid "Here's an example that illustrates the most typical case -- \"update and reload\"."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:53
msgid "In this example, we use recommended :ref:`administration practices <admin>` based on :ref:`instance files <admin-instance_file>` and :ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:57
msgid "Update the application file."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:59
msgid "For example, a module in ``/usr/share/tarantool/app.lua``:"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:61
msgid "local function start()\n"
"  -- initial version\n"
"  box.once(\"myapp:v1.0\", function()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:v1.1\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    ...\n"
"  end)\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:v1.2\", function()\n"
"    box.space.somedata.index.primary:alter(...)\n"
"    box.space.somedata:insert(...)\n"
"    ...\n"
"  end)\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and clean up resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start,\n"
"  stop = stop,\n"
"  api_for_call = api_for_call\n"
"}"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:101
msgid "Update the :ref:`instance file <admin-instance_file>`."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:103
msgid "For example, ``/etc/tarantool/instances.enabled/my_app.lua``:"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:105
msgid "#!/usr/bin/env tarantool\n"
"--\n"
"-- hot code reload example\n"
"--\n"
"\n"
"box.cfg({listen = 3302})\n"
"\n"
"-- ATTENTION: unload it all properly!\n"
"local app = package.loaded['app']\n"
"if app ~= nil then\n"
"  -- stop the old application version\n"
"  app.stop()\n"
"  -- unload the application\n"
"  package.loaded['app'] = nil\n"
"  -- unload all dependencies\n"
"  package.loaded['somedep'] = nil\n"
"end\n"
"\n"
"-- load the application\n"
"log.info('require app')\n"
"app = require('app')\n"
"\n"
"-- start the application\n"
"app.start({some app options controlled by sysadmins})"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:132
msgid "The important thing here is to properly unload the application and its dependencies."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:135
msgid "Manually reload the application file."
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:137
msgid "For example, using ``tarantoolctl``:"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:139
msgid "$ tarantoolctl eval my_app /etc/tarantool/instances.enabled/my_app.lua"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:147
msgid "Reloading a module in C"
msgstr ""

#: ../doc/2.2/book/app_server/reloading_module.rst:149
msgid "After you compiled a new version of a C module (``*.so`` shared library), call :ref:`box.schema.func.reload('module-name') <box_schema-func_reload>` from your Lua script to reload the module."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:39
msgid "Developing with an IDE"
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:41
msgid "You can use IntelliJ IDEA as an IDE to develop and debug Lua applications for Tarantool."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:44
msgid "Download and install the IDE from the `official web-site <https://www.jetbrains.com/idea/>`_."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:47
msgid "JetBrains provides specialized editions for particular languages: IntelliJ IDEA (Java), PHPStorm (PHP), PyCharm (Python), RubyMine (Ruby), CLion (C/C++), WebStorm (Web) and others. So, download a version that suits your primary programming language."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:52
msgid "Tarantool integration is supported for all editions."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:54
msgid "Configure the IDE:"
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:56
msgid "Start IntelliJ IDEA."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:57
msgid "Click ``Configure`` button and select ``Plugins``."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:64
msgid "Click ``Browse repositories``."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:71
msgid "Install ``EmmyLua`` plugin."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:75
msgid "Please don’t be confused with ``Lua`` plugin, which is less powerful than ``EmmyLua``."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:83
msgid "Restart IntelliJ IDEA."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:84
msgid "Click ``Configure``, select ``Project Defaults`` and then ``Run Configurations``."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:92
msgid "Find ``Lua Application`` in the sidebar at the left."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:94
msgid "In ``Program``, type a path to an installed ``tarantool`` binary."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:96
msgid "By default, this is ``tarantool`` or ``/usr/bin/tarantool`` on most platforms."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:99
msgid "If you installed ``tarantool`` from sources to a custom directory, please specify the proper path here."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:107
msgid "Now IntelliJ IDEA is ready to use with Tarantool."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:109
msgid "Create a new Lua project."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:116
msgid "Add a new Lua file, for example ``init.lua``."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:123
msgid "Write your code, save the file."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:125
msgid "To run you application, click ``Run -> Run`` in the main menu and select your source file in the list."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:133
msgid "Or click ``Run -> Debug`` to start debugging."
msgstr ""

#: ../doc/2.2/book/app_server/using_ide.rst:137
msgid "To use Lua debugger, please upgrade Tarantool to version 1.7.5-29-gbb6170e4b or later."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:39
msgid "Transaction control"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:41
msgid "Transactions in Tarantool occur in **fibers** on a single **thread**. That is why Tarantool has a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:49
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:51
msgid "How does Tarantool process a basic operation? As an example, let's take this query:"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:54
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:58
msgid "This is equivalent to the following SQL statement for a table that stores primary keys in ``field[1]``:"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:61
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[1]\" = 3"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:65
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:67
msgid "If we issue the query on a remote client, then the **network thread** on the server side receives the query, parses the statement and changes it to a server executable message which has already been checked, and which the server instance can understand without parsing everything again."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:72
msgid "The network thread ships this message to the instance's **transaction processor thread** using a lock-free message bus. Lua programs execute directly in the transaction processor thread, and do not require parsing and preparation."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:77
msgid "The instance's transaction processor thread uses the primary-key index on field[1] to find the location of the tuple. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:82
msgid "The transaction processor thread sends a message to the :ref:`write-ahead logging (WAL) thread <internals-wal>` to commit the transaction. When done, the WAL thread replies with a COMMIT or ROLLBACK result, which is returned to the client."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:87
msgid "Notice that there is only one transaction processor thread in Tarantool. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x, while thread #2 writes row #y. With Tarantool, no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each Tarantool instance."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:94
msgid "Like any other Tarantool thread, the transaction processor thread can handle many :ref:`fibers <fiber-fibers>`. A fiber is a set of computer instructions that may contain \"**yield**\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row #x for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:101
msgid "Yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:104
msgid ":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation or network-access causes an implicit yield, and every statement that goes through the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:108
msgid "explicit yields: in a Lua function, you can (and should) add :ref:`\"yield\" <fiber-yield>` statements to prevent hogging. This is called **cooperative multitasking**."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:116
msgid "Cooperative multitasking"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:118
msgid "Cooperative multitasking means: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a “yield point”: a transaction commit, an operating system call, or an explicit :ref:`\"yield\" <fiber-yield>` request. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted, so that another ready-to-run fiber takes its place and becomes the new running fiber."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:126
msgid "This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:130
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:134
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function’s author."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:144
#: ../doc/2.2/reference/reference_sql/sql.rst:2389
msgid "Transactions"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:146
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Multi-statement transactions exist to provide **isolation**: each transaction sees a consistent database state and commits all its changes atomically. At :ref:`commit <box-commit>` time, a yield happens and all transaction changes are written to the :ref:`write ahead log <internals-wal>` in a single batch. Or, if needed, transaction changes can be rolled back -- :ref:`completely <box-rollback>` or to a specific :ref:`savepoint <box-rollback_to_savepoint>`."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:156
msgid "To implement isolation, Tarantool uses a simple optimistic scheduler: the first transaction to commit wins. If a concurrent active transaction has read a value modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:160
msgid "The cooperative scheduler ensures that, in absence of yields, a multi-statement transaction is not preempted and hence is never aborted. Therefore, understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:166
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:172
msgid "Implicit yields"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:174
msgid "The only explicit yield requests in Tarantool are :ref:`fiber.sleep() <fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:178
msgid "Database requests imply yields if and only if there is disk I/O. For memtx, since all data is in memory, there is no disk I/O during the request. For vinyl, since some data may not be in memory, there may be disk I/O for a read (to fetch data from disk) or for a write (because a stall may occur while waiting for memory to be free). For both memtx and vinyl, since data-change requests must be recorded in the WAL, there is normally a commit. A commit happens automatically after every request in default \"autocommit\" mode, or a commit happens at the end of a transaction in \"transaction\" mode, when a user deliberately commits by calling :ref:`box.commit() <box-commit>`. Therefore for both memtx and vinyl, because there can be disk I/O, some database operations may imply yields."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:191
msgid "Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:195
#: ../doc/2.2/book/box/box_session.rst:386
msgid "**Example #1**"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:197
msgid "*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of insertion, caused by implicit commit; ``select()`` has nothing to write to the WAL and so does not yield."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:202
msgid "*Engine = vinyl* |br| ``select() insert()`` has between one and three yields, since ``select()`` may yield if the data is not in cache, ``insert()`` may yield waiting for available memory, and there is an implicit yield at commit."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:207
msgid "The sequence ``begin() insert() insert() commit()`` yields only at commit if the engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:210
#: ../doc/2.2/book/box/box_session.rst:395
#: ../doc/2.2/reference/reference_lua/key_def.rst:119
msgid "**Example #2**"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:212
msgid "Assume that in space ‘tester’ there are tuples in which the third field represents a positive dollar amount. Let's start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:217
msgid "tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:233
msgid "If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then implicit yielding at commit time does not take place, because there are no writes to the WAL."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:237
msgid "If a task is interactive -- sending requests to the server and receiving responses -- then it involves network IO, and therefore there is an implicit yield, even if the request that is sent to the server is not itself an implicit yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:245
msgid "select\n"
"select\n"
"select"
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:249
msgid "causes blocking (in memtx), if it is inside a function or Lua program being executed on the server instance, but causes yielding (in both memtx and vinyl) if it is done as a series of transmissions from a client, including a client which operates via telnet, via one of the connectors, or via the :ref:`MySQL and PostgreSQL rocks <dbms_modules>`, or via the interactive mode when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/2.2/book/box/atomic.rst:256
msgid "After a fiber has yielded and then has regained control, it immediately issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:39
msgid "Access control"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:41
msgid "Understanding security details is primarily an issue for administrators. However, ordinary users should at least skim this section to get an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:46
msgid "Briefly:"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:48
msgid "There is a method to guarantee with password checks that users really are who they say they are (“authentication”)."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:51
msgid "There is a :ref:`_user <box_space-user>` system space, where usernames and password-hashes are stored."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:54
msgid "There are functions for saying that certain users are allowed to do certain things (“privileges”)."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:57
msgid "There is a :ref:`_priv <box_space-priv>` system space, where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (“access control”)."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:61
msgid "Details follow."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:67
msgid "Users"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:69
msgid "There is a **current user** for any program working with Tarantool, local or remote. If a remote connection is using a :ref:`binary port <admin-security>`, the current user, by default, is '**guest**'. If the connection is using an :ref:`admin-console port <admin-security>`, the current user is '**admin**'. When executing a :ref:`Lua initialization script <index-init_label>`, the current user is also ‘**admin**’."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:78
msgid "The current user name can be found with :ref:`box.session.user() <box_session-user>`."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:80
msgid "The current user can be changed:"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:82
msgid "For a binary port connection -- with the :ref:`AUTH protocol command <box_protocol-iproto_protocol>`, supported by most clients;"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:86
msgid "For an admin-console connection and in a Lua initialization script -- with :ref:`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:89
msgid "For a binary-port connection invoking a stored function with the CALL command -- if the :ref:`SETUID <box_schema-func_create>` property is enabled for the function, Tarantool temporarily replaces the current user with the function’s creator, with all the creator's privileges, during function execution."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:98
msgid "Passwords"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:100
msgid "Each user (except 'guest') may have a **password**. The password is any alphanumeric string."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:103
msgid "Tarantool passwords are stored in the :ref:`_user <box_space-user>` system space with a `cryptographic hash function <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if the password is ‘x’, the stored hash-password is a long string like ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool instance, the instance sends a random `salt value <https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the client must mix with the hashed-password before sending to the instance. Thus the original value ‘x’ is never stored anywhere except in the user’s head, and the hashed value is never passed down a network wire except when mixed with a random salt."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:117
msgid "For more details of the password hashing algorithm (e.g. for the purpose of writing a new client application), read the `scramble.h <https://github.com/tarantool/tarantool/blob/2.1/src/scramble.h>`_ header file."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:122
msgid "This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago <http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which has proved adequate for medium-security installations. Nevertheless, administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally. Administrators should also advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:132
msgid "There are two functions for managing passwords in Tarantool: :ref:`box.schema.user.passwd() <box_schema-user_passwd>` for changing a user's password and :ref:`box.schema.user.password() <box_schema-user_password>` for getting a hash of a user's password."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:141
msgid "Owners and privileges"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:143
msgid "Tarantool has one database. It may be called \"box.schema\" or \"universe\". The database contains database objects, including spaces, indexes, users, roles, sequences, and functions."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:147
msgid "The **owner** of a database object is the user who created it. The owner of the database itself, and the owner of objects that are created initially (the system spaces and the default users) is '**admin**'."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:152
msgid "Owners automatically have **privileges** for what they create. They can share these privileges with other users or with roles, using **box.schema.user.grant** requests. The following privileges can be granted:"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:157
msgid "'read', e.g. allow select from a space"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:158
msgid "'write', e.g. allow update on a space"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:159
msgid "'execute', e.g. allow call of a function, or (less commonly) allow use of a role"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:160
msgid "'create', e.g. allow :ref:`box.schema.space.create <box_schema-space_create>` (access to certain system spaces is also necessary)"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:163
msgid "'alter', e.g. allow :ref:`box.space.x.index.y:alter <box_index-alter>` (access to certain system spaces is also necessary)"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:166
msgid "'drop', e.g. allow :ref:`box.sequence.x:drop <box_schema-sequence_drop>` (currently this can be granted but has no effect)"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:169
msgid "'usage', e.g. whether any action is allowable regardless of other privileges (sometimes revoking 'usage' is a convenient way to block a user temporarily without dropping the user)"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:172
msgid "'session', e.g. whether the user can 'connect'."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:174
msgid "To **create** objects, users need the 'create' privilege and at least 'read' and 'write' privileges on the system space with a similar name (for example, on the :ref:`_space <box_space-space>` if the user needs to create spaces)."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:179
msgid "To **access** objects, users need an appropriate privilege on the object (for example, the 'execute' privilege on function F if the users need to execute function F). See below some :ref:`examples for granting specific privileges <authentication-owners_privileges-examples-specific>` that a grantor -- that is, 'admin' or the object creator -- can make."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:185
msgid "To **drop** an object, users must be the object's creator or be 'admin'. As the owner of the entire database, 'admin' can drop any object including other users."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:189
msgid "To grant privileges to a user, the object owner says :ref:`grant() <box_schema-user_grant>`. To revoke privileges from a user, the object owner says :ref:`revoke() <box_schema-user_revoke>`. In either case, there are up to five parameters:"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:193
msgid "(user-name, privilege, object-type [, object-name [, options]])"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:197
msgid "``user-name`` is the user (or role) that will receive or lose the privilege;"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:198
msgid "``privilege`` is any of 'read', 'write', 'execute', 'create', 'alter', 'drop', 'usage', or 'session' (or a comma-separated list);"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:200
msgid "``object-type`` is any of 'space', 'index', 'sequence', 'function', role-name, or 'universe';"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:202
msgid "``object-name`` is what the privilege is for (omitted if ``object-type`` is 'universe');"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:204
msgid "``options`` is a list inside braces for example ``{if_not_exists=true|false}`` (usually omitted because the default is acceptable)."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:207
msgid "**Example for granting many privileges at once**"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:209
msgid "In this example user 'admin' grants many privileges on many objects to user 'U', with a single request."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:212
msgid "box.schema.user.grant('U','read,write,execute,create,drop','universe')"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:218
msgid "**Examples for granting privileges for specific operations**"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:220
msgid "In these examples the object's creator grants precisely the minimal privileges necessary for particular operations, to user 'U'."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:224
msgid "-- So that 'U' can create spaces:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','write', 'space', '_schema')\n"
"  box.schema.user.grant('U','write', 'space', '_space')\n"
"-- So that 'U' can  create indexes (assuming 'U' created the space)\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','read,write', 'space', '_index')\n"
"-- So that 'U' can  create indexes on space T (assuming 'U' did not create space T)\n"
"  box.schema.user.grant('U','create','space','T')\n"
"  box.schema.user.grant('U','read', 'space', '_space')\n"
"  box.schema.user.grant('U','write', 'space', '_index')\n"
"-- So that 'U' can  alter indexes on space T (assuming 'U' did not create the index)\n"
"  box.schema.user.grant('U','alter','space','T')\n"
"  box.schema.user.grant('U','read','space','_space')\n"
"  box.schema.user.grant('U','read','space','_index')\n"
"  box.schema.user.grant('U','read','space','_space_sequence')\n"
"  box.schema.user.grant('U','write','space','_index')\n"
"-- So that 'U' can create users or roles:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write', 'space', '_user')\n"
"  box.schema.user.grant('U','write','space', '_priv')\n"
"-- So that 'U' can create sequences:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_sequence')\n"
"-- So that 'U' can create functions:\n"
"  box.schema.user.grant('U','create','universe')\n"
"  box.schema.user.grant('U','read,write','space','_func')\n"
"-- So that 'U' can grant access on objects that 'U' created\n"
"  box.schema.user.grant('U','read','space','_user')\n"
"-- So that 'U' can select or get from a space named 'T'\n"
"  box.schema.user.grant('U','read','space','T')\n"
"-- So that 'U' can update or insert or delete or truncate a space named 'T'\n"
"  box.schema.user.grant('U','write','space','T')\n"
"-- So that 'U' can execute a function named 'F'\n"
"  box.schema.user.grant('U','execute','function','F')\n"
"-- So that 'U' can use the \"S:next()\" function with a sequence named S\n"
"  box.schema.user.grant('U','read,write','sequence','S')\n"
"-- So that 'U' can use the \"S:set()\" or \"S:reset() function with a sequence named S\n"
"  box.schema.user.grant('U','write','sequence','S')"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:266
msgid "**Example for creating users and objects then granting privileges**"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:268
msgid "Here we create a Lua function that will be executed under the user id of its creator, even if called by another user."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:271
msgid "First, we create two spaces ('u' and 'i') and grant a no-password user ('internal') full access to them. Then we define a function ('read_and_modify') and the no-password user becomes this function's creator. Finally, we grant another user ('public_user') access to execute Lua functions created by the no-password user."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:276
msgid "box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'create', 'universe')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"    u:put{key, box.session.uid()}\n"
"    i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:311
msgid "Roles"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:313
msgid "A **role** is a container for privileges which can be granted to regular users. Instead of granting or revoking individual privileges, you can put all the privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:317
msgid "Role information is stored in the :ref:`_user <box_space-user>` space, but the third field in the tuple -- the type field -- is ‘role’ rather than ‘user’."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:320
msgid "An important feature in role management is that roles can be **nested**. For example, role R1 can be granted a privilege \"role R2\", so users with the role R1 will subsequently get all privileges from both roles R1 and R2. In other words, a user gets all the privileges that are granted to a user’s roles, directly or indirectly."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:326
msgid "There are actually two ways to grant or revoke a role: :samp:`box.schema.user.grant-or-revoke({user-name-or-role-name},'execute', 'role',{role-name}...)` or :samp:`box.schema.user.grant-or-revoke({user-name-or-role-name},{role-name}...)`. The second way is preferable."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:332
msgid "The 'usage' and 'session' privileges cannot be granted to roles."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:336
msgid "-- This example will work for a user with many privileges, such as 'admin'\n"
"-- or a user with the pre-defined 'super' role\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)\n"
"-- There are two ways to grant a role; here we use the shorter way\n"
"box.schema.role.grant('R1', 'R2')\n"
"box.schema.user.grant('U1', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:361
msgid "For more detail see :ref:`box.schema.user.grant() <box_schema-user_grant>` and :ref:`box.schema.role.grant() <box_schema-role_grant>` in the built-in modules reference."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:370
msgid "Sessions and security"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:372
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:374
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:375
msgid "the :ref:`current user <authentication-users>` associated with the connection,"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:376
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:377
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:379
msgid "In Tarantool, a single session can execute multiple concurrent transactions. Each transaction is identified by a unique integer id, which can be queried at start of the transaction using :ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/2.2/book/box/authentication.rst:385
msgid "To track all connects and disconnects, you can use :ref:`connection and authentication triggers <triggers>`."
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:39
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:43
msgid "The ``box.cfg`` submodule is for administrators to specify all the :ref:`server configuration parameters <box_cfg_params>`."
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:46
msgid "Say ``box.cfg`` without braces to view the current configuration, for example:"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:48
msgid "tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:60
msgid "To set the parameters, say ``box.cfg{...}``, for example:"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:62
#: ../doc/2.2/book/getting_started/using_binary.rst:125
msgid "tarantool> box.cfg{listen = 3301}"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:66
msgid "If you say ``box.cfg{}`` with no parameters, Tarantool applies default settings:"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:68
msgid "tarantool> box.cfg{}\n"
"tarantool> box.cfg -- sorted in the alphabetic order\n"
"---\n"
"- background                   = false\n"
"  checkpoint_count             = 2\n"
"  checkpoint_interval          = 3600\n"
"  checkpoint_wal_threshold     = 1000000000000000000\n"
"  coredump                     = false\n"
"  custom_proc_title            = nil\n"
"  feedback_enabled             = true\n"
"  feedback_host                = 'https://feedback.tarantool.io'\n"
"  feedback_interval            = 3600\n"
"  force_recovery               = false\n"
"  hot_standby                  = false\n"
"  io_collect_interval          = nil\n"
"  listen                       = nil\n"
"  log                          = nil\n"
"  log_format                   = plain\n"
"  log_level                    = 5\n"
"  log_nonblock                 = true\n"
"  memtx_dir                    = '.'\n"
"  memtx_max_tuple_size         = 1024 * 1024\n"
"  memtx_memory                 = 256 * 1024 *1024\n"
"  memtx_min_tuple_size         = 16\n"
"  net_msg_max                  = 768\n"
"  pid_file                     = nil\n"
"  readahead                    = 16320\n"
"  read_only                    = false\n"
"  replication                  = nil\n"
"  replication_connect_timeout  = 4\n"
"  replication_skip_conflict    = false\n"
"  replication_sync_lag         = 10\n"
"  replication_sync_timeout     = 300\n"
"  replication_timeout          = 1\n"
"  rows_per_wal                 = 500000\n"
"  slab_alloc_factor            = 1.05\n"
"  snap_io_rate_limit           = nil\n"
"  strip_core                   = true\n"
"  too_long_threshold           = 0.5\n"
"  username                     = nil\n"
"  vinyl_bloom_fpr              = 0.05\n"
"  vinyl_cache                  = 128\n"
"  vinyl_dir                    = '.'\n"
"  vinyl_max_tuple_size         = 1024 * 1024* 1024 * 1024\n"
"  vinyl_memory                 = 128 * 1024 * 1024\n"
"  vinyl_page_size              = 8 * 1024\n"
"  vinyl_range_size             = nil\n"
"  vinyl_read_threads           = 1\n"
"  vinyl_run_count_per_level    = 2\n"
"  vinyl_run_size_ratio         = 3.5\n"
"  vinyl_timeout                = 60\n"
"  vinyl_write_threads          = 2\n"
"  wal_dir                      = '.'\n"
"  wal_dir_rescan_delay         = 2\n"
"  wal_max_size                 = 256 * 1024 * 1024\n"
"  wal_mode                     = 'write'\n"
"  worker_pool_threads          = 4\n"
"  work_dir                     = nil"
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:129
msgid "The first call to ``box.cfg{...}`` (with or without parameters) initiates Tarantool's database module :ref:`box <box-module>`. Before Tarantool 2.0, you needed to call ``box.cfg{...}`` prior to performing any database operations. Now you can start working with the database outright, without calling ``box.cfg{...}``. In this case, Tarantool initiates the database module and applies default settings, as if you said ``box.cfg{}`` (without parameters)."
msgstr ""

#: ../doc/2.2/book/box/box_cfg.rst:137
msgid "``box.cfg{...}`` is also the command that reloads :ref:`persistent data files <index-box_persistence>` into RAM upon restart once we have data."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:39
msgid "Submodule `box.ctl`"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:43
msgid "The ``box.ctl`` submodule contains two wait functions and two functions related to triggers."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:46
msgid "The wait functions ``wait_ro`` (wait until read-only) and ``wait_rw`` (wait until read-write) are useful during initialization of a server."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:49
msgid "A particular use is for :ref:`box_once() <box-once>`. For example, when a replica is initializing, it may call a ``box.once()`` function while the server is still in read-only mode, and fail to make changes that are necessary only once before the replica is fully initialized. This could cause conflicts between a master and a replica if the master is in read-write mode and the replica is in read-only mode. Waiting until \"read only mode = false\" solves this problem."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:59
msgid "To see whether a function is already in read-only or read-write mode, check :ref:`box.info.ro <box_introspection-box_info>`."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:66
msgid "Wait until ``box.info.ro`` is true."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_sql.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:0
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/say.rst:0
#: ../doc/2.2/dev_guide/reference_capi/say.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/reference/reference_lua/box_error.rst:0
#: ../doc/2.2/reference/reference_lua/box_error.rst:0
#: ../doc/2.2/reference/reference_lua/box_error.rst:0
#: ../doc/2.2/reference/reference_lua/box_once.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/console.rst:0
#: ../doc/2.2/reference/reference_lua/console.rst:0
#: ../doc/2.2/reference/reference_lua/console.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/errno.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/iconv.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/log.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/osmodule.rst:0
#: ../doc/2.2/reference/reference_lua/osmodule.rst:0
#: ../doc/2.2/reference/reference_lua/other.rst:0
#: ../doc/2.2/reference/reference_lua/other.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/table.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
msgid "Parameters"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:68
#: ../doc/2.2/book/box/box_ctl.rst:91
msgid "maximum number of seconds to wait"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_ctl.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_info.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_sql.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:0
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:0
#: ../doc/2.2/reference/reference_lua/buffer.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/console.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/iconv.rst:0
#: ../doc/2.2/reference/reference_lua/iconv.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/log.rst:0
#: ../doc/2.2/reference/reference_lua/log.rst:0
#: ../doc/2.2/reference/reference_lua/log.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/merger.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/other.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/swim.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
msgid "return"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:69
#: ../doc/2.2/book/box/box_ctl.rst:92
msgid "nil, or error (errors may be due to timeout or fiber cancellation)"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:71
#: ../doc/2.2/book/box/box_ctl.rst:95
#: ../doc/2.2/book/box/box_ctl.rst:138
#: ../doc/2.2/book/box/box_index.rst:151
#: ../doc/2.2/book/box/box_index.rst:537
#: ../doc/2.2/book/box/box_index.rst:677
#: ../doc/2.2/book/box/box_index.rst:708
#: ../doc/2.2/book/box/box_index.rst:739
#: ../doc/2.2/book/box/box_index.rst:768
#: ../doc/2.2/book/box/box_index.rst:792
#: ../doc/2.2/book/box/box_index.rst:875
#: ../doc/2.2/book/box/box_index.rst:905
#: ../doc/2.2/book/box/box_index.rst:927
#: ../doc/2.2/book/box/box_index.rst:1025
#: ../doc/2.2/book/box/box_index.rst:1038
#: ../doc/2.2/book/box/box_info.rst:233
#: ../doc/2.2/book/box/box_schema.rst:314
#: ../doc/2.2/book/box/box_schema.rst:352
#: ../doc/2.2/book/box/box_schema.rst:386
#: ../doc/2.2/book/box/box_schema.rst:425
#: ../doc/2.2/book/box/box_schema.rst:447
#: ../doc/2.2/book/box/box_schema.rst:492
#: ../doc/2.2/book/box/box_schema.rst:511
#: ../doc/2.2/book/box/box_schema.rst:526
#: ../doc/2.2/book/box/box_schema.rst:557
#: ../doc/2.2/book/box/box_schema.rst:588
#: ../doc/2.2/book/box/box_schema.rst:605
#: ../doc/2.2/book/box/box_schema.rst:647
#: ../doc/2.2/book/box/box_schema.rst:751
#: ../doc/2.2/book/box/box_schema.rst:786
#: ../doc/2.2/book/box/box_schema.rst:802
#: ../doc/2.2/book/box/box_schema.rst:827
#: ../doc/2.2/book/box/box_schema.rst:975
#: ../doc/2.2/book/box/box_slab.rst:89
#: ../doc/2.2/book/box/box_slab.rst:148
#: ../doc/2.2/book/box/box_slab.rst:190
#: ../doc/2.2/book/box/box_space.rst:234
#: ../doc/2.2/book/box/box_space.rst:260
#: ../doc/2.2/book/box/box_space.rst:286
#: ../doc/2.2/book/box/box_space.rst:647
#: ../doc/2.2/book/box/box_space.rst:704
#: ../doc/2.2/book/box/box_space.rst:753
#: ../doc/2.2/book/box/box_space.rst:790
#: ../doc/2.2/book/box/box_space.rst:865
#: ../doc/2.2/book/box/box_space.rst:967
#: ../doc/2.2/book/box/box_space.rst:1016
#: ../doc/2.2/book/box/box_space.rst:1058
#: ../doc/2.2/book/box/box_space.rst:1085
#: ../doc/2.2/book/box/box_space.rst:1253
#: ../doc/2.2/book/box/box_space.rst:1301
#: ../doc/2.2/book/box/box_space.rst:1344
#: ../doc/2.2/book/box/box_space.rst:1380
#: ../doc/2.2/book/box/box_space.rst:1401
#: ../doc/2.2/book/box/box_space.rst:1451
#: ../doc/2.2/book/box/box_space.rst:1539
#: ../doc/2.2/book/box/box_space.rst:1616
#: ../doc/2.2/book/box/box_space.rst:1728
#: ../doc/2.2/book/box/box_space.rst:1764
#: ../doc/2.2/book/box/box_space.rst:1816
#: ../doc/2.2/book/box/box_space.rst:1864
#: ../doc/2.2/book/box/box_space.rst:1882
#: ../doc/2.2/book/box/box_space.rst:1903
#: ../doc/2.2/book/box/box_space.rst:1973
#: ../doc/2.2/book/box/box_space.rst:2133
#: ../doc/2.2/book/box/box_space.rst:2411
#: ../doc/2.2/book/box/box_space.rst:2443
#: ../doc/2.2/book/box/box_tuple.rst:129
#: ../doc/2.2/book/box/box_txn_management.rst:189
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:245
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:283
#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:126
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:80
#: ../doc/2.2/dev_guide/reference_capi/say.rst:86
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:275
#: ../doc/2.2/reference/reference_lua/box_error.rst:114
#: ../doc/2.2/reference/reference_lua/box_error.rst:154
#: ../doc/2.2/reference/reference_lua/box_error.rst:194
#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:83
#: ../doc/2.2/reference/reference_lua/buffer.rst:57
#: ../doc/2.2/reference/reference_lua/clock.rst:112
#: ../doc/2.2/reference/reference_lua/clock.rst:137
#: ../doc/2.2/reference/reference_lua/clock.rst:158
#: ../doc/2.2/reference/reference_lua/clock.rst:179
#: ../doc/2.2/reference/reference_lua/clock.rst:201
#: ../doc/2.2/reference/reference_lua/console.rst:113
#: ../doc/2.2/reference/reference_lua/console.rst:144
#: ../doc/2.2/reference/reference_lua/console.rst:169
#: ../doc/2.2/reference/reference_lua/console.rst:208
#: ../doc/2.2/reference/reference_lua/crypto.rst:102
#: ../doc/2.2/reference/reference_lua/crypto.rst:134
#: ../doc/2.2/reference/reference_lua/csv.rst:111
#: ../doc/2.2/reference/reference_lua/csv.rst:193
#: ../doc/2.2/reference/reference_lua/csv.rst:238
#: ../doc/2.2/reference/reference_lua/errno.rst:94
#: ../doc/2.2/reference/reference_lua/fiber.rst:235
#: ../doc/2.2/reference/reference_lua/fiber.rst:274
#: ../doc/2.2/reference/reference_lua/fiber.rst:297
#: ../doc/2.2/reference/reference_lua/fiber.rst:317
#: ../doc/2.2/reference/reference_lua/fiber.rst:337
#: ../doc/2.2/reference/reference_lua/fiber.rst:352
#: ../doc/2.2/reference/reference_lua/fiber.rst:371
#: ../doc/2.2/reference/reference_lua/fiber.rst:390
#: ../doc/2.2/reference/reference_lua/fiber.rst:417
#: ../doc/2.2/reference/reference_lua/fiber.rst:443
#: ../doc/2.2/reference/reference_lua/fiber.rst:467
#: ../doc/2.2/reference/reference_lua/fiber.rst:492
#: ../doc/2.2/reference/reference_lua/fiber.rst:519
#: ../doc/2.2/reference/reference_lua/fiber.rst:542
#: ../doc/2.2/reference/reference_lua/fiber.rst:568
#: ../doc/2.2/reference/reference_lua/fiber.rst:588
#: ../doc/2.2/reference/reference_lua/fiber.rst:656
#: ../doc/2.2/reference/reference_lua/fiber.rst:706
#: ../doc/2.2/reference/reference_lua/fiber.rst:739
#: ../doc/2.2/reference/reference_lua/fiber.rst:758
#: ../doc/2.2/reference/reference_lua/fio.rst:218
#: ../doc/2.2/reference/reference_lua/fio.rst:240
#: ../doc/2.2/reference/reference_lua/fio.rst:260
#: ../doc/2.2/reference/reference_lua/fio.rst:279
#: ../doc/2.2/reference/reference_lua/fio.rst:355
#: ../doc/2.2/reference/reference_lua/fio.rst:391
#: ../doc/2.2/reference/reference_lua/fio.rst:430
#: ../doc/2.2/reference/reference_lua/fio.rst:450
#: ../doc/2.2/reference/reference_lua/fio.rst:471
#: ../doc/2.2/reference/reference_lua/fio.rst:494
#: ../doc/2.2/reference/reference_lua/fio.rst:511
#: ../doc/2.2/reference/reference_lua/fio.rst:526
#: ../doc/2.2/reference/reference_lua/fio.rst:550
#: ../doc/2.2/reference/reference_lua/fio.rst:572
#: ../doc/2.2/reference/reference_lua/fio.rst:595
#: ../doc/2.2/reference/reference_lua/fio.rst:621
#: ../doc/2.2/reference/reference_lua/fio.rst:647
#: ../doc/2.2/reference/reference_lua/fio.rst:671
#: ../doc/2.2/reference/reference_lua/fio.rst:694
#: ../doc/2.2/reference/reference_lua/fio.rst:716
#: ../doc/2.2/reference/reference_lua/fio.rst:742
#: ../doc/2.2/reference/reference_lua/fio.rst:760
#: ../doc/2.2/reference/reference_lua/fio.rst:861
#: ../doc/2.2/reference/reference_lua/fio.rst:892
#: ../doc/2.2/reference/reference_lua/fio.rst:1012
#: ../doc/2.2/reference/reference_lua/fio.rst:1032
#: ../doc/2.2/reference/reference_lua/fio.rst:1057
#: ../doc/2.2/reference/reference_lua/fio.rst:1078
#: ../doc/2.2/reference/reference_lua/fio.rst:1111
#: ../doc/2.2/reference/reference_lua/fio.rst:1133
#: ../doc/2.2/reference/reference_lua/http.rst:86
#: ../doc/2.2/reference/reference_lua/iconv.rst:91
#: ../doc/2.2/reference/reference_lua/iconv.rst:112
#: ../doc/2.2/reference/reference_lua/json.rst:90
#: ../doc/2.2/reference/reference_lua/json.rst:129
#: ../doc/2.2/reference/reference_lua/json.rst:160
#: ../doc/2.2/reference/reference_lua/key_def.rst:172
#: ../doc/2.2/reference/reference_lua/key_def.rst:198
#: ../doc/2.2/reference/reference_lua/key_def.rst:221
#: ../doc/2.2/reference/reference_lua/key_def.rst:244
#: ../doc/2.2/reference/reference_lua/net_box.rst:265
#: ../doc/2.2/reference/reference_lua/net_box.rst:281
#: ../doc/2.2/reference/reference_lua/net_box.rst:296
#: ../doc/2.2/reference/reference_lua/net_box.rst:337
#: ../doc/2.2/reference/reference_lua/net_box.rst:351
#: ../doc/2.2/reference/reference_lua/net_box.rst:373
#: ../doc/2.2/reference/reference_lua/net_box.rst:387
#: ../doc/2.2/reference/reference_lua/net_box.rst:401
#: ../doc/2.2/reference/reference_lua/net_box.rst:415
#: ../doc/2.2/reference/reference_lua/net_box.rst:513
#: ../doc/2.2/reference/reference_lua/net_box.rst:565
#: ../doc/2.2/reference/reference_lua/osmodule.rst:122
#: ../doc/2.2/reference/reference_lua/osmodule.rst:145
#: ../doc/2.2/reference/reference_lua/osmodule.rst:164
#: ../doc/2.2/reference/reference_lua/osmodule.rst:181
#: ../doc/2.2/reference/reference_lua/osmodule.rst:199
#: ../doc/2.2/reference/reference_lua/osmodule.rst:214
#: ../doc/2.2/reference/reference_lua/osmodule.rst:227
#: ../doc/2.2/reference/reference_lua/osmodule.rst:242
#: ../doc/2.2/reference/reference_lua/osmodule.rst:257
#: ../doc/2.2/reference/reference_lua/osmodule.rst:272
#: ../doc/2.2/reference/reference_lua/osmodule.rst:287
#: ../doc/2.2/reference/reference_lua/osmodule.rst:303
#: ../doc/2.2/reference/reference_lua/osmodule.rst:318
#: ../doc/2.2/reference/reference_lua/other.rst:86
#: ../doc/2.2/reference/reference_lua/other.rst:126
#: ../doc/2.2/reference/reference_lua/pickle.rst:125
#: ../doc/2.2/reference/reference_lua/pickle.rst:172
#: ../doc/2.2/reference/reference_lua/socket.rst:172
#: ../doc/2.2/reference/reference_lua/socket.rst:190
#: ../doc/2.2/reference/reference_lua/socket.rst:209
#: ../doc/2.2/reference/reference_lua/socket.rst:291
#: ../doc/2.2/reference/reference_lua/socket.rst:450
#: ../doc/2.2/reference/reference_lua/strict.rst:52
#: ../doc/2.2/reference/reference_lua/string.rst:112
#: ../doc/2.2/reference/reference_lua/string.rst:137
#: ../doc/2.2/reference/reference_lua/string.rst:160
#: ../doc/2.2/reference/reference_lua/string.rst:185
#: ../doc/2.2/reference/reference_lua/string.rst:215
#: ../doc/2.2/reference/reference_lua/string.rst:245
#: ../doc/2.2/reference/reference_lua/string.rst:272
#: ../doc/2.2/reference/reference_lua/string.rst:298
#: ../doc/2.2/reference/reference_lua/string.rst:325
#: ../doc/2.2/reference/reference_lua/string.rst:352
#: ../doc/2.2/reference/reference_lua/swim.rst:417
#: ../doc/2.2/reference/reference_lua/table.rst:78
#: ../doc/2.2/reference/reference_lua/tap.rst:214
#: ../doc/2.2/reference/reference_lua/tap.rst:260
#: ../doc/2.2/reference/reference_lua/tarantool.rst:54
#: ../doc/2.2/reference/reference_lua/uri.rst:99
#: ../doc/2.2/reference/reference_lua/uri.rst:126
#: ../doc/2.2/reference/reference_lua/utf8.rst:108
#: ../doc/2.2/reference/reference_lua/utf8.rst:137
#: ../doc/2.2/reference/reference_lua/utf8.rst:166
#: ../doc/2.2/reference/reference_lua/utf8.rst:190
#: ../doc/2.2/reference/reference_lua/utf8.rst:212
#: ../doc/2.2/reference/reference_lua/utf8.rst:234
#: ../doc/2.2/reference/reference_lua/utf8.rst:256
#: ../doc/2.2/reference/reference_lua/utf8.rst:288
#: ../doc/2.2/reference/reference_lua/utf8.rst:312
#: ../doc/2.2/reference/reference_lua/utf8.rst:333
#: ../doc/2.2/reference/reference_lua/utf8.rst:371
#: ../doc/2.2/reference/reference_lua/utf8.rst:393
#: ../doc/2.2/reference/reference_lua/xlog.rst:61
#: ../doc/2.2/reference/reference_rock/dbms.rst:222
#: ../doc/2.2/reference/reference_rock/dbms.rst:246
#: ../doc/2.2/reference/reference_rock/dbms.rst:270
#: ../doc/2.2/reference/reference_rock/dbms.rst:564
#: ../doc/2.2/reference/reference_rock/dbms.rst:588
#: ../doc/2.2/reference/reference_rock/dbms.rst:611
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1090
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1161
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1459
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1474
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1491
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1552
msgid "**Example:**"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:73
msgid "tarantool> box.info().ro\n"
"---\n"
"- false\n"
"...\n"
"\n"
"tarantool> n = box.ctl.wait_ro(0.1)\n"
"---\n"
"- error: timed out\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:89
msgid "Wait until box.info.ro is false."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:97
msgid "tarantool> box.ctl.wait_rw(0.1)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:105
msgid "The ``box.ctl`` submodule also contains two functions for the two :ref:`server trigger <triggers>` definitions: ``on_schema_init`` and ``on_shutdown``."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:110
msgid "Create a \"schema_init :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed when :ref:`box.cfg{} <index-book_cfg>` happens for the first time. That is, the ``schema_init`` trigger is called before the server's configuration and recovery begins, and therefore ``box.ctl.on_schema_init`` must be called before ``box.cfg`` is called."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:117
msgid "Parameter: trigger-function (function) – function which will become the trigger function"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:119
msgid "Parameter: old-trigger-function (function) – existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:121
msgid "Return:     nil or function pointer"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:123
#: ../doc/2.2/book/box/box_ctl.rst:186
#: ../doc/2.2/book/box/box_session.rst:344
#: ../doc/2.2/book/box/box_session.rst:380
#: ../doc/2.2/book/box/box_session.rst:455
#: ../doc/2.2/book/box/box_space.rst:1114
msgid "If the parameters are (nil, old-trigger-function), then the old trigger is deleted."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:126
msgid "A common use is: make a ``schema_init`` trigger function which creates a ``before_replace`` trigger function on a system space. Thus, since system spaces are created when the server starts, the ``before_replace`` triggers will be activated for each tuple in each system space. For example, such a trigger could change the storage engine of a given space, or make a given space replica-local while a replica is being bootstrapped. Making such a change after ``box.cfg`` is not reliable because other connections might use the database before the change can be made."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:136
#: ../doc/2.2/book/box/box_ctl.rst:189
#: ../doc/2.2/book/box/box_session.rst:348
#: ../doc/2.2/book/box/box_session.rst:384
#: ../doc/2.2/book/box/box_session.rst:459
#: ../doc/2.2/book/box/box_space.rst:1123
#: ../doc/2.2/book/box/box_space.rst:1203
#: ../doc/2.2/book/box/box_txn_management.rst:244
msgid "Details about trigger characteristics are in the :ref:`triggers <triggers-box_triggers>` section."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:140
msgid "Suppose that, before the server is fully up and ready for connections, you want to make sure that the engine of space ``space_name`` is vinyl. So you want to make a trigger that will be activated when a tuple is inserted in the ``_space`` system space. In this case you could end up with a master that has space-name with ``engine='memtx'`` and a replica that has space_name with ``engine='vinyl'``, with the same contents."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:149
msgid "function function_for_before_replace(old, new)\n"
"  if new[3] == 'space_name' and new[4] ~= 'vinyl' then\n"
"    return new:update{{'=', 4, 'vinyl'}}\n"
"  end\n"
"end\n"
"\n"
"box.ctl.on_schema_init(function()\n"
"  box.space._space:before_replace(function_for_before_replace)\n"
"end)\n"
"\n"
"box.cfg{replication='master_uri', ...}"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:167
msgid "Create a \"shutdown :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed whenever   :ref:`os.exit() <os-exit>` happens, or when the server is shut down after receiving a SIGTERM or SIGINT or SIGHUP signal (but not after SIGSEGV or SIGABORT or any signal that causes immediate program termination). The trigger function is actually called just before shutdown, so the trigger function can still refer to any methods and members in other Tarantool modules."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:176
msgid "Like :ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>`, ``box.ctl.on_shutdown()`` may be done before ``box.cfg{}`` is invoked."
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:179
#: ../doc/2.2/book/box/box_session.rst:340
#: ../doc/2.2/book/box/box_session.rst:376
#: ../doc/2.2/book/box/box_session.rst:451
#: ../doc/2.2/book/box/box_space.rst:1107
#: ../doc/2.2/book/box/box_txn_management.rst:235
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:181
#: ../doc/2.2/book/box/box_session.rst:341
#: ../doc/2.2/book/box/box_session.rst:377
#: ../doc/2.2/book/box/box_session.rst:452
#: ../doc/2.2/book/box/box_space.rst:1109
#: ../doc/2.2/book/box/box_txn_management.rst:237
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/2.2/book/box/box_ctl.rst:184
#: ../doc/2.2/book/box/box_session.rst:342
#: ../doc/2.2/book/box/box_session.rst:378
#: ../doc/2.2/book/box/box_session.rst:453
#: ../doc/2.2/book/box/box_space.rst:1112
#: ../doc/2.2/book/box/box_space.rst:1192
#: ../doc/2.2/book/box/box_txn_management.rst:239
msgid "nil or function pointer"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:39
msgid "Submodule `box.index`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:43
#: ../doc/2.2/book/box/box_schema.rst:45
#: ../doc/2.2/book/box/box_session.rst:43
#: ../doc/2.2/book/box/box_slab.rst:45
#: ../doc/2.2/book/box/box_space.rst:43
#: ../doc/2.2/book/box/box_tuple.rst:45
#: ../doc/2.2/book/box/box_txn_management.rst:43
#: ../doc/2.2/intro.rst:37
#: ../doc/2.2/reference/reference_lua/box_error.rst:43
#: ../doc/2.2/reference/reference_lua/clock.rst:43
#: ../doc/2.2/reference/reference_lua/console.rst:43
#: ../doc/2.2/reference/reference_lua/crypto.rst:45
#: ../doc/2.2/reference/reference_lua/csv.rst:43
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:43
#: ../doc/2.2/reference/reference_lua/digest.rst:45
#: ../doc/2.2/reference/reference_lua/errno.rst:45
#: ../doc/2.2/reference/reference_lua/fiber.rst:43
#: ../doc/2.2/reference/reference_lua/fio.rst:45
#: ../doc/2.2/reference/reference_lua/http.rst:45
#: ../doc/2.2/reference/reference_lua/iconv.rst:45
#: ../doc/2.2/reference/reference_lua/json.rst:43
#: ../doc/2.2/reference/reference_lua/log.rst:45
#: ../doc/2.2/reference/reference_lua/merger.rst:43
#: ../doc/2.2/reference/reference_lua/msgpack.rst:43
#: ../doc/2.2/reference/reference_lua/net_box.rst:43
#: ../doc/2.2/reference/reference_lua/osmodule.rst:45
#: ../doc/2.2/reference/reference_lua/socket.rst:43
#: ../doc/2.2/reference/reference_lua/string.rst:43
#: ../doc/2.2/reference/reference_lua/swim.rst:43
#: ../doc/2.2/reference/reference_lua/tap.rst:41
#: ../doc/2.2/reference/reference_lua/uri.rst:41
#: ../doc/2.2/reference/reference_lua/utf8.rst:43
#: ../doc/2.2/reference/reference_lua/uuid.rst:41
#: ../doc/2.2/reference/reference_lua/yaml.rst:43
#: ../doc/2.2/whats_new.rst:555
msgid "Overview"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:45
msgid "The ``box.index`` submodule provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:53
#: ../doc/2.2/book/box/box_schema.rst:52
#: ../doc/2.2/book/box/box_session.rst:53
#: ../doc/2.2/book/box/box_slab.rst:53
#: ../doc/2.2/book/box/box_space.rst:53
#: ../doc/2.2/book/box/box_tuple.rst:54
#: ../doc/2.2/book/box/box_txn_management.rst:82
#: ../doc/2.2/book/box/data_model.rst:101
#: ../doc/2.2/reference/reference_lua/box_error.rst:53
#: ../doc/2.2/reference/reference_lua/clock.rst:52
#: ../doc/2.2/reference/reference_lua/console.rst:51
#: ../doc/2.2/reference/reference_lua/crypto.rst:56
#: ../doc/2.2/reference/reference_lua/csv.rst:75
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:67
#: ../doc/2.2/reference/reference_lua/digest.rst:56
#: ../doc/2.2/reference/reference_lua/errno.rst:53
#: ../doc/2.2/reference/reference_lua/fiber.rst:56
#: ../doc/2.2/reference/reference_lua/fio.rst:61
#: ../doc/2.2/reference/reference_lua/http.rst:53
#: ../doc/2.2/reference/reference_lua/iconv.rst:58
#: ../doc/2.2/reference/reference_lua/json.rst:52
#: ../doc/2.2/reference/reference_lua/log.rst:80
#: ../doc/2.2/reference/reference_lua/merger.rst:50
#: ../doc/2.2/reference/reference_lua/msgpack.rst:52
#: ../doc/2.2/reference/reference_lua/net_box.rst:105
#: ../doc/2.2/reference/reference_lua/osmodule.rst:62
#: ../doc/2.2/reference/reference_lua/pickle.rst:41
#: ../doc/2.2/reference/reference_lua/socket.rst:62
#: ../doc/2.2/reference/reference_lua/string.rst:56
#: ../doc/2.2/reference/reference_lua/tap.rst:51
#: ../doc/2.2/reference/reference_lua/uri.rst:69
#: ../doc/2.2/reference/reference_lua/uuid.rst:51
#: ../doc/2.2/reference/reference_lua/yaml.rst:50
msgid "Index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:55
msgid "Below is a list of all ``box.index`` functions and members."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:63
#: ../doc/2.2/book/box/box_schema.rst:62
#: ../doc/2.2/book/box/box_schema.rst:165
#: ../doc/2.2/book/box/box_session.rst:63
#: ../doc/2.2/book/box/box_slab.rst:63
#: ../doc/2.2/book/box/box_space.rst:63
#: ../doc/2.2/book/box/box_space.rst:329
#: ../doc/2.2/book/box/box_space.rst:2317
#: ../doc/2.2/book/box/box_tuple.rst:64
#: ../doc/2.2/book/box/box_txn_management.rst:94
#: ../doc/2.2/reference/reference_lua/box_error.rst:63
#: ../doc/2.2/reference/reference_lua/clock.rst:62
#: ../doc/2.2/reference/reference_lua/console.rst:61
#: ../doc/2.2/reference/reference_lua/crypto.rst:66
#: ../doc/2.2/reference/reference_lua/csv.rst:85
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:77
#: ../doc/2.2/reference/reference_lua/digest.rst:66
#: ../doc/2.2/reference/reference_lua/errno.rst:63
#: ../doc/2.2/reference/reference_lua/fiber.rst:66
#: ../doc/2.2/reference/reference_lua/fio.rst:73
#: ../doc/2.2/reference/reference_lua/http.rst:63
#: ../doc/2.2/reference/reference_lua/iconv.rst:68
#: ../doc/2.2/reference/reference_lua/json.rst:62
#: ../doc/2.2/reference/reference_lua/log.rst:90
#: ../doc/2.2/reference/reference_lua/msgpack.rst:62
#: ../doc/2.2/reference/reference_lua/net_box.rst:115
#: ../doc/2.2/reference/reference_lua/osmodule.rst:72
#: ../doc/2.2/reference/reference_lua/other.rst:49
#: ../doc/2.2/reference/reference_lua/pickle.rst:51
#: ../doc/2.2/reference/reference_lua/socket.rst:72
#: ../doc/2.2/reference/reference_lua/string.rst:66
#: ../doc/2.2/reference/reference_lua/tap.rst:59
#: ../doc/2.2/reference/reference_lua/uri.rst:79
#: ../doc/2.2/reference/reference_lua/utf8.rst:63
#: ../doc/2.2/reference/reference_lua/uuid.rst:61
#: ../doc/2.2/reference/reference_lua/yaml.rst:60
msgid "Name"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:63
#: ../doc/2.2/book/box/box_schema.rst:62
#: ../doc/2.2/book/box/box_session.rst:63
#: ../doc/2.2/book/box/box_slab.rst:63
#: ../doc/2.2/book/box/box_space.rst:63
#: ../doc/2.2/book/box/box_tuple.rst:64
#: ../doc/2.2/book/box/box_txn_management.rst:94
#: ../doc/2.2/reference/reference_lua/box_error.rst:63
#: ../doc/2.2/reference/reference_lua/clock.rst:62
#: ../doc/2.2/reference/reference_lua/console.rst:61
#: ../doc/2.2/reference/reference_lua/crypto.rst:66
#: ../doc/2.2/reference/reference_lua/csv.rst:85
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:77
#: ../doc/2.2/reference/reference_lua/digest.rst:66
#: ../doc/2.2/reference/reference_lua/errno.rst:63
#: ../doc/2.2/reference/reference_lua/fiber.rst:66
#: ../doc/2.2/reference/reference_lua/fio.rst:73
#: ../doc/2.2/reference/reference_lua/http.rst:63
#: ../doc/2.2/reference/reference_lua/iconv.rst:68
#: ../doc/2.2/reference/reference_lua/json.rst:62
#: ../doc/2.2/reference/reference_lua/log.rst:90
#: ../doc/2.2/reference/reference_lua/msgpack.rst:62
#: ../doc/2.2/reference/reference_lua/net_box.rst:115
#: ../doc/2.2/reference/reference_lua/osmodule.rst:72
#: ../doc/2.2/reference/reference_lua/other.rst:49
#: ../doc/2.2/reference/reference_lua/pickle.rst:51
#: ../doc/2.2/reference/reference_lua/socket.rst:72
#: ../doc/2.2/reference/reference_lua/string.rst:66
#: ../doc/2.2/reference/reference_lua/tap.rst:59
#: ../doc/2.2/reference/reference_lua/uri.rst:79
#: ../doc/2.2/reference/reference_lua/utf8.rst:63
#: ../doc/2.2/reference/reference_lua/uuid.rst:61
#: ../doc/2.2/reference/reference_lua/yaml.rst:60
msgid "Use"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:65
msgid ":ref:`index_object.unique <box_index-unique>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:65
msgid "Flag, true if an index is unique"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:68
msgid ":ref:`index_object.type <box_index-type>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:68
#: ../doc/2.2/book/box/data_model.rst:313
#: ../doc/2.2/book/box/data_model.rst:955
msgid "Index type"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:71
msgid ":ref:`index_object.parts <box_index-parts>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:71
msgid "Array of index key fields"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:74
msgid ":ref:`index_object:pairs() <box_index-index_pairs>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:74
#: ../doc/2.2/book/box/box_space.rst:106
#: ../doc/2.2/book/box/box_tuple.rst:102
msgid "Prepare for iterating"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:77
msgid ":ref:`index_object:select() <box_index-select>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:77
msgid "Select one or more tuples via index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:80
msgid ":ref:`index_object:get() <box_index-get>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:80
msgid "Select a tuple via index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:83
msgid ":ref:`index_object:min() <box_index-min>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:83
msgid "Find the minimum value in index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:86
msgid ":ref:`index_object:max() <box_index-max>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:86
msgid "Find the maximum value in index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:89
msgid ":ref:`index_object:random() <box_index-random>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:89
msgid "Find a random value in index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:92
msgid ":ref:`index_object:count() <box_index-count>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:92
msgid "Count tuples matching key value"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:95
msgid ":ref:`index_object:update() <box_index-update>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:95
#: ../doc/2.2/book/box/box_space.rst:127
#: ../doc/2.2/book/box/box_space.rst:130
#: ../doc/2.2/book/box/box_tuple.rst:105
#: ../doc/2.2/reference/reference_lua/net_box.rst:149
#: ../doc/2.2/reference/reference_lua/net_box.rst:152
msgid "Update a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:98
msgid ":ref:`index_object:delete() <box_index-delete>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:98
msgid "Delete a tuple by key"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:101
msgid ":ref:`index_object:alter() <box_index-alter>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:101
msgid "Alter an index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:104
msgid ":ref:`index_object:drop() <box_index-drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:104
msgid "Drop an index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:107
msgid ":ref:`index_object:rename() <box_index-rename>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:107
msgid "Rename an index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:110
msgid ":ref:`index_object:bsize() <box_index-bsize>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:110
msgid "Get count of bytes for an index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:113
msgid ":ref:`index_object:stat() <box_index-stat>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:113
msgid "Get statistics for an index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:116
msgid ":ref:`index_object:compact() <box_index-compact>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:116
msgid "Remove unused index space"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:119
msgid ":ref:`index_object:user_defined() <box_index-user_defined>`"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:119
#: ../doc/2.2/book/box/box_space.rst:133
msgid "Any function / method that any user wants to add"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:132
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_index.rst:0
#: ../doc/2.2/book/box/box_info.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_schema.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_session.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_slab.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_space.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_tuple.rst:0
#: ../doc/2.2/book/box/box_txn_management.rst:0
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:0
#: ../doc/2.2/reference/reference_lua/buffer.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/clock.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/csv.rst:0
#: ../doc/2.2/reference/reference_lua/errno.rst:0
#: ../doc/2.2/reference/reference_lua/errno.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/fio.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/http.rst:0
#: ../doc/2.2/reference/reference_lua/iconv.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/json.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/msgpack.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/net_box.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/pickle.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/socket.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/tap.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/uri.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/utf8.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/uuid.rst:0
#: ../doc/2.2/reference/reference_lua/xlog.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
#: ../doc/2.2/reference/reference_lua/yaml.rst:0
msgid "rtype"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:134
#: ../doc/2.2/book/box/box_schema.rst:186
#: ../doc/2.2/book/box/box_schema.rst:192
#: ../doc/2.2/book/box/box_schema.rst:199
#: ../doc/2.2/book/box/box_space.rst:339
#: ../doc/2.2/book/box/box_space.rst:341
#: ../doc/2.2/book/box/data_model.rst:190
#: ../doc/2.2/reference/reference_lua/fiber.rst:883
#: ../doc/2.2/reference/reference_lua/fiber.rst:915
#: ../doc/2.2/reference/reference_lua/fiber.rst:935
#: ../doc/2.2/reference/reference_lua/fiber.rst:945
#: ../doc/2.2/reference/reference_lua/fiber.rst:955
#: ../doc/2.2/reference/reference_lua/fiber.rst:963
#: ../doc/2.2/reference/reference_lua/fiber.rst:1075
#: ../doc/2.2/reference/reference_lua/fio.rst:304
#: ../doc/2.2/reference/reference_lua/fio.rst:312
#: ../doc/2.2/reference/reference_lua/fio.rst:320
#: ../doc/2.2/reference/reference_lua/fio.rst:328
#: ../doc/2.2/reference/reference_lua/fio.rst:336
#: ../doc/2.2/reference/reference_lua/fio.rst:428
#: ../doc/2.2/reference/reference_lua/fio.rst:448
#: ../doc/2.2/reference/reference_lua/fio.rst:548
#: ../doc/2.2/reference/reference_lua/fio.rst:570
#: ../doc/2.2/reference/reference_lua/fio.rst:593
#: ../doc/2.2/reference/reference_lua/fio.rst:645
#: ../doc/2.2/reference/reference_lua/fio.rst:669
#: ../doc/2.2/reference/reference_lua/fio.rst:692
#: ../doc/2.2/reference/reference_lua/fio.rst:740
#: ../doc/2.2/reference/reference_lua/fio.rst:758
#: ../doc/2.2/reference/reference_lua/fio.rst:859
#: ../doc/2.2/reference/reference_lua/fio.rst:918
#: ../doc/2.2/reference/reference_lua/fio.rst:1003
#: ../doc/2.2/reference/reference_lua/fio.rst:1030
#: ../doc/2.2/reference/reference_lua/net_box.rst:263
#: ../doc/2.2/reference/reference_lua/net_box.rst:279
#: ../doc/2.2/reference/reference_lua/net_box.rst:294
#: ../doc/2.2/reference/reference_lua/net_box.rst:311
#: ../doc/2.2/reference/reference_lua/socket.rst:289
#: ../doc/2.2/reference/reference_lua/socket.rst:395
#: ../doc/2.2/reference/reference_lua/socket.rst:471
#: ../doc/2.2/reference/reference_lua/socket.rst:483
#: ../doc/2.2/reference/reference_lua/string.rst:210
#: ../doc/2.2/reference/reference_lua/string.rst:240
#: ../doc/2.2/reference/reference_lua/tap.rst:189
#: ../doc/2.2/reference/reference_lua/tap.rst:212
#: ../doc/2.2/reference/reference_lua/tap.rst:246
#: ../doc/2.2/reference/reference_lua/tap.rst:281
#: ../doc/2.2/reference/reference_lua/tap.rst:294
#: ../doc/2.2/reference/reference_lua/tap.rst:304
#: ../doc/2.2/reference/reference_lua/tap.rst:319
#: ../doc/2.2/reference/reference_lua/tap.rst:340
#: ../doc/2.2/reference/reference_lua/tap.rst:359
#: ../doc/2.2/reference/reference_lua/utf8.rst:183
#: ../doc/2.2/reference/reference_lua/utf8.rst:208
#: ../doc/2.2/reference/reference_lua/utf8.rst:230
#: ../doc/2.2/reference/reference_lua/utf8.rst:252
#: ../doc/2.2/reference/reference_sql/sql.rst:276
msgid "boolean"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:140
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:146
msgid "An array describing the index fields. To learn more about the index field types, refer to :ref:`this table <box_space-index_field_types>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:149
#: ../doc/2.2/book/box/box_index.rst:979
#: ../doc/2.2/book/box/box_info.rst:231
#: ../doc/2.2/book/box/box_schema.rst:175
#: ../doc/2.2/book/box/box_slab.rst:87
#: ../doc/2.2/book/box/box_slab.rst:146
#: ../doc/2.2/book/box/box_slab.rst:188
#: ../doc/2.2/book/box/box_space.rst:1901
#: ../doc/2.2/reference/reference_lua/csv.rst:109
#: ../doc/2.2/reference/reference_lua/fiber.rst:388
#: ../doc/2.2/reference/reference_lua/fio.rst:469
#: ../doc/2.2/reference/reference_lua/fio.rst:490
#: ../doc/2.2/reference/reference_lua/fio.rst:1076
#: ../doc/2.2/reference/reference_lua/http.rst:165
#: ../doc/2.2/reference/reference_lua/json.rst:127
#: ../doc/2.2/reference/reference_lua/key_def.rst:242
#: ../doc/2.2/reference/reference_lua/pickle.rst:170
#: ../doc/2.2/reference/reference_lua/socket.rst:207
#: ../doc/2.2/reference/reference_lua/socket.rst:595
#: ../doc/2.2/reference/reference_lua/socket.rst:607
#: ../doc/2.2/reference/reference_lua/string.rst:323
#: ../doc/2.2/reference/reference_lua/table.rst:76
#: ../doc/2.2/reference/reference_lua/utf8.rst:328
#: ../doc/2.2/reference/reference_lua/yaml.rst:92
msgid "table"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:153
msgid "tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:172
msgid "Search for a tuple or a set of tuples via the given index, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:175
msgid "The :samp:`{key}` parameter specifies what must match within the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:179
msgid ":samp:`{key}` is only used to find the first match. Do not assume all matched tuples will contain the key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:182
msgid "The :samp:`{iterator}` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:188
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until there is a \"context switch\": which may happen due to :ref:`the implicit yield rules <atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database. The tutorial :ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and yields can be used together."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:202
#: ../doc/2.2/book/box/box_space.rst:1297
msgid "For information about iterators' internal structures see the `\"Lua Functional library\" <https://luafun.github.io/index.html>`_ documentation."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:206
#: ../doc/2.2/book/box/box_index.rst:526
#: ../doc/2.2/book/box/box_index.rst:661
#: ../doc/2.2/book/box/box_index.rst:692
#: ../doc/2.2/book/box/box_index.rst:723
#: ../doc/2.2/book/box/box_index.rst:757
#: ../doc/2.2/book/box/box_index.rst:784
#: ../doc/2.2/book/box/box_index.rst:815
#: ../doc/2.2/book/box/box_index.rst:838
#: ../doc/2.2/book/box/box_index.rst:859
#: ../doc/2.2/book/box/box_index.rst:894
#: ../doc/2.2/book/box/box_index.rst:919
#: ../doc/2.2/book/box/box_index.rst:943
#: ../doc/2.2/book/box/box_index.rst:975
#: ../doc/2.2/book/box/box_index.rst:1021
#: ../doc/2.2/book/box/box_space.rst:1760
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:208
#: ../doc/2.2/book/box/box_space.rst:1276
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:210
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:214
#: ../doc/2.2/book/box/box_space.rst:1281
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:218
#: ../doc/2.2/book/box/box_index.rst:668
#: ../doc/2.2/book/box/box_index.rst:867
#: ../doc/2.2/book/box/box_index.rst:899
#: ../doc/2.2/book/box/box_space.rst:229
#: ../doc/2.2/book/box/box_space.rst:393
#: ../doc/2.2/book/box/box_space.rst:808
#: ../doc/2.2/book/box/box_space.rst:1285
#: ../doc/2.2/book/box/box_space.rst:1444
#: ../doc/2.2/book/box/box_space.rst:1719
msgid "**Possible errors:**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:220
msgid "no such space; wrong type;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:221
msgid "selected iteration type is not supported for the index type;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:222
msgid "key is not supported for the iteration type."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:224
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:227
msgid "A search-key-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a key will be compared to each part of an index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:232
msgid "The returned tuples will be in order by index key value, or by the hash of the index key value if index type = 'hash'. If the index is non-unique, then duplicates will be secondarily in order by primary key value. The order will be reversed if the iterator type is 'LT' or 'LE' or 'REQ'."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:239
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:250
#: ../doc/2.2/book/box/box_index.rst:349
#: ../doc/2.2/book/box/box_index.rst:385
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_schema.rst:165
#: ../doc/2.2/book/box/box_space.rst:329
#: ../doc/2.2/book/box/box_space.rst:2317
#: ../doc/2.2/reference/interactive_console.rst:98
#: ../doc/2.2/reference/reference_sql/sql.rst:460
msgid "Type"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:250
#: ../doc/2.2/book/box/box_index.rst:349
#: ../doc/2.2/book/box/box_index.rst:385
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "Arguments"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:250
#: ../doc/2.2/book/box/box_index.rst:349
#: ../doc/2.2/book/box/box_index.rst:385
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_space.rst:2317
msgid "Description"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:252
#: ../doc/2.2/book/box/box_index.rst:356
#: ../doc/2.2/book/box/box_index.rst:391
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:252
#: ../doc/2.2/book/box/box_index.rst:258
#: ../doc/2.2/book/box/box_index.rst:263
#: ../doc/2.2/book/box/box_index.rst:270
#: ../doc/2.2/book/box/box_index.rst:277
#: ../doc/2.2/book/box/box_index.rst:281
#: ../doc/2.2/book/box/box_index.rst:287
#: ../doc/2.2/book/box/box_index.rst:356
#: ../doc/2.2/book/box/box_index.rst:362
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "search value"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:252
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key. This is the default."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:258
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:258
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:263
#: ../doc/2.2/book/box/box_index.rst:362
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:263
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:270
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:270
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:277
#: ../doc/2.2/book/box/box_index.rst:387
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:277
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:281
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:281
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:287
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:287
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:295
msgid "Informally, we can state that searches with TREE indexes are generally what users will find is intuitive, provided that there are no nils and no missing parts. Formally, the logic is as follows. A search key has zero or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or more parts, for example {1}, {1,2,3},{1,2,3}. A search key may contain nil (but not msgpack.NULL, which is the wrong type). An index key may not contain nil or msgpack.NULL, although a later version of Tarantool will have different rules --  the behavior of searches with nil is subject to change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is said to \"match\" an index key if the following statements, which are pseudocode for the comparison operation, return TRUE."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:340
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:351
msgid "box.index.ALL"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:351
#: ../doc/2.2/book/box/box_index.rst:387
#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "none"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:351
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:356
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1. This is the default."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:362
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:376
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:387
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:391
#: ../doc/2.2/book/box/box_index.rst:396
#: ../doc/2.2/book/box/box_index.rst:401
#: ../doc/2.2/book/box/box_index.rst:406
msgid "bitset value"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:391
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space. This is the default."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:396
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:396
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:401
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:401
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:406
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:406
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:414
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is the default."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/2.2/book/box/box_index_rtree.csv:1
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:428
msgid "**First example of index pairs():**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:430
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:432
msgid "tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:478
msgid "**Second example of index pairs():**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:480
msgid "This Lua code finds all the tuples whose primary key values begin with 'XY'. The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a string. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 'XY'. The conditional statement within the loop ensures that the looping will stop when the first two letters are not 'XY'."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:488
msgid "for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:496
msgid "**Third example of index pairs():**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:498
msgid "This Lua code finds all the tuples whose primary key values are greater than or equal to 1000, and less than or equal to 1999 (this type of request is sometimes called a \"range search\" or a \"between search\"). The assumptions include that there is a one-part primary-key TREE index on the first field, which must be a :ref:`number <index-box_number>`. The iterator loop ensures that the search will return tuples where the first value is greater than or equal to 1000. The conditional statement within the loop ensures that the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:508
msgid "for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:520
msgid "This is an alternative to :ref:`box.space...select() <box_space-select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:528
#: ../doc/2.2/book/box/box_index.rst:663
#: ../doc/2.2/book/box/box_index.rst:694
#: ../doc/2.2/book/box/box_index.rst:725
#: ../doc/2.2/book/box/box_index.rst:786
#: ../doc/2.2/book/box/box_index.rst:817
#: ../doc/2.2/book/box/box_index.rst:840
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:529
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:530
msgid "type of iterator"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:531
msgid "maximum number of tuples"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:532
msgid "start tuple number"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:534
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:535
#: ../doc/2.2/book/box/box_space.rst:1439
msgid "array of tuples"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:539
msgid "-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:565
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:567
msgid "---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:576
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:583
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:588
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:598
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` throws an error."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:606
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:608
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:612
msgid "tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:659
msgid "Search for a tuple via the given index, as described :ref:`earlier <box_index-note>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:665
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:666
#: ../doc/2.2/book/box/box_index.rst:702
#: ../doc/2.2/book/box/box_index.rst:733
#: ../doc/2.2/book/box/box_index.rst:762
#: ../doc/2.2/book/box/box_index.rst:826
#: ../doc/2.2/book/box/box_index.rst:843
#: ../doc/2.2/book/box/box_space.rst:224
#: ../doc/2.2/book/box/box_space.rst:746
#: ../doc/2.2/book/box/box_space.rst:1003
#: ../doc/2.2/book/box/box_space.rst:1053
#: ../doc/2.2/book/box/box_space.rst:1371
#: ../doc/2.2/book/box/box_space.rst:1597
#: ../doc/2.2/book/box/box_tuple.rst:123
#: ../doc/2.2/book/box/box_tuple.rst:391
#: ../doc/2.2/book/box/box_tuple.rst:392
#: ../doc/2.2/book/box/box_tuple.rst:579
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:256
msgid "tuple"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:670
msgid "no such index;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:671
msgid "wrong type;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:672
msgid "more than one tuple matches."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:674
msgid "**Complexity factors:** Index size, Index type. See also :ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:679
msgid "tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:690
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:696
msgid "the tuple for the first key in the index. If optional ``key`` value is supplied, returns the first key which is greater than or equal to ``key`` value. Starting with Tarantool version 2.0, index_object:min(``key`` value) will return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:704
#: ../doc/2.2/book/box/box_index.rst:735
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:706
#: ../doc/2.2/book/box/box_index.rst:737
#: ../doc/2.2/book/box/box_index.rst:764
#: ../doc/2.2/book/box/box_space.rst:1290
#: ../doc/2.2/book/box/box_space.rst:1449
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:710
msgid "tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:721
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:727
msgid "the tuple for the last key in the index. If optional ``key`` value is supplied, returns the last key which is less than or equal to ``key`` value. Starting with Tarantool version 2.0, index_object:max(``key`` value) will return nothing if ``key`` value is not equal to a value in the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:741
msgid "tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:752
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:759
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:761
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:766
msgid "**Note re storage engine:** vinyl does not support ``random()``."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:770
msgid "tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:781
msgid "Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:787
#: ../doc/2.2/book/box/box_space.rst:282
msgid "comparison method"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:789
msgid "the number of matching tuples."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:790
#: ../doc/2.2/book/box/box_index.rst:947
#: ../doc/2.2/book/box/box_schema.rst:169
#: ../doc/2.2/book/box/box_schema.rst:182
#: ../doc/2.2/book/box/box_session.rst:116
#: ../doc/2.2/book/box/box_session.rst:123
#: ../doc/2.2/book/box/box_session.rst:152
#: ../doc/2.2/book/box/box_session.rst:241
#: ../doc/2.2/book/box/box_session.rst:272
#: ../doc/2.2/book/box/box_space.rst:337
#: ../doc/2.2/book/box/box_space.rst:351
#: ../doc/2.2/book/box/box_space.rst:356
#: ../doc/2.2/book/box/box_space.rst:358
#: ../doc/2.2/book/box/box_space.rst:360
#: ../doc/2.2/book/box/box_space.rst:362
#: ../doc/2.2/book/box/box_space.rst:364
#: ../doc/2.2/book/box/box_tuple.rst:157
#: ../doc/2.2/book/box/box_tuple.rst:191
#: ../doc/2.2/book/box/box_tuple.rst:347
#: ../doc/2.2/reference/reference_lua/fiber.rst:463
#: ../doc/2.2/reference/reference_lua/fiber.rst:924
#: ../doc/2.2/reference/reference_lua/fio.rst:353
#: ../doc/2.2/reference/reference_lua/fio.rst:1053
#: ../doc/2.2/reference/reference_lua/socket.rst:308
#: ../doc/2.2/reference/reference_lua/socket.rst:434
#: ../doc/2.2/reference/reference_lua/utf8.rst:91
#: ../doc/2.2/reference/reference_lua/utf8.rst:152
#: ../doc/2.2/reference/reference_lua/utf8.rst:275
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1489
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1504
#: ../doc/2.2/reference/reference_sql/sql.rst:282
msgid "number"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:794
msgid "tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:809
#: ../doc/2.2/book/box/box_space.rst:1555
#: ../doc/2.2/book/box/box_tuple.rst:556
msgid "Update a tuple."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:811
msgid "Same as :ref:`box.space...update() <box_space-update>`, but key is searched in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:818
#: ../doc/2.2/book/box/box_space.rst:1589
#: ../doc/2.2/book/box/box_space.rst:1710
msgid "operation type represented in string"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:819
#: ../doc/2.2/book/box/box_space.rst:1590
#: ../doc/2.2/book/box/box_space.rst:1711
#: ../doc/2.2/book/box/box_tuple.rst:572
msgid "what field the operation will apply to. The field number can be negative, meaning the position from the end of tuple. (#tuple + negative field number + 1)"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:823
#: ../doc/2.2/book/box/box_space.rst:1594
#: ../doc/2.2/book/box/box_space.rst:1715
#: ../doc/2.2/book/box/box_tuple.rst:576
msgid "what value will be applied"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:825
#: ../doc/2.2/book/box/box_space.rst:1596
msgid "the updated tuple."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:832
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:834
msgid "Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:842
msgid "the deleted tuple."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:845
msgid "**Note re storage engine:** vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:852
msgid "Alter an index. It is legal in some circumstances to change one or more of the index characteristics, for example its type, its sequence options, its parts, and whether it is unique, Usually this causes rebuilding of the space,  except for the simple case where a part's ``is_nullable`` flag is changed from ``false`` to ``true``."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:861
msgid "options list, same as the options list for ``create_index``, see the chart named :ref:`Options for space_object:create_index() <box_space-create_index>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:865
#: ../doc/2.2/book/box/box_index.rst:923
#: ../doc/2.2/book/box/box_schema.rst:272
#: ../doc/2.2/book/box/box_schema.rst:490
#: ../doc/2.2/book/box/box_schema.rst:645
#: ../doc/2.2/book/box/box_schema.rst:695
#: ../doc/2.2/book/box/box_space.rst:783
#: ../doc/2.2/book/box/box_space.rst:1340
#: ../doc/2.2/book/box/box_space.rst:1399
#: ../doc/2.2/book/box/box_space.rst:1529
#: ../doc/2.2/book/box/data_model.rst:188
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:279
#: ../doc/2.2/reference/reference_lua/console.rst:108
#: ../doc/2.2/reference/reference_lua/fiber.rst:517
#: ../doc/2.2/reference/reference_lua/fiber.rst:564
#: ../doc/2.2/reference/reference_lua/fiber.rst:654
#: ../doc/2.2/reference/reference_lua/fiber.rst:1084
#: ../doc/2.2/reference/reference_lua/fiber.rst:1092
#: ../doc/2.2/reference/reference_lua/log.rst:154
#: ../doc/2.2/reference/reference_lua/log.rst:168
#: ../doc/2.2/reference/reference_lua/msgpack.rst:315
#: ../doc/2.2/reference/reference_lua/tap.rst:164
#: ../doc/2.2/reference/reference_lua/tap.rst:198
#: ../doc/2.2/reference/reference_lua/tap.rst:258
msgid "nil"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:869
#: ../doc/2.2/book/box/box_index.rst:901
msgid "index does not exist,"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:870
msgid "the primary-key index cannot be changed to ``{unique = false}``."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:872
msgid "**Note re storage engine:** vinyl does not support ``alter()`` of a primary-key index unless the space is empty."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:877
msgid "tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"...\n"
"\n"
"tarantool> box.space.vinyl_space.index.i:alter({page_size=4096})\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:891
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:897
msgid "nil."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:902
msgid "a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:907
msgid "tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:917
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:274
msgid "Rename an index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:921
msgid "new name for index"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:925
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:929
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:285
msgid "tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:935
#: ../doc/2.2/book/box/box_space.rst:1527
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:941
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:946
#: ../doc/2.2/book/box/box_tuple.rst:190
msgid "number of bytes"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:953
msgid "Return statistics about actions taken that affect the index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:955
msgid "This is for use with the vinyl engine."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:957
msgid "Some detail items in the output from ``index_object:stat()`` are:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:959
msgid "``index_object:stat().latency`` -- timings subdivided by percentages;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:960
msgid "``index_object:stat().bytes`` -- the number of bytes total;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:961
msgid "``index_object:stat().disk.rows`` -- the approximate number of tuples in each range;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:962
msgid "``index_object:stat().disk.statement`` -- counts of inserts|updates|upserts|deletes;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:963
msgid "``index_object:stat().disk.compaction`` -- counts of compactions and their amounts;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:964
msgid "``index_object:stat().disk.dump`` -- counts of dumps and their amounts;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:965
msgid "``index_object:stat().disk.iterator.bloom`` -- counts of bloom filter hits|misses;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:966
msgid "``index_object:stat().disk.pages`` -- the size in pages;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:967
msgid "``index_object:stat().disk.last_level`` -- size of data in the last LSM tree level;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:968
msgid "``index_object:stat().cache.evict`` -- number of evictions from the cache;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:969
msgid "``index_object:stat().range_size`` -- maximum number of bytes in a range;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:970
msgid "``index_object:stat().dumps_per_compaction`` -- average number of dumps required to trigger major compaction in any range of the LSM tree."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:972
msgid "Summary index statistics are also available via :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl_details>`."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:978
msgid "statistics"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:985
msgid "Remove unused index space. For the memtx storage engine this method does nothing; ``index_object:compact()`` is only for the vinyl storage engine. For example, with vinyl, if a tuple is deleted, the space is not immediately reclaimed. There is a scheduler for reclaiming space automatically based on factors such as lsm shape and amplification as discussed in the section :ref:`Storing data with vinyl <engines-vinyl>`, so calling ``index_object:compact()`` manually is not always necessary."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:994
msgid "nil (Tarantool returns without waiting for compaction to complete)"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1001
msgid "Users can define any functions they want, and associate them with indexes: in effect they can make their own index methods. They do this by:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1005
#: ../doc/2.2/book/box/box_space.rst:1746
msgid "creating a Lua function,"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1006
#: ../doc/2.2/book/box/box_space.rst:1747
msgid "adding the function name to a predefined global variable which has type = table, and"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1008
msgid "invoking the function any time thereafter, as long as the server is up, by saying ``index_object:function-name([parameters])``."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1011
msgid "There are three predefined global variables:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1013
msgid "Adding to ``box_schema.index_mt`` makes the method available for all indexes."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1014
msgid "Adding to ``box_schema.memtx_index_mt`` makes the method available for all memtx indexes."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1015
msgid "Adding to ``box_schema.vinyl_index_mt`` makes the method available for all vinyl indexes."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1017
msgid "Alternatively, user-defined methods can be made available for only one index, by calling ``getmetatable(index_object)`` and then adding the function name to the meta table."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1023
#: ../doc/2.2/book/box/box_space.rst:1762
msgid "whatever the user defines"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1027
msgid "-- Visible to any index of a memtx space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t', {engine='memtx'})\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f() global_variable = global_variable + 1 end\n"
"box.schema.memtx_index_mt.counter = f\n"
"box.space.t.index.i:counter()"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1040
msgid "-- Visible to index box.space.t.index.i only, 1 parameter.\n"
"-- After these requests, the value of X will be 1005.\n"
"box.schema.space.create('t', {engine='memtx', id = 1000})\n"
"box.space.t:create_index('i')\n"
"X = 0\n"
"i = box.space.t.index.i\n"
"function f(i_arg, param) X = X + param + i_arg.space_id end\n"
"box.schema.memtx_index_mt.counter = f\n"
"meta = getmetatable(i)\n"
"meta.counter = f\n"
"i:counter(5)"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1056
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1058
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1062
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1063
msgid "raise an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1066
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1065
msgid "field[1] = 1000"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1066
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1067
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1068
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1069
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1070
msgid "Return the formatted value."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1072
msgid "The function uses Tarantool box functions :ref:`box.space...select <box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1081
msgid "function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1106
#: ../doc/2.2/book/box/box_tuple.rst:628
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1108
msgid "tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1125
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1127
msgid "Here is an example that shows how to build one's own iterator. The ``paged_iter`` function is an \"iterator function\", which will only be understood by programmers who have read the Lua manual section `Iterators and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, that is, it returns 10 tuples at a time from a table named \"t\", whose primary key was defined with ``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1134
msgid "function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1148
msgid "Programmers who use ``paged_iter`` do not need to know why it works, they only need to know that, if they call it within a loop, they will get 10 tuples at a time until there are no more tuples."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1152
msgid "In this example the tuples are merely printed, a page at a time. But it should be simple to change the functionality, for example by yielding after each retrieval, or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1157
msgid "for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1170
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1172
msgid "The :ref:`box.index <box_index>` submodule may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1180
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1184
msgid "           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1200
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1210
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1213
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1215
msgid "tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1228
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1234
msgid "tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1239
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1244
msgid "tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1260
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1268
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1271
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1282
msgid "The additional option here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1287
msgid "tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1292
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1295
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1306
msgid "The additional option here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1312
msgid "tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/2.2/book/box/box_index.rst:1318
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:39
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:43
msgid "The ``box.info`` submodule provides access to information about server instance variables."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:46
msgid "**cluster.uuid** is the UUID of the replica set. Every instance in a replica set will have the same ``cluster.uuid`` value. This value is also stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:50
msgid "**gc()** returns the state of the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` including the checkpoints and their consumers (users); see details :ref:`below <box_info_gc>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:54
msgid "**id** corresponds to **replication.id** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:56
msgid "**lsn** corresponds to **replication.lsn** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:58
msgid "**memory()** returns the statistics about memory (see :ref:`below <box_info_memory>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:60
msgid "**pid** is the process ID. This value is also shown by :ref:`tarantool <tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:63
msgid "**ro** is ``true`` if the instance is in \"read-only\" mode (same as :ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``), or if status is 'orphan'."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:66
msgid "**signature** is the sum of all **lsn** values from the vector clocks (**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:68
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:69
msgid "**uptime** is the number of seconds since the instance started. This value can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:72
msgid "**uuid** corresponds to **replication.uuid** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:74
msgid "**vclock** corresponds to **replication.downstream.vclock** (see :ref:`below <box_info_replication>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:76
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool -V <index-tarantool_version>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:78
msgid "**vinyl()** returns runtime statistics for the vinyl storage engine. This function is deprecated, use :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>` instead."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:86
msgid "The **memory** function of ``box.info`` gives the ``admin`` user a picture of the whole Tarantool instance."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:91
msgid "To get a picture of the vinyl subsystem, use :ref:`box.stat.vinyl() <box_introspection-box_stat_vinyl>` instead."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:94
msgid "**memory().cache** -- number of bytes used for caching user data. The memtx storage engine does not require a cache, so in fact this is the number of bytes in the cache for the tuples stored for the vinyl storage engine."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:98
msgid "**memory().data** -- number of bytes used for storing user data (the tuples) with the memtx engine and with level 0 of the vinyl engine, without taking memory fragmentation into account."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:101
msgid "**memory().index** -- number of bytes used for indexing user data, including memtx and vinyl memory tree extents, the vinyl page index, and the vinyl bloom filters."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:104
msgid "**memory().lua** -- number of bytes used for Lua runtime."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:105
msgid "**memory().net** -- number of bytes used for network input/output buffers."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:106
msgid "**memory().tx** -- number of bytes in use by active transactions. For the vinyl storage engine, this is the total size of all allocated objects (struct ``txv``, struct ``vy_tx``, struct ``vy_read_interval``) and tuples pinned for those objects."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:111
msgid "An example with a minimum allocation while only the memtx storage engine is in use:"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:114
msgid "tarantool> box.info.memory()\n"
"---\n"
"- cache: 0\n"
"  data: 6552\n"
"  tx: 0\n"
"  lua: 1315567\n"
"  net: 98304\n"
"  index: 1196032\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:130
msgid "The **gc** function of ``box.info`` gives the ``admin`` user a picture of the factors that affect the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>`. The garbage collector compares vclock (:ref:`vector clock <replication-vector>`) values of users and checkpoints, so a look at ``box.info.gc()`` may show why the garbage collector has not removed old WAL files, or show what it may soon remove."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:137
msgid "**gc().consumers** -- a list of users whose requests might affect the garbage collector."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:138
msgid "**gc().checkpoints** -- a list of preserved checkpoints."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:139
msgid "**gc().checkpoints[n].references** -- a list of references to a checkpoint."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:140
msgid "**gc().checkpoints[n].vclock** -- a checkpoint's vclock value."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:141
msgid "**gc().checkpoints[n].signature** -- a sum of a checkpoint's vclock's components."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:142
msgid "**gc().checkpoint_is_in_progress** -- true if a checkpoint is in progress, otherwise false"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:143
msgid "**gc().vclock** -- the garbage collector's vclock."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:144
msgid "**gc().signature** -- the sum of the garbage collector's checkpoint's components."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:150
msgid "The **replication** section of ``box.info()`` contains statistics for all instances in the replica set in regard to the current instance (see also :ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:154
msgid "**replication.id** is a short numeric identifier of the instance within the replica set."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:156
msgid "**replication.uuid** is a globally unique identifier of the instance. This value is also stored in :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:159
msgid "**replication.lsn** is the :ref:`log sequence number <replication-mechanism>` (LSN) for the latest entry in the instance's :ref:`write ahead log <index-box_persistence>` (WAL)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:163
msgid "**replication.upstream** contains statistics for the replication data uploaded by the instance."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:165
msgid "**replication.upstream.status** is the replication status of the instance:"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:167
msgid "``auth`` means that the instance is getting :ref:`authenticated <authentication>` to connect to a replication source."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:170
msgid "``connecting`` means that the instance is trying to connect to the replications source(s) listed in its :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:173
msgid "``disconnected`` means that the instance is not connected to the replica set (due to network problems, not replication errors)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:175
msgid "``follow`` means that replication is in progress."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:176
msgid "``running`` means the instance's role is \"master\" (non read-only) and replication is in progress."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:178
msgid "``stopped`` means that replication was stopped due to a replication error (e.g. :ref:`duplicate key <error_codes>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:180
msgid "``orphan`` means that the instance has not (yet) succeeded in joining the required number of masters (see :ref:`orphan status <replication-orphan_status>`)."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:182
msgid "``synch`` means that the master and replica are synchronizing to have the same data."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:187
msgid "**replication.upstream.idle** is the time (in seconds) since the instance received the last event from a master. This is the primary indicator of replication health. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:194
msgid "**replication.upstream.peer** contains the replication user name, host IP adress and port number used for the instance. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:200
msgid "**replication.upstream.lag** is the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master. See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:206
msgid "**replication.upstream.message** contains an error message in case of a :ref:`degraded state <replication-recover>`, empty otherwise."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:209
msgid "**replication.downstream** contains statistics for the replication data requested and downloaded from the instance."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:212
msgid "**replication.downstream.vclock** contains the :ref:`vector clock <replication-vector>`, which is a table of '**id**, **lsn**' pairs, for example :code:`vclock: {1: 3054773, 4: 8938827, 3: 285902018}`. Even if an instance is :ref:`removed <replication-remove_instances>`, its values will still appear here."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:219
msgid "**replication.downstream.status** ``= disconnected`` is displayed if the downstream instance disconnects from the upstream instance. Otherwise the status is not reported."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:225
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:230
msgid "keys and values in the submodule"
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:235
msgid "This example is for a master-replica set that contains one master instance and one replica instance. The request was issued at the replica instance."
msgstr ""

#: ../doc/2.2/book/box/box_info.rst:238
msgid "tarantool> box.info()\n"
"---\n"
"- version: 1.7.6-68-g51fcffb77\n"
"  id: 2\n"
"  ro: true\n"
"  vclock: {1: 5}\n"
"  uptime: 917\n"
"  lsn: 0\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 783e2285-55b1-42d4-b93c-68dcbb7a8c18\n"
"  pid: 35341\n"
"  status: running\n"
"  signature: 5\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 471cd36e-cb2e-4447-ac66-2d28e9dd3b67\n"
"      lsn: 5\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 124.98795700073\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 5}\n"
"    2:\n"
"      id: 2\n"
"      uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"      lsn: 0\n"
"  uuid: ac45d5d2-8a16-4520-ad5e-1abba6baba0a\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:39
msgid "Submodule `box.schema`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:47
msgid "The ``box.schema`` submodule has data-definition functions for spaces, users, roles, function tuples, and sequences."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:54
msgid "Below is a list of all ``box.schema`` functions."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:64
msgid ":ref:`box.schema.space.create() <box_schema-space_create>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:64
msgid "Create a space"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:67
msgid ":ref:`box.schema.user.create() <box_schema-user_create>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:67
msgid "Create a user"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:70
msgid ":ref:`box.schema.user.drop() <box_schema-user_drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:70
msgid "Drop a user"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:73
msgid ":ref:`box.schema.user.exists() <box_schema-user_exists>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:73
msgid "Check if a user exists"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:76
msgid ":ref:`box.schema.user.grant() <box_schema-user_grant>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:76
msgid "Grant privileges to a user or a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:79
msgid ":ref:`box.schema.user.revoke() <box_schema-user_revoke>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:79
msgid "Revoke privileges from a user or a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:82
msgid ":ref:`box.schema.user.password() <box_schema-user_password>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:82
msgid "Get a hash of a user's password"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:85
msgid ":ref:`box.schema.user.passwd() <box_schema-user_passwd>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:85
msgid "Associate a password with a user"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:88
msgid ":ref:`box.schema.user.info() <box_schema-user_info>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:88
msgid "Get a description of a user's privileges"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:91
msgid ":ref:`box.schema.role.create() <box_schema-role_create>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:91
msgid "Create a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:94
msgid ":ref:`box.schema.role.drop() <box_schema-role_drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:94
msgid "Drop a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:97
msgid ":ref:`box.schema.role.exists() <box_schema-role_exists>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:97
msgid "Check if a role exists"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:100
msgid ":ref:`box.schema.role.grant() <box_schema-role_grant>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:100
msgid "Grant privileges to a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:103
msgid ":ref:`box.schema.role.revoke() <box_schema-role_revoke>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:103
msgid "Revoke privileges from a role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:106
msgid ":ref:`box.schema.role.info() <box_schema-role_info>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:106
msgid "Get a description of a role's privileges"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:109
msgid ":ref:`box.schema.func.create() <box_schema-func_create>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:109
msgid "Create a function tuple"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:112
msgid ":ref:`box.schema.func.drop() <box_schema-func_drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:112
msgid "Drop a function tuple"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:115
msgid ":ref:`box.schema.func.exists() <box_schema-func_exists>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:115
msgid "Check if a function tuple exists"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:118
msgid ":ref:`box.schema.sequence.create() <box_schema-sequence_create>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:118
msgid "Create a new sequence generator"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:121
msgid ":ref:`sequence_object:next() <box_schema-sequence_next>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:121
msgid "Generate and return the next value"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:124
msgid ":ref:`sequence_object:alter() <box_schema-sequence_alter>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:124
msgid "Change sequence options"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:127
msgid ":ref:`sequence_object:reset() <box_schema-sequence_reset>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:127
msgid "Reset sequence state"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:130
msgid ":ref:`sequence_object:set() <box_schema-sequence_set>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:130
msgid "Set the new value"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:133
msgid ":ref:`sequence_object:drop() <box_schema-sequence_drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:133
msgid "Drop the sequence"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:136
msgid ":ref:`space_object:create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:136
#: ../doc/2.2/book/box/box_space.rst:74
msgid "Create an index"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:144
msgid "Create a :ref:`space <index-box_space>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:146
msgid "name of space, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:148
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:150
msgid "space object"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:151
#: ../doc/2.2/dev_guide/documentation_guidelines.rst:243
#: ../doc/2.2/reference/reference_lua/fiber.rst:233
#: ../doc/2.2/reference/reference_lua/fiber.rst:272
#: ../doc/2.2/reference/reference_lua/fiber.rst:295
#: ../doc/2.2/reference/reference_lua/fiber.rst:315
#: ../doc/2.2/reference/reference_lua/fio.rst:820
#: ../doc/2.2/reference/reference_lua/http.rst:84
#: ../doc/2.2/reference/reference_lua/iconv.rst:87
#: ../doc/2.2/reference/reference_lua/net_box.rst:244
#: ../doc/2.2/reference/reference_lua/socket.rst:170
#: ../doc/2.2/reference/reference_lua/socket.rst:188
#: ../doc/2.2/reference/reference_lua/socket.rst:419
#: ../doc/2.2/reference/reference_lua/tap.rst:133
msgid "userdata"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:155
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:165
#: ../doc/2.2/book/box/box_space.rst:329
#: ../doc/2.2/book/box/data_model.rst:533
msgid "Default"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:167
msgid "engine"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:167
msgid "'memtx' or 'vinyl'"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:167
#: ../doc/2.2/book/box/box_schema.rst:207
#: ../doc/2.2/book/box/box_schema.rst:423
#: ../doc/2.2/book/box/box_session.rst:140
#: ../doc/2.2/book/box/box_session.rst:164
#: ../doc/2.2/book/box/box_session.rst:172
#: ../doc/2.2/book/box/box_space.rst:370
#: ../doc/2.2/book/box/data_model.rst:192
#: ../doc/2.2/reference/reference_lua/errno.rst:92
#: ../doc/2.2/reference/reference_lua/fiber.rst:369
#: ../doc/2.2/reference/reference_lua/fiber.rst:488
#: ../doc/2.2/reference/reference_lua/fiber.rst:538
#: ../doc/2.2/reference/reference_lua/fio.rst:216
#: ../doc/2.2/reference/reference_lua/fio.rst:238
#: ../doc/2.2/reference/reference_lua/fio.rst:258
#: ../doc/2.2/reference/reference_lua/fio.rst:277
#: ../doc/2.2/reference/reference_lua/json.rst:88
#: ../doc/2.2/reference/reference_lua/msgpack.rst:96
#: ../doc/2.2/reference/reference_lua/pickle.rst:117
#: ../doc/2.2/reference/reference_lua/socket.rst:328
#: ../doc/2.2/reference/reference_lua/socket.rst:362
#: ../doc/2.2/reference/reference_lua/socket.rst:378
#: ../doc/2.2/reference/reference_lua/string.rst:110
#: ../doc/2.2/reference/reference_lua/string.rst:135
#: ../doc/2.2/reference/reference_lua/string.rst:158
#: ../doc/2.2/reference/reference_lua/string.rst:183
#: ../doc/2.2/reference/reference_lua/string.rst:270
#: ../doc/2.2/reference/reference_lua/string.rst:296
#: ../doc/2.2/reference/reference_lua/string.rst:350
#: ../doc/2.2/reference/reference_lua/uri.rst:124
#: ../doc/2.2/reference/reference_lua/utf8.rst:124
#: ../doc/2.2/reference/reference_lua/utf8.rst:310
#: ../doc/2.2/reference/reference_lua/utf8.rst:362
#: ../doc/2.2/reference/reference_lua/utf8.rst:386
#: ../doc/2.2/reference/reference_lua/yaml.rst:82
#: ../doc/2.2/reference/reference_sql/sql.rst:284
msgid "string"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:167
msgid "'memtx'"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:169
msgid "field_count"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:169
msgid "fixed count of :ref:`fields <index-box_tuple>`: for example if field_count=5, it is illegal to insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:169
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:175
msgid "format"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:175
msgid "field names and types: See the illustrations of format clauses in the :ref:`space_object:format() <box_space-format>` description and in the :ref:`box.space._space <box_space-space>` example. Optional and usually not specified."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:175
msgid "(blank)"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:182
#: ../doc/2.2/book/box/box_space.rst:337
msgid "id"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:182
msgid "unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:182
msgid "last space's id, +1"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:186
#: ../doc/2.2/book/box/box_space.rst:341
msgid "if_not_exists"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:186
msgid "create space only if a space with the same name does not exist already, otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:186
#: ../doc/2.2/book/box/box_schema.rst:192
#: ../doc/2.2/book/box/box_schema.rst:199
#: ../doc/2.2/book/box/data_model.rst:545
#: ../doc/2.2/book/box/data_model.rst:555
#: ../doc/2.2/reference/reference_lua/msgpack.rst:305
msgid "false"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:192
#: ../doc/2.2/reference/configuration/cfg_basic.rst:129
msgid "is_local"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:192
msgid "space contents are :ref:`replication-local <replication-local>`: changes are stored in the :ref:`write-ahead log <internals-wal>` of the local node but there is no :ref:`replication <replication>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:199
#: ../doc/2.2/reference/configuration/cfg_basic.rst:127
msgid "temporary"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:199
msgid "space contents are temporary: changes are not stored in the :ref:`write-ahead log <internals-wal>` and there is no :ref:`replication <replication>`. Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:207
#: ../doc/2.2/book/box/box_space.rst:2319
#: ../doc/2.2/book/box/box_space.rst:2322
msgid "user"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:207
msgid "name of the user who is considered to be the space's :ref:`owner <authentication-owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:207
msgid "current user's name"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:213
msgid "There are three :ref:`syntax variations <app_server-object_reference>` for object references targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:222
msgid "tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:240
msgid "After a space is created, usually the next step is to :ref:`create an index <box_space-create_index>` for it, and then it is available for insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:249
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:254
#: ../doc/2.2/book/box/box_schema.rst:346
#: ../doc/2.2/book/box/box_schema.rst:627
#: ../doc/2.2/book/box/box_schema.rst:670
#: ../doc/2.2/reference/reference_lua/digest.rst:250
msgid "The possible options are:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:256
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already exists,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:259
msgid "``password`` (default = '') - string; the ``password`` = *password* specification is good because in a :ref:`URI <index-uri>` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:266
#: ../doc/2.2/book/box/box_space.rst:2409
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:268
msgid "name of user, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:270
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:274
#: ../doc/2.2/book/box/box_schema.rst:295
#: ../doc/2.2/book/box/data_model.rst:684
#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:88
#: ../doc/2.2/reference/reference_lua/net_box.rst:246
#: ../doc/2.2/reference/reference_lua/net_box.rst:313
#: ../doc/2.2/reference/reference_lua/net_box.rst:450
#: ../doc/2.2/reference/reference_lua/net_box.rst:484
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1327
msgid "**Examples:**"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:276
msgid "box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:286
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:291
#: ../doc/2.2/book/box/box_schema.rst:311
msgid "the name of the user"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:292
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:297
msgid "box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:306
msgid "Return ``true`` if a user exists; return ``false`` if a user does not exist. For explanation of how Tarantool maintains user data, see section :ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:312
#: ../doc/2.2/book/box/box_schema.rst:524
#: ../doc/2.2/book/box/box_schema.rst:800
#: ../doc/2.2/reference/reference_lua/uuid.rst:162
msgid "bool"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:316
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:326
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a user or to another role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:329
#: ../doc/2.2/book/box/box_schema.rst:371
msgid "the name of the user."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:330
#: ../doc/2.2/book/box/box_schema.rst:372
#: ../doc/2.2/book/box/box_schema.rst:541
#: ../doc/2.2/book/box/box_schema.rst:574
msgid "'read' or 'write' or 'execute' or 'create' or 'alter' or 'drop' or a combination."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:332
#: ../doc/2.2/book/box/box_schema.rst:543
#: ../doc/2.2/book/box/box_schema.rst:576
msgid "'space' or 'function' or 'sequence' or 'role'."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:333
msgid "name of object to grant permissions for."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:334
msgid "name of role to grant to user."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:335
msgid "``grantor``, ``if_not_exists``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:337
msgid "If :samp:`'function','{object-name}'` is specified, then a _func tuple with that object-name must exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:340
#: ../doc/2.2/book/box/box_schema.rst:551
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:343
#: ../doc/2.2/book/box/box_schema.rst:383
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:348
msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:349
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the user already has the privilege."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:354
msgid "box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:368
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from another role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:374
msgid "'space' or 'function' or 'sequence'."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:375
msgid "the name of a function or space or sequence."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:377
msgid "The user must exist, and the object must exist, but it is not an error if the user does not have the privilege."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:380
#: ../doc/2.2/book/box/box_schema.rst:582
msgid "**Variation:** instead of ``object-type, object-name`` say 'universe' which means 'all object-types and all objects'."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:388
msgid "box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:399
msgid "Return a hash of a user's password. For explanation of how Tarantool maintains passwords, see section :ref:`Passwords <authentication-passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:405
msgid "If a non-'guest' user has no password, it’s **impossible** to connect to Tarantool using this user. The user is regarded as “internal” only, not usable from a remote connection. Such users can be useful if they have defined some procedures with the :ref:`SETUID <box_schema-func_create>` option, on which privileges are granted to externally-connectable users. This way, external users cannot create/drop objects, they can only invoke procedures."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:412
msgid "For the 'guest' user, it’s impossible to set a password: that would be misleading, since 'guest' is the default user on a newly-established connection over a :ref:`binary port <admin-security>`, and Tarantool does not require a password to establish a :ref:`binary connection <box_protocol-iproto_protocol>`. It is, however, possible to change the current user to ‘guest’ by providing the :ref:`AUTH packet <box_protocol-authentication>` with no password at all or an empty password. This feature is useful for connection pools, which want to reuse a connection for a different user without re-establishing it."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:422
msgid "password to be hashed"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:427
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:435
msgid "Associate a password with the user who is currently logged in, or with the user specified by user-name. The user must exist and must not be 'guest'."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:438
msgid "Users who wish to change their own passwords should use ``box.schema.user.passwd(password)`` syntax."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:441
msgid "Administrators who wish to change passwords of other users should use ``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:444
msgid "user-name"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:445
msgid "password"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:449
msgid "box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:458
msgid "Return a description of a user's :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:480
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:484
msgid "name of role, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:486
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already exists"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:494
msgid "box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:503
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:507
#: ../doc/2.2/book/box/box_schema.rst:523
msgid "the name of the role"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:508
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:513
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:521
msgid "Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:528
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:538
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:540
#: ../doc/2.2/book/box/box_schema.rst:573
#: ../doc/2.2/book/box/box_schema.rst:603
msgid "the name of the role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:544
#: ../doc/2.2/book/box/box_schema.rst:577
msgid "the name of a function or space or sequence or role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:545
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the role already has the privilege."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:549
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:554
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name`` -- to grant a role to a role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:559
msgid "box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:571
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:579
msgid "The role must exist, and the object must exist, but it is not an error if the role does not have the privilege."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:585
msgid "**Variation:** instead of ``privilege, object-type, object-name`` say ``role-name``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:590
msgid "box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:601
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:607
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:615
msgid "Create a function :ref:`tuple <index-box_tuple>`. without including the ``body`` option. (For functions created without the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-func_create_with-body>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:620
msgid "This is called a \"not persistent\" function because functions without bodies are not persistent. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:629
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the ``_func`` tuple already exists."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:632
msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that Tarantool should treat the function’s caller as the function’s owner, with owner privileges. ``setuid`` works only over :ref:`binary ports <admin-security>`, ``setuid`` does not work if the function is invoked via an :ref:`admin console <admin-security>` or inside a Lua script."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:639
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:641
#: ../doc/2.2/book/box/box_schema.rst:691
msgid "name of function, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:643
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:649
msgid "box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:660
msgid "Create a function :ref:`tuple <index-box_tuple>`. including the ``body`` option. (For functions created without the ``body`` option, see :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:665
msgid "This is called a \"persistent\" function because only functions with bodies are persistent. This does create the function itself, the body is a function definition. For explanation of how Tarantool maintains function data, see the reference for the :ref:`box.space._func <box_space-func>` space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:672
msgid "``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:675
msgid "``setuid`` = ``true|false`` (default = ``false``) - boolean; same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:678
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’) - string. same as for :ref:`box.schema.func.create(func-name [, {options-without-body}]) <box_schema-func_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:681
msgid "``is_sandboxed`` = ``true|false`` (default = ``false``) - boolean; whether the function should be executed in a sandbox."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:684
msgid "``is_deterministic`` = ``true|false`` (default = ``false``) - boolean; ``true`` means that the function should be deterministic, ``false`` means that the function may or may not be deterministic."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:688
msgid "``body`` = function definition (default = nil) - string; the function definition."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:693
msgid "``if_not_exists``, ``setuid``, ``language``, ``is_sandboxed``, ``is_deterministic``, ``body``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:697
msgid "C functions are imported from .so files, Lua functions can be defined within ``body``. We will only describe Lua functions in this section."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:700
msgid "A function tuple with a body is \"persistent\" because the tuple is stored in a snapshot and is recoverable if the server restarts. All of the option values described in this section are visible in the :ref:`box.space._func <box_space-func>` system space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:705
msgid "If ``is_sandboxed`` is true, then the function will be executed in an isolated environment: any operation that accesses the world outside the sandbox will be forbidden or will have no effect. Therefore a sandboxed function can only use modules and functions which cannot affect isolation: `assert <https://www.lua.org/manual/5.1/manual.html#pdf-assert>`_ `error <://www.lua.org/manual/5.1/manual.html#pdf-error>`_ `ipairs <https://www.lua.org/manual/5.1/manual.html#pdf-ipairs>`_ `math.* <https://www.lua.org/manual/5.1/manual.html#5.6>`_ `next <https://www.lua.org/manual/5.1/manual.html#pdf-next>`_ `pairs <https://www.lua.org/manual/5.1/manual.html#pdf-pairs>`_ `pcall <https://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_ `print <https://www.lua.org/manual/5.1/manual.html#pdf-print>`_ `select <https://www.lua.org/manual/5.1/manual.html#pdf-select>`_ `string.* <https://www.lua.org/manual/5.1/manual.html#5.4>`_ `table.* <https://www.lua.org/manual/5.1/manual.html#5.5>`_ `tonumber <https://www.lua.org/manual/5.1/manual.html#pdf-tonumber>`_ `tostring <https://www.lua.org/manual/5.1/manual.html#pdf-tostring>`_ `type <https://www.lua.org/manual/5.1/manual.html#pdf-type>`_ `unpack <https://www.lua.org/manual/5.1/manual.html#pdf-unpack>`_ :ref:`utf8.* <utf8-module>` `xpcall <https://www.lua.org/manual/5.1/manual.html#pdf-xpcall>`_. Also a sandboxed function cannot refer to global variables -- they will be treated as local variables because the sandbox is established with `setfenv <https://www.lua.org/manual/5.1/manual.html#pdf-setfenv>`_. So a sandboxed function will happen to be stateless and deterministic."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:732
msgid "If ``is_deterministic`` is true, there is no immediate effect. Tarantool plans to use the is_deterministic value in a future version. A function is deterministic if it always returns the same outputs given the same inputs. It is the function creator's responsibility to ensure that a function is truly deterministic."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:738
msgid "**Using a persistent Lua function**"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:740
msgid "After a persistent Lua function is created, it can be found in the :ref:`box.space._func <box_space-func>` system space, and it can be shown with |br| :samp:`box.func.{func-name}` |br| and it can be invoked by any user with :ref:`authorization <authentication-owners_privileges>` to 'execute' it. The syntax for invoking is: |br| :samp:`box.func.{func-name}:call([parameters])` |br| or, if the connection is remote, the syntax is as in :ref:`net_box:call() <net_box-call>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:753
msgid "tarantool> lua_code = [[function(a, b) return a + b end]]\n"
"tarantool> box.schema.func.create('sum', {body = lua_code})\n"
"\n"
"tarantool> box.func.sum\n"
"---\n"
"- is_sandboxed: false\n"
"  is_deterministic: false\n"
"  id: 2\n"
"  setuid: false\n"
"  body: function(a, b) return a + b end\n"
"  name: sum\n"
"  language: LUA\n"
"...\n"
"\n"
"tarantool> box.func.sum.call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:778
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:782
#: ../doc/2.2/book/box/box_schema.rst:799
msgid "the name of the function"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:783
msgid "``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:788
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:796
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:804
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:812
msgid "Reload a C module with all its functions without restarting the server."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:814
msgid "Under the hood, Tarantool loads a new copy of the module (``*.so`` shared library) and starts routing all new request to the new version. The previous version remains active until all started calls are finished. All shared libraries are loaded with ``RTLD_LOCAL`` (see \"man 3 dlopen\"), therefore multiple copies can co-exist without any problems."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:822
msgid "Reload will fail if a module was loaded from Lua script with `ffi.load() <http://luajit.org/ext_ffi_api.html#ffi_load>`_."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:825
msgid "the name of the module to reload"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:829
msgid "-- reload the entire module contents\n"
"box.schema.func.reload('module')"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:838
#: ../doc/2.2/book/box/data_model.rst:506
msgid "Sequences"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:840
msgid "An introduction to sequences is in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter. Here are the details for each function and option."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:844
msgid "All functions related to sequences require appropriate :ref:`privileges <authentication-owners_privileges>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:851
msgid "Create a new sequence generator."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:853
msgid "the name of the sequence"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:855
msgid "see a quick overview in the \"Options for ``box.schema.sequence.create()``\" :ref:`chart <index-box_sequence-options>` (in the :ref:`Sequences <index-box_sequence>` section of the \"Data model\" chapter), and see more details below."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:862
msgid "a reference to a new sequence object."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:864
msgid "Options:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:866
msgid "``start`` -- the STARTS WITH value. Type = integer, Default = 1."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:868
msgid "``min`` -- the MINIMUM value. Type = integer, Default = 1."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:870
msgid "``max`` - the MAXIMUM value. Type = integer, Default = 9223372036854775807."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:872
msgid "There is a rule: ``min`` <= ``start`` <= ``max``. For example it is illegal to say ``{start=0}`` because then the specified start value (0) would be less than the default min value (1)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:876
msgid "There is a rule: ``min`` <= next-value <= ``max``. For example, if the next generated value would be 1000, but the maximum value is 999, then that would be considered \"overflow\"."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:881
msgid "There is a rule: ``start`` and ``min`` and ``max`` must all be <= 9223372036854775807 which is 2^63 - 1 (not 2^64)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:884
msgid "``cycle`` -- the CYCLE value. Type = bool. Default = false."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:886
msgid "If the sequence generator's next value is an overflow number, it causes an error return -- unless ``cycle == true``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:889
msgid "But if ``cycle == true``, the count is started again, at the MINIMUM value or at the MAXIMUM value (not the STARTS WITH value)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:892
msgid "``cache`` -- the CACHE value. Type = unsigned integer. Default = 0."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:894
msgid "Currently Tarantool ignores this value, it is reserved for future use."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:896
msgid "``step`` -- the INCREMENT BY value. Type = integer. Default = 1."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:898
msgid "Ordinarily this is what is added to the previous value."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:904
msgid "Generate the next value and return it."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:906
msgid "The generation algorithm is simple:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:908
msgid "If this is the first time, then return the STARTS WITH value."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:909
msgid "If the previous value plus the INCREMENT value is less than the MINIMUM value or greater than the MAXIMUM value, that is \"overflow\", so either raise an error (if ``cycle`` = ``false``) or return the MAXIMUM value (if ``cycle`` = ``true`` and ``step`` < 0) or return the MINIMUM value (if ``cycle`` = ``true`` and ``step`` > 0)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:915
msgid "If there was no error, then save the returned result, it is now the \"previous value\"."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:918
msgid "For example, suppose sequence 'S' has:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:920
msgid "``min`` == -6,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:921
msgid "``max`` == -1,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:922
msgid "``step`` == -3,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:923
msgid "``start`` = -2,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:924
msgid "``cycle`` = true,"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:925
msgid "previous value = -2."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:927
msgid "Then ``box.sequence.S:next()`` returns -5 because -2 + (-3) == -5."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:929
msgid "Then ``box.sequence.S:next()`` again returns -1 because -5 + (-3) < -6, which is overflow, causing cycle, and ``max`` == -1."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:932
msgid "This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:937
msgid "This function should not be used in \"cross-engine\" transactions (transactions which use both the memtx and the vinyl storage engines)."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:940
msgid "To see what the previous value was, without changing it, you can select from the :ref:`_sequence_data <box_space-sequence_data>` system space."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:948
msgid "The ``alter()`` function can be used to change any of the sequence's options. Requirements and restrictions are the same as for :ref:`box.schema.sequence.create() <box_schema-sequence_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:956
msgid "Set the sequence back to its original state. The effect is that a subsequent ``next()`` will return the ``start`` value. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:965
msgid "Set the \"previous value\" to ``new-previous-value``. This function requires a :ref:`'write' privilege <box_schema-user_grant>` on the sequence."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:973
msgid "Drop an existing sequence."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:977
msgid "Here is an example showing all sequence options and operations:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:979
msgid "s = box.schema.sequence.create(\n"
"               'S2',\n"
"               {start=100,\n"
"               min=100,\n"
"               max=tonumber64('9223372036854775807'),\n"
"               cache=100000,\n"
"               cycle=false,\n"
"               step=100\n"
"               })\n"
"s:alter({step=6})\n"
"s:next()\n"
"s:reset()\n"
"s:set(150)\n"
"s:drop()"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1000
msgid "You can use the ``sequence`` option when :ref:`creating <box_space-create_index>` or :ref:`altering <box_index-alter>` a primary-key index. The sequence becomes associated with the index, so that the next ``insert()`` will put the next generated number into the primary-key field, if the field value would otherwise be nil."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1007
msgid "The syntax may be any of: |br| :samp:`sequence = {sequence identifier}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`}` |br| or :code:`sequence = {field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = {id =` :samp:`{sequence identifier}` :code:`, field =` :samp:`{field number}` :code:`}` |br| or :code:`sequence = true` |br| or :code:`sequence = {}`. |br| The sequence identifier may be either a number (the sequence id) or a string (the sequence name). The field number may be the ordinal number of any field in the index; default = 1. Examples of all possibilities: ``sequence = 1`` or ``sequence = 'sequence_name'`` or ``sequence = {id = 1}`` or ``sequence = {id = 'sequence_name'}`` or ``sequence = {id = 1, field = 1}`` or ``sequence = {id = 'sequence_name', field = 1}`` or ``sequence = {field = 1}`` or ``sequence = true`` or ``sequence = {}``. Notice that the sequence identifier can be omitted, if it is omitted then a new sequence is created automatically with default name = :samp:`{space-name}_seq`. Notice that the field number does not have to be 1, that is, the sequence can be associated with any field in the primary-key index."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1040
msgid "For example, if 'Q' is a sequence and 'T' is a new space, then this will work:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1043
msgid "tarantool> box.space.T:create_index('Q',{sequence='Q'})\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  sequence_id: 8\n"
"  id: 0\n"
"  space_id: 514\n"
"  name: Q\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1059
msgid "(Notice that the index now has a ``sequence_id`` field.)"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1061
msgid "And this will work:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1063
msgid "tarantool> box.space.T:insert{nil,0}\n"
"---\n"
"- [1, 0]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1072
msgid "The index key type may be either 'integer' or 'unsigned'. If any of the sequence options is a negative number, then the index key type should be 'integer'."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1076
msgid "Users should not insert a value greater than 9223372036854775807, which is 2^63 - 1, in the indexed field. The sequence generator will ignore it."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1080
msgid "A sequence cannot be dropped if it is associated with an index. However, :ref:`index_object:alter() <box_index-alter>` can be used to say that a sequence is not associated with an index, for example ``box.space.T.index.I:alter({sequence=false})``."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1086
msgid "If a sequence was created automatically because the sequence identifier was omitted, then it will be dropped automatically if the index is altered so that ``sequence=false``, or if the index is dropped."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1091
msgid "``index_object:alter()`` can also be used to associate a sequence with an existing index, with the same syntax for options."
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1094
msgid "When a sequence is used with an index based on a JSON path, inserted tuples must have all components of the path preceding the autoincrement field, and the autoincrement field. To achieve that use ``box.NULL`` rather than ``nil``. Example:"
msgstr ""

#: ../doc/2.2/book/box/box_schema.rst:1099
msgid "s = box.schema.space.create('test')\n"
"s:create_index('pk', {parts = {{'[1].a.b[1]', 'unsigned'}}, sequence = true})\n"
"s:replace{} -- error\n"
"s:replace{{c = {}}} -- error\n"
"s:replace{{a = {c = {}}}} -- error\n"
"s:replace{{a = {b = {}}}} -- error\n"
"s:replace{{a = {b = {nil}}}} -- error\n"
"s:replace{{a = {b = {box.NULL}}}} -- ok"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:39
msgid "Submodule `box.session`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:45
msgid "The ``box.session`` submodule allows querying the session state, writing to a session-specific temporary Lua table, or sending out-of-band messages, or setting up triggers which will fire when a session starts or ends."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:49
msgid "A *session* is an object associated with each client connection."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:55
msgid "Below is a list of all ``box.session`` functions and members."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:65
msgid ":ref:`box.session.id() <box_session-id>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:65
msgid "Get the current session's ID"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:68
msgid ":ref:`box.session.exists() <box_session-exists>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:68
msgid "Check if a session exists"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:71
msgid ":ref:`box.session.peer() <box_session-peer>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:71
msgid "Get the session peer's host address and port"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:74
msgid ":ref:`box.session.sync() <box_session-sync>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:74
msgid "Get the sync integer constant"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:77
msgid ":ref:`box.session.user() <box_session-user>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:77
msgid "Get the current user's name"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:80
msgid ":ref:`box.session.type() <box_session-type>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:80
msgid "Get the connection type or cause of action"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:83
msgid ":ref:`box.session.su() <box_session-su>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:83
msgid "Change the current user"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:86
msgid ":ref:`box.session.uid() <box_session-uid>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:86
msgid "Get the current user's ID"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:89
msgid ":ref:`box.session.euid() <box_session-euid>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:89
msgid "Get the current effective user's ID"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:92
msgid ":ref:`box.session.storage <box_session-storage>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:92
msgid "Table with session-specific names and values"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:95
msgid ":ref:`box.session.on_connect() <box_session-on_connect>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:95
msgid "Define a connect trigger"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:98
msgid ":ref:`box.session.on_disconnect() <box_session-on_disconnect>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:98
msgid "Define a disconnect trigger"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:101
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:101
msgid "Define an authentication trigger"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:104
msgid ":ref:`box.session.push() <box_session-push>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:104
msgid "Send an out-of-band message"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:114
msgid "the unique identifier (ID) for the current session. The result can be 0 or -1 meaning there is no session."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:122
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:129
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate Tarantool instance."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:132
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate instance, the return is null. The command is executed on the server instance, so the \"local name\" is the server instance's host and port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:142
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:148
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_. This value becomes invalid when the session is disconnected."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:154
msgid "This function is local for the request, i.e. not global for the session. If the connection behind the session is multiplexed, this function can be safely used inside the request processor."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:162
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:170
msgid "the type of connection or cause of action."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:174
msgid "Possible return values are:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:176
msgid "'binary' if the connection was done via the binary protocol, for example to a target made with :ref:`box.cfg{listen=...} <cfg_basic-listen>`;"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:179
msgid "'console' if the connection was done via the administrative console, for example to a target made with :ref:`console.listen <console-listen>`;"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:182
msgid "'repl' if the connection was done directly, for example when :ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`;"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:184
msgid "'applier' if the action is due to :ref:`replication <replication>`, regardless of how the connection was done;"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:187
msgid "'background' if the action is in a :ref:`background fiber <fiber-module>`, regardless of whether the Tarantool server was :ref:`started in the background <cfg_basic-background>`."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:192
msgid "``box.session.type()`` is useful for an :ref:`on_replace() <box_space-on_replace>` trigger on a replica -- the value will be 'applier' if and only if the trigger was activated because of a request that was done on the master."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:202
msgid "Change Tarantool's :ref:`current user <authentication-users>` -- this is analogous to the Unix command ``su``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:205
msgid "Or, if function-to-execute is specified, change Tarantool's :ref:`current user <authentication-users>` temporarily while executing the function -- this is analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:210
msgid "name of a target user"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:211
msgid "name of a function, or definition of a function. Additional parameters may be passed to ``box.session.su``, they will be interpreted as parameters of function-to-execute."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:218
msgid "tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:239
msgid "the user ID of the :ref:`current user <authentication-users>`."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:243
msgid "Every user has a unique name (seen with :ref:`box.session.user() <box_session-user>`) and a unique ID (seen with ``box.session.uid()``). The values are stored together in the ``_user`` space."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:251
msgid "the effective user ID of the :ref:`current user <authentication-users>`."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:253
msgid "This is the same as :ref:`box.session.uid() <box_session-uid>`, except in two cases:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:256
msgid "The first case: if the call to ``box.session.euid()`` is within a function invoked by :ref:`box.session.su(user-name, function-to-execute) <box_session-su>` -- in that case, ``box.session.euid()`` returns the ID of the changed user (the user who is specified by the ``user-name`` parameter of the ``su`` function)  but ``box.session.uid()`` returns the ID of the original user (the user who is calling the ``su`` function)."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:264
msgid "The second case: if the call to ``box.session.euid()`` is within a function specified with :ref:`box.schema.func.create(function-name, {setuid= true}) <box_schema-func_create>` and the binary protocol is in use -- in that case, ``box.session.euid()`` returns the ID of the user who created \"function-name\" but ``box.session.uid()`` returns the ID of the the user who is calling \"function-name\"."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:276
msgid "tarantool> box.session.su('admin')\n"
"---\n"
"...\n"
"tarantool> box.session.uid(), box.session.euid()\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"tarantool> function f() return {box.session.uid(),box.session.euid()} end\n"
"---\n"
"...\n"
"tarantool> box.session.su('guest', f)\n"
"---\n"
"- - 1\n"
"  - 0\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:299
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends. For example, this table could be useful to store current tasks when working with a `Tarantool queue manager <https://github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:306
msgid "tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:335
msgid "Define a trigger for execution when a new session is created due to an event such as :ref:`console.connect <console-connect>`. The trigger function will be the first thing executed after a new session is created. If the trigger execution fails and raises an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:346
#: ../doc/2.2/book/box/box_session.rst:382
#: ../doc/2.2/book/box/box_session.rst:457
#: ../doc/2.2/book/box/box_space.rst:1117
#: ../doc/2.2/book/box/box_space.rst:1197
msgid "If both parameters are omitted, then the response is a list of existing trigger functions."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:352
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:361
msgid "If a trigger always results in an error, it may become impossible to connect to a server to reset it."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:368
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as :ref:`box.session.id() <box_session-id>`."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:373
msgid "Since version 1.10, the trigger function is invoked immediately after the disconnect, even if requests that were made during the session have not finished."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:388
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:397
msgid "After the following series of requests, a Tarantool instance will write a message using the :ref:`log <log-module>` module whenever any user connects or disconnects."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:400
msgid "function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:417
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:419
msgid "2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:430
msgid "Define a trigger for execution during :ref:`authentication <authentication-users>`."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:432
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:434
msgid "The :ref:`console.connect <console-connect>` function includes an authentication check for all users except 'guest'. For this case, the ``on_auth`` trigger function is invoked after the ``on_connect`` trigger function, if and only if the connection has succeeded so far."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:439
msgid "The :ref:`binary protocol <admin-security>` has a separate :ref:`authentication packet <box_protocol-authentication>`. For this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:443
msgid "Unlike other trigger types, ``on_auth`` trigger functions are invoked **before** the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name **after** the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:449
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:461
msgid "**Example 1**"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:463
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:470
msgid "**Example 2**"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:472
msgid "This is a more complex example, with two server instances."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:474
msgid "The first server instance listens on port 3301; its default user name is 'admin'. There are three ``on_auth`` triggers:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:478
msgid "The first trigger has a function with no arguments, it can only look at ``box.session.user()``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:480
msgid "The second trigger has a function with a ``user_name`` argument, it can look at both of: ``box.session.user()`` and ``user_name``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:482
msgid "The third trigger has a function with a ``user_name`` argument and a ``status`` argument, it can look at all three of: ``box.session.user()`` and ``user_name`` and ``status``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:487
msgid "The second server instance will connect with :ref:`console.connect <console-connect>`, and then will cause a display of the variables that were set by the trigger functions."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:492
msgid "-- On the first server instance, which listens on port 3301\n"
"box.cfg{listen=3301}\n"
"function function1()\n"
"  print('function 1, box.session.user()='..box.session.user())\n"
"  end\n"
"function function2(user_name)\n"
"  print('function 2, box.session.user()='..box.session.user())\n"
"  print('function 2, user_name='..user_name)\n"
"  end\n"
"function function3(user_name, status)\n"
"  print('function 3, box.session.user()='..box.session.user())\n"
"  print('function 3, user_name='..user_name)\n"
"  if status == true then\n"
"    print('function 3, status = true, authorization succeeded')\n"
"    end\n"
"  end\n"
"box.session.on_auth(function1)\n"
"box.session.on_auth(function2)\n"
"box.session.on_auth(function3)\n"
"box.schema.user.passwd('admin')"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:515
msgid "-- On the second server instance, that connects to port 3301\n"
"console = require('console')\n"
"console.connect('admin:admin@localhost:3301')"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:521
msgid "The result looks like this:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:523
msgid "function 3, box.session.user()=guest\n"
"function 3, user_name=admin\n"
"function 3, status = true, authorization succeeded\n"
"function 2, box.session.user()=guest\n"
"function 2, user_name=admin\n"
"function 1, box.session.user()=guest"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:536
msgid "Generate an out-of-band message. By \"out-of-band\" we mean an extra message which supplements what is passed in a network via the usual channels. Although ``box.session.push()`` can be called at any time, in practice it is used with networks that are set up with :ref:`module net.box <net_box-module>`, and it is invoked by the server (on the \"remote database system\" to use our terminology for net.box), and the client has options for getting such messages."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:545
msgid "This function returns an error if the session is disconnected."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:547
msgid "what to send"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:548
msgid "an optional argument to indicate what the session is, as taken from an earlier call to :ref:`box_session:sync() <box_session-sync>`. If it is omitted, the default is the current ``box.session.sync()`` value."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:551
msgid "{nil, error} or true:"
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:553
msgid "If the result is an error, then the first part of the return is ``nil`` and the second part is the error object."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:555
msgid "If the result is not an error, then the return is the boolean value ``true``."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:556
msgid "When the return is ``true``, the message has gone to the network buffer as a :ref:`packet <box_protocol-iproto_protocol>` with the code IPROTO_CHUNK (0x80)."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:560
msgid "The server's sole job is to call ``box.session.push()``, there is no automatic mechanism for showing that the message was received."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:563
msgid "The client's job is to check for such messages after it sends something to the server. The major client methods -- :ref:`conn:call <net_box-call>`, :ref:`conn:eval <net_box-eval>`, :ref:`conn:select <conn-select>`, :ref:`conn:insert <conn-insert>`, :ref:`conn:replace <conn-replace>`, :ref:`conn:update <conn-update>`, :ref:`conn:upsert <conn-upsert>`, :ref:`delete <conn-delete>` -- may cause the server to send a message."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:571
msgid "Situation 1: when the client calls synchronously with the default ``{async=false}`` option. There are two optional additional options: :samp:`on_push={function-name}`, and :samp:`on_push_ctx={function-argument}`. When the client receives an out-of-band message for the session, it invokes \"function-name(function-argument)\". For example, with options ``{on_push=table.insert, on_push_ctx=messages}``, the client will insert whatever it receives into a table named 'messages'."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:579
msgid "Situation 2: when the client calls asynchronously with the non-default ``{async=true}`` option. Here ``on_push`` and ``on_push_ctx`` are not allowed, but the messages can be seen by calling ``pairs()`` in a loop."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:583
msgid "Situation 2 complication: ``pairs()`` is subject to timeout. So there is an optional argument = timeout per iteration. If timeout occurs before there is a new message or a final response, there is an error return. To check for an error one can use the first loop parameter (if the loop starts with \"for i, message in future:pairs()\" then the first loop parameter is i). If it is ``box.NULL`` then the second parameter (in our example, \"message\") is the error object."
msgstr ""

#: ../doc/2.2/book/box/box_session.rst:593
msgid "-- Make two shells. On Shell#1 set up a \"server\", and\n"
"-- in it have a function that includes box.session.push:\n"
"box.cfg{listen=3301}\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"x = 0\n"
"fiber = require('fiber')\n"
"function server_function() x=x+1; fiber.sleep(1); box.session.push(x); end\n"
"\n"
"-- On Shell#2 connect to this server as a \"client\" that\n"
"-- can handle Lua (such as another Tarantool server operating\n"
"-- as a client), and initialize a table where we'll get messages:\n"
"net_box = require('net.box')\n"
"conn = net_box.connect(3301)\n"
"messages_from_server = {}\n"
"\n"
"-- On Shell#2 remotely call the server function and receive\n"
"-- a SYNCHRONOUS out-of-band message:\n"
"conn:call('server_function', {},\n"
"          {is_async = false,\n"
"           on_push = table.insert,\n"
"           on_push_ctx = messages_from_server})\n"
"messages_from_server\n"
"-- After a 1-second pause that is caused by the fiber.sleep()\n"
"-- request inside server_function, the result in the\n"
"--  messages_from_server table will be: 1. Like this:\n"
"-- tarantool> messages_from_server\n"
"-- ---\n"
"-- - - 1\n"
"-- ...\n"
"-- Good. That shows that box.session.push(x) worked,\n"
"-- because we know that x was 1.\n"
"\n"
"-- On Shell#2 remotely call the same server function and\n"
"-- get an ASYNCHRONOUS out-of-band message. For this we cannot\n"
"-- use on_push and on_push_ctx options, but we can use pairs():\n"
"future = conn:call('server_function', {}, {is_async = true})\n"
"messages = {}\n"
"keys = {}\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"future:wait_result(1000)\n"
"for i, message in future:pairs() do\n"
"    table.insert(messages, message) table.insert(keys, i) end\n"
"messages\n"
"-- There is no pause because conn:call does not wait for\n"
"-- server_function to finish. The first time that we go through\n"
"-- the pairs() loop, we see the messages table is empty. Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - []\n"
"-- ...\n"
"-- That is okay because the server hasn't yet called\n"
"-- box.session.push(). The second time that we go through\n"
"-- the pairs() loop, we see the value of x at the time of\n"
"-- the second call to box.session.push(). Like this:\n"
"-- tarantool> messages\n"
"-- ---\n"
"-- - - 2\n"
"--   - &0 []\n"
"--   - 2\n"
"--   - *0\n"
"-- ...\n"
"-- Good. That shows that the message was asynchronous, and\n"
"-- that box.session.push() did its job."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:39
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:47
msgid "The ``box.slab`` submodule provides access to slab allocator statistics. The slab allocator is the main allocator used to store :ref:`tuples <index-box_tuple>`. This can be used to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:55
msgid "Below is a list of all ``box.slab`` functions."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:65
msgid ":ref:`box.runtime.info() <box_runtime_info>`"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:65
msgid "Show a memory usage report for Lua runtime"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:68
msgid ":ref:`box.slab.info() <box_slab_info>`"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:68
msgid "Show an aggregated memory usage report for slab allocator"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:71
msgid ":ref:`box.slab.stats() <box_slab_stats>`"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:71
msgid "Show a detailed memory usage report for slab allocator"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:79
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:83
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:84
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:85
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:91
msgid "tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:108
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:110
msgid "This report is useful for assessing out-of-memory risks: the risks are high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:113
msgid "If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or ``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the memory is used efficiently)."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:117
msgid "If ``quota_used_ratio`` is high (approaching 100%), then low ``arena_used_ratio`` (50-60%) indicates that the memory is heavily fragmentized. Most probably, there is no immediate out-of-memory risk in this case, but generally this is an issue to consider. For example, probable risks are that the entire memory quota is used for tuples, and there is are no slabs left for a piece of an index. Or that all slabs are allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:127
msgid "``items_size`` is the *total* amount of memory (including allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:129
msgid "``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` (these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:131
msgid "``quota_size`` is the maximum amount of memory that the slab allocator can use for both tuples and indexes (as configured in the :ref:`memtx_memory <cfg_storage-memtx_memory>` parameter, the default is 2^28 bytes =  268,435,456 bytes);"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:135
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:136
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:137
msgid "``items_used`` is the *efficient* amount of memory (omitting allocated, but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:139
msgid "``quota_used`` is the amount of memory that is already distributed to the slab allocator;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:141
msgid "``arena_size`` is the *total* memory used for tuples and indexes together (including allocated, but currently free slabs);"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:143
msgid "``arena_used`` is the *efficient* memory used for storing tuples and indexes together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:150
msgid "tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:174
msgid "Show a detailed memory usage report (in bytes) for the slab allocator. The report is broken down into groups by *data item size* as well as by *slab size* (64-byte, 136-byte, etc). The report includes the memory allocated for storing both tuples and indexes."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:181
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:182
msgid "``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:183
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:184
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:185
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:186
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:192
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:194
msgid "tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:206
msgid "This report is saying that there are 2 data items (``item_count`` = 2) stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so ``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:211
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:213
msgid "tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/2.2/book/box/box_slab.rst:244
msgid "The total ``mem_used`` for all groups in this report equals ``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:39
msgid "Submodule `box.space`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:45
msgid "The ``box.space`` submodule has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Submodule source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/2.1/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:55
msgid "Below is a list of all ``box.space`` functions and members."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:65
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:65
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:68
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:68
msgid "Get count of bytes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:71
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:71
#: ../doc/2.2/book/box/box_space.rst:95
msgid "Get count of tuples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:74
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:77
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:77
#: ../doc/2.2/reference/reference_lua/net_box.rst:155
msgid "Delete a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:80
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:80
msgid "Destroy a space"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:83
msgid ":ref:`space_object:format() <box_space-format>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:83
msgid "Declare field names and types"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:86
msgid ":ref:`space_object:frommap() <box_space-frommap>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:86
msgid "Convert from map to tuple or table"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:89
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:89
#: ../doc/2.2/reference/reference_lua/net_box.rst:140
msgid "Select a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:92
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:92
#: ../doc/2.2/reference/reference_lua/net_box.rst:143
msgid "Insert a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:95
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:98
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:98
msgid "Create a replace trigger with a function that cannot change the tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:102
msgid ":ref:`space_object:before_replace() <box_space-before_replace>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:102
msgid "Create a replace trigger with a function that can change the tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:106
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:109
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:109
#: ../doc/2.2/book/box/box_space.rst:115
#: ../doc/2.2/reference/reference_lua/net_box.rst:146
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:112
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:112
msgid "Rename a space"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:115
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:118
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:118
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:121
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:121
#: ../doc/2.2/reference/reference_lua/net_box.rst:137
msgid "Select one or more tuples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:124
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:124
msgid "Delete all tuples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:127
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:130
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:133
msgid ":ref:`space_object:user_defined() <box_space-user_defined>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:136
msgid ":ref:`space_object:create_check_constraint() <box_space-create_check_constraint>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:136
msgid "Create a check constraint"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:139
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:139
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:142
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:142
msgid "Required number of fields"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:145
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:145
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:148
msgid ":ref:`space_object.index <box_space-space_index>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:148
msgid "Container of space's indexes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:151
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:151
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:154
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:154
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:157
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:157
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:160
msgid ":ref:`box.space._vindex <box_space-vindex>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:160
msgid "(Metadata) List of indexes accessible for the current user"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:163
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:163
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:166
msgid ":ref:`box.space._vpriv <box_space-vpriv>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:166
msgid "(Metadata) List of privileges accessible for the current user"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:169
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:169
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:172
msgid ":ref:`box.space._sequence <box_space-sequence>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:172
#: ../doc/2.2/book/box/box_space.rst:175
msgid "(Metadata) List of sequences"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:175
msgid ":ref:`box.space._sequence_data <box_space-sequence_data>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:178
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:178
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:181
msgid ":ref:`box.space._vspace <box_space-vspace>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:181
msgid "(Metadata) List of spaces accessible for the current user"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:184
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:184
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:187
msgid ":ref:`box.space._ck_constraint <box_space-ck_constraint>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:187
msgid "(Metadata) List of check constraints"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:190
msgid ":ref:`box.space._vuser <box_space-vuser>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:190
msgid "(Metadata) List of users accessible for the current user"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:193
msgid ":ref:`box.space._collation <box_space-collation>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:193
msgid "(Metadata) List of collations"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:196
msgid ":ref:`box.space._vcollation <box_space-vcollation>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:196
msgid "(Metadata) List of collations accessible for the current user"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:209
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have an :ref:`'unsigned' or 'integer' or 'number' <index-box_indexed-field-types>` primary key index of type ``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:215
msgid "Since version 1.7.5 this method is deprecated – it is better to use a :ref:`sequence <index-box_sequence>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:218
#: ../doc/2.2/book/box/box_space.rst:251
#: ../doc/2.2/book/box/box_space.rst:278
#: ../doc/2.2/book/box/box_space.rst:305
#: ../doc/2.2/book/box/box_space.rst:740
#: ../doc/2.2/book/box/box_space.rst:780
#: ../doc/2.2/book/box/box_space.rst:802
#: ../doc/2.2/book/box/box_space.rst:954
#: ../doc/2.2/book/box/box_space.rst:997
#: ../doc/2.2/book/box/box_space.rst:1048
#: ../doc/2.2/book/box/box_space.rst:1080
#: ../doc/2.2/book/box/box_space.rst:1274
#: ../doc/2.2/book/box/box_space.rst:1336
#: ../doc/2.2/book/box/box_space.rst:1366
#: ../doc/2.2/book/box/box_space.rst:1422
#: ../doc/2.2/book/box/box_space.rst:1524
#: ../doc/2.2/book/box/box_space.rst:1585
#: ../doc/2.2/book/box/box_space.rst:1706
#: ../doc/2.2/book/box/box_space.rst:1789
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:220
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:223
#: ../doc/2.2/book/box/box_space.rst:1370
msgid "the inserted tuple."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:226
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, :ref:`WAL settings <cfg_binary_logging_snapshots-rows_per_wal>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:231
msgid "index has wrong type;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:232
msgid "primary-key indexed field is not a number."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:236
msgid "tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:254
msgid "Number of bytes in the space. This number, which is stored in Tarantool's internal memory, represents the total number of bytes in all tuples, not including index keys. For a measure of index size, see :ref:`index_object:bsize() <box_index-bsize>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:262
msgid "tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:273
msgid "Return the number of tuples. If compared with :ref:`len() <box_space-len>`, this method works slower because ``count()`` scans the entire space to count the tuples."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:280
#: ../doc/2.2/book/box/box_space.rst:742
#: ../doc/2.2/book/box/box_space.rst:1587
msgid "primary-key field values, must be passed as a Lua table if key is multi-part"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:284
msgid "Number of tuples."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:288
msgid "tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:299
msgid "Create an :ref:`index <index-box_index>`. It is mandatory to create an index for a space before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:307
msgid "name of index, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:309
msgid "see \"Options for space_object:create_index()\", below"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:312
msgid "index object"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:313
msgid "index_object"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:317
msgid "**Options for space_object:create_index()**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:331
msgid "type"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:331
msgid "type of index"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:331
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE') Note re storage engine: vinyl only supports 'TREE'"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:331
msgid "'TREE'"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:337
msgid "unique identifier"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:337
msgid "last index's id, +1"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:339
msgid "unique"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:339
msgid "index is unique"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:339
msgid "``true``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:341
msgid "no error if duplicate name"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:341
msgid "``false``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:343
msgid "parts"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:343
msgid "field-numbers  + types"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:343
msgid "{field_no, ``'unsigned'`` or ``'string'`` or ``'integer'`` or ``'number'`` or ``'boolean'`` or ``'varbinary'`` or ``'array'`` or ``'scalar'``, and optional collation or is_nullable value or path}"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:343
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:351
msgid "dimension"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:351
msgid "affects :ref:`RTREE <box_index-rtree>` only"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:351
#: ../doc/2.2/book/box/box_space.rst:2327
msgid "2"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:353
msgid "distance"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:353
msgid "affects RTREE only"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:353
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:353
msgid "'euclid'"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:356
msgid "bloom_fpr"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:356
#: ../doc/2.2/book/box/box_space.rst:358
#: ../doc/2.2/book/box/box_space.rst:360
#: ../doc/2.2/book/box/box_space.rst:362
#: ../doc/2.2/book/box/box_space.rst:364
msgid "affects vinyl only"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:356
msgid "``vinyl_bloom_fpr``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:358
msgid "page_size"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:358
msgid "``vinyl_page_size``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:360
msgid "range_size"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:360
msgid "``vinyl_range_size``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:362
msgid "run_count_per_level"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:362
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:364
msgid "run_size_ratio"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:364
msgid "``vinyl_run_size_ratio``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:366
msgid "sequence"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:366
msgid "see section regarding :ref:`specifying a sequence in create_index() <box_schema-sequence_create_index>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:366
msgid "string or number"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:366
#: ../doc/2.2/book/box/box_space.rst:370
msgid "not present"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:370
msgid "func"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:370
msgid ":ref:`functional index <box_space-index_func>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:373
msgid "The options in the above chart are also applicable for :ref:`index_object:alter() <box_index-alter>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:376
msgid "**Note re storage engine:** vinyl has extra options which by default are based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`, and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- see the description of those parameters. The current values can be seen by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:387
msgid "Building or rebuilding a large index will cause occasional :ref:`yields <atomic-cooperative_multitasking>` so that other requests will not be blocked. If the other requests cause an illegal situation such as a duplicate key in a unique index, the index building or rebuilding will fail."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:395
msgid "too many parts;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:396
msgid "index '...' already exists;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:397
msgid "primary key must be unique."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:399
msgid "tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:410
msgid "**Details about index field types:**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:412
msgid "The eight index field types (unsigned | string | integer | number | boolean | varbinary | array | scalar) differ depending on what values are allowed, and what index types are allowed."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:416
msgid "**unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:420
msgid "**string**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes. A string may have a :ref:`collation <index-collation>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:424
msgid "**integer**: integers between -9223372036854775808 and 18446744073709551615. May also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:427
msgid "**number**: integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, or double-precision floating point numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:431
msgid "**boolean**: true or false. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:433
msgid "**varbinary**: any set of octets, up to the :ref:`maximum length <limitations_bytes_in_index_key>`. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes. A varbinary byte sequence does not have a :ref:`collation <index-collation>` because its contents are not UTF-8 characters."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:438
msgid "**array**: array of numbers. Legal in memtx :ref:`RTREE <box_index-rtree>` indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:439
msgid "**scalar**: null (input with ``msgpack.NULL`` or ``yaml.NULL`` or ``json.NULL``), booleans (true or false), or integers between -9223372036854775808 and 18446744073709551615, or single-precision floating point numbers, or double-precison floating-point numbers, or strings. When there is a mix of types, the key order is: null, then booleans, then numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:447
msgid "Additionally, `nil` is allowed with any index field type if :ref:`is_nullable=true <box_space-is_nullable>` is specified."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:452
msgid "**Index field types to use in space_object:create_index()**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:465
msgid "Index field type"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:465
msgid "What can be in it"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:465
msgid "Where is it legal"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:465
#: ../doc/2.2/book/box/data_model.rst:313
#: ../doc/2.2/book/box/data_model.rst:533
#: ../doc/2.2/reference/reference_lua/socket.rst:656
msgid "Examples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:467
msgid "**unsigned**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:467
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:467
#: ../doc/2.2/book/box/box_space.rst:477
#: ../doc/2.2/book/box/box_space.rst:481
#: ../doc/2.2/book/box/box_space.rst:489
#: ../doc/2.2/book/box/box_space.rst:496
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:467
msgid "123456 |br|"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:471
msgid "**string**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:471
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:471
#: ../doc/2.2/book/box/box_space.rst:474
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:471
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:474
#: ../doc/2.2/book/box/data_model.rst:340
msgid "**varbinary**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:474
msgid "byte sequences -- any set of octets"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:474
msgid "'\\\\65 \\\\66 \\\\67' |br|"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:477
msgid "**integer**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:477
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:477
msgid "-2^63 |br|"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:481
#: ../doc/2.2/book/box/data_model.rst:326
msgid "**number**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:481
msgid "integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:481
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:489
#: ../doc/2.2/book/box/data_model.rst:344
msgid "**boolean**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:489
#: ../doc/2.2/reference/reference_lua/string.rst:209
#: ../doc/2.2/reference/reference_lua/string.rst:239
#: ../doc/2.2/reference/reference_lua/utf8.rst:182
#: ../doc/2.2/reference/reference_lua/utf8.rst:207
#: ../doc/2.2/reference/reference_lua/utf8.rst:229
#: ../doc/2.2/reference/reference_lua/utf8.rst:251
msgid "true or false"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:489
msgid "false |br| true"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:492
#: ../doc/2.2/book/box/data_model.rst:347
msgid "**array**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:492
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:492
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:492
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:496
#: ../doc/2.2/book/box/data_model.rst:352
msgid "**scalar**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:496
msgid "null, booleans (true or false), integers between -9223372036854775808 and 18446744073709551615, single-precision floating point numbers, double-precision floating point numbers, strings"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:496
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:509
msgid "**Allowing null for an indexed key:** If the index type is TREE, and the index is not the primary index, then the ``parts={...}`` clause may include ``is_nullable=true`` or ``is_nullable=false`` (the default). If ``is_nullable`` is true, then it is legal to insert ``nil`` or an equivalent such as ``msgpack.NULL`` (or it is legal to insert nothing at all for trailing nullable fields). Within indexes, such \"null values\" are always treated as equal to other null values, and are always treated as less than non-null values. Nulls may appear multiple times even in a unique index. Example:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:518
msgid "box.space.tester:create_index('I',{unique=true,parts={{2,'number',is_nullable=true}}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:524
msgid "It is legal to create multiple indexes for the same field with different ``is_nullable`` values, or to call :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value from what is used for an index. When there is a contradiction, the rule is: null is illegal unless ``is_nullable=true`` for every index and for the space format."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:532
msgid "**Using field names instead of field numbers:** ``create_index()`` can use field names and/or field types described by the optional :ref:`space_object:format() <box_space-format>` clause. In the following example, we show ``format()`` for a space that has two columns named 'x' and 'y', and then we show five variations of the ``parts={}`` clause of ``create_index()``, first for the 'x' column, second for both the 'x' and 'y' columns. The variations include omitting the type, using numbers, and adding extra braces."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:541
msgid "box.space.tester:format({{name='x', type='scalar'}, {name='y', type='integer'}})\n"
"box.space.tester:create_index('I2',{parts={{'x','scalar'}}})\n"
"box.space.tester:create_index('I3',{parts={{'x','scalar'},{'y','integer'}}})\n"
"box.space.tester:create_index('I4',{parts={1,'scalar'}})\n"
"box.space.tester:create_index('I5',{parts={1,'scalar',2,'integer'}})\n"
"box.space.tester:create_index('I6',{parts={1}})\n"
"box.space.tester:create_index('I7',{parts={1,2}})\n"
"box.space.tester:create_index('I8',{parts={'x'}})\n"
"box.space.tester:create_index('I9',{parts={'x','y'}})\n"
"box.space.tester:create_index('I10',{parts={{'x'}}})\n"
"box.space.tester:create_index('I11',{parts={{'x'},{'y'}}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:557
msgid "**Using the path option for map fields:** To create an index for a field that is a map (a path string and a scalar value), specify the path string during index_create, that is, :code:`parts={` :samp:`{field-number},'{data-type}',path = '{path-name}'` :code:`}`. The index type must be ``'tree'`` or ``'hash'`` and the field's contents must always be maps with the same path."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:563
msgid "-- Example 1 -- The simplest use of path:\n"
"-- Result will be - - [{'age': 44}]\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('I',{parts={{1, 'scalar', path='age'}}})\n"
"box.space.T:insert{{age=44}}\n"
"box.space.T:select(44)\n"
"-- Example 2 -- path plus format() plus JSON syntax to add clarity\n"
"-- Result will be: - [1, {'FIO': {'surname': 'Xi', 'firstname': 'Ahmed'}}]\n"
"s = box.schema.space.create('T')\n"
"format = {{'id', 'unsigned'}, {'data', 'map'}}\n"
"s:format(format)\n"
"parts = {{'data.FIO[\"firstname\"]', 'str'}, {'data.FIO[\"surname\"]', 'str'}}\n"
"i = s:create_index('info', {parts = parts})\n"
"s:insert({1, {FIO={firstname='Ahmed', surname='Xi'}}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:580
msgid "**Note re storage engine:** vinyl supports only the TREE index type, and vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:585
msgid "**Using the path option with [*]**  The string in a path option can contain '[*]' which is called an array index placeholder. Indexes defined with this are useful for JSON documents that all have the same structure. For example, when creating an index on field#2 for a string document that will start with ``{'data': [{'name': '...'}, {'name': '...'}]``, the parts section in the create_index request could look like: ``parts = {{2, 'str', path = 'data[*].name'}}``. Then tuples containing names can be retrieved quickly with ``index_object:select({key-value})``. In fact a single field can have multiple keys, as in this example which retrieves the same tuple twice because there are two keys 'A' and 'B' which both match the request:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:595
msgid "s = box.schema.space.create('json_documents')\n"
"s:create_index('primarykey')\n"
"i = s:create_index('multikey', {parts = {{2, 'str', path = 'data[*].name'}}})\n"
"s:insert({1,\n"
"         {data = {{name='A'},\n"
"                  {name='B'}},\n"
"          extra_field = 1}})\n"
"i:select({''},{iterator='GE'})\n"
"--  The result of the select request looks like this:\n"
"--  tarantool> i:select({''},{iterator='GE'})\n"
"--  ---\n"
"--  - - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--    - [1, {'data': [{'name': 'A'}, {'name': 'B'}], 'extra_field': 1}]\n"
"--  ..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:612
msgid "Some restrictions exist: () '[*]' must be alone or must be at the end of a name in the path; () '[*]' must not appear twice in the path; () if an index has a path with x[*] then no other index can have a path with x.component; () '[*]' must not appear in the path of a primary-key ; () if an index has ``unique=true`` and has a path with '[*]' then duplicate keys from different tuples are disallowed but duplicate keys for the same tuple are allowed; () As with :ref:`Using the path option for map fields <box_space-path>`, the field's value must have the structure that the path definition implies, or be nil (nil is not indexed)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:624
msgid "**Making a functional index with space_object:create_index()**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:626
msgid "Functional indexes are indexes that call a user-defined function for forming the index key, rather than depending entirely on the Tarantool default formation. Functional indexes are useful for condensing or truncating or reversing or any other way that users want to customize the index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:631
msgid "The function definition must expect a tuple (which has the contents of fields at the time a data-change request happens) and must return a tuple (which has the contents that will actually be put in the index)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:635
msgid "The space must have a memtx engine. |br| The function must be :ref:`persistent <box_schema-func_create_with-body>` and deterministic. |br| The key parts must not depend on JSON paths. |br| The ``create_index`` definition must include specification of all key parts, and the function must return a table which has the same number of key parts with the same types. |br| The function must access key-part values by index, not by field name. |br| Functional indexes must not be primary-key indexes. |br| Functional indexes cannot be altered and the function cannot be changed if it is used for an index, so the only way to change them is to drop the index and create it again."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:649
msgid "A function could make a key using only the first letter of a string field."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:651
msgid "-- Step 1: Make the space.\n"
"-- The space needs a primary-key field, which is not the field that we\n"
"-- will use for the functional index.\n"
"box.schema.space.create('x', {engine = 'memtx'})\n"
"box.space.x:create_index('i',{parts={1, 'string'}})\n"
"-- Step 2: Make the function.\n"
"-- The function expects a tuple. In this example it will work on tuple[2]\n"
"-- because the key souce is field number 2 in what we will insert.\n"
"-- Use string.sub() from the string module to get the first character.\n"
"lua_code = [[function(tuple) return {string.sub(tuple[2],1,1)} end]]\n"
"-- Step 3: Make the function persistent.\n"
"-- Use the box.schema.func.create function for this.\n"
"box.schema.func.create('F',\n"
"    {body = lua_code, is_deterministic = true, is_sandboxed = true})\n"
"-- Step 4: Make the functional index.\n"
"-- Specify the fields whose values will be passed to the function.\n"
"-- Specify the function.\n"
"box.space.x:create_index('j',{parts={1, 'string'},func = 'F'})\n"
"-- Step 5: Test.\n"
"-- Insert a few tuples.\n"
"-- Select using only the first letter, it will work because that is the key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"-- Select using only the first letter, it will work because that is the key\n"
"-- Or, select using the same function as was used for insertion\n"
"box.space.x:insert{'a', 'wombat'}\n"
"box.space.x:insert{'b', 'rabbit'}\n"
"box.space.x.index.j:select('w')\n"
"box.space.x.index.j:select(box.func.F:call({{'x', 'wombat'}}));"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:684
msgid "The results of the two ``select`` requests will look like this:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:686
msgid "tarantool>     box.space.x.index.j:select('w')\n"
"---\n"
"- - ['a', 'wombat']\n"
"...\n"
"\n"
"tarantool>     box.space.x.index.j:select(box.func.F:call({{'x','wombat'}}));\n"
"---\n"
"- - ['a', 'wombat']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:698
msgid "Functions for functional indexes can return multiple keys. |br| Such functions are called \"multikey\" functions. |br| The ``box.func.create`` options must include ``opts = {is_multikey = true}``. |br| The return value must be a table of tuples. |br| If a multikey function returns N tuples, then N keys will be added to the index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:706
msgid "s = box.schema.space.create('withdata')\n"
"s:format({{name = 'name', type = 'string'},\n"
"          {name = 'address', type = 'string'}})\n"
"pk = s:create_index('name', {parts = {1, 'string'}})\n"
"lua_code = [[function(tuple)\n"
"               local address = string.split(tuple[2])\n"
"               local ret = {}\n"
"               for _, v in pairs(address) do\n"
"                 table.insert(ret, {utf8.upper(v)})\n"
"               end\n"
"               return ret\n"
"             end]]\n"
"box.schema.func.create('address',\n"
"                        {body = lua_code,\n"
"                         is_deterministic = true,\n"
"                         is_sandboxed = true,\n"
"                         opts = {is_multikey = true}})\n"
"idx = s:create_index('addr', {unique = false,\n"
"                              func = 'address',\n"
"                              parts = {{1, 'string',\n"
"                                      collation = 'unicode_ci'}}})\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})\n"
"idx:select('Uk')\n"
"-- Both tuples will be returned."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:738
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:745
msgid "the deleted tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:748
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:750
msgid "**Note re storage engine:** vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:755
msgid "tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:770
#: ../doc/2.2/book/box/box_space.rst:1067
#: ../doc/2.2/book/box/box_space.rst:1386
#: ../doc/2.2/book/box/box_space.rst:1514
#: ../doc/2.2/book/box/box_space.rst:1686
#: ../doc/2.2/book/box/box_space.rst:1734
msgid "For more usage scenarios and typical errors see :ref:`Example: using data operations <box_space-operations-detailed-examples>` further in this section."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:778
msgid "Drop a space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:785
#: ../doc/2.2/book/box/box_space.rst:1005
#: ../doc/2.2/book/box/box_space.rst:1342
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:787
#: ../doc/2.2/book/box/box_space.rst:1007
#: ../doc/2.2/book/box/box_space.rst:1377
msgid "**Complexity factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:792
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:800
msgid "Declare field names and :ref:`types <index-box_data-types>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:804
msgid "a list of field names and types"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:806
msgid "nil, unless format-clause is omitted"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:810
msgid "``space_object`` does not exist;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:811
msgid "field names are duplicated;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:812
msgid "type is not legal."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:814
msgid "Ordinarily Tarantool allows unnamed untyped fields. But with ``format`` users can, for example, document that the Nth field is the surname field and must contain strings. It is also possible to specify a format clause in :ref:`box.schema.space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:820
msgid "The format clause contains, for each field, a definition within braces: ``{name='...',type='...'[,is_nullable=...]}``, where:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:823
msgid "the ``name`` value may be any string, provided that two fields do not have the same name;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:825
msgid "the ``type`` value may be any of those allowed for :ref:`indexed fields <index-box_indexed-field-types>`: unsigned | string | varbinary | integer | number | boolean | array | scalar (the same as the requirement in :ref:`\"Options for space_object:create_index\" <box_space-create_index-options>`);"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:830
msgid "the optional ``is_nullable`` value may be either ``true`` or ``false`` (the same as the requirement in :ref:`\"Options for space_object:create_index\" <box_space-create_index-options>`). See also the warning notice in section :ref:`Allowing null for an indexed key <box_space-is_nullable>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:836
msgid "It is not legal for tuples to contain values that have the wrong type; for example after ``box.space.tester:format({{' ',type='number'}})`` the request ``box.space.tester:insert{'string-which-is-not-a-number'}`` will cause an error."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:840
msgid "It is not legal for tuples to contain null values if ``is_nullable=false``, which is the default; for example after ``box.space.tester:format({{' ',type='number',is_nullable=false}})`` the request ``box.space.tester:insert{nil,2}`` will cause an error."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:844
msgid "It is legal for tuples to have more fields than are described by a format clause. The way to constrain the number of fields is to specify a space's :ref:`field_count <box_space-field_count>` member."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:848
msgid "It is legal for tuples to have fewer fields than are described by a format clause, if the omitted trailing fields are described with ``is_nullable=true``; for example after ``box.space.tester:format({{'a',type='number'},{'b',type='number',is_nullable=true}})`` the request ``box.space.tester:insert{2}`` will not cause a format-related error."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:853
msgid "It is legal to use ``format`` on a space that already has a format, thus replacing any previous definitions, provided that there is no conflict with existing data or index definitions."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:857
msgid "It is legal to use ``format`` to change the ``is_nullable`` flag; for example after ``box.space.tester:format({{' ',type='scalar',is_nullable=false}})`` the request ``box.space.tester:format({{' ',type='scalar',is_nullable=true}})`` will not cause an error -- and will not cause rebuilding of the space. But going the other way and changing ``is_nullable`` from ``true`` to ``false`` might cause rebuilding and might cause an error if there are existing tuples with nulls."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:867
msgid "box.space.tester:format({{name='surname',type='string'},{name='IDX',type='array'}})\n"
"box.space.tester:format({{name='surname',type='string',is_nullable=true}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:873
msgid "There are legal variations of the format clause:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:875
msgid "omitting both 'name=' and 'type=',"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:876
msgid "omitting 'type=' alone, and"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:877
msgid "adding extra braces."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:879
msgid "The following examples show all the variations, first for one field named 'x', second for two fields named 'x' and 'y'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:882
msgid "box.space.tester:format({{'x'}})\n"
"box.space.tester:format({{'x'},{'y'}})\n"
"box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:format({{name='x',type='scalar'},{name='y',type='unsigned'}})\n"
"box.space.tester:format({{name='x'}})\n"
"box.space.tester:format({{name='x'},{name='y'}})\n"
"box.space.tester:format({{'x',type='scalar'}})\n"
"box.space.tester:format({{'x',type='scalar'},{'y',type='unsigned'}})\n"
"box.space.tester:format({{'x','scalar'}})\n"
"box.space.tester:format({{'x','scalar'},{'y','unsigned'}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:895
msgid "The following example shows how to create a space, format it with all possible types, and insert into it."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:898
msgid "tarantool> box.schema.space.create('t')\n"
"--- ...\n"
"tarantool> box.space.t:format({{name='1',type='any'},\n"
"         >                     {name='2',type='unsigned'},\n"
"         >                     {name='3',type='string'},\n"
"         >                     {name='4',type='number'},\n"
"         >                     {name='5',type='integer'},\n"
"         >                     {name='6',type='boolean'},\n"
"         >                     {name='7',type='scalar'},\n"
"         >                     {name='8',type='array'},\n"
"         >                     {name='9',type='map'}})\n"
"--- ...\n"
"tarantool> box.space.t:create_index('i',{parts={2,'unsigned'}})\n"
"--- ...\n"
"tarantool> box.space.t:insert{{'a'},      -- any\n"
"         >                    1,          -- unsigned\n"
"         >                    'W?',       -- string\n"
"         >                    5.5,        -- number\n"
"         >                    -0,         -- integer\n"
"         >                    true,       -- boolean\n"
"         >                    true,       -- scalar\n"
"         >                    {{'a'}},    -- array\n"
"         >                    {val=1}}    -- map\n"
"---\n"
"- [['a'], 1, 'W?', 5.5, 0, true, true, [['a']], {'val': 1}]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:927
msgid "Names specified with the format clause can be used in :ref:`space_object:get() <box_space-get>` and in :ref:`space_object:create_index() <box_space-create_index>` and in :ref:`tuple_object[field-name] <box_tuple-field_name>` and in :ref:`tuple_object[field-path] <box_tuple-field_path>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:933
msgid "If the format clause is omitted, then the returned value is the table that was used in a previous :samp:`{space_object}:format({format-clause})` invocation. For example, after ``box.space.tester:format({{'x','scalar'}})``, ``box.space.tester:format()`` will return ``[{'name': 'x', 'type': 'scalar'}]``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:938
msgid "Formatting or reformatting a large space will cause occasional :ref:`yields <atomic-cooperative_multitasking>` so that other requests will not be blocked. If the other requests cause an illegal situation such as a field value of the wrong type, the formatting or reformatting will fail."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:948
msgid "Convert a map to a tuple instance or to a table. The map must consist of \"field name = value\" pairs. The field names and the value types must match names and types stated previously for the space, via :ref:`space_object:format() <box_space-format>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:956
msgid "a series of \"field = value\" pairs, in any order."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:957
msgid "the only legal option is ``{table = true|false}``; |br| if the option is omitted or if ``{table = false}``, then return type will be 'cdata' (i.e. tuple); |br| if ``{table = true}``, then return type will be 'table'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:962
msgid "a tuple instance or table."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:963
msgid "tuple or table"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:965
msgid "**Possible errors:** ``space_object`` does not exist or has no format; \"unknown field\"."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:969
msgid "-- Create a format with two fields named 'a' and 'b'.\n"
"-- Create a space with that format.\n"
"-- Create a tuple based on a map consistent with that space.\n"
"-- Create a table based on a map consistent with that space.\n"
"tarantool> format1 = {{name='a',type='unsigned'},{name='b',type='scalar'}}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.create_space('test', {format = format1})\n"
"---\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456})\n"
"---\n"
"- [123456, 'x']\n"
"...\n"
"tarantool> s:frommap({b = 'x', a = 123456}, {table = true})\n"
"---\n"
"- - 123456\n"
"  - x\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:995
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:999
#: ../doc/2.2/book/box/box_space.rst:1424
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1002
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1010
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns at most a single tuple. And it is possible to get the first tuple in a space by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1018
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1022
msgid "**Using field names instead of field numbers:** `get()` can use field names described by the optional :ref:`space_object:format() <box_space-format>` clause. This is similar to a standard Lua feature, where a component can be referenced by its name instead of its number. For example, we can format the `tester` space with a field named `x` and use the name `x` in the index definition:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1029
msgid "box.space.tester:format({{name='x',type='scalar'}})\n"
"box.space.tester:create_index('I',{parts={'x'}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1034
msgid "Then, if ``get`` or ``select`` retrieve a single tuple, we can reference the field 'x' in the tuple by its name:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1037
msgid "box.space.tester:get{1}['x']\n"
"box.space.tester:select{1}[1]['x']"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1046
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1050
msgid "tuple to be inserted."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1052
msgid "the inserted tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1055
msgid "**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a tuple with the same unique-key value already exists."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1060
msgid "tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1075
msgid "Return the number of tuples in the space. If compared with :ref:`count() <box_space-count>`, this method works faster because ``len()`` does not scan the entire space to count the tuples."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1083
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1087
msgid "tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1094
msgid "**Note re storage engine:** vinyl supports ``len()`` but the result may be approximate. If an exact result is necessary then use :ref:`count() <box_space-count>` or :ref:`pairs():length() <box_space-pairs>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1102
#: ../doc/2.2/book/box/box_space.rst:1179
msgid "Create a \"replace :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1119
#: ../doc/2.2/book/box/box_space.rst:1199
msgid "If it is necessary to know whether the trigger activation happened due to replication or on a specific connection type, the function can refer to :ref:`box.session.type() <box_session-type>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1125
msgid "See also :ref:`space_object:before_replace() <box_space-before_replace>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1127
#: ../doc/2.2/book/box/box_space.rst:2191
#: ../doc/2.2/reference/reference_lua/key_def.rst:94
msgid "**Example #1:**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1129
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1136
msgid "The ``trigger-function`` can have up to four parameters: (tuple) old value which has the contents before the request started, (tuple) new value which has the contents after the request ended, (string) space name, (string) type of request which is 'INSERT' or 'DELETE' or 'UPDATE' or 'REPLACE'. For example, the following code causes nil and 'INSERT' to be printed when the insert request is processed, and causes [1, 'Hi'] and 'DELETE' to be printed when the delete request is processed:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1145
msgid "box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new, s, op) print(old) print(op) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1154
#: ../doc/2.2/book/box/box_space.rst:2236
msgid "**Example #2:**"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1156
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1161
msgid "tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1184
msgid "function which will become the trigger function; for the trigger function's optional parameters see the description of ``on_replace``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1189
msgid "existing trigger function which will be replaced by ``trigger-function``"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1194
#: ../doc/2.2/book/box/box_txn_management.rst:241
msgid "If the parameters are ``(nil, old-trigger-function)``, then the old trigger is deleted."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1206
msgid "See also :ref:`space_object:on_replace() <box_space-on_replace>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1208
msgid "Administrators can make replace triggers with ``on_replace()``, or make triggers with ``before_replace()``. If they make both types, then all ``before_replace`` triggers are executed before all ``on_replace`` triggers. The functions for both ``on_replace`` and ``before_replace`` triggers can make changes to the database, but only the functions for ``before_replace`` triggers can change the tuple that is being replaced."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1217
msgid "Since a ``before_replace`` trigger function has the extra capability of making a change to the old tuple, it also can have extra overhead, to fetch the old tuple before making the change. Therefore an ``on_replace`` trigger is better if there is no need to change the old tuple. However, this only applies for the memtx engine -- for the vinyl engine, the fetch will happen for either kind of trigger. (With memtx the tuple data is stored along with the index key so no extra search is necessary; with vinyl that is not the case so the extra search is necessary.)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1229
msgid "Where the extra capability is not needed, ``on_replace`` should be used instead of ``before_replace``. Usually ``before_replace`` is used only for certain replication scenarios -- it is useful for conflict resolution."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1234
msgid "The value that a ``before_replace`` trigger function can return affects what will happen after the return. Specifically:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1237
msgid "if there is no return value, then execution proceeds, inserting|replacing the new value;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1239
msgid "if the value is nil, then the tuple will be deleted;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1240
msgid "if the value is the same as the old parameter, then no `on_replace`` function will be called and the data change will be skipped"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1243
msgid "if the value is the same as the new parameter, then it's as if the ``before_replace`` function wasn't called;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1245
msgid "if the value is something else, then execution proceeds, inserting|replacing the new value."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1248
msgid "However, if a trigger function returns an old tuple, or if a trigger function calls :ref:`run_triggers(false) <box_space-run_triggers>`, that will not affect other triggers that are activated for the same insert|update|replace request."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1255
msgid "The following are ``before_replace`` functions that have no return value, or that return nil, or the same as the old parameter, or the same as the new parameter, or something else."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1259
msgid "function f1 (old, new) return end\n"
"function f2 (old, new) return nil end\n"
"function f3 (old, new) return old end\n"
"function f4 (old, new) return new end\n"
"function f5 (old, new) return box.tuple.new({new[1],'b'}) end"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1271
msgid "Search for a tuple or a set of tuples in the given space, and allow iterating over one tuple at a time."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1278
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1287
#: ../doc/2.2/book/box/box_space.rst:1446
msgid "no such space;"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1288
#: ../doc/2.2/book/box/box_space.rst:1447
msgid "wrong type."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1292
msgid "For examples of complex ``pairs`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\"), see the later section :ref:`index_object:pairs <box_index-index_pairs>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1303
msgid "tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1334
msgid "Rename a space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1338
msgid "new name for space"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1346
msgid "tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1360
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1368
msgid "tuple to be inserted"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1373
msgid "**Possible errors:** :errcode:`ER_TUPLE_FOUND` if a different tuple with the same unique-key value already exists. (This will only happen if there is a unique secondary index.)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1382
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1394
msgid "At the time that a :ref:`trigger <triggers>` is defined, it is automatically enabled - that is, it will be executed. :ref:`Replace <box_space-on_replace>` triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1403
msgid "The following series of requests will associate an existing function named `F` with an existing space named `T`, associate the function a second time with the same space (so it will be called twice), disable all triggers of `T`, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1408
msgid "tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1420
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1426
msgid "none, any or all of the same options that :ref:`index_object:select <box_index-select>` allows:  * ``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`) * ``options.limit`` (maximum number of tuples) * ``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1426
msgid "none, any or all of the same options that :ref:`index_object:select <box_index-select>` allows:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1430
msgid "``options.iterator`` (:ref:`type of iterator <box_index-iterator-types>`)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1431
msgid "``options.limit`` (maximum number of tuples)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1432
msgid "``options.offset`` (number of tuples to skip)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1434
msgid "the tuples whose primary-key fields are equal to the fields of the passed key. If the number of passed fields is less than the number of fields in the primary key, then only the passed fields are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1441
msgid "A ``select`` request can also be done with a specific index and index options, which are the subject of :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1453
msgid "tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"...\n"
"tarantool> -- the first field must be greater than 0, and\n"
"tarantool> -- skip the first tuple, and return up to\n"
"tarantool> -- 2 tuples. This example's options all\n"
"tarantool> -- depend on index characteristics so see\n"
"tarantool> -- more explanation in index_object:select().\n"
"tarantool> s:select({0},{iterator='GT',offset=1,limit=2})\n"
"---\n"
"- - [1, 'B']\n"
"  - [1, 'C']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1508
msgid "As the last request in the above example shows: to make complex ``select`` requests, where you can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, it will be necessary to become familiar with :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1522
msgid "Deletes all tuples."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1531
msgid "The ``truncate`` method can only be called by the user who created the space, or from within a ``setuid`` function created by the user who created the space. Read more about `setuid` functions in the reference for :ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1537
msgid "The ``truncate`` method cannot be called from within a transaction."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1541
msgid "tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1557
msgid "The ``update`` function supports operations on fields — assignment, arithmetic (if the field is numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1569
msgid "Possible operators are:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1571
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1572
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1573
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1574
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1575
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1577
msgid "``:`` for string splice"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1578
msgid "``!`` for insertion"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1579
msgid "``#`` for deletion"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1580
msgid "``=`` for assignment"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1582
msgid "For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last field in the tuple."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1599
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1601
#: ../doc/2.2/book/box/box_space.rst:1725
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1604
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1606
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1610
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1618
msgid "Assume that initially there is a space named ``tester`` with a primary-key index whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1622
msgid "In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation — *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1633
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1640
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1647
msgid "In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1655
msgid "In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1664
msgid "In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]`` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1672
msgid "In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1677
msgid "In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |br| The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1694
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1696
msgid "If there is an existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:update() <box_space-update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :ref:`space_object:insert() <box_space-insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1708
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1717
#: ../doc/2.2/reference/reference_lua/fio.rst:714
msgid "null"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1721
msgid "It is illegal to modify a primary-key field."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1722
msgid "It is illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1730
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1742
msgid "Users can define any functions they want, and associate them with spaces: in effect they can make their own space methods. They do this by:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1749
msgid "invoking the function any time thereafter, as long as the server is up, by saying ``space_object:function-name([parameters])``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1752
msgid "The predefined global variable is ``box.schema.space_mt``. Adding to ``box.schema.space_mt`` makes the method available for all spaces."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1755
msgid "Alternatively, user-defined methods can be made available for only one space, by calling ``getmetatable(space_object)`` and then adding the function name to the meta table. See also the example for :ref:`index_object:user_defined() <box_index-user_defined>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1766
msgid "-- Visible to any space, no parameters.\n"
"-- After these requests, the value of global_variable will be 6.\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('i')\n"
"global_variable = 5\n"
"function f(space_arg) global_variable = global_variable + 1 end\n"
"box.schema.space_mt.counter = f\n"
"box.space.t:counter()"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1782
msgid "Create a check constraint. A check constraint is a requirement that must be met when a tuple is inserted or updated in a space. Check constraints created with ``space_object:create_check_constraint`` have the same effect as check constraints created with an SQL CHECK() clause in a :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1791
msgid "name of check constraint, which should conform to the :ref:`rules for object names <app_server-names>`"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1793
msgid "SQL code of an expression which must return a boolean result"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1795
msgid "check constraint object"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1796
msgid "check_constraint_object"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1798
msgid "The space must be formatted with :ref:`space_object:format() <box_space-format>` so that the expression can contain field names. The space must be empty. The space must not be a system space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1802
msgid "The expression must return true or false and should be deterministic. The expresion may be any SQL (not Lua) expression containing field names, built-in function names, literals, and operators. Not subqueries. If a field name contains lower case characters, it must be enclosed in \"double quotes\"."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1807
msgid "Check constraints are checked before the request is performed, at the same time as Lua :ref:`before_replace triggers <box_space-before_replace>`. If there is more than one check constraint or before_replace trigger, then they are ordered according to time of creation. (This is a change from the earlier behavior of check constraints, which caused checking before the tuple was formed.)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1814
msgid "Check constraints can be dropped with :samp:`space_object:{check_constraint_name}:drop()`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1818
msgid "box.schema.space.create('t')\n"
"box.space.t:format({{name = 'f1', type = 'unsigned'},\n"
"                    {name = 'f2', type = 'string'},\n"
"                    {name = 'f3', type = 'string'}})\n"
"box.space.t:create_index('i')\n"
"box.space.t:create_check_constraint('c1', [[\"f2\" > 'A']])\n"
"box.space.t:create_check_constraint('c2',\n"
"                        [[\"f2\"=UPPER(\"f3\") AND NOT \"f2\" LIKE '__']])\n"
"-- This insert will fail, constraint c1 expression returns false\n"
"box.space.t:insert{1, 'A', 'A'}\n"
"-- This insert will fail, constraint c2 expression returns false\n"
"box.space.t:insert{1, 'B', 'c'}\n"
"-- This insert will succeed, both constraint expressions return true\n"
"box.space.t:insert{1, 'B', 'b'}\n"
"-- This update will fail, constraint c2 expression returns false\n"
"box.space.t:update(1, {{'=', 2, 'xx'}, {'=', 3, 'xx'}})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1837
msgid "A list of check constraints is in :ref:`space_object._ck_constraint <box_space-ck_constraint>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1843
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1850
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1856
msgid "box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1862
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1866
msgid "tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1877
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1884
msgid "tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1895
msgid "A container for all defined indexes. There is a Lua object of type :ref:`box.index <box_index>` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1899
msgid "To reset, use :ref:`box.stat.reset() <box_introspection-box_stat_reset>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1905
msgid "# checking the number of indexes for space 'tester'\n"
"tarantool> local counter=0; for i=0,#box.space.tester.index do\n"
"  if box.space.tester.index[i]~=nil then counter=counter+1 end\n"
"  end; print(counter)\n"
"1\n"
"---\n"
"...\n"
"# checking the type of index 'primary'\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1924
msgid "``_cluster`` is a system space for support of the :ref:`replication feature <replication>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1931
msgid "``_func`` is a system space with function tuples made by :ref:`box.schema.func.create() <box_schema-func_create>` or :ref:`box.schema.func.create(func-name [, {options-with-body}]) <box_schema-func_create_with-body>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1936
#: ../doc/2.2/book/box/box_space.rst:2002
#: ../doc/2.2/book/box/box_space.rst:2061
#: ../doc/2.2/book/box/box_space.rst:2180
#: ../doc/2.2/book/box/box_space.rst:2296
#: ../doc/2.2/book/box/box_space.rst:2435
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1938
msgid "id (integer identifier),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1939
msgid "owner (integer identifier),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1940
msgid "the function name,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1941
msgid "the setuid flag,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1942
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1943
msgid "the body"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1944
msgid "the is_deterministic flag"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1945
msgid "the is_sandboxed flag"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1946
msgid "options"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1948
msgid "If the function tuple was made in the older way without specification of ``body``, then the ``_func`` space will contain default values for the body and the is_deterministic flag and the is_sandboxed flag. Such function tuples are called \"not persistent\". You continue to create Lua functions in the usual way, by saying ``function function_name () ... end``, without adding anything in the ``_func`` space. The ``_func`` space only exists for storing function tuples so that their names can be used within :ref:`grant/revoke <authentication-owners_privileges>` functions."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1959
msgid "If the function tuple was made the newer way with specification of ``body``, then all the fields may contain non-default values. Such functions are called \"persistent\". They should be invoked with :samp:`box.func.{func-name}:call([parameters])`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1964
#: ../doc/2.2/book/box/box_space.rst:2071
msgid "You can:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1966
msgid "Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-func_create>`,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1968
msgid "Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-func_drop>`,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1970
msgid "Check whether a ``_func`` tuple exists with :ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1975
msgid "In the following example, we create a function named ‘f7’, put it into Tarantool's ``_func`` space and grant 'execute' privilege for this function to 'guest' user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:1979
msgid "tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2000
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2004
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2005
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2006
msgid "``name``,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2007
msgid "``type``,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2008
msgid "``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2010
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2012
msgid "tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, 'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, 'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2037
msgid "``_vindex`` is a system space that represents a virtual view. The structure of its tuples is identical to that of :ref:`_index <box_space-index>`, but permissions for certain tuples are limited in accordance with user privileges. ``_vindex`` contains only those tuples that are accessible to the current user. See :ref:`Access control <authentication>` for details about user privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2043
msgid "If the user has the full set of privileges (like 'admin'), the contents of ``_vindex`` match the contents of ``_index``. If the user has limited access, ``_vindex`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2049
msgid "``_vindex`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2051
msgid "While the ``_index`` space requires proper access privileges, any user can always read from ``_vindex``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2058
msgid "``_priv`` is a system space where :ref:`privileges <authentication-owners_privileges>` are stored."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2063
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2064
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2065
msgid "the type of object: 'space', 'function', 'sequence' or 'universe',"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2066
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2067
msgid "the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, \"create\" = 32, \"drop\" = 64, \"alter\" = 128, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2073
msgid "Grant a privilege with :ref:`box.schema.user.grant() <box_schema-user_grant>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2074
msgid "Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-user_revoke>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2078
msgid "Generally, privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2081
msgid "Before dropping any objects or users, make sure that all their associated privileges have been revoked."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2084
msgid "Only the :ref:`'admin' user <authentication-owners_privileges>` can grant privileges for the 'universe'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2087
msgid "Only the 'admin' user or the creator of a space can drop, alter, or truncate the space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2090
msgid "Only the 'admin' user or the creator of a user can change a different user’s password."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2097
msgid "``_vpriv`` is a system space that represents a virtual view. The structure of its tuples is identical to that of :ref:`_priv <box_space-priv>`, but permissions for certain tuples are limited in accordance with user privileges. ``_vpriv`` contains only those tuples that are accessible to the current user. See :ref:`Access control <authentication>` for details about user privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2103
msgid "If the user has the full set of privileges (like 'admin'), the contents of ``_vpriv`` match the contents of ``_priv``. If the user has limited access, ``_vpriv`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2109
msgid "``_vpriv`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2111
msgid "While the ``_priv`` space requires proper access privileges, any user can always read from ``_vpriv``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2118
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2120
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2122
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2123
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2124
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2125
msgid "``once...`` tuples that correspond to specific :ref:`box.once() <box-once>` blocks from the instance's :ref:`initialization file <index-init_label>`. The first field in these tuples contains the ``key`` value from the corresponding ``box.once()`` block prefixed with 'once' (e.g. `oncehello`), so you can easily find a tuple that corresponds to a specific ``box.once()`` block."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2135
msgid "Here is what ``_schema`` contains in a typical installation (notice the tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2138
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2152
msgid "``_sequence`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`. It contains persistent information that was established by :ref:`box.schema.sequence.create() <box_schema-sequence_create>` or :ref:`box.schema.sequence.alter() <box_schema-sequence_alter>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2162
msgid "``_sequence_data`` is a system space for support of the :ref:`sequence feature <index-box_sequence>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2165
msgid "Each tuple in ``_sequence_data`` contains two fields:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2167
msgid "the id of the sequence, and"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2168
msgid "the last value that the sequence generator returned (non-persistent information)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2171
msgid "There is no guarantee that this space will be updated immediately after every data-change request."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2178
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2182
msgid "``id``,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2183
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2184
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2185
msgid "``flags`` (e.g. temporary),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2186
msgid "``format`` (as made by a :ref:`format clause <box_space-format>`)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2188
msgid "These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2193
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2196
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2215
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2217
msgid "tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2238
msgid "The following requests will create a space using ``box.schema.space.create()`` with a :ref:`format clause <box_space-format>`, then retrieve the ``_space`` tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2244
msgid "tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': 'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2273
msgid "``_vspace`` is a system space that represents a virtual view. The structure of its tuples is identical to that of :ref:`_space <box_space-space>`, but permissions for certain tuples are limited in accordance with user privileges. ``_vspace`` contains only those tuples that are accessible to the current user. See :ref:`Access control <authentication>` for details about user privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2279
msgid "If the user has the full set of privileges (like 'admin'), the contents of ``_vspace`` match the contents of ``_space``. If the user has limited access, ``_vspace`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2285
msgid "``_vspace`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2287
msgid "While the ``_space`` space requires proper access privileges, any user can always read from ``_vspace``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2294
msgid "``_user`` is a system space where user-names and password hashes are stored."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2298
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2299
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2300
#: ../doc/2.2/book/box/box_space.rst:2438
msgid "the name,"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2301
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2302
msgid "optional password."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2304
msgid "There are five special tuples in the ``_user`` space: 'guest', 'admin', 'public', 'replication', and 'super'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2317
msgid "ID"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2319
msgid "guest"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2319
#: ../doc/2.2/book/box/data_model.rst:548
#: ../doc/2.2/reference/reference_sql/sql.rst:280
msgid "0"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2319
msgid "Default user when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2322
msgid "admin"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2322
#: ../doc/2.2/book/box/data_model.rst:535
#: ../doc/2.2/book/box/data_model.rst:539
#: ../doc/2.2/book/box/data_model.rst:551
msgid "1"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2322
msgid "Default user when using Tarantool as a console. Usually an :ref:`administrative user <authentication-owners_privileges>` with all privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2327
msgid "public"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2327
#: ../doc/2.2/book/box/box_space.rst:2335
#: ../doc/2.2/book/box/box_space.rst:2339
msgid "role"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2327
msgid "Pre-defined :ref:`role <authentication-roles>`, automatically granted to new users when they are created with ``box.schema.user.create(user-name)``. Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is with ``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2335
msgid "replication"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2335
msgid "3"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2335
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2339
msgid "super"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2339
msgid "31"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2339
msgid "Pre-defined :ref:`role <authentication-roles>`, which the 'admin' user can grant to users who need all privileges on all objects. The 'super' role has these privileges on 'universe': read, write, execute, create, drop, alter."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2347
msgid "To select a tuple from the ``_user`` space, use ``box.space._user:select()``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2351
msgid "tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2360
msgid "To change tuples in the ``_user`` space, do not use ordinary ``box.space`` functions for insert or update or delete. The ``_user`` space is special, so there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2364
msgid "To create a new user, use :ref:`box.schema.user.create() <box_schema-user_create>`:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2369
msgid "box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2373
msgid "To change the user's password, use :ref:`box.schema.user.password() <box_schema-user_password>`:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2378
msgid "-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2385
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2390
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2392
msgid "To check whether a user exists, use :ref:`box.schema.user.exists() <box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2398
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2400
msgid "To find what privileges a user has, use :ref:`box.schema.user.info() <box_schema-user_info>`:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2405
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2413
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2416
msgid "tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2433
msgid "``_ck_constraint`` is a system space where check constraints are stored."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2437
msgid "the numeric id of the space (\"space_id\"),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2439
msgid "whether the check is deferred (\"is_deferred\"),"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2440
msgid "the language of the expression, such as 'SQL',"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2441
msgid "the expression (\"code\")"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2445
msgid "tarantool> box.space._ck_constraint:select()\n"
"---\n"
"- - [527, 'c1', false, 'SQL', '\"f2\" > ''A''']\n"
"  - [527, 'c2', false, 'SQL', '\"f2\" == UPPER(\"f3\") AND NOT \"f2\" LIKE ''__''']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2455
msgid "Example: using box.space functions to read _space tuples"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2457
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system space, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2467
msgid "function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2491
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2493
msgid "tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2513
msgid "Example: using box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2515
msgid "The objective is to display field names and field types of a system space -- using metadata to find metadata."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2518
msgid "To begin: how can one select the ``_space`` tuple that describes ``_space``?"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2520
msgid "A simple way is to look at the constants in ``box.schema``, which tell us that there is an item named SPACE_ID == 288, so these statements will retrieve the correct tuple:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2524
msgid "box.space._space:select{ 288 }\n"
"-- or --\n"
"box.space._space:select{ box.schema.SPACE_ID }"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2530
msgid "Another way is to look at the tuples in ``box.space._index``, which tell us that there is a secondary index named 'name' for space number 288, so this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2534
msgid "box.space._space.index.name:select{ '_space' }"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2538
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2540
msgid "tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, {'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': 'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': 'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2550
msgid "It looks disorganized because field number 7 has been formatted with recommended names and data types. How can one get those specific sub-fields? Since it's visible that field number 7 is an array of maps, this `for` loop will do the organizing:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2555
msgid "tarantool> do\n"
"         >   local tuple_of_space = box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2577
msgid "``_vuser`` is a system space that represents a virtual view. The structure of its tuples is identical to that of :ref:`_user <box_space-user>`, but permissions for certain tuples are limited in accordance with user privileges. ``_vuser`` contains only those tuples that are accessible to the current user. See :ref:`Access control <authentication>` for details about user privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2583
msgid "If the user has the full set of privileges (like 'admin'), the contents of ``_vuser`` match the contents of ``_user``. If the user has limited access, ``_vuser`` contains only tuples accessible to this user."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2587
msgid "To see how ``_vuser`` works, :ref:`connect to a Tarantool database remotely <connecting-remotely>` via ``tarantoolctl`` and select all tuples from the ``_user`` space, both when the 'guest' user *is* and *is not* allowed to read from the database."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2593
msgid "First, start Tarantool and grant the 'guest' user with read, write and execute privileges:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2596
msgid "tarantool> box.cfg{listen = 3301}\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2605
msgid "Switch to the other terminal, connect to the Tarantool instance and select all tuples from the ``_user`` space:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2608
msgid "$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"  - [1, 1, 'admin', 'user', {}]\n"
"  - [2, 1, 'public', 'role', {}]\n"
"  - [3, 1, 'replication', 'role', {}]\n"
"  - [31, 1, 'super', 'role', {}]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2620
msgid "This result contains the same set of users as if you made the request from your Tarantool instance as 'admin'."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2623
msgid "Switch to the first terminal and revoke the read privileges from the 'guest' user:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2625
msgid "tarantool> box.schema.user.revoke('guest', 'read', 'universe')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2631
msgid "Switch to the other terminal, stop the session (to stop ``tarantoolctl``, type Ctrl+C or Ctrl+D) and repeat the ``box.space._user:select{}`` request. The access is denied:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2635
msgid "$ tarantoolctl connect 3301\n"
"localhost:3301> box.space._user:select{}\n"
"---\n"
"- error: Read access to space '_user' is denied for user 'guest'\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2643
msgid "However, if you select from ``_vuser`` instead, the users' data available for the 'guest' user is displayed:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2646
msgid "localhost:3301> box.space._vuser:select{}\n"
"---\n"
"- - [0, 1, 'guest', 'user', {}]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2655
msgid "``_vuser`` is a system view, so it allows only read requests."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2656
msgid "While the ``_user`` space requires proper access privileges, any user can always read from ``_vuser``."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2664
msgid "``_collation`` is a system space with a list of :ref:`collations <index-collation>`. There are over 270 built-in collations and users may add more. Here is one example:"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2667
msgid "localhost:3301> box.space._collation:select(239)\n"
"---\n"
"- - [239, 'unicode_uk_s2', 1, 'ICU', 'uk', {'strength': 'secondary'}]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2674
msgid "Explanation of the fields in the example: id = 239 i.e. Tarantool's primary key is 239, name = 'unicode_uk_s2' i.e. according to Tarantool's naming convention this is a Unicode collation + it is for the uk locale + it has secondary strength, owner = 1 i.e. :ref:`the admin user <authentication-owners_privileges>`, type = 'ICU' i.e. the rules are according to `International Components for Unicode <http://site.icu-project.org/home>`_, locale = 'uk' i.e. `Ukrainian <http://www.unicode.org/cldr/charts/29/collation/uk.html>`_, opts = 'strength:secondary' i.e. with this collation comparisons use both primary and secondary `weights <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2687
msgid "``_vcollation`` is a system space with a list of :ref:`collations <index-collation>`. The structure of its tuples is identical to that of :ref:`box.space._collation <box_space-collation>`, but permissions for certain tuples are limited in accordance with user privileges."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2696
msgid "Example: using data operations"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2698
msgid "This example demonstrates all legal scenarios -- as well as typical errors -- for each :ref:`data operation <index-box_data-operations>` in Tarantool: :ref:`INSERT <box_space-operations-insert>`, :ref:`DELETE <box_space-operations-delete>`, :ref:`UPDATE <box_space-operations-update>`, :ref:`UPSERT <box_space-operations-upsert>`, :ref:`REPLACE <box_space-operations-replace>`, and :ref:`SELECT <box_space-operations-select>`."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2707
msgid "-- Bootstrap the database --\n"
"box.cfg{}\n"
"format = {}\n"
"format[1] = {'field1', 'unsigned'}\n"
"format[2] = {'field2', 'unsigned'}\n"
"format[3] = {'field3', 'unsigned'}\n"
"s = box.schema.create_space('test', {format = format})\n"
"-- Create a primary index --\n"
"pk = s:create_index('pk', {parts = {{'field1'}}})\n"
"-- Create a unique secondary index --\n"
"sk_uniq = s:create_index('sk_uniq', {parts = {{'field2'}}})\n"
"-- Create a non-unique secondary index --\n"
"sk_non_uniq = s:create_index('sk_non_uniq', {parts = {{'field3'}}, unique = false})"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2727
#: ../doc/2.2/reference/reference_sql/sql.rst:803
#: ../doc/2.2/tutorials/sql_tutorial.rst:136
msgid "INSERT"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2729
msgid "``insert`` accepts a well-formatted tuple and checks all keys for duplicates."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2731
msgid "tarantool> -- Unique indexes: ok --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> -- Conflicting primary key: error --\n"
"tarantool> s:insert({1, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'pk' in space 'test'\n"
"...\n"
"tarantool> -- Conflicting unique secondary key: error --\n"
"tarantool> s:insert({2, 1, 1})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> -- Key {1} exists in sk_non_uniq index, but it is not unique: ok --\n"
"tarantool> s:insert({2, 2, 1})\n"
"---\n"
"- [2, 2, 1]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2761
#: ../doc/2.2/book/box/engines/vinyl.rst:139
#: ../doc/2.2/reference/reference_sql/sql.rst:953
#: ../doc/2.2/tutorials/sql_tutorial.rst:434
msgid "DELETE"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2763
msgid "``delete`` accepts a full key of any unique index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2765
msgid "``space:delete`` is an alias for \"delete by primary key\"."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2767
msgid "tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"tarantool> s:delete{4}\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a primary key: ok --\n"
"tarantool> s:delete{3}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly delete by a primary key: ok --\n"
"tarantool> s.index.pk:delete{6}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a unique secondary key: ok --\n"
"s.index.sk_uniq:delete{10}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> -- Delete by a non-unique secondary index: error --\n"
"tarantool> s.index.sk_non_uniq:delete{14}\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2840
msgid "The key must be full: ``delete`` cannot work with partial keys."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2842
msgid "tarantool> s2 = box.schema.create_space('test2')\n"
"---\n"
"...\n"
"tarantool> pk2 = s2:create_index('pk2', {parts = {{1, 'unsigned'}, {2, 'unsigned'}}})\n"
"---\n"
"...\n"
"tarantool> s2:insert{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> -- Delete by a partial key: error --\n"
"tarantool> s2:delete{1}\n"
"---\n"
"- error: Invalid key part count in an exact match (expected 2, got 1)\n"
"...\n"
"tarantool> -- Delete by a full key: ok --\n"
"tarantool> s2:delete{1, 1}\n"
"---\n"
"- [1, 1]\n"
"...\n"
"tarantool> s2:select{}\n"
"---\n"
"- []\n"
"...\n"
"tarantool> s2:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2876
#: ../doc/2.2/reference/reference_sql/sql.rst:875
#: ../doc/2.2/tutorials/sql_tutorial.rst:417
msgid "UPDATE"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2878
msgid "Similarly to ``delete``, ``update`` accepts a full key of any unique index, and also the operations to execute."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2881
msgid "``space:update`` is an alias for \"update by primary key\"."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2883
msgid "tarantool> -- Insert some test data --\n"
"tarantool> s:insert{3, 4, 5}\n"
"---\n"
"- [3, 4, 5]\n"
"...\n"
"tarantool> s:insert{6, 7, 8}\n"
"---\n"
"- [6, 7, 8]\n"
"...\n"
"tarantool> s:insert{9, 10, 11}\n"
"---\n"
"- [9, 10, 11]\n"
"...\n"
"tarantool> s:insert{12, 13, 14}\n"
"---\n"
"- [12, 13, 14]\n"
"...\n"
"tarantool> -- Nothing done here: no {4} key in pk index --\n"
"s:update({4}, {{'=', 2, 400}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 4, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a primary key: ok --\n"
"tarantool> s:update({3}, {{'=', 2, 400}})\n"
"---\n"
"- [3, 400, 5]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 7, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Explicitly update by a primary key: ok --\n"
"tarantool> s.index.pk:update({6}, {{'=', 2, 700}})\n"
"---\n"
"- [6, 700, 8]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 10, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a unique secondary key: ok --\n"
"tarantool> s.index.sk_uniq:update({10}, {{'=', 2, 1000}})\n"
"---\n"
"- [9, 1000, 11]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> -- Update by a non-unique secondary key: error --\n"
"tarantool> s.index.sk_non_uniq:update({14}, {{'=', 2, 1300}})\n"
"---\n"
"- error: Get() doesn't support partial keys and non-unique indexes\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [3, 400, 5]\n"
"  - [6, 700, 8]\n"
"  - [9, 1000, 11]\n"
"  - [12, 13, 14]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2969
#: ../doc/2.2/book/box/engines/vinyl.rst:140
msgid "UPSERT"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2971
msgid "``upsert`` accepts a well-formatted tuple and update operations."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2973
msgid "If an old tuple is found by the primary key of the specified tuple, then the update operations are applied to the old tuple, and the new tuple is ignored."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2977
msgid "If no old tuple is found, then the new tuple is inserted, and the update operations are **ignored**."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2980
msgid "Indexes have no ``upsert`` method - this is a method of a space."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:2982
msgid "tarantool> s.index.pk.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.index.sk_uniq.upsert == nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s.upsert ~= nil\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- As the first argument, upsert accepts --\n"
"tarantool> -- a well-formatted tuple, NOT a key! --\n"
"tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:upsert({1}, {{'=', 2, 200}})\n"
"---\n"
"- error: Tuple field count 1 is less than required by space format or defined indexes\n"
"    (expected at least 3)\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:delete{1}\n"
"---\n"
"- [1, 2, 3]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3016
msgid "``upsert`` turns into ``insert`` when no old tuple is found by the primary key."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3018
msgid "tarantool> s:upsert({1, 2, 3}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- As you can see, {1, 2, 3} were inserted, --\n"
"tarantool> -- and the update operations were not applied. --\n"
"s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> -- Performing another upsert with the same primary key, --\n"
"tarantool> -- but different values in the other fields. --\n"
"s:upsert({1, 20, 30}, {{'=', 2, 200}})\n"
"---\n"
"...\n"
"tarantool> -- The old tuple was found by the primary key {1} --\n"
"tarantool> -- and update operations were applied. --\n"
"tarantool> -- The new tuple was ignored. --\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3042
msgid "``upsert`` searches for an old tuple by the primary index, NOT by a secondary index. This can lead to a duplication error if the new tuple ruins the uniqueness of a secondary index."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3046
msgid "tarantool> s:upsert({2, 200, 3}, {{'=', 3, 300}})\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"...\n"
"tarantool> -- But this works, when uniqueness is preserved. --\n"
"tarantool> s:upsert({2, 0, 0}, {{'=', 3, 300}})\n"
"---\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 200, 3]\n"
"  - [2, 0, 0]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3073
#: ../doc/2.2/book/box/engines/vinyl.rst:138
#: ../doc/2.2/reference/reference_sql/sql.rst:1003
msgid "REPLACE"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3075
msgid "``replace`` accepts a well-formatted tuple and searches for an old tuple by the primary key of the new tuple."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3078
msgid "If the old tuple is found, then it is deleted, and the new tuple is inserted."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3080
msgid "If the old tuple was not found, then just the new tuple is inserted."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3082
msgid "tarantool> s:replace{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:replace{1, 3, 4}\n"
"---\n"
"- [1, 3, 4]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 3, 4]\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3104
msgid "``replace`` can ruin unique constraints, like ``upsert`` does."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3106
msgid "tarantool> s:insert{1, 1, 1}\n"
"---\n"
"- [1, 1, 1]\n"
"...\n"
"tarantool> s:insert{2, 2, 2}\n"
"---\n"
"- [2, 2, 2]\n"
"...\n"
"tarantool> -- This replace fails, because if the new tuple {1, 2, 0} replaces --\n"
"tarantool> -- the old tuple by the primary key from 'pk' index {1, 1, 1}, --\n"
"tarantool> -- this results in a duplicate unique secondary key in 'sk_uniq' index: --\n"
"tarantool> -- key {2} is used both in the new tuple and in {2, 2, 2}. --\n"
"tarantool> s:replace{1, 2, 0}\n"
"---\n"
"- error: Duplicate key exists in unique index 'sk_uniq' in space 'test'\n"
"...\n"
"tarantool> s:truncate()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3132
#: ../doc/2.2/reference/reference_sql/sql.rst:1467
msgid "SELECT"
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3134
msgid "``select`` works with any indexes (primary/secondary) and with any keys (unique/non-unique, full/partial)."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3137
msgid "If a key is partial, then ``select`` searches by all keys, where the prefix matches the specified key part."
msgstr ""

#: ../doc/2.2/book/box/box_space.rst:3140
msgid "tarantool> s:insert{1, 2, 3}\n"
"---\n"
"- [1, 2, 3]\n"
"...\n"
"tarantool> s:insert{4, 5, 6}\n"
"---\n"
"- [4, 5, 6]\n"
"...\n"
"tarantool> s:insert{7, 8, 9}\n"
"---\n"
"- [7, 8, 9]\n"
"...\n"
"tarantool> s:insert{10, 11, 9}\n"
"---\n"
"- [10, 11, 9]\n"
"...\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 2, 3]\n"
"...\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 2, 3]\n"
"  - [4, 5, 6]\n"
"  - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"...\n"
"tarantool> s.index.pk:select{4}\n"
"---\n"
"- - [4, 5, 6]\n"
"...\n"
"tarantool> s.index.sk_uniq:select{8}\n"
"---\n"
"- - [7, 8, 9]\n"
"...\n"
"tarantool> s.index.sk_non_uniq:select{9}\n"
"---\n"
"- - [7, 8, 9]\n"
"  - [10, 11, 9]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:39
msgid "Functions for SQL"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:41
msgid "The ``box`` module contains two functions related to SQL:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:43
msgid "``box.internal.sql_create_function`` -- for making Lua functions callable from SQL statements. This, or an SQL statement with the same effect, will be part of the documentation regarding SQL Plus Lua."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:47
msgid "``box.execute`` -- for making SQL statements callable from Lua functions."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:49
msgid "Some SQL statements are illustrated in the :ref:`SQL tutorial <sql_tutorial>`."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:55
msgid "Execute the SQL statement contained in the sql-statement parameter."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:57
msgid "statement, which should conform to the rules for SQL grammar"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:58
msgid "optional list for placeholders in the statement"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:60
msgid "depends on statement"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:62
msgid "There are two ways to pass extra parameters for ``box.execute()``:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:64
msgid "The first way is to concatenate strings. For example, this Lua script will insert 10 rows with different primary-key values into table t:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:68
msgid "for i=1,10,1 do\n"
"  box.execute(\"insert into t values (\" .. i .. \")\")\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:74
msgid "The second way is to put one or more placeholder \"?\" tokens inside the string, and pass a second argument, which must be a table containing values for each placeholder. For example these two requests are equivalent:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:78
msgid "box.execute([[INSERT INTO tt VALUES (1,'x');]]);\n"
"x = {1,'x'}; box.execute([[INSERT INTO tt VALUES (?,?);]], x);"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:83
msgid "Since ``box.execute()`` is an invocation of a Lua function, it either causes an error message or returns a value."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:86
msgid "For some statements the returned value will contain a field named rowcount. For example;"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:89
msgid "tarantool> box.execute([[INSERT INTO tt VALUES (8,8),(9,9);]])\n"
"tarantool> box.execute([[CREATE TABLE table1 (column1 INT PRIMARY key, column2 VARCHAR(10));]])\n"
"---\n"
"- rowcount: 1\n"
"...\n"
"tarantool> box.execute([[INSERT INTO table1 VALUES (55,'Hello SQL world!');]])\n"
"---\n"
"- rowcount: 1\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:101
msgid "For statements that cause generation of values for PRIMARY KEY AUTOINCREMENT columns, there will also be a field named \"autoincrement_ids\"."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:104
msgid "For SELECT statements the returned value will contain a field named metadata (a table with column names and data types) and a field named \"rows\" (a table with the result set). For example:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:108
msgid "tarantool> box.execute([[SELECT * FROM table1 WHERE column1 > 0;]])\n"
"---\n"
"- metadata:\n"
"  - name: COLUMN1\n"
"    type: integer\n"
"  - name: COLUMN2\n"
"    type: string\n"
"  rows:\n"
"  - [55, 'Hello SQL world!']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:121
msgid "The result structure contains Tarantool/NoSQL data type names in MsgPack format. For example, for a statement SELECT \"x\" FROM t WHERE \"x\"=5; where \"x\" is an integer column and there is one row, the raw data for the result set will look like this:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:126
msgid "dd 00 00 00 01                  1-element array\n"
"82                              2-element map (for metadata + rows)\n"
"a8 6d 65 74 61 64 61 74 61      string = \"metadata\"\n"
"91                              1-element array (for column count)\n"
"82                              2-element map (for name + type)\n"
"a4 6e 61 6d 65                  string = \"name\"\n"
"a1 78                           string = \"x\"\n"
"a4 74 79 70 6                   string = \"type\"\n"
"a7 69 6e 74 65 67 65 72         string = \"integer\"\n"
"a4 72 6f 77 73                  string = \"rows\"\n"
"91                              1-element array (for row count)\n"
"91                              1-element array (for field count)\n"
"05                              contents"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:142
msgid "The order of components within a map is not guaranteed."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:144
msgid "Alternative: if you are using the Tarantool server as a client, you can switch languages thus:"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:147
msgid "\\set language sql\n"
"\\set delimiter ;"
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:152
msgid "Afterwards, you can enter any SQL statement directly without needing ``box.execute()``."
msgstr ""

#: ../doc/2.2/book/box/box_sql.rst:154
msgid "There is also an ``execute()`` function available via :ref:`module net.box <net_box-module>`, for example after ``conn = net_box.connect(url-string)`` one can say ``conn:execute(sql-statement])``."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:39
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:41
msgid "The ``box.stat`` submodule provides access to request and network statistics."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:43
msgid "Use ``box.stat()`` to show the average number of requests per second, and the total number of requests since startup, broken down by request type."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:46
msgid "Use ``box.stat.net()``  to see network activity: the number of packets sent and received, the count of active iproto connections, and the average number of requests per second."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:51
msgid "Use ``box.stat.vinyl()`` to see vinyl-storage-engine activity, for example ``box.stat.vinyl().tx`` has the number of commits and rollbacks. See details at :ref:`the end of this section <box_introspection-box_stat_vinyl_details>`."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:57
msgid "Use ``box.stat.reset()`` to reset the statistics of ``box.stat()``, ``box.stat.net()``, ``box.stat.vinyl()`` and :ref:`box.space.index <box_space-space_index>`."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:61
msgid "In the tables that ``box.stat()`` and ``box.stat.net()`` return: ``rps`` stands for \"[average number of] requests per second [in the last 5 seconds]\", ``total`` stands for \"total [number processed since the server began]\", ``current`` stands for \"[number of] current [requests in progress, which can be limited by :ref:`box.cfg.net_msg_max <cfg_networking-net_msg_max>`]\". \"ERROR\" is the count of requests that resulted in an error."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:68
msgid "tarantool> box.stat() -- return 10 tables\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- total + requests per second from one table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net() -- 4 tables\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  CONNECTIONS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  REQUESTS:\n"
"    current: 0\n"
"    rps: 0\n"
"    total: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat.vinyl().tx.commit -- one item of the vinyl table\n"
"---\n"
"- 1047632\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:132
msgid "Here are details about the ``box.stat.vinyl()`` items."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:136
msgid "**Details about box.stat.vinyl().regulator:** The vinyl regulator decides when to take or delay actions for disk IO, grouping activity in batches so that it is consistent and efficient. The regulator is invoked by the vinyl scheduler, once per second, and updates related variables whenever it is invoked."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:143
msgid "``box.stat.vinyl().regulator.dump_bandwidth`` is the estimated average rate at which dumps are done. Initially this will appear as 10485760 (10 megabytes per second). Only significant dumps (larger than one megabyte) are used for estimating."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:148
msgid "``box.stat.vinyl().regulator.dump_watermark`` is the point when dumping must occur. The value is slightly smaller than the amount of memory that is allocated for vinyl trees, which is the :ref:`vinyl_memory <cfg_storage-vinyl_memory>` parameter."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:154
msgid "``box.stat.vinyl().regulator.write_rate`` is the actual average rate at which recent writes to disk are done. Averaging is done over a 5-second time window, so if there has been no activity for 5 seconds then ``regulator.write_rate = 0``. The ``write_rate`` may be slowed when a dump is in progress or when the user has set :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:162
msgid "``box.stat.vinyl().regulator.rate_limit`` is the write rate limit, in bytes per second, imposed on transactions by the regulator based on the observed dump/compaction performance."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:168
msgid "**Details about box.stat.vinyl().disk:** Since vinyl is an on-disk storage engine (unlike memtx which is an in-memory storage engine), it can handle large databases -- but if a database is larger than the amount of memory that is allocated for vinyl, then there will be more disk activity."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:175
msgid "``box.stat.vinyl().disk.data`` and ``box.stat.vinyl().disk.index`` are the amount of data that has gone into files in a subdirectory of :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, with names like ``{lsn}.run`` and ``{lsn}.index``. The size of the run will be related to the output of ``scheduler.dump_*``."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:182
msgid "``box.stat.vinyl().disk.data_compacted`` Sum size of data stored at the last LSM tree level, in bytes, without taking disk compression into account. It can be thought of as the size of disk space that the user data would occupy if there were no compression, indexing, or space increase caused by the LSM tree design."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:190
msgid "**Details about box.stat.vinyl().memory:** Although the vinyl storage engine is not \"in-memory\", Tarantool does need to have memory for write buffers and for caches:"
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:194
msgid "``box.stat.vinyl().memory.tuple_cache`` is the number of bytes that are being used for tuples (data)."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:196
msgid "``box.stat.vinyl().memory.tx`` is transactional memory. This will usually be 0."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:198
msgid "``box.stat.vinyl().memory.level0`` is the \"level0\" memory area, sometimes abbreviated \"L0\", which is the area that vinyl can use for in-memory storage of an LSM tree."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:202
msgid "Therefore we can say that \"L0 is becoming full\" when the amount in ``memory.level0`` is close to the maximum, which is :ref:`regulator.dump_watermark <box_introspection-box_stat_vinyl_regulator>`. We can expect that \"L0 = 0\" immediately after a dump. ``box.stat.vinyl().memory.page_index`` and  ``box.stat.vinyl().memory.bloom_filter`` have the current amount being used for index-related structures. The size is a function of the number and size of keys, plus :ref:`page_size <cfg_storage-vinyl_page_size>`, plus :ref:`bloom_fpr <cfg_storage-vinyl_bloom_fpr>`. This is not a count of bloom filter \"hits\" (the number of reads that could be avoided because the bloom filter predicts their presence in a run file) -- that statistic can be found with :ref:`index_object:stat() <box_index-stat>`."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:219
msgid "**Details about box.stat.vinyl().tx:** This is about requests that affect transactional activity (\"tx\" is used here as an abbreviation for \"transaction\"):"
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:223
msgid "``box.stat.vinyl().tx.conflict`` counts conflicts that caused a transaction to roll back."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:225
msgid "``box.stat.vinyl().tx.commit`` is the count of commits (successful transaction ends). It includes implicit commits, for example any insert causes a commit unless it is within a begin-end block."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:229
msgid "``box.stat.vinyl().tx.rollback`` is the count of rollbacks (unsuccessful transaction ends). This is not merely a count of explicit :ref:`box.rollback <box-rollback>` requests -- it includes requests that ended in errors. For example, after an attempted insert request that causes a \"Duplicate key exists in unique index\" error, ``tx.rollback`` is incremented."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:237
msgid "``box.stat.vinyl().tx.statements`` will usually be 0."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:239
msgid "``box.stat.vinyl().tx.transactions`` is the number of transactions that are currently running."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:241
msgid "``box.stat.vinyl().tx.gap_locks`` is the number of gap locks that are outstanding during execution of a request. For a low-level description of Tarantool's implementation of gap locking, see `Gap locks in Vinyl transaction manager <https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:245
msgid "``box.stat.vinyl().tx.read_views`` shows whether a transaction has entered a read-only state to avoid conflict temporarily. This will usually be 0."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:249
msgid "**Details about box.stat.vinyl().scheduler:** This primarily has counters related to tasks that the scheduler has arranged for dumping or compaction: (most of these items are reset to 0 when the server restarts or when :ref:`box.stat.reset() <box_introspection-box_stat_reset>` occurs):"
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:255
msgid "``box.stat.vinyl().scheduler.compaction_*`` is the amount of data from recent changes that has been :ref:`compacted <box_index-compact>`. This is divided into ``scheduler.compaction_input`` (the amount that is being compacted), ``scheduler.compaction_queue`` (the amount that is waiting to be compacted), ``scheduler.compaction_time`` (total time spent by all worker threads performing compaction, in seconds), and ``scheduler.compaction_output`` (the amount that has been compacted, which is presumably smaller than ``scheduler.compaction_input``)."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:265
msgid "``box.stat.vinyl().scheduler.tasks_*`` is about dump/compaction tasks, in three categories, ``scheduler.tasks_inprogress`` (currently running), ``scheduler.tasks_completed`` (successfully completed) ``scheduler.tasks_failed`` (aborted due to errors)."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:271
msgid "``box.stat.vinyl().scheduler_dump_*`` has the amount of data from recent changes that has been dumped, including ``dump_time`` (total time spent by all worker threads performing dumps, in seconds), and ``dump_count`` (the count of completed dumps), ``dump_input`` and ``dump_output``."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:277
msgid "A \"dump\" is explained in section :ref:`Storing data with vinyl <engines-algorithm_filling_lsm>`:"
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:279
msgid "Sooner or later the number of elements in an LSM tree exceeds the L0 size and that is when L0 gets written to a file on disk (called a 'run') and then cleared for storing new elements. This operation is called a 'dump'."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:283
msgid "Thus it can be predicted that a dump will occur if the size of L0 (which is :ref:`memory.level0 <box_introspection-box_stat_vinyl_memory>`) is approaching the maximum (which is :ref:`regulator.dump_watermark <box_introspection-box_stat_vinyl_regulator>`) and a dump is not already in progress. In fact Tarantool will try to arrange a dump before this hard limit is reached."
msgstr ""

#: ../doc/2.2/book/box/box_stat.rst:293
msgid "A dump will also occur during a  :ref:`snapshot <box-snapshot>` operation."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:39
msgid "Submodule `box.tuple`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:47
msgid "The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata type. It allows, for a single :ref:`tuple <index-box_tuple>`: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a `Lua table <https://www.lua.org/pil/2.5.html>`_."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:56
msgid "Below is a list of all ``box.tuple`` functions."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:66
msgid ":ref:`box.tuple.new() <box_tuple-new>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:66
msgid "Create a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:69
msgid ":ref:`#tuple_object <box_tuple-count_fields>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:69
msgid "Count tuple fields"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:72
msgid ":ref:`tuple_object:bsize() <box_tuple-bsize>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:72
msgid "Get count of bytes in a tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:75
msgid ":ref:`tuple_object[field-number] <box_tuple-field_number>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:75
msgid "Get a tuple's field by specifying a number"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:78
msgid ":ref:`tuple_object[field-name] <box_tuple-field_name>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:78
msgid "Get a tuple's field by specifying a name"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:81
msgid ":ref:`tuple_object[field-path] <box_tuple-field_path>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:81
msgid "Get a tuple's fields or parts by specifying a path"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:84
msgid ":ref:`tuple_object:find() <box_tuple-find>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:84
msgid "Get the number of the first field matching the search value"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:87
msgid ":ref:`tuple_object:findall() <box_tuple-find>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:87
msgid "Get the number of all fields matching the search value"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:90
msgid ":ref:`tuple_object:transform() <box_tuple-transform>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:90
msgid "Remove (and replace) a tuple's fields"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:93
msgid ":ref:`tuple_object:unpack() <box_tuple-unpack>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:93
msgid "Get a tuple's fields"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:96
msgid ":ref:`tuple_object:totable() <box_tuple-totable>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:96
msgid "Get a tuple's fields as a table"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:99
msgid ":ref:`tuple_object:tomap() <box_tuple-tomap>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:99
msgid "Get a tuple's fields as a table along with key:value pairs"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:102
msgid ":ref:`tuple_object:pairs() <box_tuple-pairs>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:105
msgid ":ref:`tuple_object:update() <box_tuple-update>`"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:113
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:`update <box_space-update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:120
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:122
msgid "a new tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:125
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:131
msgid "tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:154
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:159
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:162
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:176
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. With both the memtx storage engine and the vinyl storage engine the default maximum is one megabyte (:ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`). Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:185
msgid "The value does not include the size of \"struct tuple\" (for the current size of this structure look in the `tuple.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/tuple.h>`_ file in Tarantool's source code)."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:193
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and then there is one more byte to store a count of the number of fields, so ``bsize()`` returns ``3*(1+3)+1``. This is the same as the size of the string that :ref:`msgpack.encode({'aaa','bbb','ccc'}) <msgpack-encode>` would return."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:200
msgid "tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:214
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:217
#: ../doc/2.2/book/box/box_tuple.rst:241
msgid "field value."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:218
#: ../doc/2.2/book/box/box_tuple.rst:242
msgid "lua-value"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:220
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:223
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:237
msgid "If ``t`` is a tuple instance, ``t['field-name']`` will return the field named 'field-name' in the tuple. Fields have names if the tuple has been retrieved from a space that has an associated :ref:`format <box_space-format>`."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:244
msgid "In the following example, a tuple named ``t`` is returned from ``replace`` and then the second field in ``t`` named 'field2' is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:247
msgid "tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, 'Я'}\n"
"---\n"
"...\n"
"tarantool> t['field2']\n"
"---\n"
"- Я\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:276
msgid "If ``t`` is a tuple instance, ``t['path']`` will return the field or subset of fields that are in ``path``. ``path`` must be a well formed JSON specification. ``path`` may contain field names if the tuple has been retrieved from a space that has an associated :ref:`format <box_space-format>`."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:281
msgid "To prevent ambiguity, Tarantool first tries to interpret the request as :ref:`tuple_object[field-number] <box_tuple-field_number>` or :ref:`tuple_object[field-name] <box_tuple-field_name>`. If and only if that fails, Tarantool tries to interpret the request as ``tuple_object[field-path]``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:287
msgid "The path must be a well formed JSON specification, but it may be preceded by '.'. The '.' is a signal that the path acts as a suffix for the tuple."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:291
msgid "The advantage of specifying a path is that Tarantool will use it to search through a tuple body and get only the tuple part, or parts, that are actually necessary."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:295
msgid "In the following example, a tuple named ``t`` is returned from ``replace`` and then only the relevant part (in this case, matching a name) of a relevant field is returned. Namely: the second field, the sixth part, the value following 'value='."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:300
msgid "tarantool> format = {}\n"
"---\n"
"...\n"
"tarantool> format[1] = {name = 'field1', type = 'unsigned'}\n"
"---\n"
"...\n"
"tarantool> format[2] = {name = 'field2', type = 'array'}\n"
"---\n"
"...\n"
"tarantool> format[3] = {name = 'field4', type = 'string' }\n"
"---\n"
"...\n"
"tarantool> format[4] = {name = \"[2][6]['пw']['Я']\", type = 'string'}\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('test', {format = format})\n"
"---\n"
"...\n"
"tarantool> pk = s:create_index('pk')\n"
"---\n"
"...\n"
"tarantool> field2 = {1, 2, 3, \"4\", {5,6,7}, {пw={Я=\"п\"}, key=\"V!\", value=\"K!\"}}\n"
"---\n"
"...\n"
"tarantool> t = s:replace{1, field2, \"123456\", \"Not K!\"}\n"
"---\n"
"...\n"
"tarantool> t[\"[2][6]['value']\"]\n"
"---\n"
"- K!\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:339
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate “start searching at field number ``field-number``.”"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:346
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:349
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:355
msgid "tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:378
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:384
msgid "If the original tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`, the formatting will not be preserved for the result tuple."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:388
msgid "base 1, may be negative"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:394
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:398
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:412
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:416
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:417
msgid "lua-value(s)"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:419
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:422
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:440
msgid "If ``t`` is a tuple instance, ``t:totable()`` will return all fields, ``t:totable(1)`` will return all fields starting with field number 1, ``t:totable(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:444
msgid "It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:446
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:447
#: ../doc/2.2/book/box/box_tuple.rst:496
msgid "lua-table"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:449
msgid "In the following example, a tuple named ``t`` is created, then all its fields are selected, then the result is returned."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:452
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:466
msgid "A `Lua table <https://www.lua.org/pil/2.5.html>`_ can have indexed values, also called key:value pairs. For example, here:"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:470
msgid "a = {}; a['field1'] = 10; a['field2'] = 20"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:474
msgid "``a`` is a table with \"field1: 10\" and \"field2: 20\"."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:476
msgid "The :ref:`tuple_object:totable() <box_tuple-totable>` function only returns a table containing the values. But the ``tuple_object:tomap()`` function returns a table containing not only the values, but also the key:value pairs."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:481
msgid "This only works if the tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:484
msgid "the only possible option is ``names_only``.  If ``names_only`` is false or omitted (default), then all the fields will appear twice, first with numeric headings and second with name headings.  If ``names_only`` is true, then all the fields will appear only once, with name headings."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:484
msgid "the only possible option is ``names_only``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:486
msgid "If ``names_only`` is false or omitted (default), then all the fields will appear twice, first with numeric headings and second with name headings."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:491
msgid "If ``names_only`` is true, then all the fields will appear only once, with name headings."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:495
msgid "field-number:value pair(s) and key:value pair(s) from the tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:498
msgid "In the following example, a tuple named ``t1`` is returned from a space that has been formatted, then tables named ``t1map1`` and ``t1map2`` are produced from ``t1``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:502
msgid "format = {{'field1', 'unsigned'}, {'field2', 'unsigned'}}\n"
"s = box.schema.space.create('test', {format = format})\n"
"s:create_index('pk',{parts={1,'unsigned',2,'unsigned'}})\n"
"t1 = s:insert{10, 20}\n"
"t1map = t1:tomap()\n"
"t1map_names_only = t1:tomap({names_only=true})"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:511
msgid "``t1map`` will contain \"1: 10\", \"2: 20\", \"field1: 10\", \"field2: 20\"."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:513
msgid "``t1map_names_only`` will contain \"field1: 10\", \"field2: 20\"."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:519
msgid "In Lua, `lua-table-value:pairs() <https://www.lua.org/pil/7.3.html>`_ is a method which returns: ``function``, ``lua-table-value``, ``nil``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:523
msgid "Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:528
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:529
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:531
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:534
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:558
msgid "This function updates a tuple which is not in a space. Compare the function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a tuple in a space."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:562
msgid "For details: see the description for ``operator``, ``field_no``, and ``value`` in the section :ref:`box.space.space-name:update{key, format, {field_number, value}...) <box_space-update>`."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:566
msgid "If the original tuple comes from a space that has been formatted with a :ref:`format clause <box_space-format>`, the formatting will be preserved for the result tuple."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:570
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:578
msgid "new tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:581
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:584
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:596
#: ../doc/2.2/book/sql.rst:57
#: ../doc/2.2/reference/configuration/index.rst:125
#: ../doc/2.2/reference/reference_lua/digest.rst:387
#: ../doc/2.2/reference/reference_lua/fiber.rst:770
#: ../doc/2.2/reference/reference_lua/fiber.rst:967
#: ../doc/2.2/reference/reference_lua/fiber.rst:1096
#: ../doc/2.2/reference/reference_lua/log.rst:172
#: ../doc/2.2/reference/reference_lua/msgpack.rst:206
#: ../doc/2.2/reference/reference_lua/net_box.rst:603
#: ../doc/2.2/reference/reference_lua/tap.rst:382
#: ../doc/2.2/reference/reference_lua/uuid.rst:166
#: ../doc/2.2/reference/reference_lua/yaml.rst:102
#: ../doc/2.2/reference/reference_rock/dbms.rst:283
#: ../doc/2.2/reference/reference_rock/dbms.rst:624
msgid "Example"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:598
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:601
msgid "tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"lua_table = tuple:totable()                             -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:609
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:614
msgid "function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_tuple.rst:630
msgid "tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:39
msgid "Functions for transaction management"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:45
msgid "For general information and examples, see section :ref:`Transaction control <atomic-atomic_execution>`."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:48
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:50
msgid "Rule #1"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:53
msgid "The requests in a transaction must be sent to a server as a single block. It is not enough to enclose them between begin and commit or rollback. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:59
msgid "Rule #2"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:62
msgid "All database operations in a transaction should use the same storage engine. It is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:67
msgid "Rule #3"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:70
msgid "Requests which cause changes to the data definition -- create, alter, drop, truncate -- are only allowed with Tarantool version 2.1 or later. Data-definition requests which change an index or change a format, such as :ref:`space_object:create_index() <box_schema-sequence_create_index>` and :ref:`space_object:format() <box_space-format>`, are not allowed inside transactions except as the first request after ``box.begin()``."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:84
msgid "Below is a list of all functions for transaction management."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:96
msgid ":ref:`box.begin() <box-begin>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:96
msgid "Begin the transaction"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:99
msgid ":ref:`box.commit() <box-commit>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:99
msgid "End the transaction and save all changes"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:102
msgid ":ref:`box.rollback() <box-rollback>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:102
msgid "End the transaction and discard all changes"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:105
msgid ":ref:`box.savepoint() <box-savepoint>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:105
msgid "Get a savepoint descriptor"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:108
msgid ":ref:`box.rollback_to_savepoint() <box-rollback_to_savepoint>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:108
msgid "Do not end the transaction and discard all changes made after a savepoint"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:112
msgid ":ref:`box.atomic() <box-atomic>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:112
msgid "Execute a function, treating it as a transaction"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:115
msgid ":ref:`box.on_commit() <box-on_commit>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:115
msgid "Define a trigger that will be activated by box.commit"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:118
msgid ":ref:`box.on_rollback() <box-on_rollback>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:118
msgid "Define a trigger that will be activated by box.rollback"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:121
msgid ":ref:`box.is_in_txn() <box-is_in_txn>`"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:121
msgid "State whether a transaction is in progress"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:129
msgid "Begin the transaction. Disable :ref:`implicit yields <atomic-implicit-yields>` until the transaction ends. Signal that writes to the :ref:`write-ahead log <internals-wal>` will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:137
msgid "**Possible errors:** error if this operation is not permitted because there"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:137
msgid "is already an active transaction. error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:144
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:147
msgid "**Possible errors:**  error and abort the transaction in case of a conflict."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:147
msgid "error if the operation fails to write to disk. error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:154
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-yield>`, will have the same effect."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:163
msgid "Return a descriptor of a savepoint (type = table), which can be used later by :ref:`box.rollback_to_savepoint(savepoint) <box-rollback_to_savepoint>`. Savepoints can only be created while a transaction is active, and they are destroyed when a transaction ends."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:168
msgid "savepoint table"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:169
#: ../doc/2.2/reference/reference_lua/fiber.rst:1059
msgid "Lua object"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:171
#: ../doc/2.2/book/box/box_txn_management.rst:184
msgid "error if the savepoint cannot be set in absence of active transaction."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:174
msgid "**Possible errors:** error if for some reason memory cannot be allocated."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:180
msgid "Do not end the transaction, but cancel all its data-change and :ref:`box.savepoint() <box-savepoint>` operations that were done after the specified savepoint."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:187
msgid "**Possible errors:** error if the savepoint does not exist."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:191
msgid "function f()\n"
"  box.begin()           -- start transaction\n"
"  box.space.t:insert{1} -- this will not be rolled back\n"
"  local s = box.savepoint()\n"
"  box.space.t:insert{2} -- this will be rolled back\n"
"  box.rollback_to_savepoint(s)\n"
"  box.commit()          -- end transaction\n"
"end"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:206
msgid "Execute a function, acting as if the function starts with an implicit :ref:`box.begin() <box-begin>` and ends with an implicit :ref:`box.commit() <box-commit>` if successful, or ends with an implicit :ref:`box.rollback() <box-rollback>` if there is an error."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:211
msgid "the result of the function passed to ``atomic()`` as an argument."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:213
msgid "**Possible errors:** any error that :ref:`box.begin() <box-begin>` and"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:214
msgid ":ref:`box.commit() <box-commit>` can return."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:220
msgid "Define a trigger for execution when a transaction ends due to an event such as :ref:`box.commit <box-commit>`."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:223
msgid "The trigger function may take an iterator parameter, as described in an example for this section."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:226
msgid "The trigger function should not access any database spaces."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:228
msgid "If the trigger execution fails and raises an error, the effect is severe and should be avoided -- use Lua's ``pcall()`` mechanism around code that might fail."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:232
msgid "``box.on_commit()`` must be invoked within a transaction, and the trigger ceases to exist when the transaction ends."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:247
msgid "**Simple and useless example:** this will display 'commit happened':"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:249
msgid "function f()\n"
"function f() print('commit happened') end\n"
"box.begin() box.on_commit(f) box.commit()"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:255
msgid "But of course there is more to it: the function parameter can be an ITERATOR."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:257
msgid "The iterator goes through the effects of every request that changed a space during the transaction."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:260
msgid "The iterator will have:"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:262
msgid "an ordinal request number,"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:263
msgid "the old value of the tuple before the request (this will be nil for an insert request),"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:265
msgid "the new value of the tuple after the request (this will be nil for a delete request),"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:267
msgid "and the id of the space."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:269
msgid "**Less simple more useful example:** this will display the effects of two replace requests:"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:272
msgid "box.space.test:drop()\n"
"s = box.schema.space.create('test')\n"
"i = box.space.test:create_index('i')\n"
"function f(iterator)\n"
"  for request_number, old_tuple, new_tuple, space_id in iterator() do\n"
"    print('request_number ' .. tostring(request_number))\n"
"    print('  old_tuple ' .. tostring(old_tuple[1]) .. ' ' .. old_tuple[2])\n"
"    print('  new_tuple ' .. tostring(new_tuple[1]) .. ' ' .. new_tuple[2])\n"
"    print('  space_id ' .. tostring(space_id))\n"
"  end\n"
"end\n"
"s:insert{1,'-'}\n"
"box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) box.commit()"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:288
msgid "The result will look like this:"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:290
msgid "tarantool> box.begin() s:replace{1,'x'} s:replace{1,'y'} box.on_commit(f) box.commit()\n"
"request_number 1\n"
"  old_tuple 1 -\n"
"  new_tuple 1 x\n"
"  space_id 517\n"
"request_number 2\n"
"  old_tuple 1 x\n"
"  new_tuple 1 y\n"
"  space_id 517"
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:306
msgid "Define a trigger for execution when a transaction ends due to an event such as :ref:`box.rollback <box-rollback>`."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:309
msgid "The parameters and warnings are exactly the same as for :ref:`box.on-commit <box-on_commit>`."
msgstr ""

#: ../doc/2.2/book/box/box_txn_management.rst:316
msgid "If a transaction is in progress (for example the user has called :ref:`box.begin <box-begin>` and has not yet called either :ref:`box.commit <box-commit>` or :ref:`box.rollback <box-rollback>`, return ``true``. Otherwise return ``false``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:39
msgid "Data model"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:41
msgid "This section describes how Tarantool stores values and what operations with data it supports."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:44
msgid "If you tried to create a database as suggested in our :ref:`\"Getting started\" exercises <getting_started>`, then your test database now looks like this:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:54
msgid "Space"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:56
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:58
msgid "When Tarantool is being used to store data, there is always at least one space. Each space has a unique **name** specified by the user. Besides, each space has a unique **numeric identifier** which can be specified by the user, but usually is assigned automatically by Tarantool. Finally, a space always has an **engine**: *memtx* (default) -- in-memory engine, fast but limited in size, or *vinyl* -- on-disk engine for huge data sets."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:65
msgid "A space is a container for :ref:`tuples <index-box_tuple>`. To be functional, it needs to have a :ref:`primary index <index-box_index>`. It can also have secondary indexes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:73
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:52
msgid "Tuple"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:75
msgid "A **tuple** plays the same role as a “row” or a “record”, and the components of a tuple (which we call “fields”) play the same role as a “row column” or “record field”, except that:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:79
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:80
msgid "fields don't need to have names."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:82
msgid "Any given tuple may have any number of fields, and the fields may be of different :ref:`types <index-box_data-types>`. The identifier of a field is the field's number, base 1 (in Lua and other 1-based languages) or base 0 (in PHP or C/C++). For example, ``1`` or ``0`` can be used in some contexts to refer to the first field of a tuple."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:89
msgid "Tuples in Tarantool are stored as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:92
msgid "When Tarantool returns a tuple value in the console, by default it uses :ref:`YAML <interactive_console>` format, `YAML <https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of Base', 1993]``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:103
msgid "An **index** is a group of key values and pointers."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:105
msgid "As with spaces, you should specify the index **name**, and let Tarantool come up with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:108
msgid "An index always has a **type**. The default index type is 'TREE'. TREE indexes are provided by all Tarantool engines, can index unique and non-unique values, support partial key searches, comparisons and ordered results. Additionally, memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:113
msgid "An index may be **multi-part**, that is, you can declare that an index key value is composed of two or more fields in the tuple, in any order. For example, for an ordinary TREE index, the maximum number of parts is 255."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:117
msgid "An index may be **unique**, that is, you can declare that it would be illegal to have the same key value twice."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:120
msgid "The first index defined on a space is called the **primary key index**, and it must be unique. All other indexes are called **secondary indexes**, and they may be non-unique."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:124
msgid "An index definition may include identifiers of tuple fields and their expected **types** (see allowed :ref:`indexed field types <index-box_indexed-field-types>` below)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:128
msgid "In our example, we first defined the primary index (named 'primary') based on field #1 of each tuple:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:131
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:135
msgid "The effect is that, for all tuples in space 'tester', field #1 must exist and must contain an unsigned integer. The index type is 'hash', so values in field #1 must be unique, because keys in HASH indexes are unique."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:140
msgid "After that, we defined a secondary index (named 'secondary') based on field #2 of each tuple:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:143
msgid "tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, 'string'}})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:147
msgid "The effect is that, for all tuples in space 'tester', field #2 must exist and must contain a string. The index type is 'tree', so values in field #2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:154
msgid "Space definitions and index definitions are stored permanently in Tarantool's system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-index>` (for details, see reference on :ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:158
msgid "You can add, drop, or alter the definitions at runtime, with some restrictions. See syntax details in reference on :ref:`box <box-module>` module."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:165
msgid "Data types"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:167
msgid "Tarantool is both a database and an application server. Hence a developer often deals with two type sets: the programming language types (e.g. Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:176
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:186
msgid "Scalar / compound"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:186
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:186
msgid "Lua type"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:186
msgid "Example value"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:188
#: ../doc/2.2/book/box/data_model.rst:190
#: ../doc/2.2/book/box/data_model.rst:192
#: ../doc/2.2/book/box/data_model.rst:194
#: ../doc/2.2/book/box/data_model.rst:196
#: ../doc/2.2/book/box/data_model.rst:198
#: ../doc/2.2/reference/interactive_console.rst:100
#: ../doc/2.2/reference/reference_sql/sql.rst:289
msgid "scalar"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:188
msgid "\"`nil`_\""
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:188
#: ../doc/2.2/book/box/data_model.rst:352
#: ../doc/2.2/reference/reference_lua/msgpack.rst:317
msgid "msgpack.NULL"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:190
msgid "\"`boolean`_\""
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:190
#: ../doc/2.2/book/box/data_model.rst:344
#: ../doc/2.2/book/box/data_model.rst:354
#: ../doc/2.2/reference/reference_lua/msgpack.rst:307
msgid "true"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:192
msgid "\"`string`_\""
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:192
msgid "'A B C'"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:194
#: ../doc/2.2/reference/reference_lua/errno.rst:79
#: ../doc/2.2/reference/reference_sql/sql.rst:278
msgid "integer"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:194
#: ../doc/2.2/book/box/data_model.rst:196
msgid "\"`number`_\""
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:194
msgid "12345"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:196
msgid "double"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:196
msgid "1.2345"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:198
msgid "bin"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:198
msgid "\"`cdata`_\""
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:198
msgid "[!!binary 3t7e]"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:200
#: ../doc/2.2/book/box/data_model.rst:202
#: ../doc/2.2/book/box/data_model.rst:204
msgid "compound"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:200
#: ../doc/2.2/reference/interactive_console.rst:115
msgid "map"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:200
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:200
msgid "{'a': 5, 'b': 6}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:202
#: ../doc/2.2/book/box/data_model.rst:204
msgid "array"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:202
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:202
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:204
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:204
msgid "[12345, 'A B C']"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:214
msgid "In Lua, a **nil** type has only one possible value, also called *nil* (displayed as **null** on Tarantool's command line, since the output is in the YAML format). Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:222
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:226
msgid "A **string** is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes. In both Lua and MsgPack, strings are treated as binary data, with no attempts to determine a string's character set or to perform any string conversion -- unless there is an optional :ref:`collation <index-collation>`. So, usually, string sorting and comparison are done byte-by-byte, without any special collation rules applied. (Example: numbers are ordered by their point on the number line, so 2345 is greater than 500; meanwhile, strings are ordered by the encoding of the first byte, then the encoding of the second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:239
msgid "In Lua, a **number** is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a Lua number as floating-point if the value contains a decimal point or is very large (greater than 100 trillion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers are stored as integers, use the :ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix and the ``tonumber64`` function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, ``tonumber64('18446744073709551615')``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:250
msgid "A **bin** (binary) value is not directly supported by Lua but there is a Tarantool type ``VARBINARY`` which is encoded as MessagePack binary. For an (advanced) example showing how to insert VARBINARY into a database, see the Cookbook Recipe for :ref:`ffi_varbinary_insert <cookbook-ffi_varbinary_insert>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:255
msgid "Lua **tables** with string keys are stored as MsgPack maps; Lua tables with integer keys starting with 1 -- as MsgPack arrays. Nils may not be used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:260
msgid "A **tuple** is a light reference to a MsgPack array stored in the database. It is a special type (cdata) to avoid conversion to a Lua table on retrieval. A few functions may return tables with multiple tuples. For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:267
msgid "Tarantool uses the MsgPack format for database storage, which is variable-length. So, for example, the smallest number requires only one byte, but the largest number requires nine bytes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:271
msgid "Examples of insert requests with different data types:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:273
msgid "tarantool> box.space.K:insert{1,nil,true,'A B C',12345,1.2345}\n"
"---\n"
"- [1, null, true, 'A B C', 12345, 1.2345]\n"
"...\n"
"tarantool> box.space.K:insert{2,{['a']=5,['b']=6}}\n"
"---\n"
"- [2, {'a': 5, 'b': 6}]\n"
"...\n"
"tarantool> box.space.K:insert{3,{1,2,3,4,5}}\n"
"---\n"
"- [3, [1, 2, 3, 4, 5]]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:292
msgid "Indexed field types"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:294
msgid "Indexes restrict values which Tarantool's MsgPack may contain. This is why, for example, 'unsigned' is a separate **indexed field type**, compared to ‘integer’ data type in MsgPack: they both store ‘integer’ values, but an 'unsigned' index contains only *non-negative* integer values and an ‘integer’ index contains *all* integer values."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:300
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:313
msgid "Indexed field type"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:313
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:316
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:316
msgid "**integer** (integer between 0 and 18446744073709551615, i.e. about 18 quintillion)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:316
#: ../doc/2.2/book/box/data_model.rst:336
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:316
msgid "123456"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:321
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:321
#: ../doc/2.2/book/box/data_model.rst:326
#: ../doc/2.2/book/box/data_model.rst:357
msgid "**integer** (integer between -9223372036854775808 and 18446744073709551615)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:321
#: ../doc/2.2/book/box/data_model.rst:326
#: ../doc/2.2/book/box/data_model.rst:340
#: ../doc/2.2/book/box/data_model.rst:344
#: ../doc/2.2/book/box/data_model.rst:352
msgid "TREE or HASH"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:321
msgid "-2^63"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:331
#: ../doc/2.2/book/box/data_model.rst:362
msgid "**double** (single-precision floating point number or double-precision floating point number)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:326
#: ../doc/2.2/book/box/data_model.rst:358
msgid "1.234"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:328
msgid "-44"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:330
msgid "1.447e+44"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:336
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:336
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:336
msgid "‘A B C’"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:338
#: ../doc/2.2/book/box/data_model.rst:340
msgid "‘\\\\65 \\\\66 \\\\67’"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:340
msgid "**bin** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:344
#: ../doc/2.2/book/box/data_model.rst:354
msgid "**bool** (true or false)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:347
msgid "**array** (list of numbers representing points in a geometric figure)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:347
msgid "RTREE"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:347
msgid "{10, 11}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:349
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:352
msgid "**null**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:367
msgid "**string** (any set of octets)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:369
msgid "**varbinary** (any set of octets)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:371
msgid "Note: When there is a mix of types, the key order is: null, then booleans, then numbers, then strings, then varbinary."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:356
msgid "-1"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:360
msgid "‘’"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:362
msgid "‘ру’"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:381
msgid "Collations"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:383
msgid "By default, when Tarantool compares strings, it uses what we call a **\"binary\" collation**. The only consideration here is the numeric value of each byte in the string. Therefore, if the string is encoded with ASCII or UTF-8, then ``'A' < 'B' < 'a'``, because the encoding of 'A' (what used to be called the \"ASCII value\") is 65, the encoding of 'B' is 66, and the encoding of 'a' is 98. Binary collation is best if you prefer fast deterministic simple maintenance and searching with Tarantool indexes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:392
msgid "But if you want the ordering that you see in phone books and dictionaries, then you need Tarantool's optional collations, such as ``unicode`` and ``unicode_ci``, which allow for ``'a' < 'A' < 'B'`` and ``'a' = 'A' < 'B'`` respectively."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:397
msgid "**The unicode and unicode_ci optional collations** use the ordering according to the `Default Unicode Collation Element Table (DUCET) <http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_ and the rules described in `Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_. The only difference between the two collations is about `weights <https://unicode.org/reports/tr10/#Weight_Level_Defn>`_:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:404
msgid "``unicode`` collation observes L1 and L2 and L3 weights (strength = 'tertiary'),"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:405
msgid "``unicode_ci`` collation observes only L1 weights (strength = 'primary'), so for example 'a' = 'A' = 'á' = 'Á'."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:407
msgid "As an example, take some Russian words:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:409
msgid "'ЕЛЕ'\n"
"'елейный'\n"
"'ёлка'\n"
"'еловый'\n"
"'елозить'\n"
"'Ёлочка'\n"
"'ёлочный'\n"
"'ЕЛь'\n"
"'ель'"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:421
msgid "...and show the difference in ordering and selecting by index:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:423
msgid "with ``unicode`` collation:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:425
msgid "tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode'}}})\n"
"...\n"
"tarantool> box.space.T.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ель']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.T.index.I:select{'ЁлКа'}\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:446
msgid "with ``unicode_ci`` collation:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:448
msgid "tarantool> box.space.T:create_index('I', {parts = {{1,'str', collation='unicode_ci'}}})\n"
"...\n"
"tarantool> box.space.S.index.I:select()\n"
"---\n"
"- - ['ЕЛЕ']\n"
"  - ['елейный']\n"
"  - ['ёлка']\n"
"  - ['еловый']\n"
"  - ['елозить']\n"
"  - ['Ёлочка']\n"
"  - ['ёлочный']\n"
"  - ['ЕЛь']\n"
"...\n"
"tarantool> box.space.S.index.I:select{'ЁлКа'}\n"
"---\n"
"- - ['ёлка']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:469
msgid "In all, collation involves much more than these simple examples of upper case / lower case and accented / unaccented equivalence in alphabets. We also consider variations of the same character, non-alphabetic writing systems, and special rules that apply for combinations of characters."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:474
msgid "For English: use \"unicode\" and \"unicode_ci\". For Russian: use \"unicode\" and \"unicode_ci\" (although a few Russians might prefer the Kyrgyz collation which says Cyrillic letters 'Е' and 'Ё' are the same with level-1 weights). For Dutch, German (dictionary), French, Indonesian, Irish, Italian, Lingala, Malay, Portuguese, Southern Soho, Xhosa, or Zulu: \"unicode\" and \"unicode_ci\" will do."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:482
msgid "**The tailored optional collations**: For other languages, Tarantool supplies tailored collations for every modern language that has more than a million native speakers, and for specialized situations such as the difference between dictionary order and telephone book order. To see a complete list say ``box.space._collation:select()``. The tailored collation names have the form unicode_[language code]_[strength] where language code is a standard 2-character or 3-character language abbreviation, and strength is s1 for \"primary strength\" (level-1 weights), s2 for \"secondary\", s3 for \"tertiary\". Tarantool uses the same language codes as the ones in the \"list of tailorable locales\" on man pages of `Ubuntu <http://manpages.ubuntu.com/manpages/bionic/man3/Unicode::Collate::Locale.3perl.html>`_ and `Fedora <http://www.polarhome.com/service/man/?qf=Unicode%3A%3ACollate%3A%3ALocale&af=0&tf=2&of=Fedora>`_. Charts explaining the precise differences from DUCET order are in the `Common Language Data Repository <https://unicode.org/cldr/charts/30/collation>`_."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:508
msgid "A **sequence** is a generator of ordered integer values."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:510
msgid "As with spaces and indexes, you should specify the sequence **name**, and let Tarantool come up with a unique **numeric identifier** (\"sequence id\")."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:513
msgid "As well, you can specify several options when creating a new sequence. The options determine what value will be generated whenever the sequence is used."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:520
msgid "Options for ``box.schema.sequence.create()``"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:533
msgid "Option name"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:533
msgid "Type and meaning"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:535
msgid "**start**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:535
msgid "Integer. The value to generate the first time a sequence is used"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:535
msgid "start=0"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:539
msgid "**min**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:539
msgid "Integer. Values smaller than this cannot be generated"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:539
msgid "min=-1000"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:542
msgid "**max**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:542
msgid "Integer. Values larger than this cannot be generated"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:542
msgid "9223372036854775807"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:542
msgid "max=0"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:545
msgid "**cycle**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:545
msgid "Boolean. Whether to start again when values cannot be generated"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:545
msgid "cycle=true"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:548
msgid "**cache**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:548
msgid "Integer. The number of values to store in a cache"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:548
msgid "cache=0"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:551
msgid "**step**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:551
msgid "Integer. What to add to the previous generated value, when generating a new value"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:551
msgid "step=-1"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:555
msgid "**if_not_exists**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:555
msgid "Boolean. If this is true and a sequence with this name exists already, ignore other options and use the existing values"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:555
msgid "if_not_exists=true"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:561
msgid "Once a sequence exists, it can be altered, dropped, reset, forced to generate the next value, or associated with an index."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:564
msgid "For an initial example, we generate a sequence named 'S'."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:566
msgid "tarantool> box.schema.sequence.create('S',{min=5, start=5})\n"
"---\n"
"- step: 1\n"
"  id: 5\n"
"  min: 5\n"
"  cache: 0\n"
"  uid: 1\n"
"  max: 9223372036854775807\n"
"  cycle: false\n"
"  name: S\n"
"  start: 5\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:581
msgid "The result shows that the new sequence has all default values, except for the two that were specified, ``min`` and ``start``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:584
msgid "Then we get the next value, with the ``next()`` function."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:586
msgid "tarantool> box.sequence.S:next()\n"
"---\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:593
msgid "The result is the same as the start value. If we called ``next()`` again, we would get 6 (because the previous value plus the step value is 6), and so on."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:597
msgid "Then we create a new table, and say that its primary key may be generated from the sequence."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:600
msgid "tarantool> s=box.schema.space.create('T');s:create_index('I',{sequence='S'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:606
msgid "Then we insert a tuple, without specifying a value for the primary key."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:608
msgid "tarantool> box.space.T:insert{nil,'other stuff'}\n"
"---\n"
"- [6, 'other stuff']\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:615
msgid "The result is a new tuple where the first field has a value of 6. This arrangement, where the system automatically generates the values for a primary key, is sometimes called \"auto-incrementing\" or \"identity\"."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:620
msgid "For syntax and implementation details, see the reference for :ref:`box.schema.sequence <box_schema-sequence>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:627
msgid "Persistence"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:629
msgid "In Tarantool, updates to the database are recorded in the so-called :ref:`write ahead log (WAL) <internals-wal>` files. This ensures data persistence. When a power outage occurs or the Tarantool instance is killed incidentally, the in-memory database is lost. In this situation, WAL files are used to restore the data. Namely, Tarantool reads the WAL files and redoes the requests (this is called the \"recovery process\"). You can change the timing of the WAL writer, or turn it off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:638
msgid "Tarantool also maintains a set of :ref:`snapshot files <internals-snapshot>`. These files contain an on-disk copy of the entire data set for a given moment. Instead of reading every WAL file since the databases were created, the recovery process can load the latest snapshot file and then read only those WAL files that were produced after the snapshot file was made. After checkpointing, old WAL files can be removed to free up space."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:645
msgid "To force immediate creation of a snapshot file, you can use Tarantool's :ref:`box.snapshot() <box-snapshot>` request. To enable automatic creation of snapshot files, you can use Tarantool's :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets intervals for forced checkpoints. It makes sure that the states of both memtx and vinyl storage engines are synchronized and saved to disk, and automatically removes old WAL files."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:653
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:657
msgid "The memtx engine makes only regular checkpoints with the interval set in :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:660
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:662
msgid "See the :ref:`Internals <internals-data_persistence>` section for more details about the WAL writer and the recovery process."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:669
msgid "Operations"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:675
msgid "Data operations"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:677
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:679
msgid "five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, REPLACE), and"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:680
msgid "one data-retrieval operation (SELECT)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:682
msgid "All of them are implemented as functions in :ref:`box.space <box_space>` submodule."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:686
msgid ":ref:`INSERT <box_space-insert>`: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:688
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:690
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:692
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:696
msgid ":ref:`UPDATE <box_space-update>`: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:698
msgid "The clause \"{999}\", which has the value to look up in the index of the tuple's primary-key field, is mandatory, because ``update()`` requests must always have a clause that specifies a unique key, which in this case is field[1]."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:702
msgid "The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will happen to field[2] with the new value."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:705
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:709
msgid ":ref:`UPSERT <box_space-upsert>`: Upsert the tuple, changing field field[2] again."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:712
msgid "The syntax of ``upsert()`` is similar to the syntax of ``update()``. However, the execution logic of these two requests is different. UPSERT is either UPDATE or INSERT, depending on the database's state. Also, UPSERT execution is postponed until after transaction commit, so, unlike ``update()``, ``upsert()`` doesn't return data back."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:718
msgid "tarantool> box.space.tester:upsert({999, 'Taranted'}, {{'=', 2, 'Tarantism'}})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:722
msgid ":ref:`REPLACE <box_space-replace>`: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:724
msgid "This is also possible with the ``update()`` request, but the ``update()`` request is usually more complicated."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:727
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:731
msgid ":ref:`SELECT <box_space-select>`: Retrieve the tuple."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:733
msgid "The clause \"{999}\" is still mandatory, although it does not have to mention the primary key."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:736
msgid "tarantool> box.space.tester:select{999}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:740
msgid ":ref:`DELETE <box_space-delete>`: Delete the tuple."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:742
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:744
msgid "tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:748
msgid "Summarizing the examples:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:750
msgid "Functions ``insert`` and ``replace`` accept a tuple (where a primary key comes as part of the tuple)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:752
msgid "Function ``upsert`` accepts a tuple (where a primary key comes as part of the tuple), and also the update operations to execute."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:755
msgid "Function ``delete`` accepts a full key of any unique index (primary or secondary)."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:757
msgid "Function ``update`` accepts a full key of any unique index (primary or secondary), and also the operations to execute."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:760
msgid "Function ``select`` accepts any key: primary/secondary, unique/non-unique, full/partial."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:763
msgid "See reference on ``box.space`` for more :ref:`details on using data operations <box_space-operations-detailed-examples>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:768
msgid "Besides Lua, you can use :ref:`Perl, PHP, Python or other programming language connectors <index-box_connectors>`. The client server protocol is open and documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:777
msgid "Index operations"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:779
msgid "Index operations are automatic: if a data-manipulation request changes a tuple, then it also changes the index keys defined for the tuple."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:782
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:787
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:789
msgid "This creates a unique TREE index on the first field of all tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:792
msgid "The simple SELECT request that we've illustrated before is:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:797
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:799
msgid "This looks for a single tuple via the first index. Since the first index is always unique, the maximum number of returned tuples will be: one."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:802
msgid "The following SELECT variations exist:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:804
msgid "The search can use comparisons other than equality."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:811
msgid "The :ref:`comparison operators <box_index-iterator-types>` are LT, LE, EQ, REQ, GE, GT (for \"less than\", \"less than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", \"greater than\" respectively). Comparisons make sense if and only if the index type is ‘TREE'."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:816
msgid "This type of search may return more than one tuple; if so, the tuples will be in descending order by key when the comparison operator is LT or LE or REQ, otherwise in ascending order."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:820
msgid "The search can use a secondary index."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:827
msgid "For a primary-key search, it is optional to specify an index name. For a secondary-key search, it is mandatory."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:830
msgid "The search may be for some or all key parts."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:851
msgid "The search may be for all fields, using a table for the value:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:858
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:865
msgid "In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:868
msgid "You can specify even zero fields, causing all three tuples to be returned. (Notice that partial key searches are available only in TREE indexes.)"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:871
msgid "**Examples**"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:873
msgid "BITSET example:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:875
msgid "tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, {iterator='BITS_ANY_SET'})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:886
#: ../doc/2.2/book/box/data_model.rst:908
#: ../doc/2.2/tutorials/lua_tutorials.rst:877
#: ../doc/2.2/tutorials/sql_tutorial.rst:152
#: ../doc/2.2/tutorials/sql_tutorial.rst:172
#: ../doc/2.2/tutorials/sql_tutorial.rst:234
#: ../doc/2.2/tutorials/sql_tutorial.rst:263
#: ../doc/2.2/tutorials/sql_tutorial.rst:306
#: ../doc/2.2/tutorials/sql_tutorial.rst:356
#: ../doc/2.2/tutorials/sql_tutorial.rst:455
#: ../doc/2.2/tutorials/sql_tutorial.rst:543
#: ../doc/2.2/tutorials/sql_tutorial.rst:570
msgid "The result will be:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:888
msgid "---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:895
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:897
msgid "RTREE example:"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:899
msgid "tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = 'GT'})"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:910
msgid "---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:916
msgid "because a rectangle whose corners are at coordinates ``4,7,5,9`` is entirely within a rectangle whose corners are at coordinates ``3,5,9,10``."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:919
msgid "Additionally, there exist :ref:`index iterator operations <box_index-index_pairs>`. They can only be used with code in Lua and C/C++. Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:925
msgid "See also other index operations like :ref:`alter() <box_index-alter>` and :ref:`drop() <box_index-drop>` in reference for :ref:`box.index <box_index>` submodule."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:930
msgid "Complexity factors"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:932
msgid "In reference for :ref:`box.space <box_space>` and :ref:`box.index <box_index>` submodules, there are notes about which complexity factors might affect the resource usage of each function."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:944
msgid "Complexity factor"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:947
msgid "Index size"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:947
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys, then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys, then there is more RAM used, but the number of low-level steps tends to remain constant."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:955
msgid "Typically, a HASH index is faster than a TREE index if the number of tuples in the space is greater than one."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:959
msgid "Number of indexes accessed"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:959
msgid "Ordinarily, only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the space has N different indexes."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:963
msgid "Note re storage engine: Vinyl optimizes away such accesses if secondary index fields are unchanged by the update. So, this complexity factor applies only to memtx, since it always makes a full-tuple copy on every update."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:969
msgid "Number of tuples accessed"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:969
msgid "A few requests, for example SELECT, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:973
msgid "WAL settings"
msgstr ""

#: ../doc/2.2/book/box/data_model.rst:973
msgid "The important setting for the write-ahead log is :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:39
msgid "Storage engines"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:41
msgid "A storage engine is a set of very-low-level routines which actually store and retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:44
msgid "memtx (the in-memory storage engine) is the default and was the first to arrive."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:47
msgid "vinyl (the on-disk storage engine) is a working key-value engine and will especially appeal to users who like to see data go directly to disk, so that recovery time might be shorter and database size might be larger."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:51
msgid "On the other hand, vinyl lacks some functions and options that are available with memtx. Where that is the case, the relevant description in this manual contains a note beginning with the words \"Note re storage engine\"."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:55
msgid "Further in this section we discuss the details of storing data using the vinyl storage engine."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:58
msgid "To specify that the engine should be vinyl, add the clause ``engine = 'vinyl'`` when creating a space, for example:"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:61
msgid "space = box.schema.space.create('name', {engine='vinyl'})"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:69
msgid "Differences between memtx and vinyl storage engines"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:71
msgid "The primary difference between memtx and vinyl is that memtx is an \"in-memory\" engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is generally faster (each query is usually run under 1 ms), and the memtx engine is justifiably the default for Tarantool, but on-disk engine such as vinyl is preferable when the database is larger than the available memory and adding more memory is not a realistic option."
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:84
#: ../doc/2.2/reference/configuration/cfg_basic.rst:123
msgid "Option"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:84
msgid "memtx"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:84
msgid "vinyl"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:86
msgid "Supported index type"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:86
msgid "TREE, HASH, :ref:`RTREE <box_index-rtree>` or BITSET"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:86
msgid "TREE"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:88
msgid "Temporary spaces"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:88
#: ../doc/2.2/book/box/engines/index.rst:90
#: ../doc/2.2/book/box/engines/index.rst:92
msgid "Supported"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:88
#: ../doc/2.2/book/box/engines/index.rst:90
msgid "Not supported"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:90
msgid ":ref:`random() <box_index-random>` function"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:92
msgid ":ref:`alter() <box_index-alter>` function"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:92
msgid "Supported starting from the 1.10.2 release (the primary index cannot be modified)"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:95
msgid ":ref:`len() <box_space-len>` function"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:95
msgid "Returns the number of tuples in the space"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:95
msgid "Returns the maximum approximate number of tuples in the space"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:98
msgid ":ref:`count() <box_index-count>` function"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:98
msgid "Takes a constant amount of time"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:98
msgid "Takes a variable amount of time depending on a state of a DB"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:101
msgid ":ref:`delete() <box_space-delete>` function"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:101
msgid "Returns the deleted tuple, if any"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:101
msgid "Always returns nil"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:103
msgid "yield"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:103
msgid "Does not yield on the select requests unless the transaction is commited to WAL"
msgstr ""

#: ../doc/2.2/book/box/engines/index.rst:103
msgid "Yields on the select requests or on its equivalents: get() or pairs()"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:5
msgid "Storing data with vinyl"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:7
msgid "Tarantool is a transactional and persistent DBMS that maintains 100% of its data in RAM. The greatest advantages of in-memory databases are their speed and ease of use: they demonstrate consistently high performance, but you never need to tune them."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:12
msgid "A few years ago we decided to extend the product by implementing a classical storage engine similar to those used by regular DBMSes: it uses RAM for caching, while the bulk of its data is stored on disk. We decided to make it possible to set a storage engine independently for each table in the database, which is the same way that MySQL approaches it, but we also wanted to support transactions from the very beginning."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:19
msgid "The first question we needed to answer was whether to create our own storage engine or use an existing library. The open-source community offered a few viable solutions. The RocksDB library was the fastest growing open-source library and is currently one of the most prominent out there. There were also several lesser-known libraries to consider, such as WiredTiger, ForestDB, NestDB, and LMDB."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:26
msgid "Nevertheless, after studying the source code of existing libraries and considering the pros and cons, we opted for our own storage engine. One reason is that the existing third-party libraries expected requests to come from multiple operating system threads and thus contained complex synchronization primitives for controlling parallel data access. If we had decided to embed one of these in Tarantool, we would have made our users bear the overhead of a multithreaded application without getting anything in return. The thing is, Tarantool has an actor-based architecture. The way it processes transactions in a dedicated thread allows it to do away with the unnecessary locks, interprocess communication, and other overhead that accounts for up to 80% of processor time in multithreaded DBMSes."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:41
msgid "*The Tarantool process consists of a fixed number of \"actor\" threads*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:43
msgid "If you design a database engine with cooperative multitasking in mind right from the start, it not only significantly speeds up the development process, but also allows the implementation of certain optimization tricks that would be too complex for multithreaded engines. In short, using a third-party solution wouldn’t have yielded the best result."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:53
msgid "Algorithm"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:55
msgid "Once the idea of using an existing library was off the table, we needed to pick an architecture to build upon. There are two competing approaches to on-disk data storage: the older one relies on B-trees and their variations; the newer one advocates the use of log-structured merge-trees, or \"LSM\" trees. MySQL, PostgreSQL, and Oracle use B-trees, while Cassandra, MongoDB, and CockroachDB have adopted LSM trees."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:62
msgid "B-trees are considered better suited for reads and LSM trees—for writes. However, with SSDs becoming more widespread and the fact that SSDs have read throughput that’s several times greater than write throughput, the advantages of LSM trees in most scenarios was more obvious to us."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:67
msgid "Before dissecting LSM trees in Tarantool, let’s take a look at how they work. To do that, we’ll begin by analyzing a regular B-tree and the issues it faces. A B-tree is a balanced tree made up of blocks, which contain sorted lists of key- value pairs. (Topics such as filling and balancing a B-tree or splitting and merging blocks are outside of the scope of this article and can easily be found on Wikipedia). As a result, we get a container sorted by key, where the smallest element is stored in the leftmost node and the largest one in the rightmost node. Let’s have a look at how insertions and searches in a B-tree happen."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:78
msgid "*Classical B-tree*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:80
msgid "If you need to find an element or check its membership, the search starts at the root, as usual. If the key is found in the root block, the search stops; otherwise, the search visits the rightmost block holding the largest element that’s not larger than the key being searched (recall that elements at each level are sorted). If the first level yields no results, the search proceeds to the next level. Finally, the search ends up in one of the leaves and probably locates the needed key. Blocks are stored and read into RAM one by one, meaning the algorithm reads :math:`logB(N)` blocks in a single search, where N is the number of elements in the B-tree. In the simplest case, writes are done similarly: the algorithm finds the block that holds the necessary element and updates (inserts) its value."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:92
msgid "To better understand the data structure, let’s consider a practical example: say we have a B-tree with 100,000,000 nodes, a block size of 4096 bytes, and an element size of 100 bytes. Thus each block will hold up to 40 elements (all overhead considered), and the B-tree will consist of around 2,570,000 blocks and 5 levels: the first four will have a size of 256 Mb, while the last one will grow up to 10 Gb. Obviously, any modern computer will be able to store all of the levels except the last one in filesystem cache, so read requests will require just a single I/O operation."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:101
msgid "But if we change our perspective —B-trees don’t look so good anymore. Suppose we need to update a single element. Since working with B-trees involves reading and writing whole blocks, we would have to read in one whole block, change our 100 bytes out of 4096, and then write the whole updated block to disk. In other words,we were forced to write 40 times more data than we actually modified!"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:108
msgid "If you take into account the fact that an SSD block has a size of 64 Kb+ and not every modification changes a whole element, the extra disk workload can be greater still."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:113
msgid "Authors of specialized literature and blogs dedicated to on-disk data storage have coined two terms for these phenomena: extra reads are referred to as \"read amplification\" and writes as \"write amplification\"."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:117
msgid "The amplification factor (multiplication coefficient) is calculated as the ratio of the size of actual read (or written) data to the size of data needed (or actually changed). In our B-tree example, the amplification factor would be around 40 for both reads and writes."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:123
msgid "The huge number of extra I/O operations associated with updating data is one of the main issues addressed by LSM trees. Let’s see how they work."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:127
msgid "The key difference between LSM trees and regular B-trees is that LSM trees don’t just store data (keys and values), but also data operations: insertions and deletions."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:133
#: ../doc/2.2/book/box/engines/vinyl.rst:189
#: ../doc/2.2/book/box/engines/vinyl.rst:204
#: ../doc/2.2/book/box/engines/vinyl.rst:226
#: ../doc/2.2/book/box/engines/vinyl.rst:278
#: ../doc/2.2/book/box/engines/vinyl.rst:303
#: ../doc/2.2/book/box/engines/vinyl.rst:640
#: ../doc/2.2/book/box/engines/vinyl.rst:792
#: ../doc/2.2/reference/reference_sql/sql.rst:51
#: ../doc/2.2/reference/reference_sql/sql.rst:56
#: ../doc/2.2/reference/reference_sql/sql.rst:134
#: ../doc/2.2/reference/reference_sql/sql.rst:139
#: ../doc/2.2/reference/reference_sql/sql.rst:232
#: ../doc/2.2/reference/reference_sql/sql.rst:548
#: ../doc/2.2/reference/reference_sql/sql.rst:553
#: ../doc/2.2/reference/reference_sql/sql.rst:597
#: ../doc/2.2/reference/reference_sql/sql.rst:602
#: ../doc/2.2/reference/reference_sql/sql.rst:652
#: ../doc/2.2/reference/reference_sql/sql.rst:657
#: ../doc/2.2/reference/reference_sql/sql.rst:694
#: ../doc/2.2/reference/reference_sql/sql.rst:699
#: ../doc/2.2/reference/reference_sql/sql.rst:770
#: ../doc/2.2/reference/reference_sql/sql.rst:775
#: ../doc/2.2/reference/reference_sql/sql.rst:811
#: ../doc/2.2/reference/reference_sql/sql.rst:816
#: ../doc/2.2/reference/reference_sql/sql.rst:883
#: ../doc/2.2/reference/reference_sql/sql.rst:888
#: ../doc/2.2/reference/reference_sql/sql.rst:959
#: ../doc/2.2/reference/reference_sql/sql.rst:964
#: ../doc/2.2/reference/reference_sql/sql.rst:1011
#: ../doc/2.2/reference/reference_sql/sql.rst:1016
#: ../doc/2.2/reference/reference_sql/sql.rst:1061
#: ../doc/2.2/reference/reference_sql/sql.rst:1066
#: ../doc/2.2/reference/reference_sql/sql.rst:1388
#: ../doc/2.2/reference/reference_sql/sql.rst:1393
#: ../doc/2.2/reference/reference_sql/sql.rst:1427
#: ../doc/2.2/reference/reference_sql/sql.rst:1432
#: ../doc/2.2/reference/reference_sql/sql.rst:1478
#: ../doc/2.2/reference/reference_sql/sql.rst:1483
#: ../doc/2.2/reference/reference_sql/sql.rst:1500
#: ../doc/2.2/reference/reference_sql/sql.rst:1505
#: ../doc/2.2/reference/reference_sql/sql.rst:1562
#: ../doc/2.2/reference/reference_sql/sql.rst:1567
#: ../doc/2.2/reference/reference_sql/sql.rst:1617
#: ../doc/2.2/reference/reference_sql/sql.rst:1622
#: ../doc/2.2/reference/reference_sql/sql.rst:1657
#: ../doc/2.2/reference/reference_sql/sql.rst:1662
#: ../doc/2.2/reference/reference_sql/sql.rst:1809
#: ../doc/2.2/reference/reference_sql/sql.rst:1814
#: ../doc/2.2/reference/reference_sql/sql.rst:1862
#: ../doc/2.2/reference/reference_sql/sql.rst:1867
#: ../doc/2.2/reference/reference_sql/sql.rst:1966
#: ../doc/2.2/reference/reference_sql/sql.rst:1971
#: ../doc/2.2/reference/reference_sql/sql.rst:2011
#: ../doc/2.2/reference/reference_sql/sql.rst:2016
#: ../doc/2.2/reference/reference_sql/sql.rst:2108
#: ../doc/2.2/reference/reference_sql/sql.rst:2113
#: ../doc/2.2/reference/reference_sql/sql.rst:2178
#: ../doc/2.2/reference/reference_sql/sql.rst:2183
#: ../doc/2.2/reference/reference_sql/sql.rst:2253
#: ../doc/2.2/reference/reference_sql/sql.rst:2258
#: ../doc/2.2/reference/reference_sql/sql.rst:2263
#: ../doc/2.2/reference/reference_sql/sql.rst:2268
#: ../doc/2.2/reference/reference_sql/sql.rst:2336
#: ../doc/2.2/reference/reference_sql/sql.rst:2341
#: ../doc/2.2/reference/reference_sql/sql.rst:2401
#: ../doc/2.2/reference/reference_sql/sql.rst:2406
#: ../doc/2.2/reference/reference_sql/sql.rst:2470
#: ../doc/2.2/reference/reference_sql/sql.rst:2475
#: ../doc/2.2/reference/reference_sql/sql.rst:2499
#: ../doc/2.2/reference/reference_sql/sql.rst:2504
#: ../doc/2.2/reference/reference_sql/sql.rst:2529
#: ../doc/2.2/reference/reference_sql/sql.rst:2534
#: ../doc/2.2/reference/reference_sql/sql.rst:2558
#: ../doc/2.2/reference/reference_sql/sql.rst:2563
msgid "|br|"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:135
msgid "LSM tree:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:140
msgid "Stores statements, not values:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:142
msgid "Every statement is marked by LSN Append-only files, garbage is collected after a checkpoint"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:144
msgid "Transactional log of all filesystem changes: vylog"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:146
msgid "For example, an element corresponding to an insertion operation has, apart from a key and a value, an extra byte with an operation code (\"REPLACE\" in the image above). An element representing the deletion operation contains a key (since storing a value is unnecessary) and the corresponding operation code—\"DELETE\". Also, each LSM tree element has a log sequence number (LSN), which is the value of a monotonically increasing sequence that uniquely identifies each operation. The whole tree is first ordered by key in ascending order, and then, within a single key scope, by LSN in descending order."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:157
msgid "*A single level of an LSM tree*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:163
msgid "Filling an LSM tree"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:165
msgid "Unlike a B-tree, which is stored completely on disk and can be partly cached in RAM, when using an LSM tree, memory is explicitly separated from disk right from the start. The issue of volatile memory and data persistence is beyond the scope of the storage algorithm and can be solved in various ways—for example, by logging changes."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:171
msgid "The part of an LSM tree that’s stored in RAM is called L0 (level zero). The size of RAM is limited, so L0 is allocated a fixed amount of memory. For example, in Tarantool, the L0 size is controlled by the ``vinyl_memory`` parameter. Initially, when an LSM tree is empty, operations are written to L0. Recall that all elements are ordered by key in ascending order, and then within a single key scope, by LSN in descending order, so when a new value associated with a given key gets inserted, it’s easy to locate the older value and delete it. L0 can be structured as any container capable of storing a sorted sequence of elements. For example, in Tarantool, L0 is implemented as a B+*-tree. Lookups and insertions are standard operations for the data structure underlying L0, so I won’t dwell on those."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:183
msgid "Sooner or later the number of elements in an LSM tree exceeds the L0 size and that’s when L0 gets written to a file on disk (called a \"run\") and then cleared for storing new elements. This operation is called a \"dump\"."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:191
msgid "Dumps on disk form a sequence ordered by LSN: LSN ranges in different runs don’t overlap, and the leftmost runs (at the head of the sequence) hold newer operations. Think of these runs as a pyramid, with the newest ones closer to the top. As runs keep getting dumped, the pyramid grows higher. Note that newer runs may contain deletions or replacements for existing keys. To remove older data, it’s necessary to perform garbage collection (this process is sometimes called \"merge\" or \"compaction\") by combining several older runs into a new one. If two versions of the same key are encountered during a compaction, only the newer one is retained; however, if a key insertion is followed by a deletion, then both operations can be discarded."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:206
msgid "The key choices determining an LSM tree’s efficiency are which runs to compact and when to compact them. Suppose an LSM tree stores a monotonically increasing sequence of keys (1, 2, 3, ...,) with no deletions. In this case, compacting runs would be useless: all of the elements are sorted, the tree doesn’t have any garbage, and the location of any key can unequivocally be determined. On the other hand, if an LSM tree contains many deletions, doing a compaction would free up some disk space. However, even if there are no deletions, but key ranges in different runs overlap a lot, compacting such runs could speed up lookups as there would be fewer runs to scan. In this case, it might make sense to compact runs after each dump. But keep in mind that a compaction causes all data stored on disk to be overwritten, so with few reads it’s recommended to perform it less often."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:219
msgid "To ensure it’s optimally configurable for any of the scenarios above, an LSM tree organizes all runs into a pyramid: the newer the data operations, the higher up the pyramid they are located. During a compaction, the algorithm picks two or more neighboring runs of approximately equal size, if possible."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:228
msgid "Multi-level compaction can span any number of levels"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:229
msgid "A level can contain multiple runs"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:231
msgid "All of the neighboring runs of approximately equal size constitute an LSM tree level on disk. The ratio of run sizes at different levels determines the pyramid’s proportions, which allows optimizing the tree for write-intensive or read-intensive scenarios."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:236
msgid "Suppose the L0 size is 100 Mb, the ratio of run sizes at each level (the ``vinyl_run_size_ratio`` parameter) is 5, and there can be no more than 2 runs per level (the ``vinyl_run_count_per_level`` parameter). After the first 3 dumps, the disk will contain 3 runs of 100 Mb each—which constitute L1 (level one). Since 3 > 2, the runs will be compacted into a single 300 Mb run, with the older ones being deleted. After 2 more dumps, there will be another compaction, this time of 2 runs of 100 Mb each and the 300 Mb run, which will produce one 500 Mb run. It will be moved to L2 (recall that the run size ratio is 5), leaving L1 empty. The next 10 dumps will result in L2 having 3 runs of 500 Mb each, which will be compacted into a single 1500 Mb run. Over the course of 10 more dumps, the following will happen: 3 runs of 100 Mb each will be compacted twice, as will two 100 Mb runs and one 300 Mb run, which will yield 2 new 500 Mb runs in L2. Since L2 now has 3 runs, they will also be compacted: two 500 Mb runs and one 1500 Mb run will produce a 2500 Mb run that will be moved to L3, given its size."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:251
msgid "This can go on infinitely, but if an LSM tree contains lots of deletions, the resulting compacted run can be moved not only down, but also up the pyramid due to its size being smaller than the sizes of the original runs that were compacted. In other words, it’s enough to logically track which level a certain run belongs to, based on the run size and the smallest and greatest LSN among all of its operations."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:262
msgid "Controlling the form of an LSM tree"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:264
msgid "If it’s necessary to reduce the number of runs for lookups, then the run size ratio can be increased, thus bringing the number of levels down. If, on the other hand, you need to minimize the compaction-related overhead, then the run size ratio can be decreased: the pyramid will grow higher, and even though runs will be compacted more often, they will be smaller, which will reduce the total amount of work done. In general, write amplification in an LSM tree is described by this formula: :math:`log_{x}(\\frac {N} {L0}) × x` or, alternatively, :math:`x × \\frac {ln (\\frac {N} {C0})} {ln(x)}`, where N is the total size of all tree elements, L0 is the level zero size, and x is the level size ratio (the ``level_size_ratio`` parameter). At :math:`\\frac {N} {C0}` = 40 (the disk-to- memory ratio), the plot would look something like this:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:280
msgid "As for read amplification, it’s proportional to the number of levels. The lookup cost at each level is no greater than that for a B-tree. Getting back to the example of a tree with 100,000,000 elements: given 256 Mb of RAM and the default values of ``vinyl_level_size_ratio`` and ``run_count_per_level``, write amplification would come out to about 13, while read amplification could be as high as 150. Let’s try to figure out why this happens."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:291
msgid "Search"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:293
msgid "When doing a lookup in an LSM tree, what we need to find is not the element itself, but the most recent operation associated with it. If it’s a deletion, then the tree doesn’t contain this element. If it’s an insertion, we need to grab the topmost value in the pyramid, and the search can be stopped after finding the first matching key. In the worst-case scenario, that is if the tree doesn’t hold the needed element, the algorithm will have to sequentially visit all of the levels, starting from L0."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:305
msgid "Unfortunately, this scenario is quite common in real life. For example, when inserting a value into a tree, it’s necessary to make sure there are no duplicates among primary/unique keys. So to speed up membership checks, LSM trees use a probabilistic data structure called a \"Bloom filter\", which will be covered a bit later, in a section on how vinyl works under the hood."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:315
msgid "Range searching"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:317
msgid "In the case of a single-key search, the algorithm stops after encountering the first match. However, when searching within a certain key range (for example, looking for all the users with the last name \"Ivanov\"), it’s necessary to scan all tree levels."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:324
msgid "*Searching within a range of [24,30)*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:326
msgid "The required range is formed the same way as when compacting several runs: the algorithm picks the key with the largest LSN out of all the sources, ignoring the other associated operations, then moves on to the next key and repeats the procedure."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:335
msgid "Deletion"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:337
msgid "Why would one store deletions? And why doesn’t it lead to a tree overflow in the case of for i=1,10000000 put(i) delete(i) end?"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:340
msgid "With regards to lookups, deletions signal the absence of a value being searched; with compactions, they clear the tree of \"garbage\" records with older LSNs."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:343
msgid "While the data is in RAM only, there’s no need to store deletions. Similarly, you don’t need to keep them following a compaction if they affect, among other things, the lowest tree level, which contains the oldest dump. Indeed, if a value can’t be found at the lowest level, then it doesn’t exist in the tree."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:348
msgid "We can't delete from append-only files"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:349
msgid "Tombstones (delete markers) are inserted into L0 instead"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:353
msgid "*Deletion, step 1: a tombstone is inserted into L0*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:357
msgid "*Deletion, step 2: the tombstone passes through intermediate levels*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:361
msgid "*Deletion, step 3: in the case of a major compaction, the tombstone is removed from the tree*"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:363
msgid "If a deletion is known to come right after the insertion of a unique value, which is often the case when modifying a value in a secondary index, then the deletion can safely be filtered out while compacting intermediate tree levels. This optimization is implemented in vinyl."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:372
msgid "Advantages of an LSM tree"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:374
msgid "Apart from decreasing write amplification, the approach that involves periodically dumping level L0 and compacting levels L1-Lk has a few advantages over the approach to writes adopted by B-trees:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:378
msgid "Dumps and compactions write relatively large files: typically, the L0 size is 50-100 Mb, which is thousands of times larger than the size of a B-tree block."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:381
msgid "This large size allows efficiently compressing data before writing it. Tarantool compresses data automatically, which further decreases write amplification."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:384
msgid "There is no fragmentation overhead, since there’s no padding/empty space between the elements inside a run."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:386
msgid "All operations create new runs instead of modifying older data in place. This allows avoiding those nasty locks that everyone hates so much. Several operations can run in parallel without causing any conflicts. This also simplifies making backups and moving data to replicas."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:391
msgid "Storing older versions of data allows for the efficient implementation of transaction support by using multiversion concurrency control."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:399
msgid "Disadvantages of an LSM tree and how to deal with them"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:401
msgid "One of the key advantages of the B-tree as a search data structure is its predictability: all operations take no longer than :math:`log_{B}(N)` to run. Conversely, in a classical LSM tree, both read and write speeds can differ by a factor of hundreds (best case scenario) or even thousands (worst case scenario). For example, adding just one element to L0 can cause it to overflow, which can trigger a chain reaction in levels L1, L2, and so on. Lookups may find the needed element in L0 or may need to scan all of the tree levels. It’s also necessary to optimize reads within a single level to achieve speeds comparable to those of a B-tree. Fortunately, most disadvantages can be mitigated or even eliminated with additional algorithms and data structures. Let’s take a closer look at these disadvantages and how they’re dealt with in Tarantool."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:417
msgid "Unpredictable write speed"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:419
msgid "In an LSM tree, insertions almost always affect L0 only. How do you avoid idle time when the memory area allocated for L0 is full?"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:422
msgid "Clearing L0 involves two lengthy operations: writing to disk and memory deallocation. To avoid idle time while L0 is being dumped, Tarantool uses writeaheads. Suppose the L0 size is 256 Mb. The disk write speed is 10 Mbps. Then it would take 26 seconds to dump L0. The insertion speed is 10,000 RPS, with each key having a size of 100 bytes. While L0 is being dumped, it’s necessary to reserve 26 Mb of RAM, effectively slicing the L0 size down to 230 Mb."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:430
msgid "Tarantool does all of these calculations automatically, constantly updating the rolling average of the DBMS workload and the histogram of the disk speed. This allows using L0 as efficiently as possible and it prevents write requests from timing out. But in the case of workload surges, some wait time is still possible. That’s why we also introduced an insertion timeout (the ``vinyl_timeout`` parameter), which is set to 60 seconds by default. The write operation itself is executed in dedicated threads. The number of these threads (2 by default) is controlled by the ``vinyl_write_threads`` parameter. The default value of 2 allows doing dumps and compactions in parallel, which is also necessary for ensuring system predictability."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:441
msgid "In Tarantool, compactions are always performed independently of dumps, in a separate execution thread. This is made possible by the append-only nature of an LSM tree: after dumps runs are never changed, and compactions simply create new runs."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:446
msgid "Delays can also be caused by L0 rotation and the deallocation of memory dumped to disk: during a dump, L0 memory is owned by two operating system threads, a transaction processing thread and a write thread. Even though no elements are being added to the rotated L0, it can still be used for lookups. To avoid read locks when doing lookups, the write thread doesn’t deallocate the dumped memory, instead delegating this task to the transaction processor thread. Following a dump, memory deallocation itself happens instantaneously: to achieve this, L0 uses a special allocator that deallocates all of the memory with a single operation."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:458
msgid "anticipatory dump"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:459
msgid "throttling"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:461
msgid "The dump is performed from the so-called \"shadow\" L0 without blocking new insertions and lookups"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:468
msgid "Unpredictable read speed"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:470
msgid "Optimizing reads is the most difficult optimization task with regards to LSM trees. The main complexity factor here is the number of levels: any optimization causes not only much slower lookups, but also tends to require significantly larger RAM resources. Fortunately, the append-only nature of LSM trees allows us to address these problems in ways that would be nontrivial for traditional data structures."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:479
msgid "page index"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:480
msgid "bloom filters"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:481
msgid "tuple range cache"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:482
msgid "multi-level compaction"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:488
msgid "Compression and page index"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:490
msgid "In B-trees, data compression is either the hardest problem to crack or a great marketing tool—rather than something really useful. In LSM trees, compression works as follows:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:494
msgid "During a dump or compaction all of the data within a single run is split into pages. The page size (in bytes) is controlled by the ``vinyl_page_size`` parameter and can be set separately for each index. A page doesn’t have to be exactly of ``vinyl_page_size`` size—depending on the data it holds, it can be a little bit smaller or larger. Because of this, pages never have any empty space inside."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:501
msgid "Data is compressed by `Facebook’s streaming algorithm <https://github.com/facebook/zstd>`_ called \"zstd\". The first key of each page, along with the page offset, is added to a \"page index\", which is a separate file that allows the quick retrieval of any page. After a dump or compaction, the page index of the created run is also written to disk."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:508
msgid "All `.index` files are cached in RAM, which allows finding the necessary page with a single lookup in a `.run` file (in vinyl, this is the extension of files resulting from a dump or compaction). Since data within a page is sorted, after it’s read and decompressed, the needed key can be found using a regular binary search. Decompression and reads are handled by separate threads, and are controlled by the ``vinyl_read_threads`` parameter."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:515
msgid "Tarantool uses a universal file format: for example, the format of a `.run` file is no different from that of an `.xlog` file (log file). This simplifies backup and recovery as well as the usage of external tools."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:523
msgid "Bloom filters"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:525
msgid "Even though using a page index enables scanning fewer pages per run when doing a lookup, it’s still necessary to traverse all of the tree levels. There’s a special case, which involves checking if particular data is absent when scanning all of the tree levels and it’s unavoidable: I’m talking about insertions into a unique index. If the data being inserted already exists, then inserting the same data into a unique index should lead to an error. The only way to throw an error in an LSM tree before a transaction is committed is to do a search before inserting the data. Such reads form a class of their own in the DBMS world and are called \"hidden\" or \"parasitic\" reads."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:535
msgid "Another operation leading to hidden reads is updating a value in a field on which a secondary index is defined. Secondary keys are regular LSM trees that store differently ordered data. In most cases, in order not to have to store all of the data in all of the indexes, a value associated with a given key is kept in whole only in the primary index (any index that stores both a key and a value is called \"covering\" or \"clustered\"), whereas the secondary index only stores the fields on which a secondary index is defined, and the values of the fields that are part of the primary index. Thus, each time a change is made to a value in a field on which a secondary index is defined, it’s necessary to first remove the old key from the secondary index—and only then can the new key be inserted. At update time, the old value is unknown, and it is this value that needs to be read in from the primary key \"under the hood\"."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:550
msgid "update t1 set city=’Moscow’ where id=1"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:554
msgid "To minimize the number of disk reads, especially for nonexistent data, nearly all LSM trees use probabilistic data structures, and Tarantool is no exception. A classical Bloom filter is made up of several (usually 3-to-5) bit arrays. When data is written, several hash functions are calculated for each key in order to get corresponding array positions. The bits at these positions are then set to 1. Due to possible hash collisions, some bits might be set to 1 twice. We’re most interested in the bits that remain 0 after all keys have been added. When looking for an element within a run, the same hash functions are applied to produce bit positions in the arrays. If any of the bits at these positions is 0, then the element is definitely not in the run. The probability of a false positive in a Bloom filter is calculated using Bayes’ theorem: each hash function is an independent random variable, so the probability of a collision simultaneously occurring in all of the bit arrays is infinitesimal."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:568
msgid "The key advantage of Bloom filters in Tarantool is that they’re easily configurable. The only parameter that can be specified separately for each index is called ``bloom_fpr`` (FPR stands for \"false positive ratio\") and it has the default value of 0.05, which translates to a 5% FPR. Based on this parameter, Tarantool automatically creates Bloom filters of the optimal size for partial- key and full-key searches. The Bloom filters are stored in the `.index` file, along with the page index, and are cached in RAM."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:580
msgid "Caching"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:582
msgid "A lot of people think that caching is a silver bullet that can help with any performance issue. \"When in doubt, add more cache\". In vinyl, caching is viewed rather as a means of reducing the overall workload and consequently, of getting a more stable response time for those requests that don’t hit the cache. vinyl boasts a unique type of cache among transactional systems called a \"range tuple cache\". Unlike, say, RocksDB or MySQL, this cache doesn’t store pages, but rather ranges of index values obtained  from disk, after having performed a compaction spanning all tree levels. This allows the use of caching for both single-key and key-range searches. Since this method of caching stores only hot data and not, say, pages (you may need only some data from a page), RAM is used in the most efficient way possible. The cache size is controlled by the ``vinyl_cache`` parameter."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:599
msgid "Garbage collection control"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:601
msgid "Chances are that by now you’ve started losing focus and need a well-deserved dopamine reward. Feel free to take a break, since working through the rest of the article is going to take some serious mental effort."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:605
msgid "An LSM tree in vinyl is just a small piece of the puzzle. Even with a single table (or so-called \"space\"), vinyl creates and maintains several LSM trees, one for each index. But even a single index can be comprised of dozens of LSM trees. Let’s try to understand why this might be necessary."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:610
msgid "Recall our example with a tree containing 100,000,000 records, 100 bytes each. As time passes, the lowest LSM level may end up holding a 10 Gb run. During compaction, a temporary run of approximately the same size will be created. Data at intermediate levels takes up some space as well, since the tree may store several operations associated with a single key. In total, storing 10 Gb of actual data may require up to 30 Gb of free space: 10 Gb for the last tree level, 10 Gb for a temporary run, and 10 Gb for the remaining data. But what if the data size is not 10 Gb, but 1 Tb? Requiring that the available disk space always be several times greater than the actual data size is financially unpractical, not to mention that it may take dozens of hours to create a 1 Tb run. And in the case of an emergency shutdown or system restart, the process would have to be started from scratch."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:623
msgid "Here’s another scenario. Suppose the primary key is a monotonically increasing sequence—for example, a time series. In this case, most insertions will fall into the right part of the key range, so it wouldn’t make much sense to do a compaction just to append a few million more records to an already huge run."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:628
msgid "But what if writes predominantly occur in a particular region of the key range, whereas most reads take place in a different region? How do you optimize the form of the LSM tree in this case? If it’s too high, read performance is impacted; if it’s too low—write speed is reduced."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:633
msgid "Tarantool \"factorizes\" this problem by creating multiple LSM trees for each index. The approximate size of each subtree may be controlled by the :ref:`vinyl_range_size <cfg_storage-vinyl_range_size>` configuration parameter. We call such subtrees \"ranges\"."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:642
msgid "Factorizing large LSM trees via ranging"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:644
msgid "Ranges reflect a static layout of sorted runs"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:645
msgid "Slices connect a sorted run into a range"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:649
msgid "Initially, when the index has few elements, it consists of a single range. As more elements are added, its total size may exceed :ref:`the maximum range size <cfg_storage-vinyl_range_size>`. In that case a special operation called \"split\" divides the tree into two equal parts. The tree is split at the middle element in the range of keys stored in the tree. For example, if  the tree initially stores the full range of -inf…+inf, then after splitting it at the middle key X, we get two subtrees: one that stores the range of -inf...X, and the other storing the range of X…+inf. With this approach, we always know which subtree to use for writes and which one for reads. If the tree contained deletions and each of the neighboring ranges grew smaller as a result, the opposite operation called \"coalesce\" combines two neighboring trees into one."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:662
msgid "Split and coalesce don’t entail a compaction, the creation of new runs, or other resource-intensive operations. An LSM tree is just a collection of runs. vinyl has a special metadata log that helps keep track of which run belongs to which subtree(s). This has the `.vylog` extension and its format is compatible with an .xlog file. Similarly to an `.xlog` file, the metadata log gets rotated at each checkpoint. To avoid the creation of extra runs with split and coalesce, we have also introduced an auxiliary entity called \"slice\". It’s a reference to a run containing a key range and it’s stored only in the metadata log. Once the reference counter drops to zero, the corresponding file gets removed. When it’s necessary to perform a split or to coalesce, Tarantool creates slice objects for each new tree, removes older slices, and writes these operations to the metadata log, which literally stores records that look like this: ``<tree id, slice id>`` or ``<slice id, run id, min, max>``."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:676
msgid "This way all of the heavy lifting associated with splitting a tree into two subtrees is postponed until a compaction and then is performed automatically. A huge advantage of dividing all of the keys into ranges is the ability to independently control the L0 size as well as the dump and compaction processes for each subtree, which makes these processes manageable and predictable. Having a separate metadata log also simplifies the implementation of both \"truncate\" and \"drop\". In vinyl, they’re processed instantly, since they only work with the metadata log, while garbage collection is done in the background."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:689
msgid "Advanced features of vinyl"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:695
msgid "Upsert"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:697
msgid "In the previous sections, we mentioned only two operations stored by an LSM tree: deletion and replacement. Let’s take a look at how all of the other operations can be represented. An insertion can be represented via a replacement—you just need to make sure there are no other elements with the specified key. To perform an update, it’s necessary to read the older value from the tree, so it’s easier to represent this operation as a replacement as well—this speeds up future read requests by the key. Besides, an update must return the new value, so there’s no avoiding hidden reads."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:706
msgid "In B-trees, the cost of hidden reads is negligible: to update a block, it first needs to be read from disk anyway. Creating a special update operation for an LSM tree that doesn’t cause any hidden reads is really tempting."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:711
msgid "Such an operation must contain not only a default value to be inserted if a key has no value yet, but also a list of update operations to perform if a value does exist."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:715
msgid "At transaction execution time, Tarantool just saves the operation in an LSM tree, then \"executes\" it later, during a compaction."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:719
msgid "The upsert operation:"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:721
msgid "space:upsert(tuple, {{operator, field, value}, ... })"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:725
msgid "Non-reading update or insert"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:726
msgid "Delayed execution"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:727
msgid "Background upsert squashing prevents upserts from piling up"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:729
msgid "Unfortunately, postponing the operation execution until a compaction doesn’t leave much leeway in terms of error handling. That’s why Tarantool tries to validate upserts as fully as possible before writing them to an LSM tree. However, some checks are only possible with older data on hand, for example when the update operation is trying to add a number to a string or to remove a field that doesn’t exist."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:736
msgid "A semantically similar operation exists in many products including PostgreSQL and MongoDB. But anywhere you look, it’s just syntactic sugar that combines the update and replace operations without avoiding hidden reads. Most probably, the reason is that LSM trees as data storage structures are relatively new."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:742
msgid "Even though an upsert is a very important optimization and implementing it cost us a lot of blood, sweat, and tears, we must admit that it has limited applicability. If a table contains secondary keys or triggers, hidden reads can’t be avoided. But if you have a scenario where secondary keys are not required and the update following the transaction completion will certainly not cause any errors, then the operation is for you."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:749
msgid "I’d like to tell you a short story about an upsert. It takes place back when vinyl was only beginning to \"mature\" and we were using an upsert in production for the first time. We had what seemed like an ideal environment for it: we had tons of keys, the current time was being used as values; update operations were inserting keys or modifying the current time; and we had few reads. Load tests yielded great results."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:757
msgid "Nevertheless, after a couple of days, the Tarantool process started eating up 100% of our CPU, and the system performance dropped close to zero."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:760
msgid "We started digging into the issue and found out that the distribution of requests across keys was significantly different from what we had seen in the test environment. It was...well, quite nonuniform. Most keys were updated once or twice a day, so the database was idle for the most part, but there were much hotter keys with tens of thousands of updates per day. Tarantool handled those just fine. But in the case of lookups by key with tens of thousands of upserts, things quickly went downhill. To return the most recent value, Tarantool had to read and \"replay\" the whole history consisting of all of the upserts. When designing upserts, we had hoped this would happen automatically during a compaction, but the process never even got to that stage: the L0 size was more than enough, so there were no dumps."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:773
msgid "We solved the problem by adding a background process that performed readaheads on any keys that had more than a few dozen upserts piled up, so all those upserts were squashed and substituted with the read value."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:782
msgid "Secondary keys"
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:784
msgid "Update is not the only operation where optimizing hidden reads is critical. Even the replace operation, given secondary keys, has to read the older value: it needs to be independently deleted from the secondary indexes, and inserting a new element might not do this, leaving some garbage behind."
msgstr ""

#: ../doc/2.2/book/box/engines/vinyl.rst:794
msgid "If secondary indexes are not unique, then collecting \"garbage\" from them can be put off until a compaction, which is what we do in Tarantool. The append-only nature of LSM trees allowed us to implement full-blown serializable transactions in vinyl. Read-only requests use older versions of data without blocking any writes. The transaction manager itself is fairly simple for now: in classical terms, it implements the MVTO (multiversion timestamp ordering) class, whereby the winning transaction is the one that finished earlier. There are no locks and associated deadlocks. Strange as it may seem, this is a drawback rather than an advantage: with parallel execution, you can increase the number of successful transactions by simply holding some of them on lock when necessary. We’re planning to improve the transaction manager soon. In the current release, we focused on making the algorithm behave 100% correctly and predictably. For example, our transaction manager is one of the few on the NoSQL market that supports so-called \"gap locks\"."
msgstr ""

#: ../doc/2.2/book/box/index.rst:39
msgid "Database"
msgstr ""

#: ../doc/2.2/book/box/index.rst:41
msgid "In this chapter, we introduce the basic concepts of working with Tarantool as a database manager."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:39
msgid "Limitations"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:41
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:43
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For :ref:`RTREE <box_index-rtree>` indexes, the maximum is 1 but the field is an ARRAY of up to 20 dimensions. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:50
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:52
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:56
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:58
msgid "The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <box_space-field_count>` member, or the maximal tuple length."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:65
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:67
msgid "The maximal number of bytes in a tuple is roughly equal to :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>` (with a metadata overhead of about 20 bytes per tuple, which is added on top of useful bytes). By default, the value of either ``memtx_max_tuple_size`` or ``vinyl_max_tuple_size`` is 1,048,576. To increase it, specify a larger value when starting the Tarantool instance. For example, ``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:79
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:81
msgid "If a field in a tuple can contain a million bytes, then the index key can contain a million bytes, so the maximum is determined by factors such as :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index support."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:88
msgid "**Number of spaces**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:90
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``) but the practical maximum is around 65,000."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:95
msgid "**Number of connections**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:97
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:102
msgid "**Space size**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:104
msgid "The total maximum size for all spaces is in effect set by :ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited by the total available memory."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:110
msgid "**Update operations count**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:112
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:117
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:119
msgid "32 (``BOX_USER_MAX``)."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:123
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:125
msgid "65000 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:129
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/2.2/book/box/limitations.rst:131
msgid "32 (``vclock.VCLOCK_MAX``)."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:40
#: ../doc/2.2/tutorials/sql_tutorial.rst:491
msgid "Triggers"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:42
msgid "**Triggers**, also known as **callbacks**, are functions which the server executes when certain events happen."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:45
msgid "There are six types of triggers in Tarantool:"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:47
msgid ":ref:`connection triggers <box_session-on_connect>`, which are executed when a session begins or ends,"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:50
msgid ":ref:`authentication triggers <box_session-on_auth>`, which are executed during authentication,"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:53
msgid ":ref:`replace triggers <box_space-on_replace>`, which are for database events,"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:56
msgid ":ref:`transaction triggers <box-on_commit>`, which are executed during commit or rollback,"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:59
msgid ":ref:`server triggers <box_ctl-on_schema_init>`, which are executed when the server starts or stops."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:62
msgid ":ref:`member triggers <swim-on_member_event>`, which are executed when a SWIM member is updated."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:65
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:67
msgid "Triggers associate a function with an event. The request to \"define a trigger\" implies passing the trigger's function to one of the \"on_event()\" functions:"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:71
msgid ":ref:`box.session.on_connect() <box_session-on_connect>` and :ref:`box.session.on_disconnect() <box_session-on_disconnect>`, or"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:72
msgid ":ref:`box.session.on_auth() <box_session-on_auth>`, or"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:73
msgid ":ref:`space_object:on_replace() <box_space-on_replace>` and :ref:`space_object:before_replace() <box_space-before_replace>`, or"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:74
msgid ":ref:`box.on_commit() <box-on_commit>` and :ref:`box.on_rollback() <box-on_rollback>`, or"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:75
msgid ":ref:`box.ctl.on_schema_init() <box_ctl-on_schema_init>` and :ref:`box.ctl.on_shutdown() <box_ctl-on_shutdown>`, or"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:76
msgid ":ref:`swim_object:on_member_event() <swim-on_member_event>`."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:78
msgid "Triggers are defined only by the :ref:`'admin' user <authentication-owners_privileges>`."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:80
msgid "Triggers are stored in the Tarantool instance's memory, not in the database. Therefore triggers disappear when the instance is shut down. To make them permanent, put function definitions and trigger settings into Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:85
msgid "Triggers have low overhead. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a function."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:89
msgid "There can be multiple triggers for one event. In this case, triggers are executed in the reverse order that they were defined in. (Exception: member triggers are executed in the order that they appear in the member list.)"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:93
msgid "Triggers must work within the event context. However, effects are undefined if a function contains requests which normally could not occur immediately after the event, but only before the return from the event. For example, putting `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or :ref:`box.rollback() <box-rollback>` in a trigger function would be bringing in requests outside the event context."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:100
msgid "Triggers are replaceable. The request to \"redefine a trigger\" implies passing a new trigger function and an old trigger function to one of the \"on_event()\" functions."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:104
msgid "The \"on_event()\" functions all have parameters which are function pointers, and they all return function pointers. Remember that a Lua function definition such as \"function f() x = x + 1 end\" is the same as \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function pointer. And \"trigger = box.session.on_connect(f)\" is the same as \"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in both cases ``trigger`` gets the function pointer which was passed."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:112
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:114
msgid "box.session.on_connect() – with no arguments – to return a table of all connect-trigger functions;"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:115
msgid "box.session.on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:116
msgid "box.session.on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:117
msgid "space_object:on_replace() to return all replace-trigger functions made for on_replace()."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:118
msgid "space_object:before_replace() to return all replace-trigger functions made for before_replace()."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:119
msgid "box.ctl.on_shutdown() to return all shutdown-trigger functions made for on_shutdown()."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:120
msgid "box.ctl.on_schema_init() to return all initialization-trigger functions made for on_schema_init()."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:121
msgid "swim_object:on_member_event() to return all member triggers made for on_member_event()."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:125
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/2.2/book/box/triggers.rst:127
msgid "log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\"\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:39
msgid "Connectors"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:41
msgid "This chapter documents APIs for various programming languages."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:45
msgid "Protocol"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:47
msgid "Tarantool's binary protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, instance id, log sequence number, and so on."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:52
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:58
msgid "Unless implementing a client driver, you needn't concern yourself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:67
msgid "Packet example"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:69
msgid "The Tarantool API exists so that a client program can send a request packet to a server instance, and receive a response. Here is an example of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``. The BNF description of the components is on the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:85
msgid "Component"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:85
msgid "Byte #0"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:85
msgid "Byte #1"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:85
msgid "Byte #2"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:85
msgid "Byte #3"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:87
msgid "code for insert"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:87
#: ../doc/2.2/book/connectors/index.rst:91
msgid "02"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:89
msgid "rest of header"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:89
#: ../doc/2.2/book/connectors/index.rst:89
#: ../doc/2.2/book/connectors/index.rst:89
#: ../doc/2.2/book/connectors/index.rst:89
msgid "..."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:91
msgid "2-digit number: space id"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:91
msgid "cd"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:91
msgid "01"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:93
msgid "code for tuple"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:93
msgid "21"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:95
msgid "1-digit number: field count = 2"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:95
msgid "92"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:97
msgid "1-character string: field[1]"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:97
msgid "a1"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:97
msgid "41"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:99
msgid "2-character string: field[2]"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:99
msgid "a2"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:99
#: ../doc/2.2/book/connectors/index.rst:99
msgid "42"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:102
msgid "Now, you could send that packet to the Tarantool instance, and interpret the response (the page about :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if you could invoke a routine that formats the packet according to typed parameters. Something like ``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:115
msgid "Setting up the server for connector examples"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:117
msgid "This chapter has examples that show how to connect to a Tarantool instance via the Perl, PHP, Python, node.js, and C connectors. The examples contain hard code that will work if and only if the following conditions are met:"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:121
msgid "the Tarantool instance (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:124
msgid "space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has a primary-key index for a numeric field (``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:128
msgid "user 'guest' has privileges for reading and writing."
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:130
msgid "It is easy to meet all the conditions by starting the instance and executing this script:"
msgstr ""

#: ../doc/2.2/book/connectors/index.rst:133
msgid "box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""

#: ../doc/2.2/book/connectors/__java.rst:3
msgid "Java"
msgstr ""

#: ../doc/2.2/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr ""

#: ../doc/2.2/book/connectors/__go.rst:3
msgid "Go"
msgstr ""

#: ../doc/2.2/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr ""

#: ../doc/2.2/book/connectors/__r.rst:3
msgid "R"
msgstr ""

#: ../doc/2.2/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr ""

#: ../doc/2.2/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr ""

#: ../doc/2.2/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:3
msgid "Perl"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `tarantool-perl <https://github.com/tarantool/tarantool-perl>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is by cloning from GitHub."
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:10
msgid "To avoid minor warnings that may appear the first time ``tarantool-perl`` is installed, start with installing some other modules that ``tarantool-perl`` uses, with `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_:"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:14
msgid "$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:19
msgid "Then, to install ``tarantool-perl`` itself, say:"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:21
msgid "$ git clone https://github.com/tarantool/tarantool-perl.git tarantool-perl\n"
"$ cd tarantool-perl\n"
"$ git submodule init\n"
"$ git submodule update --recursive\n"
"$ perl Makefile.PL\n"
"$ make\n"
"$ sudo make install"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:31
msgid "Here is a complete Perl program that inserts ``[99999,'BB']`` into ``space[999]`` via the Perl API. Before trying to run, check that the server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`space_object:INSERT<box_space-insert>` request, then — if all is well — end without displaying any messages. If Tarantool is not running on ``localhost`` with :ref:`listen<cfg_basic-listen>` port = 3301, the program will print “Connection refused”."
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:43
msgid "#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. for 'guest' we do not also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:67
msgid "The example program uses field type names 'STR' and 'NUM' instead of :ref:`'string' and 'unsigned'<box_space-create_index>`, due to a temporary Perl limitation."
msgstr ""

#: ../doc/2.2/book/connectors/__perl.rst:70
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see the `tarantool-perl repository <https://github.com/tarantool/tarantool-perl>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:3
msgid "PHP"
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:5
msgid "`tarantool-php <https://github.com/tarantool/tarantool-php>`_ is the official PHP connector for Tarantool. It is not supplied as part of the Tarantool repository and must be installed separately (see `installation instructions <https://github.com/tarantool/tarantool-php/#installing-and-building>`_ in the connector's ``README`` file)."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:12
msgid "Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named ``examples`` via the PHP API."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:15
msgid "Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:19
msgid "To run, paste the code into a file named :file:`example.php` and say:"
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:21
msgid "$ php -d extension=~/tarantool-php/modules/tarantool.so example.php"
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:25
msgid "The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` request, then -- if all is well -- print \"Insert succeeded\"."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:29
msgid "If the tuple already exists, the program will print \"Duplicate key exists in unique index 'primary' in space 'examples'\"."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:32
msgid "<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', [99999, 'BB']);\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:44
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool/tarantool-php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""

#: ../doc/2.2/book/connectors/__php.rst:49
msgid "Besides, there is another community-driven `GitHub project <https://github.com/tarantool-php>`_ which includes an `alternative connector <https://github.com/tarantool-php/client>`_ written in pure PHP, an `object mapper <https://github.com/tarantool-php/mapper>`_, a `queue <https://github.com/tarantool-php/queue>`_ and other packages."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:3
msgid "Python"
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:5
msgid "`tarantool-python <http://github.com/tarantool/tarantool-python>`_ is the official Python connector for Tarantool. It is not supplied as part of the Tarantool repository and must be installed separately (see below for details)."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:9
msgid "Here is a complete Python program that inserts ``[99999,'Value','Value']`` into space ``examples`` via the high-level Python API."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:12
msgid "#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:21
msgid "To prepare, paste the code into a file named :file:`example.py` and install the ``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:27
msgid "Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`python example.py`. The program will connect to the Tarantool server, will send the :ref:`INSERT<box_space-insert>` request, and will not throw any exception if all went well. If the tuple already exists, the program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")``."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:35
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see `tarantool-python <http://github.com/tarantool/tarantool-python>`_ project at GitHub. For an example of using Python API with `queue managers for Tarantool <https://github.com/tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:42
msgid "Also there are several community-driven Python connectors:"
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:44
msgid "`asynctnt <https://github.com/igorcoding/asynctnt>`_ with asyncio support"
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:45
msgid "`aiotarantool <https://github.com/shveenkov/aiotarantool>`_ also with asyncio support"
msgstr ""

#: ../doc/2.2/book/connectors/__python.rst:46
msgid "`gtarantool <https://github.com/shveenkov/gtarantool>`_ with gevent support **no active maintenance**"
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:5
msgid "The most commonly used node.js driver is the `Node Tarantool driver <https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `npm <https://www.sitepoint.com/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the installation could look like this after npm has been installed:"
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:13
msgid "$ npm install tarantool-driver --global"
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:17
msgid "Here is a complete node.js program that inserts ``[99999,'BB']`` into ``space[999]`` via the node.js API. Before trying to run, check that the server instance is :ref:`listening <cfg_basic-listen>` at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the code into a file named :file:`example.rs` and say ``node example.rs``. The program will connect using an application-specific definition of the space. The program will open a socket connection with the Tarantool instance at ``localhost:3301``, then send an :ref:`INSERT <box_space-insert>` request, then — if all is well — end after saying \"Insert succeeded\". If Tarantool is not running on ``localhost`` with listen port = 3301, the program will print “Connect failed”. If :ref:`the 'guest' user <box_space-user>` does not have authorization to connect, the program will print \"Auth failed\". If the insert request fails for any reason, for example because the tuple already exists, the program will print \"Insert failed\"."
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:31
msgid "var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/2.2/book/connectors/__nodejs.rst:45
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, please see  `The node.js driver repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:3
msgid "C#"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:5
msgid "The most commonly used C# driver is `progaudi.tarantool <https://github.com/progaudi/progaudi.tarantool>`_, previously named ``tarantool-csharp``. It is not supplied as part of the Tarantool repository; it must be installed separately. The makers recommend `cross-platform installation using Nuget <https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:11
msgid "To be consistent with the other instructions in this chapter, here is a way to install the driver directly on Ubuntu 16.04."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:14
msgid "Install .net core from Microsoft. Follow `.net core installation instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:19
msgid "Mono will not work, nor will .Net from xbuild. Only .net core supported on Linux and Mac."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:21
msgid "Read the Microsoft End User License Agreement first, because it is not an ordinary open-source agreement and there will be a message during installation saying \"This software may collect information about you and your use of the software, and send that to Microsoft.\" Still you can `set environment variables <https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:29
msgid "Create a new console project."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:31
msgid "$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:38
msgid "Add ``progaudi.tarantool`` reference."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:40
msgid "$ dotnet add package progaudi.tarantool"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:44
msgid "Change code in ``Program.cs``."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:46
msgid "$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:69
msgid "Build and run your application."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:71
msgid "Before trying to run, check that the server is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:75
msgid "$ dotnet restore\n"
"$ dotnet run"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:80
msgid "The program will:"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:82
msgid "connect using an application-specific definition of the space,"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:83
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:84
msgid "send an INSERT request, and — if all is well — end without saying anything."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:86
msgid "If Tarantool is not running on localhost with listen port = 3301, or if user 'guest' does not have authorization to connect, or if the INSERT request fails for any reason, the program will print an error message, among other things (stacktrace, etc)."
msgstr ""

#: ../doc/2.2/book/connectors/__csharp.rst:91
msgid "The example program only shows one request and does not show all that’s necessary for good practice. For that, please see the `progaudi.tarantool driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:3
msgid "C"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:9
msgid "Example 1"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:11
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:14
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:44
msgid "Paste the code into a file named :file:`example.c` and install ``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:47
msgid "$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:57
#: ../doc/2.2/book/connectors/__c.rst:282
msgid "To compile and link the program, say:"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:59
msgid "$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:65
msgid "Before trying to run, check that a server instance is listening at ``localhost:3301`` and that the space ``examples`` exists, as :ref:`described earlier <index-connector_setting>`. To run the program, say :samp:`./example`. The program will connect to the Tarantool instance, and will send the request. If Tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”. If the insert fails, the program will print \"Insert failed\" and an error number (see all error codes in the source file `/src/box/errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_)."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:81
msgid "struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:86
msgid "In this program, the stream will be named ``tnt``. Before connecting on the ``tnt`` stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program, the :ref:`URI <index-uri>` is ``localhost:3301``, since that is where the Tarantool instance is supposed to be listening."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:92
#: ../doc/2.2/book/connectors/__c.rst:107
#: ../doc/2.2/book/connectors/__c.rst:134
#: ../doc/2.2/book/connectors/__c.rst:153
#: ../doc/2.2/book/connectors/__c.rst:177
#: ../doc/2.2/book/connectors/__c.rst:195
msgid "Function description:"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:94
msgid "struct tnt_stream *tnt_net(struct tnt_stream *s)\n"
"int tnt_set(struct tnt_stream *s, int option, variant option-value)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:99
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to a server instance."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:102
msgid "if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:109
msgid "int tnt_connect(struct tnt_stream *s)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:113
msgid "The connection might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid :ref:`password<authentication-passwords>`. If the connection fails, the return value will be -1."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:117
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:120
msgid "struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:125
msgid "In this program, the request will be an :ref:`INSERT<box_space-insert>`, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:136
msgid "ssize_t tnt_object_format(struct tnt_stream *s, const char *fmt, ...)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:140
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:143
msgid "tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:148
msgid "In this program, the choice is to do an INSERT request, so the program passes the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:155
msgid "ssize_t tnt_insert(struct tnt_stream *s, uint32_t space, struct tnt_stream *tuple)\n"
"ssize_t tnt_replace(struct tnt_stream *s, uint32_t space, struct tnt_stream *tuple)\n"
"ssize_t tnt_select(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream *key)\n"
"ssize_t tnt_update(struct tnt_stream *s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream *key, struct tnt_stream *ops)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:165
msgid "**GET REPLY:** For most requests, the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:168
msgid "struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:175
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:179
msgid "struct tnt_reply *tnt_reply_init(struct tnt_reply *r)\n"
"tnt->read_reply(struct tnt_stream *s, struct tnt_reply *r)\n"
"void tnt_reply_free(struct tnt_reply *r)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:185
msgid "**TEARDOWN:** When a session ends, the connection that was made with :c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that were made in the setup should be destroyed."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:189
msgid "tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:197
msgid "void tnt_close(struct tnt_stream *s)\n"
"void tnt_stream_free(struct tnt_stream *s)"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:204
msgid "Example 2"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:206
msgid "Here is a complete C program that selects, using index key ``[99999]``, from space ``examples`` via the high-level C API. To display the results, the program uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:212
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:279
msgid "Similarly to the first example, paste the code into a file named :file:`example2.c`."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:284
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:288
msgid "To run the program, say :samp:`./example2`."
msgstr ""

#: ../doc/2.2/book/connectors/__c.rst:290
msgid "The two example programs only show a few requests and do not show all that's necessary for good practice. See more in the `tarantool-c documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:6
msgid "For all connectors, calling a function via Tarantool causes a return in the MsgPack format. If the function is called using the connector's API, some conversions may occur. All scalar values are returned as tuples (with a MsgPack type-identifier followed by a value); all non-scalar values are returned as a group of tuples (with a MsgPack array-identifier followed by the scalar values). If the function is called via the binary protocol command layer -- \"eval\" -- rather than via the connector's API, no conversions occur."
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:14
msgid "In the following example, a Lua function will be created. Since it will be accessed externally by a :ref:`'guest' user<box_space-user>`, a :ref:`grant <box_schema-user_grant>` of an execute privilege will be necessary. The function returns an empty array, a scalar string, two booleans, and a short integer. The values are the ones described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:21
msgid "tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:37
msgid "Here is a C program which calls the function. Although C is being used for the example, the result would be precisely the same if the calling program was written in Perl, PHP, Python, Go, or Java."
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:41
msgid "#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:79
msgid "When this program is executed, it will print:"
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:81
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr ""

#: ../doc/2.2/book/connectors/__results.rst:85
msgid "The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit array header with value 5\" (see `MsgPack specification <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :ref:`Common Types and MsgPack Encodings <msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/2.2/book/faq.rst:39
msgid "FAQ"
msgstr ""

#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
msgid "Q"
msgstr ""

#: ../doc/2.2/book/faq.rst:43
msgid "Why Tarantool?"
msgstr ""

#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
#: ../doc/2.2/book/faq.rst:0
msgid "A"
msgstr ""

#: ../doc/2.2/book/faq.rst:44
msgid "Tarantool is the latest generation of a family of in-memory data servers developed for web applications. It is the result of practical experience and trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/2.2/book/faq.rst:48
msgid "Why Lua?"
msgstr ""

#: ../doc/2.2/book/faq.rst:49
msgid "Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens to be very easy to embed. Lua coroutines relate very closely to Tarantool fibers, and Lua architecture works well with Tarantool internals. Lua acts well as a stored program language for Tarantool, although connecting with other languages is also easy."
msgstr ""

#: ../doc/2.2/book/faq.rst:55
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/2.2/book/faq.rst:0
msgid "Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, composite indexes, transactions, triggers, asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/2.2/book/faq.rst:0
msgid "These two properties make it possible to be a fast, atomic and reliable in-memory data server which handles non-trivial application-specific logic. The advantage over traditional SQL servers is in performance: low-overhead, lock-free architecture means Tarantool can serve an order of magnitude more requests per second, on comparable hardware. The advantage over NoSQL alternatives is in flexibility: Lua allows flexible processing of data stored in a compact, denormalized format."
msgstr ""

#: ../doc/2.2/book/faq.rst:69
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/2.2/book/faq.rst:70
msgid "There is an engineering team employed by Mail.Ru -- check out our commit logs on `github.com/tarantool <http://github.com/tarantool/>`_. The development is fully open. Most of the connectors' authors, and the maintainers for different distributions, come from the wider community."
msgstr ""

#: ../doc/2.2/book/faq.rst:75
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/2.2/book/faq.rst:76
msgid "The principal storage engine (memtx) is designed for RAM plus persistent storage. It is immune to data loss because there is a write-ahead log. Its memory-allocation and compression techniques ensure there is no waste. And if Tarantool runs out of memory, then it will stop accepting updates until more memory is available, but will continue to handle read and delete requests without difficulty. However, for databases which are much larger than the available RAM space, Tarantool has a second storage engine (vinyl) which is only limited by the available disk space."
msgstr ""

#: ../doc/2.2/book/faq.rst:85
msgid "Can I store (large) BLOBs in Tarantool?"
msgstr ""

#: ../doc/2.2/book/faq.rst:86
msgid "Starting with Tarantool 1.7, there is no \"hard\" limit for the maximal tuple size. Tarantool, however, is designed for high-velocity workload with a lot of small chunks. For example, when you change an existing tuple, Tarantool creates a new version of the tuple in memory. Thus, an optimal tuple size is within kilobytes."
msgstr ""

#: ../doc/2.2/book/faq.rst:93
msgid "I delete data from vinyl, but disk usage stays the same. What gives?"
msgstr ""

#: ../doc/2.2/book/faq.rst:94
msgid "Data you write to vinyl is persisted in append-only run files. These files are immutable, and to perform a delete, a deletion marker (tombstone) is written to a newer run file instead. On compaction, new and old run files are merged, and a new run file is produced. Independently, the checkpoint manager keeps track of all run files involved in a checkpoint, and deletes obsolete files once they are no longer needed."
msgstr ""

#: ../doc/2.2/book/getting_started/index.rst:39
msgid "Getting started"
msgstr ""

#: ../doc/2.2/book/getting_started/index.rst:41
msgid "In this chapter, we explain how to install Tarantool, how to start it, and how to create a simple database."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:39
msgid "Using a binary package"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:41
msgid "For production purposes, we recommend `official binary packages <http://tarantool.org/download.html>`_. You can choose from two Tarantool versions: ``1.10`` (stable) or ``2.2`` (beta). An automatic build system creates, tests and publishes packages for every push into a corresponding branch (``1.10`` or ``2.2``) at `Tarantool's GitHub repository <https://github.com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:48
msgid "To download and install the package that’s appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at Tarantool's `download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:54
msgid "Starting Tarantool"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:56
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:58
msgid "$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:65
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:67
msgid "tarantool>"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:71
#: ../doc/2.2/book/getting_started/using_docker.rst:118
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:75
#: ../doc/2.2/book/getting_started/using_docker.rst:122
msgid "On production machines, Tarantool's interactive mode is for system administration only. But we use it for most examples in this manual, because the interactive mode is convenient for learning."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:81
#: ../doc/2.2/book/getting_started/using_docker.rst:128
msgid "Creating a database"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:83
msgid "Here is how to create a simple test database after installation."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:85
msgid "To let Tarantool store data in a separate place, create a new directory dedicated for tests:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:88
msgid "$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:93
msgid "You can delete the directory when the tests are over."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:95
msgid "Check if the default port the database instance will listen to is vacant."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:97
msgid "Depending on the release, during installation Tarantool may start a demonstrative global ``example.lua`` instance that listens to the ``3301`` port by default. The ``example.lua`` file showcases basic configuration and can be found in the ``/etc/tarantool/instances.enabled`` or ``/etc/tarantool/instances.available`` directories."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:103
msgid "However, we encourage you to perform the instance startup manually, so you can learn."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:106
msgid "Make sure the default port is vacant:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:108
msgid "To check if the demonstrative instance is running, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:110
msgid "$ lsof -i :3301\n"
"COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n"
"tarantool 6851 root   12u  IPv4  40827      0t0  TCP *:3301 (LISTEN)"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:116
msgid "If it does, kill the corresponding process. In this example:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:118
msgid "$ kill 6851"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:122
msgid "To start Tarantool's database module and make the instance accept TCP requests on port ``3301``, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:129
msgid "Create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:131
msgid "tarantool> s = box.schema.space.create('tester')"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:135
#: ../doc/2.2/book/getting_started/using_docker.rst:138
msgid "Format the created space by specifying field names and types:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:137
msgid "tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:145
#: ../doc/2.2/book/getting_started/using_docker.rst:148
msgid "Create the first :ref:`index <index-box_index>` (named ``primary``):"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:147
msgid "tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:154
#: ../doc/2.2/book/getting_started/using_docker.rst:157
msgid "This is a primary index based on the ``id`` field of each tuple."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:156
#: ../doc/2.2/book/getting_started/using_docker.rst:159
msgid "Insert three :ref:`tuples <index-box_tuple>` (our name for records) into the space:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:159
msgid "tarantool> s:insert{1, 'Roxette', 1986}\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:165
#: ../doc/2.2/book/getting_started/using_docker.rst:168
msgid "To select a tuple using the ``primary`` index, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:167
msgid "tarantool> s:select{3}"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:171
#: ../doc/2.2/book/getting_started/using_docker.rst:174
msgid "The terminal screen now looks like this:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:173
msgid "tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> s:format({\n"
"         > {name = 'id', type = 'unsigned'},\n"
"         > {name = 'band_name', type = 'string'},\n"
"         > {name = 'year', type = 'unsigned'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         > type = 'hash',\n"
"         > parts = {'id'}\n"
"         > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:217
#: ../doc/2.2/book/getting_started/using_docker.rst:220
msgid "To add a secondary index based on the ``band_name`` field, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:219
msgid "tarantool> s:create_index('secondary', {\n"
"         > type = 'hash',\n"
"         > parts = {'band_name'}\n"
"         > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:226
#: ../doc/2.2/book/getting_started/using_docker.rst:229
msgid "To select tuples using the ``secondary`` index, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:228
msgid "tarantool> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:235
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:237
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:246
msgid "Connecting remotely"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:248
msgid "In the request ``box.cfg{listen = 3301}`` that we made earlier, the ``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform resource identifier). In this case, it’s just a local port: port ``3301``. You can send requests to the listen URI via:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:253
msgid "``telnet``,"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:254
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:255
msgid "another instance of Tarantool (using the :ref:`console <console-module>` module), or"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:256
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:258
msgid "Let’s try (4)."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:260
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. You can switch to any working directory in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:264
msgid "Start the ``tarantoolctl`` utility:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:266
msgid "$ tarantoolctl connect '3301'"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:270
msgid "This means \"use ``tarantoolctl connect`` to connect to the Tarantool instance that’s listening on ``localhost:3301``\"."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:273
msgid "Try this request:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:275
msgid "localhost:3301> box.space.tester:select{2}"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:279
msgid "This means \"send a request to that Tarantool instance, and display the result\". The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:283
msgid "$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:292
msgid "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:295
msgid "When the testing is over:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:297
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:298
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:299
msgid "To stop Tarantool (an alternative): the standard Lua function `os.exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:301
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/2.2/book/getting_started/using_binary.rst:302
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:39
msgid "Using a Docker image"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:41
msgid "For trial and test purposes, we recommend using `official Tarantool images for Docker <https://github.com/tarantool/docker>`_. An official image contains a particular Tarantool version and all popular external modules for Tarantool. Everything is already installed and configured in Linux. These images are the easiest way to install and use Tarantool."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:50
msgid "If you're new to Docker, we recommend going over `this tutorial <https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding with this chapter."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:58
msgid "Launching a container"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:60
msgid "If you don't have Docker installed, please follow the official `installation guide <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-docker>`_ for your OS."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:64
msgid "To start a fully functional Tarantool instance, run a container with minimal options:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:67
msgid "$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:2"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:75
msgid "This command runs a new container named ``mytarantool``. Docker starts it from an official image named ``tarantool/tarantool:1``, with Tarantool version ``1.9`` and all external modules already installed."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:79
msgid "Tarantool will be accepting incoming connections on ``localhost:3301``. You may start using it as a key-value storage right away."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:82
msgid "Tarantool :ref:`persists data <index-box_persistence>` inside the container. To make your test data available after you stop the container, this command also mounts the host's directory ``/data/dir/on/host`` (you need to specify here an absolute path to an existing local directory) in the container's directory ``/var/lib/tarantool`` (by convention, Tarantool in a container uses this directory to persist data). So, all changes made in the mounted directory on the container's side are applied to the host's disk."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:91
msgid "Tarantool's database module in the container is already :ref:`configured <box_introspection-box_cfg>` and started. You needn't do it manually, unless you use Tarantool as an :ref:`application server <app_server>` and run it with an application."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:98
msgid "Attaching to Tarantool"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:100
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:102
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:106
msgid "This command:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:108
msgid "Instructs Tarantool to open an interactive console port for incoming connections."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:109
msgid "Attaches to the Tarantool server inside the container under ``admin`` user via a standard Unix socket."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:112
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:114
msgid "tarantool.sock>"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:130
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:132
msgid "First, create the first :ref:`space <index-box_space>` (named ``tester``):"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:134
msgid "tarantool.sock> s = box.schema.space.create('tester')"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:140
msgid "tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:150
msgid "tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:162
msgid "tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:170
msgid "tarantool.sock> s:select{3}"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:176
msgid "tarantool.sock> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool.sock> s:format({\n"
"              > {name = 'id', type = 'unsigned'},\n"
"              > {name = 'band_name', type = 'string'},\n"
"              > {name = 'year', type = 'unsigned'}\n"
"              > })\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {\n"
"              > type = 'hash',\n"
"              > parts = {'id'}\n"
"              > })\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    is_nullable: false\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 512\n"
"  name: primary\n"
"  type: HASH\n"
"...\n"
"tarantool.sock> s:insert{1, 'Roxette', 1986}\n"
"---\n"
"- [1, 'Roxette', 1986]\n"
"...\n"
"tarantool.sock> s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"- [2, 'Scorpions', 2015]\n"
"...\n"
"tarantool.sock> s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"- [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"..."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:222
msgid "tarantool.sock> s:create_index('secondary', {\n"
"              > type = 'hash',\n"
"              > parts = {'band_name'}\n"
"              > })"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:231
msgid "tarantool.sock> s.index.secondary:select{'Scorpions'}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"..."
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:240
msgid "Stopping a container"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:242
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:244
msgid "$ docker stop mytarantool"
msgstr ""

#: ../doc/2.2/book/getting_started/using_docker.rst:248
msgid "This was a temporary container, and its disk/memory data were flushed when you stopped it. But since you mounted a data directory from the host in the container, Tarantool's data files were persisted to the host's disk. Now if you start a new container and mount that data directory in it, Tarantool will recover all data from disk and continue working with the persisted data."
msgstr ""

#: ../doc/2.2/book/index.rst:39
msgid "User's Guide"
msgstr ""

#: ../doc/2.2/book/intro.rst:37
msgid "Preface"
msgstr ""

#: ../doc/2.2/book/intro.rst:39
msgid "Welcome to Tarantool! This is the User's Guide. We recommend reading it first, and consulting :ref:`Reference <reference>` materials for more detail afterwards, if needed."
msgstr ""

#: ../doc/2.2/book/intro.rst:45
msgid "How to read the documentation"
msgstr ""

#: ../doc/2.2/book/intro.rst:47
msgid "To get started, you can install and launch Tarantool using :ref:`a Docker container <getting_started-using_docker>`, :ref:`a binary package <getting_started-using_binary>`, or the online Tarantool server at http://try.tarantool.org. Either way, as the first tryout, you can follow the introductory exercises from :ref:`Chapter 2 \"Getting started\" <getting_started>`. If you want more hands-on experience, proceed to :ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""

#: ../doc/2.2/book/intro.rst:56
msgid ":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is about using Tarantool as an application server."
msgstr ""

#: ../doc/2.2/book/intro.rst:60
msgid ":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 \"Replication\" <replication>` are primarily for administrators."
msgstr ""

#: ../doc/2.2/book/intro.rst:63
msgid ":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for users who are connecting from a different language such as C or Perl or Python — other users will find no immediate need for this chapter."
msgstr ""

#: ../doc/2.2/book/intro.rst:67
msgid ":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked questions about Tarantool."
msgstr ""

#: ../doc/2.2/book/intro.rst:70
msgid "For experienced users, there are also :ref:`Reference <reference>` materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in the source code."
msgstr ""

#: ../doc/2.2/book/intro.rst:76
msgid "Getting in touch with the Tarantool community"
msgstr ""

#: ../doc/2.2/book/intro.rst:78
msgid "Please report bugs or make feature requests at http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/2.2/book/intro.rst:80
msgid "You can contact developers directly in `telegram <http://telegram.me/tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google.com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""

#: ../doc/2.2/book/intro.rst:87
msgid "Conventions used in this manual"
msgstr ""

#: ../doc/2.2/book/intro.rst:89
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/2.2/book/intro.rst:91
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/2.2/book/intro.rst:93
msgid "A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr ""

#: ../doc/2.2/book/replication/index.rst:39
#: ../doc/2.2/reference/configuration/index.rst:258
msgid "Replication"
msgstr ""

#: ../doc/2.2/book/replication/index.rst:41
msgid "Replication allows multiple Tarantool instances to work on copies of the same databases. The databases are kept in sync because each instance can communicate its changes to all the other instances."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:39
msgid "Adding instances"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:45
msgid "Adding a replica"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:50
msgid "To add a second **replica** instance to the **master-replica** set from our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, we need an analog of the instance file that we created for the first replica in that set:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:54
msgid "-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = ('replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1 URI\n"
"                 'replicator:password@192.168.0.103:3301'), -- replica #2 URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:72
msgid "Here we add the URI of replica #2 to the :ref:`replication <cfg_replication-replication>` parameter, so now it contains three URIs."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:75
msgid "After we launch the new replica instance, it gets connected to the master instance and retrieves the master's write-ahead-log and snapshot files:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:78
msgid "$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:97
msgid "Since we are adding a read-only instance, there is no need to dynamically update the ``replication`` parameter on the other running instances. This update would be required if we :ref:`added a master instance <replication-add_master>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:101
msgid "However, we recommend specifying the URI of replica #3 in all instance files of the replica set. This will keep all the files consistent with each other and with the current replication topology, and so will help to avoid configuration errors in case of further configuration updates and replica set restart."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:110
msgid "Adding a master"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:115
msgid "To add a third master instance to the **master-master** set from our :ref:`bootstrapping example <replication-master_master_bootstrap>`, we need an analog of the instance files that we created to bootstrap the other master instances in that set:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:120
msgid "-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant \"replication\" role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:137
msgid "Here we make the following changes:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:139
msgid "Add the URI of master #3 to the :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:141
msgid "Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to disable data-change operations on the instance. After launch, master #3 will act as a replica until it retrieves all data from the other masters in the replica set."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:145
msgid "After we launch master #3, it gets connected to the other master instances and retrieves their write-ahead-log and snapshot files:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:148
msgid "$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:171
msgid "Next, we add the URI of master #3 to the ``replication`` parameter on the existing two masters. Replication-related parameters are dynamic, so we only need to make a ``box.cfg{}`` request on each of the running instances:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:175
msgid "# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:185
msgid "When master #3 catches up with the other masters' state, we can disable read-only mode for this instance:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:188
msgid "# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:195
msgid "We also recommend to specify master #3 URI in all instance files in order to keep all the files consistent with each other and with the current replication topology."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:203
msgid "Orphan status"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:205
msgid "Starting with Tarantool version 1.9, there is a change to the procedure when an instance joins a replica set. During ``box.cfg()`` the instance will try to join all masters listed in :ref:`box.cfg.replication <cfg_replication-replication>`. If the instance does not succeed with at least the number of masters specified in :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`, then it will switch to **orphan status**. While an instance is in orphan status, it is read-only."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:215
msgid "To \"join\" a master, a replica instance must \"connect\" to the master node and then \"sync\"."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:218
msgid "\"Connect\" means contact the master over the physical network and receive acknowledgment. If there is no acknowledgment after :ref:`box.replication_connect_timeout <cfg_replication-replication_connect_timeout>` seconds (usually 4 seconds), and retries fail, then the connect step fails."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:223
msgid "\"Sync\" means receive updates from the master in order to make a local database copy. Syncing is complete when the replica has received all the updates, or at least has received enough updates that the replica's lag (see :ref:`replication.upstream.lag <box_info_replication_upstream_lag>` in ``box.info()``) is less than or equal to the number of seconds specified in :ref:`box.cfg.replication_sync_lag <cfg_replication-replication_sync_lag>`. If ``replication_sync_lag`` is unset (nil) or set to TIMEOUT_INFINITY, then the replica skips the \"sync\" state and switches to \"follow\" immediately."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:235
msgid "The following situations are possible."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:239
msgid "**Situation 1: bootstrap**"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:241
msgid "Here ``box.cfg{}`` is being called for the first time. A replica is joining but no replica set exists yet."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:244
msgid "Set status to 'orphan'."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:245
msgid "Try to connect to all nodes from ``box.cfg.replication``, or to the number of nodes required by :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`. Retrying up to 3 times in 30 seconds is possible because this is bootstrap, :ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>` is overridden."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:252
msgid "Abort if not connected to all nodes in ``box.cfg.replication`` or :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:255
msgid "This instance might be elected as the replica set 'leader'. Criteria for electing a leader include vclock value (largest is best), and whether it is read-only or read-write (read-write is best unless there is no other choice). The leader is the master that other instances must join. The leader is the master that executes :ref:`box_once() <box-once>` functions."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:261
msgid "If this instance is elected as the replica set leader, then perform an \"automatic bootstrap\":"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:265
msgid "Set status to 'running'."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:266
msgid "Return from ``box.cfg{}``."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:268
msgid "Otherwise this instance will be a replica joining an existing replica set, so:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:271
msgid "Bootstrap from the leader. See examples in section :ref:`Bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:273
msgid "In background, sync with all the other nodes in the replication set."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:275
msgid "**Situation 2: recovery**"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:277
msgid "Here ``box.cfg{}`` is not being called for the first time. It is being called again in order to perform recovery."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:280
msgid "Perform :ref:`recovery <internals-recovery_process>` from the last local snapshot and the WAL files."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:283
msgid "Connect to at least :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>` nodes."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:287
msgid "Sync with all connected nodes, until the difference is not more than :ref:`replication_sync_lag <cfg_replication-replication_sync_lag>` seconds."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:292
msgid "**Situation 3: configuration update**"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:294
msgid "Here ``box.cfg{}`` is not being called for the first time. It is being called again because some replication parameter or something in the replica set has changed."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:298
msgid "Try to connect to all nodes from ``box.cfg.replication``, or to the number of nodes required by :ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`, within the time period specified in :ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:304
msgid "Try to sync with the connected nodes, within the time period specified in :ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:308
msgid "If earlier steps fail, change status to 'orphan'. (Attempts to sync will continue in the background and when/if they succeed then 'orphan' status will end.)"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:312
msgid "If earlier steps succeed, set status to 'running' (master) or 'follow' (replica)."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:316
msgid "**Situation 4: rebootstrap**"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:318
msgid "Here ``box.cfg{}`` is not being called. The replica connected successfully at some point in the past, and is now ready for an update from the master. But the master cannot provide an update. This can happen by accident, or more likely can happen because the replica is slow (its :ref:`lag <cfg_replication-replication_sync_lag>` is large), and the WAL (.xlog) files containing the updates have been deleted. This is not crippling. The replica can discard what it received earlier, and then ask for the master's latest snapshot (.snap) file contents. Since it is effectively going through the bootstrap process a second time, this is called \"rebootstrapping\". However, there has to be one difference from an ordinary bootstrap -- the replica's :ref:`replica id <replication-replica-id>` will remain the same. If it changed, then the master would think that the replica is a new addition to the cluster, and would maintain a record of an instance ID of a replica that has ceased to exist. Rebootstrapping was introduced in Tarantool version 1.10.2 and is completely automatic."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:339
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:39
msgid "Server startup with replication"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:341
msgid "In addition to the recovery process described in the section :ref:`Recovery process <internals-recovery_process>`, the server must take additional steps and precautions if :ref:`replication <replication>` is enabled."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:345
msgid "Once again the startup procedure is initiated by the ``box.cfg{}`` request. One of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-replication>` which specifies replication source(-s). We will refer to this replica, which is starting up due to ``box.cfg``, as the \"local\" replica to distinguish it from the other replicas in a replica set, which we will refer to as \"distant\" replicas."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:352
msgid "*If there is no snapshot .snap file and the 'replication' parameter is empty*: |br| then the local replica assumes it is an unreplicated \"standalone\" instance, or is the first replica of a new replica set. It will generate new UUIDs for itself and for the replica set. The replica UUID is stored in the ``_cluster`` space; the replica set UUID is stored in the ``_schema`` space. Since a snapshot contains all the data in all the spaces, that means the local replica's snapshot will contain the replica UUID and the replica set UUID. Therefore, when the local replica restarts on later occasions, it will be able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:362
msgid "*If there is no snapshot .snap file and the 'replication' parameter is not empty and the '_cluster' space contains no other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, but is not yet part of a replica set. It must now join the replica set. It will send its replica UUID to the first distant replica which is listed in ``replication`` and which will act as a master. This is called the \"join request\". When a distant replica receives a join request, it will send back:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:370
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:69
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:371
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:70
msgid "the contents of the distant replica's .snap file. |br| When the local replica receives this information, it puts the replica set UUID in its ``_schema`` space, puts the distant replica's UUID and connection information in its ``_cluster`` space, and makes a snapshot containing all the data sent by the distant replica. Then, if the local replica has data in its WAL .xlog files, it sends that data to the distant replica. The distant replica will receive this and update its own copy of the data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:380
msgid "*If there is no snapshot .snap file and the 'replication' parameter is not empty and the ``_cluster`` space contains other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, and is already part of a replica set. It will send its replica UUID and replica set UUID to all the distant replicas which are listed in ``replication``. This is called the \"on-connect handshake\". When a distant replica receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:387
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:86
msgid "the distant replica compares its own copy of the replica set UUID to the one in the on-connect handshake. If there is no match, then the handshake fails and the local replica will display an error."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:390
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:89
msgid "the distant replica looks for a record of the connecting instance in its ``_cluster`` space. If there is none, then the handshake fails. |br| Otherwise the handshake is successful. The distant replica will read any new information from its own .snap and .xlog files, and send the new requests to the local replica."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:396
msgid "In the end, the local replica knows what replica set it belongs to, the distant replica knows that the local replica is a member of the replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:402
msgid "*If there is a snapshot file and replication source is not empty*: |br| first the local replica goes through the recovery process described in the previous section, using its own .snap and .xlog files. Then it sends a \"subscribe\" request to all the other replicas of the replica set. The subscribe request contains the server vector clock. The vector clock has a collection of pairs 'server id, lsn' for every replica in the ``_cluster`` system space. Each distant replica, upon receiving a subscribe request, will read its .xlog files' requests and send them to the local replica if (lsn of .xlog file request) is greater than (lsn of the vector clock in the subscribe request). After all the other replicas of the replica set have responded to the local replica's subscribe request, the replica startup is complete."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:414
msgid "The following temporary limitations applied for Tarantool versions earlier than 1.7.7:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:417
#: ../doc/2.2/dev_guide/internals/replication_internals.rst:115
msgid "The URIs in the ``replication`` parameter should all be in the same order on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:419
msgid "The replicas of a replica set should be started up at slightly different times. This is not mandatory but prevents a situation where each replica is waiting for the other replica to be ready."
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:423
msgid "The following limitation still applies for the current Tarantool version:"
msgstr ""

#: ../doc/2.2/book/replication/repl_add_instances.rst:425
msgid "The maximum number of entries in the ``_cluster`` space is :ref:`32 <limitations_replicas>`. Tuples for out-of-date replicas are not automatically re-used, so if this 32-replica limit is reached, users may have to reorganize the ``_cluster`` space manually."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:39
msgid "Replication architecture"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:45
msgid "Replication mechanism"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:47
msgid "A pack of instances which operate on copies of the same databases make up a **replica set**. Each instance in a replica set has a role, **master** or **replica**."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:51
msgid "A replica gets all updates from the master by continuously fetching and applying its :ref:`write ahead log (WAL)<internals-wal>`. Each record in the WAL represents a single Tarantool data-change request such as :ref:`INSERT<box_space-insert>`, :ref:`UPDATE<box_space-update>` or :ref:`DELETE<box_space-delete>`, and is assigned a monotonically growing log sequence number (**LSN**). In essence, Tarantool replication is **row-based**: each data-change request is fully deterministic and operates on a single :ref:`tuple<index-box_tuple>`. However, unlike a classical row-based log, which contains entire copies of the changed rows, Tarantool's WAL contains copies of the requests. For example, for UPDATE requests, Tarantool only stores the primary key of the row and the update operations, to save space."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:62
msgid "Invocations of **stored programs** are not written to the WAL. Instead, records of the actual **data-change requests, performed by the Lua code**, are written to the WAL. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:67
msgid "Data definition operations on **temporary spaces**, such as creating/dropping, adding indexes, truncating, etc., are written to the WAL, since information about temporary spaces is stored in non-temporary system spaces, such as :ref:`box.space._space <box_space-space>`. Data change operations on temporary spaces are not written to the WAL and are not replicated."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:75
msgid "Data change operations on **replication-local** spaces (spaces :ref:`created <box_schema-space_create>` with ``is_local`` = true) are written to the WAL but are not replicated."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:79
msgid "To create a valid initial state, to which WAL changes can be applied, every instance of a replica set requires a start set of :ref:`checkpoint files <index-box_persistence>`, such as .snap files for memtx and .run files for vinyl. A replica joining an existing replica set, chooses an existing master and automatically downloads the initial state from it. This is called an **initial join**."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:86
msgid "When an entire replica set is bootstrapped for the first time, there is no master which could provide the initial checkpoint. In such a case, replicas connect to each other and elect a master, which then creates the starting set of checkpoint files, and distributes it to all the other replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:92
msgid "When a replica contacts a master (there can be many masters) for the first time, it becomes part of a replica set. On subsequent occasions, it should always contact a master in the same replica set. Once connected to the master, the replica requests all changes that happened after the latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:98
msgid "Each replica set is identified by a globally unique identifier, called the **replica set UUID**. The identifier is created by the master which creates the very first checkpoint, and is part of the checkpoint file. It is stored in system space :ref:`box.space._schema <box_space-schema>`. For example:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:103
msgid "tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:112
msgid "Additionally, each instance in a replica set is assigned its own UUID, when it joins the replica set. It is called an **instance UUID** and is a globally unique identifier. The instance UUID is checked to ensure that instances do not join a different replica set, e.g. because of a configuration error. A unique instance identifier is also necessary to apply rows originating from different masters only once, that is, to implement multi-master replication. This is why each row in the write ahead log, in addition to its log sequence number, stores the instance identifier of the instance on which it was created. But using a UUID as such an identifier would take too much space in the write ahead log, thus a shorter integer number is assigned to the instance when it joins a replica set. This number is then used to refer to the instance in the write ahead log. It is called **instance id**. All identifiers are stored in system space :ref:`box.space._cluster <box_space-cluster>`. For example:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:133
msgid "Here the instance ID is ``1`` (unique within the replica set), and the instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally unique)."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:136
msgid "Using instance IDs is also handy for tracking the state of the entire replica set. For example, :ref:`box.info.vclock <box_introspection-box_info>` describes the state of replication in regard to each connected peer."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:140
msgid "tarantool> box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:147
msgid "Here ``vclock`` contains log sequence numbers (827 and 584) for instances with instance IDs 1 and 2."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:150
msgid "Starting in Tarantool 1.7.7, it is possible for administrators to assign the instance UUID and the replica set UUID values, rather than let the system generate them -- see the description of the :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` configuration parameter."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:159
msgid "Replication setup"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:161
msgid "To enable replication, you need to specify two parameters in a ``box.cfg{}`` request:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:164
msgid ":ref:`replication <cfg_replication-replication>` which defines the replication source(s), and"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:166
msgid ":ref:`read_only <cfg_basic-read_only>` which is ``true`` for a replica and ``false`` for a master."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:169
msgid "Both these parameters are \"dynamic\". This allows a replica to become a master and vice versa on the fly with the help of a ``box.cfg{}`` request."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:172
msgid "Later we will give a detailed example of :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:179
msgid "Replication roles: master and replica"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:181
msgid "The replication role (master or replica) is set by the :ref:`read_only <cfg_basic-read_only>` configuration parameter. The recommended role is \"read_only\" (replica) for all but one instance in the replica set."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:185
msgid "In a master-replica configuration, every change that happens on the master will be visible on the replicas, but not vice versa."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:191
msgid "A simple two-instance replica set with the master on one machine and the replica on a different machine provides two benefits:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:194
msgid "**failover**, because if the master goes down then the replica can take over, and"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:196
msgid "**load balancing**, because clients can connect to either the master or the replica for read requests."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:199
msgid "In a **master-master** configuration (also called \"multi-master\"), every change that happens on either instance will be visible on the other one."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:205
msgid "The failover benefit in this case is still present, and the load-balancing benefit is enhanced, because any instance can handle both read and write requests. Meanwhile, for multi-master configurations, it is necessary to understand the **replication guarantees** provided by the asynchronous protocol that Tarantool implements."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:211
msgid "Tarantool multi-master replication guarantees that each change on each master is propagated to all instances and is applied only once. Changes from the same instance are applied in the same order as on the originating instance. Changes from different instances, however, can be mixed and applied in a different order on different instances. This may lead to replication going out of sync in certain cases."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:218
msgid "For example, assuming the database is only appended to (i.e. it contains only insertions), a multi-master configuration is safe. If there are also deletions, but it is not mission critical that deletion happens in the same order on all replicas (e.g. the DELETE is used to prune expired data), a master-master configuration is also safe."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:224
msgid "UPDATE operations, however, can easily go out of sync. For example, assignment and increment are not commutative, and may yield different results if applied in different order on different instances."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:228
msgid "More generally, it is only safe to use Tarantool master-master replication if all database changes are **commutative**: the end result does not depend on the order in which the changes are applied. You can start learning more about conflict-free replicated data types `here <https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:238
msgid "Replication topologies: cascade, ring and full mesh"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:240
msgid "Replication topology is set by the :ref:`replication <cfg_replication-replication>` configuration parameter. The recommended topology is a **full mesh**, because it makes potential failover easy."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:244
msgid "Some database products offer **cascading replication** topologies: creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:250
msgid "The problem with a cascading replica set is that some instances have no connection to other instances and may not receive changes from them. One essential change that must be propagated across all instances in a replica set is an entry in ``box.space._cluster`` system space with the replica set UUID. Without knowing the replica set UUID, a master refuses to accept connections from such instances when replication topology changes. Here is how this can happen:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:260
msgid "We have a chain of three instances. Instance #1 contains entries for instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:267
msgid "Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its new master, but the master refuses the connection since it has no entry for instance #3."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:271
msgid "**Ring replication** topology is, however, supported:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:276
msgid "So, if you need a cascading topology, you may first create a ring to ensure all instances know each other’s UUID, and then disconnect the chain in the place you desire."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:280
msgid "A stock recommendation for a master-master replication topology, however, is a **full mesh**:"
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:286
msgid "You then can decide where to locate instances of the mesh -- within the same data center, or spread across a few data centers. Tarantool will automatically ensure that each row is applied only once on each instance. To remove a degraded instance from a mesh, simply change the ``replication`` configuration parameter."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:291
msgid "This ensures full cluster availability in case of a local failure, e.g. one of the instances failing in one of the data centers, as well as in case of an entire data center failure."
msgstr ""

#: ../doc/2.2/book/replication/repl_architecture.rst:295
msgid "The maximal number of replicas in a mesh is 32."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:39
msgid "Bootstrapping a replica set"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:45
msgid "Master-replica bootstrap"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:47
msgid "Let us first bootstrap a simple **master-replica** set containing two instances, each located on its own machine. For easier administration, we make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:54
msgid "Here is an example of the master's instance file:"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:56
msgid "-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:75
msgid "the ``box.cfg()`` :ref:`listen <cfg_basic-listen>` parameter defines a URI (port 3301 in our example), on which the master can accept connections from replicas."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:78
msgid "the ``box.cfg()`` :ref:`replication <cfg_replication-replication>` parameter defines the URIs at which all instances in the replica set can accept connections. It includes the replica's URI as well, although the replica is not a replication source right now."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:85
msgid "For security reasons, we recommend that administrators prevent unauthorized replication sources by associating a password with every user that has a replication :ref:`role <authentication-roles>`. That way, the :ref:`URI <index-uri>` for ``replication`` parameter must have the long form ``username:password@host:port``."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:91
msgid "the :ref:`read_only = false <cfg_basic-read_only>` parameter setting enables data-change operations on the instance and makes the instance act as a master, not as a replica. *That is the only parameter setting in our instance files that will differ.*"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:95
msgid "the :ref:`box.once() <box-once>` function contains database initialization logic that should be executed only once during the replica set lifetime."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:98
msgid "In this example, we create a space with a primary index, and a user for replication purposes. We also say ``print('box.once executed on master')`` so that it will later be visible on a console whether ``box.once()`` was executed."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:104
msgid "Replication requires privileges. We can grant privileges for accessing spaces directly to the user who will start the instance. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <authentication-roles>`, and then grant the role to the user who will start the replica."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:110
msgid "Here we use Tarantool's predefined role named \"replication\" which by default grants \"read\" privileges for all database objects (\"universe\"), and we can change privileges for this role as required."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:114
msgid "In the replica's instance file, we set the ``read_only`` parameter to \"true\", and say ``print('box.once executed on replica')`` so that later it will be visible that ``box.once()`` was not executed more than once. Otherwise the replica's instance file is identical to the master's instance file."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:119
msgid "-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:138
msgid "The replica does not inherit the master’s configuration parameters, such as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` run on the master. To get the same behavior, set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:143
msgid "Now we can launch the two instances. The master..."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:145
msgid "$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:168
msgid "... (the display confirms that ``box.once()`` was executed on the master) -- and the replica:"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:170
msgid "$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:183
msgid "In both logs, there are messages saying that the replica was bootstrapped from the master:"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:185
msgid "$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:195
msgid "$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:210
msgid "Notice that ``box.once()`` was executed only at the master, although we added ``box.once()`` to both instance files."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:213
msgid "We could as well launch the replica first:"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:215
msgid "$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio.cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:228
msgid "... and the master later:"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:230
msgid "$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> authenticated"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:255
msgid "In this case, the replica would wait for the master to become available, so the launch order doesn't matter. Our ``box.once()`` logic would also be executed only once, at the master."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:259
msgid "$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:279
msgid "Controlled failover"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:281
msgid "To perform a **controlled failover**, that is, swap the roles of the master and replica, all we need to do is to set ``read_only=true`` at the master, and ``read_only=false`` at the replica. The order of actions is important here. If a system is running in production, we do not want concurrent writes happening both at the replica and the master. Nor do we want the new replica to accept any writes until it has finished fetching all replication data from the old master. To compare replica and master state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:290
msgid "Set ``read_only=true`` at the master."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:292
msgid "# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:297
msgid "Record the master’s current position with ``box.info.signature``, containing the sum of all LSNs in the master’s vector clock."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:300
msgid "# at the master\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:305
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:307
msgid "# at the replica\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:312
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:314
msgid "# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:319
msgid "These four steps ensure that the replica doesn’t accept new writes until it’s done fetching writes from the master."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:326
msgid "Master-master bootstrap"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:328
msgid "Now let us bootstrap a two-instance **master-master** set. For easier administration, we make master#1 and master#2 instance files fully identical."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:334
msgid "We re-use the master's instance file from the :ref:`master-replica example <replication-master_replica_bootstrap>` above."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:337
msgid "-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:354
msgid "In the :ref:`replication <cfg_replication-replication>` parameter, we define the URIs of both masters in the replica set and say ``print('box.once executed on master #1')`` so it will be clear when and where the ``box.once()`` logic is executed."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:359
msgid "Now we can launch the two masters. Again, the launch order doesn't matter. The ``box.once()`` logic will also be executed only once, at the master which is elected as the replica set :ref:`leader <replication-leader>` at bootstrap."
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:363
msgid "$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio.cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_bootstrap.rst:387
msgid "$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> authenticated"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:39
msgid "Preventing duplicate actions"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:41
msgid "Tarantool guarantees that every update is applied only once on every replica. However, due to the asynchronous nature of replication, the order of updates is not guaranteed. We now analyze this problem with more details, provide examples of replication going out of sync, and suggest solutions."
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:50
msgid "Replication stops"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:52
msgid "In a replica set of two masters, suppose master #1 tries to do something that master #2 has already done. For example, try to insert a tuple with the same unique key:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:56
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:60
msgid "This would cause an error saying ``Duplicate key exists in unique index 'primary' in space 'tester'`` and the replication would be stopped. (This is the behavior when the :ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>` configuration parameter has its default recommended value, ``false``.)"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:66
msgid "$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> exiting the relay loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:82
msgid "If we check replication statuses with ``box.info``, we will see that replication at master #1 is stopped (``1.upstream.status = stopped``). Additionally, no data is replicated from that master (section ``1.downstream`` is missing in the report), because the downstream has encountered the same error:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:87
msgid "# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        peer: replicator@192.168.0.101:3301\n"
"        lag: 0.00050592422485352\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space 'tester'\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:133
msgid "When replication is later manually resumed:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:135
msgid "# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:142
msgid "... the faulty row in the write-ahead-log files is skipped."
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:148
msgid "Replication runs out of sync"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:150
msgid "In a master-master cluster of two instances, suppose we make the following operation:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:153
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:157
msgid "When this operation is applied on both instances in the replica set:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:159
msgid "# at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"# at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:166
msgid "... we can have the following results, depending on the order of execution:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:168
msgid "each master’s row contains the UUID from master #1,"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:169
msgid "each master’s row contains the UUID from master #2,"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:170
msgid "master #1 has the UUID of master #2, and vice versa."
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:176
msgid "Commutative changes"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:178
msgid "The cases described in the previous paragraphs represent examples of **non-commutative** operations, i.e. operations whose result depends on the execution order. On the contrary, for **commutative operations**, the execution order does not matter."
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:183
msgid "Consider for example the following command:"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:185
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr ""

#: ../doc/2.2/book/replication/repl_duplicates.rst:189
msgid "This operation is commutative: we get the same result no matter in which order the update is applied on the other masters."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:39
msgid "Monitoring a replica set"
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:41
msgid "To learn what instances belong in the replica set, and obtain statistics for all these instances, issue a :ref:`box.info.replication <box_info_replication>` request:"
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:44
msgid "tarantool> box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        peer: replicator@192.168.0.102:3301\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        peer: replicator@192.168.0.103:3301\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:77
msgid "This report is for a master-master replica set of three instances, each having its own instance id, UUID and log sequence number."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:83
msgid "The request was issued at master #1, and the reply includes statistics for the other two masters, given in regard to master #1."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:86
msgid "The primary indicators of replication health are:"
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:90
msgid ":ref:`idle <box_info_replication_upstream_idle>`, the time (in seconds) since the instance received the last event from a master."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:93
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it does not see heartbeat messages within :ref:`replication_timeout <cfg_replication-replication_timeout>` seconds."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:98
msgid "Therefore, in a healthy replication setup, ``idle`` should never exceed ``replication_timeout``: if it does, either the replication is lagging seriously behind, because the master is running ahead of the replica, or the network link between the instances is down."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:103
msgid ":ref:`lag <box_info_replication_upstream_lag>`, the time difference between the local time at the instance, recorded when the event was received, and the local time at another master recorded when the event was written to the :ref:`write ahead log <internals-wal>` on that master."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:108
msgid "Since the ``lag`` calculation uses the operating system clocks from two different machines, do not be surprised if it’s negative: a time drift may lead to the remote master clock being consistently behind the local instance's clock."
msgstr ""

#: ../doc/2.2/book/replication/repl_monitoring.rst:112
msgid "For multi-master configurations, ``lag`` is the maximal lag."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:39
msgid "Recovering from a degraded state"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:41
msgid "\"Degraded state\" is a situation when the master becomes unavailable -- due to hardware or network failure, or due to a programming bug."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:47
msgid "In a master-replica set, if a master disappears, error messages appear on the replicas stating that the connection is lost:"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:50
msgid "$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka 192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> exiting the relay loop"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:61
msgid "... and the master's status is reported as \"disconnected\":"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:63
msgid "# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00026607513427734\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:90
msgid "# report from replica #2\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      peer: replicator@192.168.0.101:3301\n"
"      lag: 0.00027203559875488\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      peer: replicator@192.168.0.102:3301\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:120
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:122
msgid "Make sure that the old master is gone for good:"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:124
msgid "change network routing rules to avoid any more packets being delivered to the master, or"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:126
msgid "shut down the master instance, if you have access to the machine, or"
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:127
msgid "power off the container or the machine."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:129
msgid "Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and ``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:134
msgid "If there are updates on the old master that were not propagated before the old master went down, :ref:`re-apply them manually <admin-disaster_recovery-master_replica>` to the new master using ``tarantoolctl cat`` and ``tarantoolctl play`` commands."
msgstr ""

#: ../doc/2.2/book/replication/repl_recover.rst:139
msgid "There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires an external observer."
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:39
msgid "Removing instances"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:41
msgid "To remove an instance from a replica set politely, follow these steps:"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:43
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:45
msgid "tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:51
msgid "The other instances in the replica set will carry on. If later the removed instance rejoins, it will receive all the updates that the other instances made while it was away."
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:55
msgid "If the instance is decommissioned forever, delete the instance's record from the following locations:"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:58
msgid "the :ref:`replication <cfg_replication-replication>` parameter at all running instances in the replica set:"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:61
msgid "tarantool> box.cfg{replication=...}"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:65
msgid "the :ref:`box.space._cluster <box_space-cluster>` tuple on any master instance in the replica set. For example, for a record with instance id = 3:"
msgstr ""

#: ../doc/2.2/book/replication/repl_remove_instances.rst:68
msgid "tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:39
msgid "Reseeding a replica"
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:41
msgid "If any of a replica's .xlog/.snap/.run files are corrupted or deleted, you can \"re-seed\" the replica:"
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:44
msgid "Stop the replica and destroy all local database files (the ones with extensions .xlog/.snap/.run/.inprogress)."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:47
msgid "Delete the replica's record from the following locations:"
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:49
msgid "the ``replication`` parameter at all running instances in the replica set."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:50
msgid "the ``box.space._cluster`` tuple on the master instance."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:52
msgid "See section :ref:`Removing instances <replication-remove_instances>` for details."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:55
msgid "Restart the replica with the same instance file to contact the master again. The replica will then catch up with the master by retrieving all the master’s tuples."
msgstr ""

#: ../doc/2.2/book/replication/repl_reseed.rst:61
msgid "Remember that this procedure works only if the master’s WAL files are present."
msgstr ""

#: ../doc/2.2/book/sql.rst:39
msgid "SQL"
msgstr ""

#: ../doc/2.2/book/sql.rst:41
msgid "In this section we will go through SQL:2016's \"Feature taxonomy and definition for mandatory features\"."
msgstr ""

#: ../doc/2.2/book/sql.rst:44
msgid "For each feature in that list, we will come up with a simple example SQL statement. If Tarantool appears to handle the example, we will mark it \"Okay\", else we will mark it \"Fail\". Since this is rough and arbitrary, we believe that tests which are unfairly marked \"Okay\" will probably be balanced by tests which are unfairly marked \"Fail\"."
msgstr ""

#: ../doc/2.2/book/sql.rst:57
msgid "Feature ID"
msgstr ""

#: ../doc/2.2/book/sql.rst:57
msgid "Feature"
msgstr ""

#: ../doc/2.2/book/sql.rst:57
msgid "Test"
msgstr ""

#: ../doc/2.2/book/sql.rst:59
msgid "E011"
msgstr ""

#: ../doc/2.2/book/sql.rst:59
msgid "Numeric data types"
msgstr ""

#: ../doc/2.2/book/sql.rst:61
msgid "E011-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:61
msgid "INTEGER and SMALLINT"
msgstr ""

#: ../doc/2.2/book/sql.rst:61
msgid "``create table t (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:61
#: ../doc/2.2/book/sql.rst:63
#: ../doc/2.2/book/sql.rst:79
#: ../doc/2.2/book/sql.rst:81
#: ../doc/2.2/book/sql.rst:106
#: ../doc/2.2/book/sql.rst:108
#: ../doc/2.2/book/sql.rst:110
#: ../doc/2.2/book/sql.rst:128
#: ../doc/2.2/book/sql.rst:130
#: ../doc/2.2/book/sql.rst:134
#: ../doc/2.2/book/sql.rst:136
#: ../doc/2.2/book/sql.rst:138
#: ../doc/2.2/book/sql.rst:141
#: ../doc/2.2/book/sql.rst:145
#: ../doc/2.2/book/sql.rst:147
#: ../doc/2.2/book/sql.rst:153
#: ../doc/2.2/book/sql.rst:155
#: ../doc/2.2/book/sql.rst:157
#: ../doc/2.2/book/sql.rst:159
#: ../doc/2.2/book/sql.rst:161
#: ../doc/2.2/book/sql.rst:163
#: ../doc/2.2/book/sql.rst:167
#: ../doc/2.2/book/sql.rst:169
#: ../doc/2.2/book/sql.rst:171
#: ../doc/2.2/book/sql.rst:175
#: ../doc/2.2/book/sql.rst:178
#: ../doc/2.2/book/sql.rst:186
#: ../doc/2.2/book/sql.rst:194
#: ../doc/2.2/book/sql.rst:224
#: ../doc/2.2/book/sql.rst:226
#: ../doc/2.2/book/sql.rst:228
#: ../doc/2.2/book/sql.rst:230
#: ../doc/2.2/book/sql.rst:232
#: ../doc/2.2/book/sql.rst:234
#: ../doc/2.2/book/sql.rst:238
#: ../doc/2.2/book/sql.rst:240
#: ../doc/2.2/book/sql.rst:243
#: ../doc/2.2/book/sql.rst:245
#: ../doc/2.2/book/sql.rst:251
#: ../doc/2.2/book/sql.rst:253
#: ../doc/2.2/book/sql.rst:267
#: ../doc/2.2/book/sql.rst:271
#: ../doc/2.2/book/sql.rst:274
#: ../doc/2.2/book/sql.rst:280
#: ../doc/2.2/book/sql.rst:284
#: ../doc/2.2/book/sql.rst:287
#: ../doc/2.2/book/sql.rst:293
#: ../doc/2.2/book/sql.rst:302
#: ../doc/2.2/book/sql.rst:314
#: ../doc/2.2/book/sql.rst:327
#: ../doc/2.2/book/sql.rst:343
#: ../doc/2.2/book/sql.rst:346
#: ../doc/2.2/book/sql.rst:348
#: ../doc/2.2/book/sql.rst:354
#: ../doc/2.2/book/sql.rst:360
#: ../doc/2.2/book/sql.rst:387
#: ../doc/2.2/book/sql.rst:392
#: ../doc/2.2/book/sql.rst:395
#: ../doc/2.2/book/sql.rst:398
#: ../doc/2.2/book/sql.rst:401
#: ../doc/2.2/book/sql.rst:406
#: ../doc/2.2/book/sql.rst:412
#: ../doc/2.2/book/sql.rst:414
#: ../doc/2.2/book/sql.rst:416
#: ../doc/2.2/book/sql.rst:418
#: ../doc/2.2/book/sql.rst:436
#: ../doc/2.2/book/sql.rst:460
msgid "Okay."
msgstr ""

#: ../doc/2.2/book/sql.rst:63
msgid "E011-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:63
msgid "REAL, DOUBLE PRECISION, and FLOAT data types"
msgstr ""

#: ../doc/2.2/book/sql.rst:63
msgid "``create table tr (s1 float primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:65
msgid "**Note:** Floating point SQL types are not planned to be compatible between 2.1 and 2.2 releases. The reason is that in 2.1 we set 'number' format for columns of these types, but will restrict it to 'float32' and 'float64' in 2.2. The format change requires data migration and cannot be done automatically, because in 2.1 we have no information to distinguish 'number' columns (created from Lua) from FLOAT/DOUBLE/REAL ones (created from SQL)."
msgstr ""

#: ../doc/2.2/book/sql.rst:75
msgid "E011-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:75
msgid "DECIMAL and NUMERIC data types"
msgstr ""

#: ../doc/2.2/book/sql.rst:75
msgid "``create table td (s1 numeric primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:75
msgid "Fail, DECIMAL and NUMERIC data types are not supported and a number containing post-decimal digits will be treated as approximate numeric."
msgstr ""

#: ../doc/2.2/book/sql.rst:79
msgid "E011-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:79
msgid "Arithmetic operators"
msgstr ""

#: ../doc/2.2/book/sql.rst:79
msgid "``select 10+1,9-2,8*3,7/2 from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:81
msgid "E011-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:81
msgid "Numeric comparisons"
msgstr ""

#: ../doc/2.2/book/sql.rst:81
msgid "``select * from t where 1 < 2;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:83
msgid "E011-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:83
msgid "Implicit casting among the numeric data types"
msgstr ""

#: ../doc/2.2/book/sql.rst:83
msgid "``select * from t where s1 = 1.00;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:83
msgid "Okay, but only because Tarantool doesn't distinguish between numeric data types."
msgstr ""

#: ../doc/2.2/book/sql.rst:86
msgid "E021"
msgstr ""

#: ../doc/2.2/book/sql.rst:86
msgid "Character string types"
msgstr ""

#: ../doc/2.2/book/sql.rst:88
msgid "E021-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:88
msgid "Character data type (including all its spellings)"
msgstr ""

#: ../doc/2.2/book/sql.rst:88
msgid "``create table t44 (s1 char primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:88
msgid "Fail, CHAR is not supported. This type of Fail will only be counted once."
msgstr ""

#: ../doc/2.2/book/sql.rst:91
msgid "E021-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:91
msgid "CHARACTER VARYING data type (including all its spellings)"
msgstr ""

#: ../doc/2.2/book/sql.rst:91
msgid "``create table t45 (s1 varchar primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:91
msgid "Fail, only the spelling VARCHAR is allowed."
msgstr ""

#: ../doc/2.2/book/sql.rst:93
msgid "**Note:** VARCHAR(N) does not check the string length."
msgstr ""

#: ../doc/2.2/book/sql.rst:95
msgid "E021-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:95
msgid "Character literals"
msgstr ""

#: ../doc/2.2/book/sql.rst:95
msgid "``insert into t45 values ('');``"
msgstr ""

#: ../doc/2.2/book/sql.rst:95
msgid "Okay, and the bad practice of accepting \"\"'s for character literals is avoided."
msgstr ""

#: ../doc/2.2/book/sql.rst:98
msgid "E021-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:98
msgid "CHARACTER_LENGTH function"
msgstr ""

#: ../doc/2.2/book/sql.rst:98
msgid "``select character_length(s1) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:98
msgid "Fail. There is no such function. There is a function LENGTH(), which is okay."
msgstr ""

#: ../doc/2.2/book/sql.rst:101
msgid "E021-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:101
msgid "OCTET_LENGTH"
msgstr ""

#: ../doc/2.2/book/sql.rst:101
msgid "``select octet_length(s1) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:101
msgid "Fail. There is no such function."
msgstr ""

#: ../doc/2.2/book/sql.rst:103
msgid "E021-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:103
msgid "SUBSTRING function."
msgstr ""

#: ../doc/2.2/book/sql.rst:103
msgid "``select substring(s1 from 1 for 1) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:103
msgid "Fail. There is no such function. There is a function SUBSTR(x,n,n) which is okay."
msgstr ""

#: ../doc/2.2/book/sql.rst:106
msgid "E021-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:106
msgid "Character concatenation"
msgstr ""

#: ../doc/2.2/book/sql.rst:106
msgid "``select 'a' || 'b' from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:108
msgid "E021-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:108
msgid "UPPER and LOWER functions"
msgstr ""

#: ../doc/2.2/book/sql.rst:108
msgid "``select upper('a'),lower('B') from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:110
msgid "E021-09"
msgstr ""

#: ../doc/2.2/book/sql.rst:110
msgid "TRIM function"
msgstr ""

#: ../doc/2.2/book/sql.rst:110
msgid "``select trim('a ') from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:112
msgid "E021-10"
msgstr ""

#: ../doc/2.2/book/sql.rst:112
msgid "Implicit casting among the fixed-length and variable-length character string types"
msgstr ""

#: ../doc/2.2/book/sql.rst:112
msgid "``select * from tm where char_column > varchar_column;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:112
msgid "Fail, there is no fixed-length character string type."
msgstr ""

#: ../doc/2.2/book/sql.rst:115
msgid "E021-11"
msgstr ""

#: ../doc/2.2/book/sql.rst:115
msgid "POSITION function"
msgstr ""

#: ../doc/2.2/book/sql.rst:115
msgid "``select position(x in y) from z;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:115
msgid "Fail. Tarantool's function uses ',' rather than 'in'"
msgstr ""

#: ../doc/2.2/book/sql.rst:117
msgid "E021-12"
msgstr ""

#: ../doc/2.2/book/sql.rst:117
msgid "Character comparison"
msgstr ""

#: ../doc/2.2/book/sql.rst:117
msgid "``select * from t where s1 > 'a';``"
msgstr ""

#: ../doc/2.2/book/sql.rst:117
msgid "Okay. We should note here that comparisons use a binary collation by default, but it is easy to specify unicode or unicode_ci collations, or create new collations."
msgstr ""

#: ../doc/2.2/book/sql.rst:121
msgid "E031"
msgstr ""

#: ../doc/2.2/book/sql.rst:121
msgid "Identifiers"
msgstr ""

#: ../doc/2.2/book/sql.rst:121
msgid "``create table rank (ceil int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:121
msgid "Fail. Tarantool's list of reserved words differs from the standard's list of reserved words."
msgstr ""

#: ../doc/2.2/book/sql.rst:124
msgid "E031-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:124
msgid "Delimited Identifiers"
msgstr ""

#: ../doc/2.2/book/sql.rst:124
msgid "``create table \"t47\" (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:124
msgid "Okay. And enclosing identifiers inside double quotes means they won't be converted to upper case or lower case, this is behavior that some other DBMSs sadly lack."
msgstr ""

#: ../doc/2.2/book/sql.rst:128
msgid "E031-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:128
msgid "Lower case identifiers"
msgstr ""

#: ../doc/2.2/book/sql.rst:128
msgid "``create table t48 (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:130
msgid "E031-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:130
msgid "Trailing underscore"
msgstr ""

#: ../doc/2.2/book/sql.rst:130
msgid "``create table t49_ (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:132
msgid "E051"
msgstr ""

#: ../doc/2.2/book/sql.rst:132
msgid "Basic query specification"
msgstr ""

#: ../doc/2.2/book/sql.rst:134
msgid "E051-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:134
msgid "SELECT DISTINCT"
msgstr ""

#: ../doc/2.2/book/sql.rst:134
msgid "``select distinct s1 from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:136
msgid "E051-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:136
#: ../doc/2.2/reference/reference_sql/sql.rst:1651
msgid "GROUP BY clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:136
msgid "``select distinct s1 from t group by s1;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:138
msgid "E051-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:138
msgid "GROUP BY can contain columns not in select list"
msgstr ""

#: ../doc/2.2/book/sql.rst:138
msgid "``select s1 from t group by lower(s1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:141
msgid "E051-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:141
msgid "Select list items can be renamed"
msgstr ""

#: ../doc/2.2/book/sql.rst:141
msgid "``select s1 as K from t order by K;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:143
msgid "E051-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:143
#: ../doc/2.2/reference/reference_sql/sql.rst:1803
msgid "HAVING clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:143
msgid "``select count(*) from t having count(*) > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:143
msgid "Okay. GROUP BY is not mandatory before HAVING."
msgstr ""

#: ../doc/2.2/book/sql.rst:145
msgid "E051-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:145
msgid "Qualified * in select list"
msgstr ""

#: ../doc/2.2/book/sql.rst:145
msgid "``select t.* from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:147
msgid "E051-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:147
msgid "Correlation names in the FROM clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:147
msgid "``select * from t as K;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:149
msgid "E051-09"
msgstr ""

#: ../doc/2.2/book/sql.rst:149
msgid "Rename columns in the FROM clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:149
msgid "``select * from t as x(q,c);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:149
msgid "Fail."
msgstr ""

#: ../doc/2.2/book/sql.rst:151
msgid "E061"
msgstr ""

#: ../doc/2.2/book/sql.rst:151
msgid "Basic predicates and search conditions"
msgstr ""

#: ../doc/2.2/book/sql.rst:153
msgid "E061-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:153
msgid "Comparison predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:153
msgid "``select * from t where 0 = 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:155
msgid "E061-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:155
msgid "BETWEEN predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:155
msgid "``select * from t where ' ' between '' and ' ';``"
msgstr ""

#: ../doc/2.2/book/sql.rst:157
msgid "E061-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:157
msgid "IN predicate with list of values"
msgstr ""

#: ../doc/2.2/book/sql.rst:157
msgid "``select * from t where s1 in ('a',upper('a'));``"
msgstr ""

#: ../doc/2.2/book/sql.rst:159
msgid "E061-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:159
msgid "LIKE predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:159
msgid "``select * from t where s1 like '_';``"
msgstr ""

#: ../doc/2.2/book/sql.rst:161
msgid "E061-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:161
msgid "LIKE predicate: ESCAPE clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:161
msgid "``VALUES ('abc_' LIKE 'abcX_' ESCAPE 'X');``"
msgstr ""

#: ../doc/2.2/book/sql.rst:163
msgid "E061-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:163
msgid "NULL predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:163
msgid "``select * from t where s1 is not null;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:165
msgid "E061-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:165
msgid "Quantified comparison predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:165
msgid "``select * from t where s1 = any (select s1 from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:165
#: ../doc/2.2/book/sql.rst:173
#: ../doc/2.2/book/sql.rst:306
#: ../doc/2.2/book/sql.rst:309
#: ../doc/2.2/book/sql.rst:351
#: ../doc/2.2/book/sql.rst:367
#: ../doc/2.2/book/sql.rst:370
#: ../doc/2.2/book/sql.rst:379
#: ../doc/2.2/book/sql.rst:381
#: ../doc/2.2/book/sql.rst:383
#: ../doc/2.2/book/sql.rst:385
#: ../doc/2.2/book/sql.rst:408
#: ../doc/2.2/book/sql.rst:438
msgid "Fail. Syntax error."
msgstr ""

#: ../doc/2.2/book/sql.rst:167
msgid "E061-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:167
msgid "EXISTS predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:167
msgid "``select * from t where not exists (select * from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:169
msgid "E061-09"
msgstr ""

#: ../doc/2.2/book/sql.rst:169
msgid "Subqueries in comparison predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:169
msgid "``select * from t where s1 > (select s1 from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:171
msgid "E061-11"
msgstr ""

#: ../doc/2.2/book/sql.rst:171
msgid "Subqueries in IN predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:171
msgid "``select * from t where s1 in (select s1 from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:173
msgid "E061-12"
msgstr ""

#: ../doc/2.2/book/sql.rst:173
msgid "Subqueries in quantified comparison predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:173
msgid "``select * from t where s1 >= all (select s1 from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:175
msgid "E061-13"
msgstr ""

#: ../doc/2.2/book/sql.rst:175
msgid "Correlated subqueries"
msgstr ""

#: ../doc/2.2/book/sql.rst:175
msgid "``select * from t where s1 = (select s1 from t2 where t2.s2 = t.s1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:178
msgid "E061-14"
msgstr ""

#: ../doc/2.2/book/sql.rst:178
msgid "Search condition"
msgstr ""

#: ../doc/2.2/book/sql.rst:178
msgid "``select * from t where 0 <> 0 or 'a' < 'b' and s1 is null;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:181
msgid "E071"
msgstr ""

#: ../doc/2.2/book/sql.rst:181
msgid "Basic query expressions"
msgstr ""

#: ../doc/2.2/book/sql.rst:183
msgid "E071-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:183
msgid "UNION DISTINCT table operator"
msgstr ""

#: ../doc/2.2/book/sql.rst:183
msgid "``select * from t union distinct select * from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:183
msgid "Fail. However, \"select * from t union select * from t;\" is okay."
msgstr ""

#: ../doc/2.2/book/sql.rst:186
msgid "E071-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:186
msgid "UNION ALL table operator"
msgstr ""

#: ../doc/2.2/book/sql.rst:186
msgid "``select * from t union all select * from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:188
msgid "E071-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:188
msgid "EXCEPT DISTINCT table operator"
msgstr ""

#: ../doc/2.2/book/sql.rst:188
msgid "``select * from t except distinct select * from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:188
msgid "Fail. However, ``select * from t except select * from t;`` is okay."
msgstr ""

#: ../doc/2.2/book/sql.rst:191
msgid "E071-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:191
msgid "Columns combined via table operators need not have exactly the same data type."
msgstr ""

#: ../doc/2.2/book/sql.rst:191
msgid "``select s1 from t union select 5 from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:191
msgid "Okay, but only because Tarantool doesn't distinguish data types very well."
msgstr ""

#: ../doc/2.2/book/sql.rst:194
msgid "E071-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:194
msgid "Table operators in subqueries"
msgstr ""

#: ../doc/2.2/book/sql.rst:194
msgid "``select * from t where 'a' in (select * from t union select * from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:197
msgid "E081"
msgstr ""

#: ../doc/2.2/book/sql.rst:197
msgid "Basic privileges"
msgstr ""

#: ../doc/2.2/book/sql.rst:199
msgid "E081-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:199
msgid "Select privilege at the table level"
msgstr ""

#: ../doc/2.2/book/sql.rst:199
msgid "Fail. Syntax error. (Tarantool doesn't support privileges.)"
msgstr ""

#: ../doc/2.2/book/sql.rst:202
msgid "E081-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:202
msgid "DELETE privilege"
msgstr ""

#: ../doc/2.2/book/sql.rst:202
#: ../doc/2.2/book/sql.rst:204
#: ../doc/2.2/book/sql.rst:206
#: ../doc/2.2/book/sql.rst:208
#: ../doc/2.2/book/sql.rst:210
#: ../doc/2.2/book/sql.rst:212
#: ../doc/2.2/book/sql.rst:214
#: ../doc/2.2/book/sql.rst:216
#: ../doc/2.2/book/sql.rst:218
msgid "Fail. (Tarantool doesn't support privileges.)"
msgstr ""

#: ../doc/2.2/book/sql.rst:204
msgid "E081-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:204
msgid "INSERT privilege at the table level"
msgstr ""

#: ../doc/2.2/book/sql.rst:206
msgid "E081-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:206
msgid "UPDATE privilege at the table level"
msgstr ""

#: ../doc/2.2/book/sql.rst:208
msgid "E081-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:208
msgid "UPDATE privilege at column level"
msgstr ""

#: ../doc/2.2/book/sql.rst:210
msgid "E081-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:210
msgid "REFERENCES privilege at the table level"
msgstr ""

#: ../doc/2.2/book/sql.rst:212
msgid "E081-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:212
msgid "REFERENCES privilege at column level"
msgstr ""

#: ../doc/2.2/book/sql.rst:214
msgid "E081-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:214
msgid "WITH GRANT OPTION"
msgstr ""

#: ../doc/2.2/book/sql.rst:216
msgid "E081-09"
msgstr ""

#: ../doc/2.2/book/sql.rst:216
msgid "USAGE privilege"
msgstr ""

#: ../doc/2.2/book/sql.rst:218
msgid "E081-10"
msgstr ""

#: ../doc/2.2/book/sql.rst:218
msgid "EXECUTE privilege"
msgstr ""

#: ../doc/2.2/book/sql.rst:220
msgid "E091"
msgstr ""

#: ../doc/2.2/book/sql.rst:220
msgid "Set functions"
msgstr ""

#: ../doc/2.2/book/sql.rst:222
msgid "E091-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:222
msgid "AVG"
msgstr ""

#: ../doc/2.2/book/sql.rst:222
msgid "``select avg(s1) from t7;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:222
msgid "Fail. No warning that nulls were eliminated."
msgstr ""

#: ../doc/2.2/book/sql.rst:224
msgid "E091-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:224
msgid "COUNT"
msgstr ""

#: ../doc/2.2/book/sql.rst:224
msgid "``select count(*) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:226
msgid "E091-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:226
msgid "MAX"
msgstr ""

#: ../doc/2.2/book/sql.rst:226
msgid "``select max(s1) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:228
msgid "E091-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:228
msgid "MIN"
msgstr ""

#: ../doc/2.2/book/sql.rst:228
msgid "``select min(s1) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:230
msgid "E091-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:230
msgid "SUM"
msgstr ""

#: ../doc/2.2/book/sql.rst:230
msgid "``select sum(1) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:232
msgid "E091-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:232
msgid "ALL quantifier"
msgstr ""

#: ../doc/2.2/book/sql.rst:232
msgid "``select sum(all s1) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:234
msgid "E091-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:234
msgid "DISTINCT quantifier"
msgstr ""

#: ../doc/2.2/book/sql.rst:234
msgid "``select sum(distinct s1) from t7 where s1 > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:236
msgid "E101"
msgstr ""

#: ../doc/2.2/book/sql.rst:236
msgid "Basic data manipulation"
msgstr ""

#: ../doc/2.2/book/sql.rst:238
msgid "E101-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:238
msgid "INSERT statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:238
msgid "``insert into t (s1,s2) values (1,''),(2,null),(3,55);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:240
msgid "E101-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:240
msgid "Searched UPDATE statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:240
msgid "``update t set s1 = null where s1 in (select s1 from t2);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:243
msgid "E101-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:243
msgid "Searched DELETE statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:243
msgid "``delete from t where s1 in (select s1 from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:245
msgid "E111"
msgstr ""

#: ../doc/2.2/book/sql.rst:245
msgid "Single row SELECT statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:245
msgid "``select count(*) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:247
msgid "E121"
msgstr ""

#: ../doc/2.2/book/sql.rst:247
msgid "Basic cursor support"
msgstr ""

#: ../doc/2.2/book/sql.rst:249
msgid "E121-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:249
msgid "DECLARE CURSOR"
msgstr ""

#: ../doc/2.2/book/sql.rst:249
#: ../doc/2.2/book/sql.rst:255
#: ../doc/2.2/book/sql.rst:257
#: ../doc/2.2/book/sql.rst:259
#: ../doc/2.2/book/sql.rst:261
#: ../doc/2.2/book/sql.rst:263
#: ../doc/2.2/book/sql.rst:265
msgid "Fail. Tarantool doesn't support cursors."
msgstr ""

#: ../doc/2.2/book/sql.rst:251
msgid "E121-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:251
msgid "ORDER BY columns need not be in select list"
msgstr ""

#: ../doc/2.2/book/sql.rst:251
msgid "``select s1 from t order by s2;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:253
msgid "E121-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:253
msgid "Value expressions in select list"
msgstr ""

#: ../doc/2.2/book/sql.rst:253
msgid "``select s1 from t7 order by -s1;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:255
msgid "E121-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:255
msgid "OPEN statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:257
msgid "E121-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:257
msgid "Positioned UPDATE statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:259
msgid "E121-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:259
msgid "Positioned DELETE statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:261
msgid "E121-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:261
msgid "CLOSE statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:263
msgid "E121-10"
msgstr ""

#: ../doc/2.2/book/sql.rst:263
msgid "FETCH statement implicit next"
msgstr ""

#: ../doc/2.2/book/sql.rst:265
msgid "E121-17"
msgstr ""

#: ../doc/2.2/book/sql.rst:265
msgid "WITH HOLD cursors"
msgstr ""

#: ../doc/2.2/book/sql.rst:267
msgid "E131"
msgstr ""

#: ../doc/2.2/book/sql.rst:267
msgid "Null value support (nulls in lieu of values)"
msgstr ""

#: ../doc/2.2/book/sql.rst:267
msgid "``select s1 from t7 where s1 is null;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:269
msgid "E141"
msgstr ""

#: ../doc/2.2/book/sql.rst:269
msgid "Basic integrity constraints"
msgstr ""

#: ../doc/2.2/book/sql.rst:271
msgid "E141-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:271
msgid "NOT NULL constraints"
msgstr ""

#: ../doc/2.2/book/sql.rst:271
msgid "``create table t8 (s1 int primary key, s2 int not null);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:274
msgid "E141-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:274
msgid "UNIQUE constraints of NOT NULL columns"
msgstr ""

#: ../doc/2.2/book/sql.rst:274
msgid "``create table t9 (s1 int primary key , s2 int not null unique);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:277
msgid "E141-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:277
msgid "PRIMARY KEY constraints"
msgstr ""

#: ../doc/2.2/book/sql.rst:277
msgid "``create table t10 (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:277
msgid "Okay, although Tarantool shouldn't always insist on having a primary key."
msgstr ""

#: ../doc/2.2/book/sql.rst:280
msgid "E141-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:280
msgid "Basic FOREIGN KEY constraint with the NO ACTION default for both referential delete action and referential update action."
msgstr ""

#: ../doc/2.2/book/sql.rst:280
msgid "``create table t11 (s0 int primary key, s1 int references t10);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:284
msgid "E141-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:284
msgid "CHECK constraints"
msgstr ""

#: ../doc/2.2/book/sql.rst:284
msgid "``create table t12 (s1 int primary key, s2 int, check (s1 = s2));``"
msgstr ""

#: ../doc/2.2/book/sql.rst:287
msgid "E141-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:287
msgid "Column defaults"
msgstr ""

#: ../doc/2.2/book/sql.rst:287
msgid "``create table t13 (s1 int primary key, s2 int default -1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:290
msgid "E141-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:290
msgid "NOT NULL inferred on primary key"
msgstr ""

#: ../doc/2.2/book/sql.rst:290
msgid "``create table t14 (s1 int primary key);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:290
msgid "Okay. We are unable to insert NULL although we don't explicitly say the column is NOT NULL."
msgstr ""

#: ../doc/2.2/book/sql.rst:293
msgid "E141-10"
msgstr ""

#: ../doc/2.2/book/sql.rst:293
msgid "Names in a foreign key can be specified in any order"
msgstr ""

#: ../doc/2.2/book/sql.rst:293
msgid "``create table t15 (s1 int, s2 int, primary key (s1,s2));`` ``create table t16 (s1 int primary key, s2 int, foreign key (s2,s1) references t15 (s1,s2));``"
msgstr ""

#: ../doc/2.2/book/sql.rst:298
msgid "E151"
msgstr ""

#: ../doc/2.2/book/sql.rst:298
msgid "Transaction support"
msgstr ""

#: ../doc/2.2/book/sql.rst:300
msgid "E151-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:300
msgid "COMMIT statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:300
msgid "``commit;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:300
msgid "Fail. We have to say START TRANSACTION first."
msgstr ""

#: ../doc/2.2/book/sql.rst:302
msgid "E151-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:302
msgid "ROLLBACK statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:302
msgid "``rollback;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:304
msgid "E152"
msgstr ""

#: ../doc/2.2/book/sql.rst:304
msgid "Basic SET TRANSACTION statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:306
msgid "E152-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:306
msgid "SET TRANSACTION statement ISOLATION SERIALIZABLE clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:306
msgid "``set transaction isolation level serializable;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:309
msgid "E152-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:309
msgid "SET TRANSACTION statement READ ONLY and READ WRITE clauses"
msgstr ""

#: ../doc/2.2/book/sql.rst:309
msgid "``set transaction read only;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:312
msgid "E153"
msgstr ""

#: ../doc/2.2/book/sql.rst:312
msgid "Updatable queries with subqueries"
msgstr ""

#: ../doc/2.2/book/sql.rst:314
msgid "E161"
msgstr ""

#: ../doc/2.2/book/sql.rst:314
msgid "SQL comments using leading double minus"
msgstr ""

#: ../doc/2.2/book/sql.rst:314
msgid "``--comment;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:316
msgid "E171"
msgstr ""

#: ../doc/2.2/book/sql.rst:316
msgid "SQLSTATE support"
msgstr ""

#: ../doc/2.2/book/sql.rst:316
msgid "``drop table no_such_table;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:316
msgid "Fail. At least, the error message doesn't hint that SQLSTATE exists."
msgstr ""

#: ../doc/2.2/book/sql.rst:319
msgid "E182"
msgstr ""

#: ../doc/2.2/book/sql.rst:319
msgid "Host language binding"
msgstr ""

#: ../doc/2.2/book/sql.rst:319
msgid "Okay. Any of the Tarantool connectors should be able to call ``box.execute()``."
msgstr ""

#: ../doc/2.2/book/sql.rst:322
msgid "F031"
msgstr ""

#: ../doc/2.2/book/sql.rst:322
msgid "Basic schema manipulation"
msgstr ""

#: ../doc/2.2/book/sql.rst:324
msgid "F031-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:324
msgid "CREATE TABLE statement to create persistent base tables"
msgstr ""

#: ../doc/2.2/book/sql.rst:324
msgid "``create table t20 (t20_1 int not null);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:324
msgid "Fail. We always have to say PRIMARY KEY (we only count this flaw once)."
msgstr ""

#: ../doc/2.2/book/sql.rst:327
msgid "F031-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:327
msgid "CREATE VIEW statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:327
msgid "``create view t21 as select * from t20;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:329
msgid "F031-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:329
#: ../doc/2.2/book/sql.rst:433
msgid "GRANT statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:329
msgid "Fail. Tarantool doesn't support privileges except via NoSQL."
msgstr ""

#: ../doc/2.2/book/sql.rst:332
msgid "F031-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:332
msgid "ALTER TABLE statement: add column"
msgstr ""

#: ../doc/2.2/book/sql.rst:332
msgid "``alter table t7 add column t7_2 varchar default 'q';``"
msgstr ""

#: ../doc/2.2/book/sql.rst:332
msgid "Fail. Table alterations work but not this clause."
msgstr ""

#: ../doc/2.2/book/sql.rst:334
msgid "F031-13"
msgstr ""

#: ../doc/2.2/book/sql.rst:334
msgid "DROP TABLE statement: RESTRICT clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:334
msgid "``drop table t20 restrict;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:334
#: ../doc/2.2/book/sql.rst:336
msgid "Fail. Syntax error, and RESTRICT is not assumed."
msgstr ""

#: ../doc/2.2/book/sql.rst:336
msgid "F031-16"
msgstr ""

#: ../doc/2.2/book/sql.rst:336
msgid "DROP VIEW statement: RESTRICT clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:336
msgid "``drop view v2 restrict;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:338
msgid "F031-19"
msgstr ""

#: ../doc/2.2/book/sql.rst:338
msgid "REVOKE statement: RESTRICT clause"
msgstr ""

#: ../doc/2.2/book/sql.rst:338
msgid "Fail. Tarantool does not support privileges except via NoSQL."
msgstr ""

#: ../doc/2.2/book/sql.rst:341
msgid "F041"
msgstr ""

#: ../doc/2.2/book/sql.rst:341
msgid "Basic joined table"
msgstr ""

#: ../doc/2.2/book/sql.rst:343
msgid "F041-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:343
msgid "Inner join but not necessarily the INNER keyword"
msgstr ""

#: ../doc/2.2/book/sql.rst:343
msgid "``select a.s1 from t7 a join t7 b;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:346
msgid "F041-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:346
msgid "INNER keyword"
msgstr ""

#: ../doc/2.2/book/sql.rst:346
msgid "``select a.s1 from t7 a inner join t7 b;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:348
msgid "F041-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:348
msgid "LEFT OUTER JOIN"
msgstr ""

#: ../doc/2.2/book/sql.rst:348
msgid "``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:351
msgid "F041-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:351
msgid "RIGHT OUTER JOIN"
msgstr ""

#: ../doc/2.2/book/sql.rst:351
msgid "``select t7.*,t22.* from t22 right outer join t7 on (t22_1=s1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:354
msgid "F041-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:354
msgid "Outer joins can be nested"
msgstr ""

#: ../doc/2.2/book/sql.rst:354
msgid "``select t7.*,t22.* from t22 left outer join t7 on (t22_1=s1) left outer join t23;``."
msgstr ""

#: ../doc/2.2/book/sql.rst:357
msgid "F041-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:357
msgid "The inner table in a left or right outer join can also be used in an inner join"
msgstr ""

#: ../doc/2.2/book/sql.rst:357
msgid "``select t7.* from t22 left outer join t7 on (t22_1=s1) inner join t22 on (t22_4=t22_5);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:357
msgid "Okay. The query fails due to a syntax error but that's expectable."
msgstr ""

#: ../doc/2.2/book/sql.rst:360
msgid "F041-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:360
msgid "All comparison operators are supported"
msgstr ""

#: ../doc/2.2/book/sql.rst:360
msgid "``select * from t where 0=1 or 0>1 or 0<1 or 0<>1;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:362
msgid "F051 Basic date and time"
msgstr ""

#: ../doc/2.2/book/sql.rst:364
msgid "F051-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:364
msgid "DATE data type (including support of DATE literal)"
msgstr ""

#: ../doc/2.2/book/sql.rst:364
msgid "``create table dates (s1 date);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:364
msgid "Fail. Tarantool does not support DATE data type."
msgstr ""

#: ../doc/2.2/book/sql.rst:367
msgid "F051-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:367
msgid "TIME data type (including support of TIME literal)"
msgstr ""

#: ../doc/2.2/book/sql.rst:367
msgid "``create table times (s1 time default time '1:2:3');``"
msgstr ""

#: ../doc/2.2/book/sql.rst:370
msgid "F051-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:370
msgid "TIMESTAMP data type (including support of TIMESTAMP literal)"
msgstr ""

#: ../doc/2.2/book/sql.rst:370
msgid "``create table timestamps (s1 timestamp);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:373
msgid "F051-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:373
msgid "Comparison predicate on DATE, TIME and TIMESTAMP data types"
msgstr ""

#: ../doc/2.2/book/sql.rst:373
msgid "``select * from dates where s1 = s1;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:373
#: ../doc/2.2/book/sql.rst:376
msgid "Fail. The data types are not supported."
msgstr ""

#: ../doc/2.2/book/sql.rst:376
msgid "F051-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:376
msgid "Explicit CAST between date-time types and character string types"
msgstr ""

#: ../doc/2.2/book/sql.rst:376
msgid "``select cast(s1 as varchar(10)) from dates;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:379
msgid "F051-06"
msgstr ""

#: ../doc/2.2/book/sql.rst:379
msgid "CURRENT_DATE"
msgstr ""

#: ../doc/2.2/book/sql.rst:379
msgid "``select current_date from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:381
msgid "F051-07"
msgstr ""

#: ../doc/2.2/book/sql.rst:381
msgid "CURRENT_TIME"
msgstr ""

#: ../doc/2.2/book/sql.rst:381
msgid "``select * from t where current_time < '23:23:23';``"
msgstr ""

#: ../doc/2.2/book/sql.rst:383
msgid "F051-08"
msgstr ""

#: ../doc/2.2/book/sql.rst:383
msgid "LOCALTIME"
msgstr ""

#: ../doc/2.2/book/sql.rst:383
msgid "``select localtime from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:385
msgid "F051-09"
msgstr ""

#: ../doc/2.2/book/sql.rst:385
msgid "LOCALTIMESTAMP"
msgstr ""

#: ../doc/2.2/book/sql.rst:385
msgid "``select localtimestamp from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:387
msgid "F081"
msgstr ""

#: ../doc/2.2/book/sql.rst:387
msgid "UNION and EXCEPT in views"
msgstr ""

#: ../doc/2.2/book/sql.rst:387
msgid "``create view vv as select * from t7 except select * from t15;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:390
msgid "F131"
msgstr ""

#: ../doc/2.2/book/sql.rst:390
msgid "Grouped operations"
msgstr ""

#: ../doc/2.2/book/sql.rst:392
msgid "F131-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:392
msgid "WHERE, GROUP BY, and HAVING clauses supported in queries with grouped views"
msgstr ""

#: ../doc/2.2/book/sql.rst:392
msgid "``create view vv2 as select * from vv group by s1;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:395
msgid "F131-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:395
msgid "Multiple tables supported in queries with grouped views"
msgstr ""

#: ../doc/2.2/book/sql.rst:395
msgid "``create view vv3 as select * from vv2,t30;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:398
msgid "F131-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:398
msgid "Set functions supported in queries with grouped views"
msgstr ""

#: ../doc/2.2/book/sql.rst:398
msgid "``create view vv4 as select count(*) from vv2;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:401
msgid "F131-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:401
msgid "Subqueries with GROUP BY and HAVING clauses and grouped views"
msgstr ""

#: ../doc/2.2/book/sql.rst:401
msgid "``create view vv5 as select count(*) from vv2 group by s1 having count(*) > 0;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:404
msgid "F181"
msgstr ""

#: ../doc/2.2/book/sql.rst:404
msgid "Multiple module support"
msgstr ""

#: ../doc/2.2/book/sql.rst:404
msgid "Fail. Tarantool doesn't have modules."
msgstr ""

#: ../doc/2.2/book/sql.rst:406
msgid "F201"
msgstr ""

#: ../doc/2.2/book/sql.rst:406
msgid "CAST function"
msgstr ""

#: ../doc/2.2/book/sql.rst:406
msgid "``select cast(s1 as int) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:408
msgid "F221"
msgstr ""

#: ../doc/2.2/book/sql.rst:408
msgid "Explicit defaults"
msgstr ""

#: ../doc/2.2/book/sql.rst:408
msgid "``update t set s1 = default;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:410
msgid "F261"
msgstr ""

#: ../doc/2.2/book/sql.rst:410
msgid "CASE expression"
msgstr ""

#: ../doc/2.2/book/sql.rst:412
msgid "F261-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:412
msgid "Simple CASE"
msgstr ""

#: ../doc/2.2/book/sql.rst:412
msgid "``select case when 1 = 0 then 5 else 7 end from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:414
msgid "F261-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:414
msgid "Searched CASE"
msgstr ""

#: ../doc/2.2/book/sql.rst:414
msgid "``select case 1 when 0 then 5 else 7 end from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:416
msgid "F261-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:416
#: ../doc/2.2/reference/reference_sql/sql.rst:2737
msgid "NULLIF"
msgstr ""

#: ../doc/2.2/book/sql.rst:416
msgid "``select nullif(s1,7) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:418
msgid "F261-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:418
#: ../doc/2.2/reference/reference_sql/sql.rst:2653
msgid "COALESCE"
msgstr ""

#: ../doc/2.2/book/sql.rst:418
msgid "``select coalesce(s1,7) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:420
msgid "F311"
msgstr ""

#: ../doc/2.2/book/sql.rst:420
msgid "Schema definition statement"
msgstr ""

#: ../doc/2.2/book/sql.rst:422
msgid "F311-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:422
msgid "CREATE SCHEMA"
msgstr ""

#: ../doc/2.2/book/sql.rst:422
msgid "Fail. Tarantool doesn't have schemas or databases."
msgstr ""

#: ../doc/2.2/book/sql.rst:424
msgid "F311-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:424
msgid "CREATE TABLE for persistent base tables"
msgstr ""

#: ../doc/2.2/book/sql.rst:424
msgid "Fail. Tarantool doesn't have CREATE TABLE inside CREATE SCHEMA."
msgstr ""

#: ../doc/2.2/book/sql.rst:427
msgid "F311-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:427
#: ../doc/2.2/reference/reference_sql/sql.rst:591
msgid "CREATE VIEW"
msgstr ""

#: ../doc/2.2/book/sql.rst:427
#: ../doc/2.2/book/sql.rst:430
msgid "Fail. Tarantool doesn't have CREATE VIEW inside CREATE SCHEMA."
msgstr ""

#: ../doc/2.2/book/sql.rst:430
msgid "F311-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:430
msgid "CREATE VIEW: WITH CHECK OPTION"
msgstr ""

#: ../doc/2.2/book/sql.rst:433
msgid "F311-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:433
msgid "Fail. Tarantool doesn't have GRANT inside CREATE SCHEMA."
msgstr ""

#: ../doc/2.2/book/sql.rst:436
msgid "F471"
msgstr ""

#: ../doc/2.2/book/sql.rst:436
msgid "Scalar subquery values"
msgstr ""

#: ../doc/2.2/book/sql.rst:436
msgid "``select s1 from t where s1 = (select count(*) from t);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:438
msgid "F481"
msgstr ""

#: ../doc/2.2/book/sql.rst:438
msgid "Expanded NULL Predicate"
msgstr ""

#: ../doc/2.2/book/sql.rst:438
msgid "``select * from t where row(s1,s1) is not null;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:440
msgid "F812"
msgstr ""

#: ../doc/2.2/book/sql.rst:440
msgid "Basic flagging"
msgstr ""

#: ../doc/2.2/book/sql.rst:440
msgid "Fail. Tarantool doesn't support any flagging."
msgstr ""

#: ../doc/2.2/book/sql.rst:442
msgid "S011"
msgstr ""

#: ../doc/2.2/book/sql.rst:442
msgid "Distinct types"
msgstr ""

#: ../doc/2.2/book/sql.rst:442
msgid "``create type x as float;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:442
msgid "Fail. Tarantool doesn't support distinct types."
msgstr ""

#: ../doc/2.2/book/sql.rst:444
msgid "T321"
msgstr ""

#: ../doc/2.2/book/sql.rst:444
msgid "Basic SQL-invoked routines"
msgstr ""

#: ../doc/2.2/book/sql.rst:446
msgid "T321-01"
msgstr ""

#: ../doc/2.2/book/sql.rst:446
msgid "User-defined functions with no overloading"
msgstr ""

#: ../doc/2.2/book/sql.rst:446
msgid "``create function f () returns int return 5;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:446
msgid "Fail. Tarantool doesn't support user-defined SQL functions."
msgstr ""

#: ../doc/2.2/book/sql.rst:449
msgid "T321-02"
msgstr ""

#: ../doc/2.2/book/sql.rst:449
msgid "User-defined procedures with no overloading"
msgstr ""

#: ../doc/2.2/book/sql.rst:449
msgid "``create procedure p () begin end;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:449
#: ../doc/2.2/book/sql.rst:454
msgid "Fail. Tarantool doesn't support user-defined procedures."
msgstr ""

#: ../doc/2.2/book/sql.rst:452
msgid "T321-03"
msgstr ""

#: ../doc/2.2/book/sql.rst:452
msgid "Function invocation"
msgstr ""

#: ../doc/2.2/book/sql.rst:452
msgid "``select f(1) from t;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:452
msgid "Okay. Tarantool can invoke Lua user-defined functions."
msgstr ""

#: ../doc/2.2/book/sql.rst:454
msgid "T321-04"
msgstr ""

#: ../doc/2.2/book/sql.rst:454
msgid "CALL statement."
msgstr ""

#: ../doc/2.2/book/sql.rst:454
msgid "``call p();``"
msgstr ""

#: ../doc/2.2/book/sql.rst:457
msgid "T321-05"
msgstr ""

#: ../doc/2.2/book/sql.rst:457
msgid "RETURN statement."
msgstr ""

#: ../doc/2.2/book/sql.rst:457
msgid "``create function f() returns int return 5;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:457
msgid "Fail. Tarantool doesn't support user-defined functions."
msgstr ""

#: ../doc/2.2/book/sql.rst:460
msgid "T631"
msgstr ""

#: ../doc/2.2/book/sql.rst:460
msgid "IN predicate with one list element"
msgstr ""

#: ../doc/2.2/book/sql.rst:460
msgid "``select * from t where 1 in (1);``"
msgstr ""

#: ../doc/2.2/book/sql.rst:462
msgid "F021"
msgstr ""

#: ../doc/2.2/book/sql.rst:462
msgid "Basic information schema"
msgstr ""

#: ../doc/2.2/book/sql.rst:462
msgid "``select * from information_schema.tables;``"
msgstr ""

#: ../doc/2.2/book/sql.rst:462
msgid "Fail. There is no schema with that name (not counted in the final score)."
msgstr ""

#: ../doc/2.2/book/sql.rst:466
msgid "Total number of items marked \"Fail\": 69"
msgstr ""

#: ../doc/2.2/book/sql.rst:468
msgid "Total number of items marked \"Okay\": 77"
msgstr ""

#: ../doc/2.2/dev_guide/build_contribute_index.rst:37
msgid "Build and contribute"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:39
msgid "Building documentation"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:41
msgid "Tarantool documentation is built using a simplified markup system named ``Sphinx`` (see http://sphinx-doc.org). You can build a local version of this documentation and you can contribute to Tarantool's version."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:45
msgid "You need to install these packages:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:47
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:48
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:49
msgid "``Python`` version greater than 2.6 -- preferably 2.7 -- and less than 3.0 (Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:51
msgid "``LaTeX`` (a system for document preparation; the installable package name usually begins with the word 'texlive' or 'tetex', on Ubuntu the name is 'texlive-latex-base')"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:54
msgid "``ImageMagick`` (a system for image conversion; on MacOS install it using ``brew``)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:57
msgid "You need to install these Python modules:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:59
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:60
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:64
msgid "If you encounter the \"Missing SPHINX_EXECUTABLE\" error message on Mac, manually export the PATH variable:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:67
msgid "export PATH=$PATH:/User/user_name/Library/Python/2.7/bin"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:71
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:75
msgid "If you encounter the \"Missing SPHINX_INTL_DIR\" error message on Mac, manually export the SPHINX_INTL_DIR variable:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:78
msgid "export SPHINX_INTL_DIR=/User/user_name/Library/Python/2.7/bin"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:82
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:86
msgid "You should specify ``--user`` flag on Mac while installing Python modules for correct installation."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:89
msgid "See more details about installation in the :ref:`build-from-source <building_from_source>` section of this documentation."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:92
msgid "Use ``git`` to download the latest source code of this documentation from the GitHub repository ``tarantool/doc``, branch 2.1. For example, to download to a local directory named ``~/tarantool-doc``:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:96
msgid "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:100
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:102
msgid "$ cd ~/tarantool-doc\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # initiate"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:109
msgid "Build a local version of the documentation."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:111
msgid "Run the ``make`` command with an appropriate option to specify which documentation version to build."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:114
msgid "$ cd ~/tarantool-doc\n"
"$ make sphinx-html           # multi-page English version\n"
"$ make sphinx-singlehtml     # one-page English version\n"
"$ make sphinx-html-ru        # multi-page Russian version\n"
"$ make sphinx-singlehtml-ru  # one-page Russian version\n"
"$ make all                   # all versions plus the entire web-site"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:123
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:125
msgid "``/output/en`` (files of the English version)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:126
msgid "``/output/ru`` (files of the Russian version)"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:128
msgid "The entry point for each version is the ``index.html`` file in the appropriate directory."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:131
msgid "Set up a web server."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:133
msgid "One way is to say ``make sphinx-webserver``. This will set up and run the web server on port ``8000``:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:136
msgid "$ cd ~/tarantool-doc\n"
"$ make sphinx-html       # as an example, build the multi-page English documentation\n"
"$ make sphinx-webserver  # set up and run the web server"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:142
msgid "In case port ``8000`` is already in use, you can specify any other port number that is bigger than ``1000`` in the ``tarantool-doc/CMakeLists.txt`` file (search it for the ``sphinx-webserver`` target) and rebuild cmake files:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:147
msgid "$ cd ~/tarantool-doc\n"
"$ git clean -qfxd        # clean up old cmake files\n"
"$ cmake .                # rebuild cmake files\n"
"$ make sphinx-html       # as an example, build the multi-page English documentation\n"
"$ make sphinx-webserver  # set up and run the web server on the custom port"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:155
msgid "Or you can release the port:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:157
msgid "$ sudo lsof -i :8000  # get the process ID (PID)\n"
"COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\n"
"Python 19516 user 3u IPv4 0xe7f8gc6be1b43c7 0t0 TCP *:irdmi (LISTEN)\n"
"$ sudo kill -9 19516  # kill the process"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:164
msgid "The other way is to run the built-in web server in Python. Make sure to run it from the documentation ``output`` folder:"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:167
msgid "$ cd ~/tarantool-doc/output\n"
"$ python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:172
msgid "In case port ``8000`` is already in use, you can specify any other port number that is bigger than ``1000``."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:175
msgid "Open your browser and enter ``127.0.0.1:8000/en/doc/2.1/`` into the address box (or ``127.0.0.1:8000/ru/doc/2.1/`` if you built the Russian documentation). Mind the trailing slash \"/\" in the address string."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:179
msgid "If your local documentation build is valid, the manual will appear in the browser."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:182
msgid "To contribute to documentation, use the `REST <http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_ format for drafting and submit your updates as a `pull request <https://help.github.com/articles/creating-a-pull-request/>`_ via GitHub."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:188
msgid "To comply with the writing and formatting style, use the :ref:`guidelines <documentation_guidelines>` provided in the documentation, common sense and existing documents."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:194
msgid "If you suggest creating a new documentation section (a whole new page), it has to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/2.2/dev_guide/building_documentation.rst:197
msgid "If you want to contribute to localizing this documentation (for example into Russian), add your translation strings to ``.po`` files stored in the corresponding locale directory (for example ``/locale/ru/LC_MESSAGES/`` for Russian). See more about localizing with Sphinx at http://www.sphinx-doc.org/en/stable/intl.html"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:39
msgid "Building from source"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:41
msgid "For downloading Tarantool source and building it, the platforms can differ and the preferences can differ. But strategically the steps are always the same."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:44
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:47
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:49
msgid "A program for downloading source repositories. |br| For all platforms, this is ``git``. It allows downloading the latest complete set of source files from the Tarantool repository on GitHub."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:53
msgid "A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version 4.6 or later. On Mac OS X, this is ``Clang`` version 3.2+."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:56
msgid "A program for managing the build process. |br| For all platforms, this is ``CMake`` version 2.8+."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:59
msgid "`ReadLine <http://www.gnu.org/software/readline/>`_ library, any version"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:60
msgid "`ncurses <https://www.gnu.org/software/ncurses/>`_ library, any version"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:61
msgid "`OpenSSL <https://www.openssl.org>`_ library, version 1.0.1+"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:62
msgid "`cURL <https://curl.haxx.se/>`_ library, version 0.725+"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:63
msgid "`LibYAML <http://pyyaml.org/wiki/LibYAML>`_ library, version 0.1.4+"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:64
msgid "`ICU <http://site.icu-project.org/download>`_ library, recent version"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:66
msgid "Python and modules. |br| Python interpreter is not necessary for building Tarantool itself, unless you intend to use the \"Run the test suite\" option in step 5. For all platforms, this is ``python`` version 2.7+ (but not 3.x). You need the following Python modules:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:71
msgid "`pyyaml <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:72
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:73
msgid "`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version 0.4.6"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:74
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1.2"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:75
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:77
msgid "To install all required dependencies, follow the instructions for your OS:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:79
msgid "For Debian/Ubuntu, say:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:81
msgid "$ apt install -y build-essential cmake coreutils sed \\\n"
"      libreadline-dev libncurses5-dev libyaml-dev libssl-dev \\\n"
"      libcurl4-openssl-dev libunwind-dev libicu-dev \\\n"
"      python python-pip python-setuptools python-dev \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:89
msgid "For RHEL/CentOS/Fedora, say:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:91
msgid "$ yum install -y gcc gcc-c++ cmake coreutils sed \\\n"
"      readline-devel ncurses-devel libyaml-devel openssl-devel \\\n"
"      libcurl-devel libunwind-devel libicu-devel \\\n"
"      python python-pip python-setuptools python-devel \\\n"
"      python-msgpack python-yaml python-argparse python-six python-gevent"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:99
msgid "For Mac OS X (instructions below are for OS X El Capitan):"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:101
msgid "If you're using Homebrew as your package manager, say:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:103
msgid "$ brew install cmake autoconf binutils zlib \\\n"
"       readline ncurses libyaml openssl curl libunwind-headers icu4c \\\n"
"       && pip install python-daemon \\\n"
"       msgpack-python pyyaml configargparse six gevent"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:110
msgid "Alternatively, download Apple's default Xcode toolset:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:112
msgid "$ xcode-select --install\n"
"$ xcode-select -switch /Applications/Xcode.app/Contents/Developer"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:117
msgid "For FreeBSD (instructions below are for FreeBSD 10.1 release), say:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:119
msgid "$ pkg install -y sudo git cmake gmake gcc coreutils \\\n"
"      readline ncurses libyaml openssl curl libunwind icu \\\n"
"      python27 py27-pip py27-setuptools py27-daemon \\\n"
"      py27-msgpack-python py27-yaml py27-argparse py27-six py27-gevent"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:126
msgid "If some Python modules are not available in a repository, it is best to set up the modules by getting a tarball and doing the setup with ``python setup.py`` like this:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:130
msgid "$ # On some machines, this initial command may be necessary:\n"
"$ wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"$ # Python module for parsing YAML (pyYAML), for test suite:\n"
"$ # (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"$ # what the current version is.)\n"
"$ cd ~\n"
"$ wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"$ tar -xzf PyYAML-3.10.tar.gz\n"
"$ cd PyYAML-3.10\n"
"$ sudo python setup.py install"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:144
msgid "Finally, use Python ``pip`` to bring in Python packages that may not be up-to-date in the distro repositories. (On CentOS 7, it will be necessary to install ``pip`` first, with :code:`sudo yum install epel-release` followed by :code:`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:150
msgid "$ pip install -r \\\n"
"      https://raw.githubusercontent.com/tarantool/test-run/master/requirements.txt \\\n"
"      --user"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:156
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:158
msgid "Use ``git`` to download the latest Tarantool source code from the GitHub repository ``tarantool/tarantool``, branch 2.1, to a local directory named ``~/tarantool``, for example:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:162
msgid "$ git clone --recursive https://github.com/tarantool/tarantool.git -b 2.1 ~/tarantool"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:166
msgid "On rare occasions, the submodules need to be updated again with the command:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:169
msgid "$ git submodule update --init --recursive"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:173
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:175
msgid "$ cd ~/tarantool\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:182
msgid "On some platforms, it may be necessary to specify the C and C++ versions, for example:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:185
msgid "$ CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:189
msgid "The CMake option for specifying build type is :samp:`-DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:192
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:193
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:194
msgid "``RelWithDebInfo`` -- used for production, also provides debugging capabilities"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:196
msgid "The CMake option for hinting that the result will be distributed is :code:`-DENABLE_DIST=ON`. If this option is on, then later ``make install`` will install ``tarantoolctl`` files in addition to ``tarantool`` files."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:200
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:202
msgid "$ make"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:208
msgid "For FreeBSD, use ``gmake`` instead."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:210
msgid "This creates the 'tarantool' executable in the ``src/`` directory."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:212
msgid "Next, it's highly recommended to say ``make install`` to install Tarantool to the ``/usr/local`` directory and keep your system clean. However, it is possible to run the Tarantool executable without installation."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:216
msgid "Run the test suite."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:218
msgid "This step is optional. Tarantool's developers always run the test suite before they publish new versions. You should run the test suite too, if you make any changes in the code. Assuming you downloaded to ``~/tarantool``, the principal steps are:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:223
msgid "$ # make a subdirectory named `bin`\n"
"$ mkdir ~/tarantool/bin\n"
"\n"
"$ # link Python to bin (this may require superuser privileges)\n"
"$ ln /usr/bin/python ~/tarantool/bin/python\n"
"\n"
"$ # get to the test subdirectory\n"
"$ cd ~/tarantool/test\n"
"\n"
"$ # run tests using Python\n"
"$ PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:237
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:239
msgid "======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:252
msgid "To prevent later confusion, clean up what's in the ``bin`` subdirectory:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:254
msgid "$ rm ~/tarantool/bin/python\n"
"$ rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:259
msgid "Make RPM and Debian packages."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:261
msgid "This step is optional. It's only for people who want to redistribute Tarantool. We highly recommend to use official packages from the `tarantool.org <https://tarantool.org/download.html>`_ web-site. However, you can build RPM and Debian packages using `PackPack <https://github.com/packpack/packpack>`_ or using the ``dpkg-buildpackage`` or ``rpmbuild`` tools. Please consult ``dpkg`` or ``rpmbuild`` documentation for details."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:269
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:271
msgid "$ # if you installed tarantool locally after build\n"
"$ tarantool\n"
"$ # - OR -\n"
"$ # if you didn't install tarantool locally after build\n"
"$ ./src/tarantool"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:279
msgid "This starts Tarantool in the interactive mode."
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:281
msgid "See also:"
msgstr ""

#: ../doc/2.2/dev_guide/building_from_source.rst:283
msgid "`Tarantool README.md <https://github.com/tarantool/tarantool/blob/2.1/README.md>`_"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:37
msgid "C Style Guide"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:39
msgid "The project's coding style is based on a version of the Linux kernel coding style."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:41
msgid "The latest version of the Linux style can be found at: http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:44
msgid "Since it is open for changes, the version of style that we follow, one from 2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:47
msgid "There are a few additional guidelines, either unique to Tarantool or deviating from the Kernel guidelines."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:50
msgid "Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 \"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-invent the kernel macros\" do not apply, since they are specific to Linux kernel programming environment."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:55
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:59
msgid "General guidelines"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:61
msgid "We use Git for revision control. The latest development is happening in the default branch (currently ``2.1``). Our git repository is hosted on GitHub, and can be checked out with ``git clone git://github.com/tarantool/tarantool.git`` (anonymous read-only access)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:66
msgid "If you have any questions about Tarantool internals, please post them on the developer discussion list, https://groups.google.com/forum/#!forum/tarantool. However, please be warned: Launchpad silently deletes posts from non-subscribed members, thus please be sure to have subscribed to the list prior to posting. Additionally, some engineers are always present on #tarantool channel on irc.freenode.net."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:74
msgid "Commenting style"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:76
msgid "Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than `\\tag`. The main tags in use are @param, @retval, @return, @see, @note and @todo."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:79
msgid "Every function, except perhaps a very short and obvious one, should have a comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:82
msgid "/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:97
msgid "Public structures and important structure members should be commented as well."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:101
msgid "Header files"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:103
msgid "Use header guards. Put the header guard in the first line in the header, before the copyright or declarations. Use all-uppercase name for the header guard. Derive the header guard name from the file name, and append _INCLUDED to get a macro name. For example, core/log_io.h -> CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the respective declaration header before all other headers, to ensure that the header is self- sufficient. Header \"header.h\" is self-sufficient if the following compiles without errors:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:111
msgid "#include \"header.h\""
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:117
msgid "Allocating memory"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:119
msgid "Prefer the supplied slab (salloc) and pool (palloc) allocators to malloc()/free() for any performance-intensive or large  memory allocations. Repetitive use of malloc()/free() can lead to memory fragmentation and should therefore be avoided."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:123
msgid "Always free all allocated memory, even allocated  at start-up. We aim at being valgrind leak-check clean, and in most cases it's just as easy to free() the allocated memory as it is to write a valgrind suppression. Freeing all allocated memory is also dynamic-load friendly: assuming a plug-in can be dynamically loaded and unloaded multiple times, reload should not lead to a memory leak."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:131
msgid "Other"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:133
msgid "Select GNU C99 extensions are acceptable. It's OK to mix declarations and statements, use true and false."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:136
msgid "The not-so-current list of all GCC C extensions can be found at: http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:141
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:143
msgid "This is a short document describing the preferred coding style for the linux kernel.  Coding style is very personal, and I won't _force_ my views on anybody, but this is what goes for anything that I have to be able to maintain, and I'd prefer it for most other things too.  Please at least consider the points made here."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:149
msgid "First off, I'd suggest printing out a copy of the GNU coding standards, and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:152
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:156
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:158
msgid "Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:163
msgid "Rationale: The whole idea behind indentation is to clearly define where a block of control starts and ends.  Especially when you've been looking at your screen for 20 straight hours, you'll find it a lot easier to see how the indentation works if you have large indentations."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:168
msgid "Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen.  The answer to that is that if you need more than 3 levels of indentation, you're screwed anyway, and should fix your program."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:174
msgid "In short, 8-char indents make things easier to read, and have the added benefit of warning you when you're nesting your functions too deep. Heed that warning."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:178
msgid "The preferred way to ease multiple indentation levels in a switch statement is to align the \"switch\" and its subordinate \"case\" labels in the same column instead of \"double-indenting\" the \"case\" labels. e.g.:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:182
msgid "switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:202
msgid "Don't put multiple statements on a single line unless you have something to hide:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:205
msgid "if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:210
msgid "Don't put multiple assignments on a single line either. Kernel coding style is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:213
msgid "Outside of comments, documentation and except in Kconfig, spaces are never used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:216
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:221
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:223
msgid "Coding style is all about readability and maintainability using commonly available tools."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:226
msgid "The limit on the length of lines is 80 columns, reduced to 66 columns for comments, and this is a strongly preferred limit."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:229
msgid "Statements longer than 80 columns will be broken into sensible chunks. Descendants are always substantially shorter than the parent and are placed substantially to the right. The same applies to function headers with a long argument list. Long strings are as well broken into shorter strings. The only exception to this is where exceeding 80 columns significantly increases readability and does not hide information."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:236
msgid "void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:250
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:252
msgid "The other issue that always comes up in C styling is the placement of braces.  Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:258
msgid "if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:264
msgid "This applies to all non-function statement blocks (if, switch, for, while, do). e.g.:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:267
msgid "switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:280
msgid "However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:283
msgid "int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:290
msgid "Heretic people all over the world have claimed that this inconsistency is ...  well ...  inconsistent, but all right-thinking people know that (a) K&R are _right_ and (b) K&R are right.  Besides, functions are special anyway (you can't nest them in C)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:295
msgid "Note that the closing brace is empty on a line of its own, _except_ in the cases where it is followed by a continuation of the same statement, ie a \"while\" in a do-statement or an \"else\" in an if-statement, like this:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:300
msgid "do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:306
#: ../doc/2.2/tutorials/sql_tutorial.rst:209
msgid "and"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:308
msgid "if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:318
msgid "Rationale: K&R."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:320
msgid "Also, note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability.  Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:326
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:328
msgid "if (condition)\n"
"    action();"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:333
msgid "This does not apply if one branch of a conditional statement is a single statement. Use braces in both branches."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:336
msgid "if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:347
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:349
msgid "Linux kernel style for use of spaces depends (mostly) on function-versus-keyword usage.  Use a space after (most) keywords.  The notable exceptions are sizeof, typeof, alignof, and __attribute__, which look somewhat like functions (and are usually used with parentheses in Linux, although they are not required in the language, as in: \"sizeof info\" after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:356
msgid "So use a space after these keywords: if, switch, case, for, do, while but not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:359
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:363
msgid "Do not add spaces around (inside) parenthesized expressions. This example is **bad**:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:366
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:370
msgid "When declaring pointer data or a function that returns a pointer type, the preferred use of '*' is adjacent to the data name or function name and not adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:374
msgid "char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:380
msgid "Use one space around (on each side of) most binary and ternary operators, such as any of these:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:383
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:385
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:387
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:389
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:391
#: ../doc/2.2/dev_guide/c_style_guide.rst:395
msgid "++  --"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:393
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:397
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:399
msgid "Do not leave trailing whitespace at the ends of lines.  Some editors with \"smart\" indentation will insert whitespace at the beginning of new lines as appropriate, so you can start typing the next line of code right away. However, some such editors do not remove the whitespace if you end up not putting a line of code there, such as if you leave a blank line.  As a result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:406
msgid "Git will warn you about patches that introduce trailing whitespace, and can optionally strip the trailing whitespace for you; however, if applying a series of patches, this may make later patches in the series fail by changing their context lines."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:414
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:416
msgid "C is a Spartan language, and so should your naming be.  Unlike Modula-2 and Pascal programmers, C programmers do not use cute names like ThisVariableIsATemporaryCounter.  A C programmer would call that variable \"tmp\", which is much easier to write, and not the least more difficult to understand."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:422
msgid "HOWEVER, while mixed-case names are frowned upon, descriptive names for global variables are a must.  To call a global function \"foo\" is a shooting offense."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:426
msgid "GLOBAL variables (to be used only if you _really_ need them) need to have descriptive names, as do global functions.  If you have a function that counts the number of active users, you should call that \"count_active_users()\" or similar, you should _not_ call it \"cntusr()\"."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:431
msgid "Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer.  No wonder MicroSoft makes buggy programs."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:436
msgid "LOCAL variable names should be short, and to the point.  If you have some random integer loop counter, it should probably be called \"i\". Calling it \"loop_counter\" is non-productive, if there is no chance of it being mis-understood.  Similarly, \"tmp\" can be just about any type of variable that is used to hold a temporary value."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:442
msgid "If you are afraid to mix up your local variable names, you have another problem, which is called the function-growth-hormone-imbalance syndrome. See chapter 6 (Functions)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:449
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:451
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:453
msgid "It's a _mistake_ to use typedef for structures and pointers. When you see a"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:455
msgid "vps_t a;"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:459
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:461
msgid "In contrast, if it says"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:463
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:467
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:469
msgid "Lots of people think that typedefs \"help readability\". Not so. They are useful only for:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:472
msgid "totally opaque objects (where the typedef is actively used to _hide_ what the object is)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:475
msgid "Example: \"pte_t\" etc. opaque objects that you can only access using the proper accessor functions."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:478
msgid "NOTE! Opaqueness and \"accessor functions\" are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:482
msgid "Clear integer types, where the abstraction _helps_ avoid confusion whether it is \"int\" or \"long\"."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:485
msgid "u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) better than here."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:488
msgid "NOTE! Again - there needs to be a _reason_ for this. If something is \"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:491
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:495
msgid "but if there is a clear reason for why it under certain circumstances might be an \"unsigned int\" and under other configurations might be \"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:499
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:502
msgid "New types which are identical to standard C99 types, in certain exceptional circumstances."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:505
msgid "Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like 'uint32_t', some people object to their use anyway."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:509
msgid "Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed equivalents which are identical to standard types are permitted -- although they are not mandatory in new code of your own."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:514
msgid "When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:517
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:519
msgid "In certain structures which are visible to userspace, we cannot require C99 types and cannot use the 'u32' form above. Thus, we use __u32 and similar types in all structures which are shared with userspace."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:524
msgid "Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:527
msgid "In general, a pointer, or a struct that has elements that can reasonably be directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:533
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:535
msgid "Functions should be short and sweet, and do just one thing.  They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we all know), and do one thing and do that well."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:539
msgid "The maximum length of a function is inversely proportional to the complexity and indentation level of that function.  So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it's OK to have a longer function."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:545
msgid "However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely.  Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it's performance-critical, and it will probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:553
msgid "Another measure of the function is the number of local variables.  They shouldn't exceed 5-10, or you're doing something wrong.  Re-think the function, and split it into smaller pieces.  A human brain can generally easily keep track of about 7 different things, anything more and it gets confu/sed.  You know you're brilliant, but maybe you'd like to understand what you did 2 weeks from now."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:560
msgid "In source files, separate functions with one blank line.  If the function is exported, the EXPORT* macro for it should follow immediately after the closing function brace line.  E.g.:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:564
msgid "int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:572
msgid "In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in Linux because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:578
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:580
msgid "Albeit deprecated by some people, the equivalent of the goto statement is used frequently by compilers in form of the unconditional jump instruction."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:583
msgid "The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:586
msgid "The rationale is:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:588
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:589
msgid "nesting is reduced"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:590
msgid "errors by not updating individual exit points when making modifications are prevented"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:592
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:594
msgid "int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:619
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:621
msgid "Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment: it's much better to write the code so that the _working_ is obvious, and it's a waste of time to explain badly written code. с Generally, you want your comments to tell WHAT your code does, not HOW. Also, try to avoid putting comments inside a function body: if the function is so complex that you need to separately comment parts of it, you should probably go back to chapter 6 for a while.  You can make small comments to note or warn about something particularly clever (or ugly), but try to avoid excess.  Instead, put the comments at the head of the function, telling people what it does, and possibly WHY it does it."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:635
msgid "When commenting the kernel API functions, please use the kernel-doc format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc for details."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:639
msgid "Linux style for comments is the C89 :code:`/* ... */`` style. Don't use C99-style :code:`// ...` comments."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:642
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:644
msgid "/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:655
msgid "It's also important to comment data, whether they are basic types or derived types.  To this end, use just one data declaration per line (no commas for multiple data declarations).  This leaves you room for a small comment on each item, explaining its use."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:662
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:664
msgid "That's OK, we all do.  You've probably been told by your long-time Unix user helper that \"GNU emacs\" automatically formats the C sources for you, and you've noticed that yes, it does do that, but the defaults it uses are less than desirable (in fact, they are worse than random typing - an infinite number of monkeys typing into GNU emacs would never make a good program)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:671
msgid "So, you can either get rid of GNU emacs, or change it to use saner values.  To do the latter, you can stick the following in your .emacs file:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:674
msgid "(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:705
msgid "This will make emacs go better with the kernel coding style for C files below ~/src/linux-trees."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:708
msgid "But even if you fail in getting emacs to do sane formatting, not everything is lost: use \"indent\"."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:711
msgid "Now, again, GNU indent has the same brain-dead settings that GNU emacs has, which is why you need to give it a few command line options. However, that's not too bad, because even the makers of GNU indent recognize the authority of K&R (the GNU people aren't evil, they are just severely misguided in this matter), so you just give indent the options \"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use \"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:719
msgid "\"indent\" has a lot of options, and especially when it comes to comment re-formatting you may want to take a look at the man page.  But remember: \"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:726
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:728
msgid "For all of the Kconfig* configuration files throughout the source tree, the indentation is somewhat different.  Lines under a \"config\" definition are indented with one tab, while help text is indented an additional two spaces. Example:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:733
msgid "config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:744
msgid "Features that might still be considered unstable should be defined as dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:747
msgid "config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:754
msgid "while seriously dangerous features (such as write support for certain filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:757
msgid "config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:764
msgid "For full documentation on the configuration files, see the file Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:770
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:772
msgid "Data structures that have visibility outside the single-threaded environment they are created and destroyed in should always have reference counts.  In the kernel, garbage collection doesn't exist (and outside the kernel garbage collection is slow and inefficient), which means that you absolutely _have_ to reference count all your uses."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:778
msgid "Reference counting means that you can avoid locking, and allows multiple users to have access to the data structure in parallel - and not having to worry about the structure suddenly going away from under them just because they slept or did something else for a while."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:783
msgid "Note that locking is _not_ a replacement for reference counting. Locking is used to keep data structures coherent, while reference counting is a memory management technique.  Usually both are needed, and they are not to be confused with each other."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:788
msgid "Many data structures can indeed have two levels of reference counting, when there are users of different \"classes\".  The subclass count counts the number of subclass users, and decrements the global count just once when the subclass count goes to zero."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:793
msgid "Examples of this kind of \"multi-level-reference-counting\" can be found in memory management (\"struct mm_struct\": mm_users and mm_count), and in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:797
msgid "Remember: if another thread can find your data structure, and you don't have a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:802
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:804
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:806
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:810
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:812
msgid "CAPITALIZED macro names are appreciated but macros resembling functions may be named in lower case."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:815
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:817
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:819
msgid "#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:827
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:829
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:831
msgid "#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:839
msgid "is a _very_ bad idea.  It looks like a function call but exits the \"calling\" function; don't break the internal parsers of those who will read the code."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:842
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:844
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:848
msgid "might look like a good thing, but it's confusing as hell when one reads the code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:851
msgid "macros with arguments that are used as l-values: FOO(x) = y; will bite you if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:854
msgid "forgetting about precedence: macros defining constants using expressions must enclose the expression in parentheses. Beware of similar issues with macros using parameters."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:858
msgid "#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:863
msgid "The cpp manual deals with macros exhaustively. The gcc internals manual also covers RTL which is used frequently with assembly language in the kernel."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:868
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:870
msgid "Kernel developers like to be seen as literate. Do mind the spelling of kernel messages to make a good impression. Do not use crippled words like \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages concise, clear, and unambiguous."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:875
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:877
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:879
msgid "There are a number of driver model diagnostic macros in <linux/device.h> which you should use to make sure messages are matched to the right device and driver, and are tagged with the right level:  dev_err(), dev_warn(), dev_info(), and so forth.  For messages that aren't associated with a particular device, <linux/kernel.h> defines pr_debug() and pr_info()."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:885
msgid "Coming up with good debugging messages can be quite a challenge; and once you have them, they can be a huge help for remote troubleshooting.  Such messages should be compiled out when the DEBUG symbol is not defined (that is, by default they are not included).  When you use dev_dbg() or pr_debug(), that's automatic.  Many subsystems have Kconfig options to turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:895
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:897
msgid "The kernel provides the following general purpose memory allocators: kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API documentation for further information about them."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:901
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:903
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:907
msgid "The alternative form where struct name is spelled out hurts readability and introduces an opportunity for a bug when the pointer variable type is changed but the corresponding sizeof that is passed to a memory allocator is not."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:911
msgid "Casting the return value which is a void pointer is redundant. The conversion from void pointer to any other pointer type is guaranteed by the C programming language."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:917
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:919
msgid "There appears to be a common misperception that gcc has a magic \"make me faster\" speedup option called \"inline\". While the use of inlines can be appropriate (for example as a means of replacing macros, see Chapter 12), it very often is not. Abundant use of the inline keyword leads to a much bigger kernel, which in turn slows the system as a whole down, due to a bigger icache footprint for the CPU and simply because there is less memory available for the pagecache. Just think about it; a pagecache miss causes a disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:929
msgid "A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them. An exception to this rule are the cases where a parameter is known to be a compiletime constant, and as a result of this constantness you *know* the compiler will be able to optimize most of your function away at compile time. For a good example of this later case, see the kmalloc() inline function."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:936
msgid "Often people argue that adding inline to functions that are static and used only once is always a win since there is no space tradeoff. While this is technically correct, gcc is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells gcc to do something it would have done anyway."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:945
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:947
msgid "Functions can return values of many different kinds, and one of the most common is a value indicating whether the function succeeded or failed.  Such a value can be represented as an error-code integer (-Exxx = failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero = success)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:953
msgid "Mixing up these two sorts of representations is a fertile source of difficult-to-find bugs.  If the C language included a strong distinction between integers and booleans then the compiler would find these mistakes for us... but it doesn't.  To help prevent such bugs, always follow this convention:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:961
msgid "If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:965
msgid "For example, \"add work\" is a command, and the add_work() function returns 0 for success or -EBUSY for failure.  In the same way, \"PCI device present\" is a predicate, and the pci_dev_present() function returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:970
msgid "All EXPORTed functions must respect this convention, and so should all public functions.  Private (static) functions need not, but it is recommended that they do."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:974
msgid "Functions whose return value is the actual result of a computation, rather than an indication of whether the computation succeeded, are not subject to this rule.  Generally they indicate failure by returning some out-of-range result.  Typical examples would be functions that return pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:983
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:985
msgid "The header file include/linux/kernel.h contains a number of macros that you should use, rather than explicitly coding some variant of them yourself. For example, if you need to calculate the length of an array, take advantage of the macro"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:990
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:994
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:996
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1000
msgid "There are also min() and max() macros that do strict type checking if you need them.  Feel free to peruse that header file to see what else is already defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1006
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1008
msgid "Some editors can interpret configuration information embedded in source files, indicated with special markers.  For example, emacs interprets lines marked like this:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1012
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1016
msgid "Or like this:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1018
msgid "/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1026
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1028
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1032
msgid "Do not include any of these in source files.  People have their own personal editor configurations, and your source files should not override them.  This includes markers for indentation and mode configuration.  People may use their own custom mode, or may have some other magic method for making indentation work correctly."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1040
msgid "Appendix I: References"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1042
msgid "`The C Programming Language, Second Edition <https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1047
msgid "`The Practice of Programming <https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W. Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1052
msgid "`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R and this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1055
msgid "`WG14 International standardization workgroup for the programming language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/2.2/dev_guide/c_style_guide.rst:1058
msgid "`Kernel CodingStyle, by greg@kroah.com at OLS 2002 <http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:37
msgid "Developer guidelines"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:43
msgid "How to work on a bug"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:45
msgid "Any defect, even minor, if it changes the user-visible server behavior, needs a bug report. Report a bug at http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:48
msgid "When reporting a bug, try to come up with a test case right away. Set the current maintenance milestone for the bug fix, and specify the series. Assign the bug to yourself. Put the status to 'In progress' Once the patch is ready, put the bug the bug to 'In review' and solicit a review for the fix."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:53
msgid "Once there is a positive code review, push the patch and set the status to 'Closed'"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:55
msgid "Patches for bugs should contain a reference to the respective Launchpad bug page or at least bug id. Each patch should have a test, unless coming up with one is difficult in the current framework, in which case QA should be alerted."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:59
msgid "There are two things you need to do when your patch makes it into the master:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:61
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:62
msgid "delete the remote branch."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:68
msgid "How to write a commit message"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:70
msgid "Any commit needs a helpful message. Mind the following guidelines when committing to any of Tarantool repositories at GitHub."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:73
msgid "Separate subject from body with a blank line."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:74
msgid "Try to limit the subject line to **50 characters** or so."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:75
msgid "Start the subject line with a capital letter unless it prefixed with a subsystem name and semicolon:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:78
msgid "memtx:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:79
msgid "vinyl:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:80
msgid "xlog:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:81
msgid "replication:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:82
msgid "recovery:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:83
msgid "iproto:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:84
msgid "net.box:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:85
msgid "lua:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:86
msgid "sql:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:88
msgid "Do not end the subject line with a period."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:89
msgid "Do not put \"gh-xx\", \"closes #xxx\" to the subject line."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:90
msgid "Use the imperative mood in the subject line. A properly formed Git commit subject line should always be able to complete the following sentence: \"If applied, this commit will */your subject line here/*\"."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:93
msgid "Wrap the body to **72 characters** or so."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:94
msgid "Use the body to explain **what and why** vs. how."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:95
msgid "Link GitHub issues on the lasts lines (`see how <https://help.github.com/articles/closing-issues-via-commit-messages>`_)."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:97
msgid "Use your real name and real email address. For Tarantool team members, **@tarantool.org** email is preferred, but not mandatory."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:101
msgid "A template:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:103
msgid "Summarize changes in 50 characters or less\n"
"\n"
"More detailed explanatory text, if necessary.\n"
"Wrap it to 72 characters or so.\n"
"In some contexts, the first line is treated as the subject of the\n"
"commit, and the rest of the text as the body.\n"
"The blank line separating the summary from the body is critical\n"
"(unless you omit the body entirely); various tools like `log`,\n"
"`shortlog` and `rebase` can get confused if you run the two together.\n"
"\n"
"Explain the problem that this commit is solving. Focus on why you\n"
"are making this change as opposed to how (the code explains that).\n"
"Are there side effects or other unintuitive consequences of this\n"
"change? Here's the place to explain them.\n"
"\n"
"Further paragraphs come after blank lines.\n"
"\n"
"- Bullet points are okay, too.\n"
"\n"
"- Typically a hyphen or asterisk is used for the bullet, preceded\n"
"  by a single space, with blank lines in between, but conventions\n"
"  vary here.\n"
"\n"
"Fixes: #123\n"
"Closes: #456\n"
"Needed for: #859\n"
"See also: #343, #789"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:133
msgid "Some real-world examples:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:135
msgid "`tarantool/tarantool@2993a75 <https://github.com/tarantool/tarantool/commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:136
msgid "`tarantool/tarantool@ccacba2 <https://github.com/tarantool/tarantool/commit/ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:137
msgid "`tarantool/tarantool@386df3d <https://github.com/tarantool/tarantool/commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:138
msgid "`tarantool/tarantool@076a842 <https://github.com/tarantool/tarantool/commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:140
msgid "Based on [1_] and [2_]."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:146
msgid "How to submit a patch for review"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:148
msgid "We don't accept GitHub pull requests. Instead, all patches should be sent as plain-text messages to tarantool-patches@freelists.org. Please subscribe to our mailing list at https://www.freelists.org/list/tarantool-patches to ensure that your messages are added to the archive."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:154
msgid "**Preparing a patch**"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:156
msgid "Once you have committed a patch to your local git repository, you can submit it for review."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:159
msgid "To prepare an email, use ``git format-patch`` command:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:161
msgid "$ git format-patch -1"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:165
msgid "It will format the commit at the top of your local git repository as a plain-text email and write it to a file in the current directory. The file name will look like ``0001-your-commit-subject-line.patch``. To specify a different directory, use ``-o`` option:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:170
msgid "$ git format-patch -1 -o ~/patches-to-send"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:174
msgid "Once the patch has been formatted, you can view and edit it with your favorite text editor (after all, it is a plain-text file!). We strongly recommend adding:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:178
msgid "a hyperlink to the branch where this patch can be found at GitHub, and"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:179
msgid "a hyperlink to the GitHub issue your patch is supposed to fix, if any."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:181
msgid "If there is just one patch, the change log should go right after ``---`` in the message body (it will be ignored by ``git am`` then)."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:184
msgid "If there are multiple patches you want to submit in one go (e.g. this is a big feature which requires some preparatory patches to be committed first), you should send each patch in a separate email in reply to a cover letter. To format a patch series accordingly, pass the following options to ``git format-patch``:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:190
msgid "$ git format-patch --cover-letter --thread=shallow HEAD~2"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:196
msgid "``--cover-letter`` will make ``git format-patch`` generate a cover letter;"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:197
msgid "``--thread=shallow`` will mark each formatted patch email to be sent in reply to the cover letter;"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:199
msgid "``HEAD~2`` (we now use it instead of ``-1``) will make ``git format-patch`` format the first two patches at the top of your local git branch instead of just one. To format three patches, use ``HEAD~3``, and so forth."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:203
msgid "After the command has been successfully executed, you will find all your patches formatted as separate emails in your current directory (or in the directory specified via ``-o`` option):"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:207
msgid "0000-cover-letter.patch\n"
"0001-first-commit.patch\n"
"0002-second-commit.patch\n"
"..."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:214
msgid "The cover letter will have BLURB in its subject and body. You'll have to edit it before submitting (again, it is a plain text file). Please write:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:217
msgid "a short series description in the subject line;"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:218
msgid "a few words about each patch of the series in the body."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:220
msgid "And don't forget to add hyperlinks to the GitHub issue and branch where your series can be found. In this case you don't need to put links or any additional information to each individual email -- the cover letter will cover everything."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:227
msgid "To omit ``--cover-letter`` and ``--thread=shallow`` options, you can add the following lines to your gitconfig:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:230
msgid "[format]\n"
"    thread = shallow\n"
"    coverLetter = auto"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:236
msgid "**Sending a patch**"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:238
msgid "Once you have formatted your patches, they are ready to be sent via email. Of course, you can send them with your favorite mail agent, but it is much easier to use ``git send-email`` for this. Before using this command, you need to configure it."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:243
msgid "If you use a GMail account, add the following code to your ``.gitconfig``:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:245
msgid "[sendemail]\n"
"    smtpencryption = tls\n"
"    smtpserver = smtp.gmail.com\n"
"    smtpserverport = 587\n"
"    smtpuser = your.name@gmail.com\n"
"    smtppass = topsecret"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:254
msgid "For mail.ru users, the configuration will be slightly different:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:256
msgid "[sendemail]\n"
"    smtpencryption = ssl\n"
"    smtpserver = smtp.mail.ru\n"
"    smtpserverport = 465\n"
"    smtpuser = your.name@mail.ru\n"
"    smtppass = topsecret"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:265
msgid "If your email account is hosted by another service, consult your service provider about your SMTP settings."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:268
msgid "Once configured, use the following command to send your patches:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:270
msgid "$ git send-email --to tarantool-patches@freelists.org 00*"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:274
msgid "(``00*`` wildcard will be expanded by your shell to the list of patches generated at the previous step.)"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:277
msgid "If you want someone in particular to review your patch, add them to the list of recipients by passing ``--to`` or ``--cc`` once per each recipient."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:282
msgid "It is useful to check that ``git send-email`` will work as expected without sending anything to the world. Use ``--dry-run`` option for that."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:285
msgid "**Review process**"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:287
msgid "After having sent your patches, you just wait for a review. The reviewer will send their comments back to you in reply to the email that contains the patch that in their opinion needs to be fixed."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:291
msgid "Upon receiving an email with review remarks, you carefully read it and reply about whether you agree or disagree with. Please note that we use the interleaved reply style (aka \"inline reply\") for communications over email."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:295
msgid "Upon reaching an agreement, you send a fixed patch in reply to the email that ended the discussion. To send a patch, you can either attach a plain diff (created by ``git diff`` or ``git format-patch``) to email and send it with your favorite mail agent, or use ``--in-reply-to`` option of ``git send-email`` command."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:301
msgid "If you feel that the accumulated change set is large enough to send the whole series anew and restart the review process in a different thread, you generate the patch email(s) again with ``git format-patch``, this time adding v2 (then v3, v4, and so forth) to the subject and a change log to the message body. To modify the subject line accordingly, use the ``--subject-prefix`` option to ``git format-patch`` command:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:308
msgid "$ git format-patch -1 --subject-prefix='PATCH v2'"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:312
msgid "To add a change log, open the generated email with you favorite text editor and edit the message body. If there is just one patch, the change log should go right after ``---`` in the message body (it will be ignored by ``git am`` then). If there is more than one patch, the change log should be added to the cover letter. Here is an example of a good change log:"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:318
msgid "Changes in v3:\n"
"  - Fixed comments as per review by Alex\n"
"  - Added more tests\n"
"Changes in v2:\n"
"  - Fixed a crash if the user passes invalid options\n"
"  - Fixed a memory leak at exit"
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:327
msgid "It is also a good practice to add a reference to the previous version of your patch set (via a hyperlink or message id)."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:332
msgid "Do not disagree with the reviewer without providing a good argument supporting your point of view."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:334
msgid "Do not take every word the reviewer says for granted. Reviewers are humans too, hence fallible."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:336
msgid "Do not expect that the reviewer will tell you how to do your thing. It is not their job. The reviewer might suggest alternative ways to tackle the problem, but in general it is your responsibility."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:339
msgid "Do not forget to update your remote git branch every time you send a new version of your patch."
msgstr ""

#: ../doc/2.2/dev_guide/developer_guidelines.rst:341
msgid "Do follow the guidelines above. If you do not comply, your patches are likely to be silently ignored."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:39
msgid "Documentation guidelines"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:41
msgid "These guidelines are updated on the on-demand basis, covering only those issues that cause pains to the existing writers. At this point, we do not aim to come up with an exhaustive Documentation Style Guide for the Tarantool project."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:47
msgid "Markup issues"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:51
msgid "Wrapping text"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:53
msgid "The limit is 80 characters per line for plain text, and no limit for any other constructions when wrapping affects ReST readability and/or HTML output. Also, it makes no sense to wrap text into lines shorter than 80 characters unless you have a good reason to do so."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:58
msgid "The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, and it's unlikely that readers/writers will use 80-character consoles. Yet it's still a standard for many coding guidelines (including Tarantool). As for writers, the benefit is that an 80-character page guide allows keeping the text window rather narrow most of the time, leaving more space for other applications in a wide-screen environment."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:67
msgid "Formatting code snippets"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:69
msgid "For code snippets, we mainly use the ``code-block`` directive with an appropriate highlighting language. The most commonly used highlighting languages are:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:73
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:74
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:75
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:77
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:79
msgid "for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:86
msgid "In rare cases, when we need custom highlight for specific parts of a code snippet and the ``code-block`` directive is not enough, we use the per-line ``codenormal`` directive together and explicit output formatting (defined in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:91
#: ../doc/2.2/reference/reference_sql/sql.rst:61
#: ../doc/2.2/reference/reference_sql/sql.rst:178
#: ../doc/2.2/reference/reference_sql/sql.rst:576
#: ../doc/2.2/reference/reference_sql/sql.rst:628
#: ../doc/2.2/reference/reference_sql/sql.rst:673
#: ../doc/2.2/reference/reference_sql/sql.rst:746
#: ../doc/2.2/reference/reference_sql/sql.rst:855
#: ../doc/2.2/reference/reference_sql/sql.rst:919
#: ../doc/2.2/reference/reference_sql/sql.rst:990
#: ../doc/2.2/reference/reference_sql/sql.rst:1026
#: ../doc/2.2/reference/reference_sql/sql.rst:1099
#: ../doc/2.2/reference/reference_sql/sql.rst:1408
#: ../doc/2.2/reference/reference_sql/sql.rst:1537
#: ../doc/2.2/reference/reference_sql/sql.rst:1594
#: ../doc/2.2/reference/reference_sql/sql.rst:1638
#: ../doc/2.2/reference/reference_sql/sql.rst:1715
#: ../doc/2.2/reference/reference_sql/sql.rst:1835
#: ../doc/2.2/reference/reference_sql/sql.rst:1919
#: ../doc/2.2/reference/reference_sql/sql.rst:1983
#: ../doc/2.2/reference/reference_sql/sql.rst:2025
#: ../doc/2.2/reference/reference_sql/sql.rst:2144
#: ../doc/2.2/reference/reference_sql/sql.rst:2577
#: ../doc/2.2/reference/reference_sql/sql.rst:2684
#: ../doc/2.2/reference/reference_sql/sql.rst:2726
#: ../doc/2.2/reference/reference_sql/sql.rst:2746
msgid "Examples:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:93
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:95
msgid ":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:create_index('index-name')`"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:97
msgid "A tdb session (user input is in bold, command prompt is in blue, computer output is in green):"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:109
msgid "Warning: Every entry of explicit output formatting (``codenormal``, ``codebold``, etc) tends to cause troubles when this documentation is translated to other languages. Please avoid using explicit output formatting unless it is REALLY needed."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:116
msgid "Using separated links"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:118
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:120
msgid "This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:126
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:128
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:132
msgid "Warning: Every separated link tends to cause troubles when this documentation is translated to other languages. Please avoid using separated links unless it is REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:138
msgid "Creating labels for local links"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:140
msgid "We avoid using links that sphinx generates automatically for most objects. Instead, we add our own labels for linking to any place in this documentation."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:143
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:145
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:147
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:149
msgid "Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is the directory name, |br| ``box_index`` is the file name (without \".rst\"), and |br| ``iterator_type`` is the tag."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:155
msgid "The file name is useful for knowing, when you see \"ref\", where it is pointing to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:158
msgid "The file name alone, without a path, is enough when the file name is unique within ``doc/sphinx``. So, for ``fiber.rst`` it should be just \"fiber\", not \"reference-fiber\". While for \"index.rst\" (we have a handful of \"index.rst\" in different directories) please specify the path before the file name, e.g. \"reference-index\"."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:165
msgid "Use a dash \"-\" to delimit the path and the file name. In the documentation source, we use only underscores \"_\" in paths and file names, reserving dash \"-\" as the delimiter for local links."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:169
msgid "The tag can be anything meaningful. The only guideline is for Tarantool syntax items (such as members), where the preferred tag syntax is ``module_or_object_name dash member_name``. For example, ``box_space-drop``."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:175
msgid "Making comments"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:177
msgid "Sometimes we may need to leave comments in a ReST file. To make sphinx ignore some text during processing, use the following per-line notation with \".. //\" as the comment marker:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:181
msgid ".. // your comment here"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:185
msgid "The starting symbols \".. //\" do not interfere with the other ReST markup, and they are easy to find both visually and using grep. There are no symbols to escape in grep search, just go ahead with something like this:"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:189
msgid "$ grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:193
msgid "These comments don't work properly in nested documentation, though (e.g. if you leave a comment in module -> object -> method, sphinx ignores the comment and all nested content that follows in the method description)."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:199
msgid "Language and style issues"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:203
msgid "US vs British spelling"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:205
msgid "We use English US spelling."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:209
msgid "Instance vs server"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:211
msgid "We say \"instance\" rather than \"server\" to refer to an instance of Tarantool server. This keeps the manual terminology consistent with names like ``/etc/tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:215
msgid "Wrong usage: \"Replication allows multiple Tarantool *servers* to work on copies of the same databases.\""
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:218
msgid "Correct usage: \"Replication allows multiple Tarantool *instances* to work on copies of the same databases.\""
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:223
msgid "Examples and templates"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:227
msgid "Module and function"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:229
msgid "Here is an example of documenting a module (``my_fiber``) and a function (``my_fiber.create``)."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:236
msgid "Create and start a ``my_fiber`` object. The object is created and begins to run immediately."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:239
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:240
#: ../doc/2.2/reference/reference_lua/fiber.rst:230
#: ../doc/2.2/reference/reference_lua/fiber.rst:269
msgid "what will be passed to function"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:242
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:247
msgid "tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:263
msgid "Module, class and method"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:265
msgid "Here is an example of documenting a module (``my_box.index``), a class (``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:276
msgid "an object reference"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:277
msgid "a new name for the index (type = string)"
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:281
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/2.2/dev_guide/documentation_guidelines.rst:291
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/2.2/dev_guide/guidelines_index.rst:37
msgid "Guidelines"
msgstr ""

#: ../doc/2.2/dev_guide/index.rst:39
msgid "Contributor's Guide"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:41
msgid "Binary protocol"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:43
msgid "The binary protocol in Tarantool is a binary request/response protocol."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:49
msgid "Notation in diagrams"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:51
msgid "0    X\n"
"+----+\n"
"|    | - X + 1 bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:70
msgid "MsgPack data types:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:72
msgid "**MP_INT** - Integer"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:73
msgid "**MP_MAP** - Map"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:74
msgid "**MP_ARR** - Array"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:75
msgid "**MP_STRING** - String"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:76
msgid "**MP_FIXSTR** - Fixed size string"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:77
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:78
msgid "**MP_BIN** - MsgPack binary format"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:82
msgid "Greeting packet"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:84
msgid "TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:100
msgid "The server instance begins the dialogue by sending a fixed-size (128-byte) text greeting to the client. The greeting always contains two 64-byte lines of ASCII text, each line ending with a newline character (:code:`\\n`). The first line contains the instance version and protocol type. The second line contains up to 44 bytes of base64-encoded random string, to use in the authentication packet, and ends with up to 23 spaces."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:110
msgid "Unified packet structure"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:112
msgid "Once a greeting is read, the protocol becomes pure request/response and features a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:115
msgid "request multiplexing, e.g. ability to asynchronously issue multiple requests via the same connection"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:117
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:119
msgid "The protocol uses `msgpack <http://msgpack.org>`_ for data structures and encoding."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:122
msgid "The protocol uses maps that contain some integer constants as keys. These constants are defined in `src/box/iproto_constants.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/iproto_constants.h>`_. We list common constants here:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:127
msgid "-- user keys\n"
"<iproto_sync>          ::= 0x01\n"
"<iproto_schema_id>     ::= 0x05  /* also known as schema_version */\n"
"<iproto_space_id>      ::= 0x10\n"
"<iproto_index_id>      ::= 0x11\n"
"<iproto_limit>         ::= 0x12\n"
"<iproto_offset>        ::= 0x13\n"
"<iproto_iterator>      ::= 0x14\n"
"<iproto_key>           ::= 0x20\n"
"<iproto_tuple>         ::= 0x21\n"
"<iproto_function_name> ::= 0x22\n"
"<iproto_username>      ::= 0x23\n"
"<iproto_expr>          ::= 0x27 /* also known as expression */\n"
"<iproto_ops>           ::= 0x28\n"
"<iproto_data>          ::= 0x30\n"
"<iproto_error>         ::= 0x31\n"
"<iproto_sql_text>      ::= 0x40\n"
"<iproto_sql_bind>      ::= 0x41\n"
"<iproto_sql_info>      ::= 0x42"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:149
msgid "-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<iproto_select>         ::= 0x01\n"
"<iproto_insert>         ::= 0x02\n"
"<iproto_replace>        ::= 0x03\n"
"<iproto_update>         ::= 0x04\n"
"<iproto_delete>         ::= 0x05\n"
"<iproto_call_16>        ::= 0x06 /* as used in version 1.6 */\n"
"<iproto_auth>           ::= 0x07\n"
"<iproto_eval>           ::= 0x08\n"
"<iproto_upsert>         ::= 0x09\n"
"<iproto_call>           ::= 0x0a\n"
"<iproto_execute>        ::= 0x0b\n"
"<iproto_nop>            ::= 0x0c\n"
"<iproto_type_stat_max>  ::= 0x0d\n"
"-- Admin command codes\n"
"-- (including codes for replica-set initialization and master election)\n"
"<iproto_ping>         ::= 0x40\n"
"<iproto_join>         ::= 0x41 /* i.e. replication join */\n"
"<iproto_subscribe>    ::= 0x42\n"
"<iproto_request_vote> ::= 0x43\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<iproto_ok>           ::= 0x00\n"
"<iproto_type_error>   ::= 0x8XXX /* where XXX is a value in errcode.h */"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:177
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:179
msgid "Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:191
msgid "UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:203
msgid "They only differ in the allowed set of keys and values. The key defines the type of value that follows. If a body has no keys, the entire msgpack map for the body may be missing. Such is the case, for example, for a <ping> request. ``schema_id`` may be absent in the request's header, meaning that there will be no version checking, but it must be present in the response. If ``schema_id`` is sent in the header, then it will be checked."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:214
msgid "Authentication"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:216
msgid "When a client connects to the server instance, the instance responds with a 128-byte text greeting message. Part of the greeting is base-64 encoded session salt - a random string which can be used for authentication. The length of decoded salt (44 bytes) exceeds the amount necessary to sign the authentication message (first 20 bytes). An excess is reserved for future authentication schemas."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:223
msgid "PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:251
msgid ":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 fields: authentication mechanism (\"chap-sha1\" is the only supported mechanism right now) and password, encrypted according to the specified mechanism. Authentication in Tarantool is optional, if no authentication is performed, session user is 'guest'. The instance responds to authentication packet with a standard response with 0 tuples."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:259
msgid "Requests"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:261
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:264
msgid "SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:281
msgid "INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:283
msgid "REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing one."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:286
msgid "INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:299
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:302
msgid "UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:321
msgid "OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:344
msgid "    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:366
msgid "0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:378
msgid "It is an error to specify an argument of a type that differs from the expected type."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:380
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:383
msgid "DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:396
msgid "CALL_16: CODE - 0x06 Call a stored function, returning an array of tuples. This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:399
msgid "CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:413
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:416
msgid "EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:429
msgid "UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to insert tuple. Always use primary index for key."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:432
msgid "UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is skipped.\n"
"      It's not possible to change with update operations a part of the primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:473
msgid "CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a list of values, unconverted"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:476
msgid "CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:491
msgid "Response packet structure"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:493
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:495
msgid "OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:509
msgid "Set of tuples in the response :code:`<data>` expects a msgpack array of tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary MsgPack values."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:512
msgid "ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:527
msgid "An error message is present in the response only if there is an error; :code:`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:530
msgid "Convenience macros which define hexadecimal constants for return codes can be found in `src/box/errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:536
msgid "Replication packet structure"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:538
msgid "-- replication keys\n"
"<server_id>    ::= 0x02\n"
"<lsn>          ::= 0x03\n"
"<timestamp>    ::= 0x04\n"
"<server_uuid>  ::= 0x24\n"
"<cluster_uuid> ::= 0x25\n"
"<vclock>       ::= 0x26"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:548
msgid "-- replication codes\n"
"<join>         ::= 0x41\n"
"<subscribe>    ::= 0x42"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:555
msgid "JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:615
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:617
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:619
msgid "<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:627
msgid "After the file header come the data tuples. Tuples begin with a row marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker ``0xd510aded``. Thus, between the file header and the EOF marker, there may be data tuples that have this form:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:634
msgid "0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/2.2/dev_guide/internals/box_protocol.rst:651
msgid "See the example in the following section."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:39
msgid "File formats"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:45
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:47
msgid "To maintain data persistence, Tarantool writes each data change request (insert, update, delete, replace, upsert) into a write-ahead log (WAL) file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` records, or for every :ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>` bytes. Each data change request gets assigned a continuously growing 64-bit log sequence number. The name of the WAL file is based on the log sequence number of the first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:56
msgid "Apart from a log sequence number and the data change request (formatted as in :ref:`Tarantool's binary protocol <internals-box_protocol>`), each WAL record contains a header, some metadata, and then the data formatted according to `msgpack <https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is what the WAL file looks like after the first INSERT request (\"s:insert({1})\") for the sandbox database created in our :ref:`\"Getting started\" exercises <getting_started>`. On the left are the hexadecimal bytes that you would see with:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:65
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:69
msgid "and on the right are comments."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:71
msgid "Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" follows\n"
"00 02                         element#1: tag=request type, value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte \"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed array={1}"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:100
msgid "Tarantool processes requests atomically: a change is either accepted and recorded in the WAL, or discarded completely. Let's clarify how this happens, using the REPLACE request as an example:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:104
msgid "The server instance attempts to locate the original tuple by primary key. If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:107
msgid "The new tuple is validated. If for example it does not contain an indexed field, or it has an indexed field whose type does not match the type according to the index definition, the change is aborted."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:111
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:113
msgid "A message is sent to the WAL writer running in a separate thread, requesting that the change be recorded in the WAL. The instance switches to work on the next request until the write is acknowledged."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:117
msgid "On success, a confirmation is sent to the client. On failure, a rollback procedure is begun. During the rollback procedure, the transaction processor rolls back all changes to the database which occurred after the first failed change, from latest to oldest, up to the first failed change. All rolled back requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No new change is applied while rollback is in progress. When the rollback procedure is finished, the server restarts the processing pipeline."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:125
msgid "One advantage of the described algorithm is that complete request pipelining is achieved, even for requests on the same value of the primary key. As a result, database performance doesn't degrade even if all requests refer to the same key in the same space."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:130
msgid "The transaction processor thread communicates with the WAL writer thread using asynchronous (yet reliable) messaging; the transaction processor thread, not being blocked on WAL tasks, continues to handle requests quickly even at high volumes of disk I/O. A response to a request is sent as soon as it is ready, even if there were earlier incomplete requests on the same connection. In particular, SELECT performance, even for SELECTs running on a connection packed with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:138
msgid "The WAL writer employs a number of durability modes, as defined in configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible to turn the write-ahead log completely off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the write-ahead log it's still possible to take a persistent copy of the entire data set with the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:145
msgid "An .xlog file always contains changes based on the primary key. Even if the client requested an update or delete using a secondary key, the record in the .xlog file will contain the primary key."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:153
msgid "The snapshot file format"
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:155
msgid "The format of a snapshot .snap file is nearly the same as the format of a WAL .xlog file. However, the snapshot header differs: it contains the instance's global unique identifier and the snapshot file's position in history, relative to earlier snapshot files. Also, the content differs: an .xlog file may contain records for any data-change requests (inserts, updates, upserts, and deletes), a .snap file may only contain records of inserts to memtx spaces."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:162
msgid "Primarily, the .snap file's records are ordered by space id. Therefore the records of system spaces -- such as ``_schema``, ``_space``, ``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start of the .snap file, before the records of any spaces that were created by users."
msgstr ""

#: ../doc/2.2/dev_guide/internals/file_formats.rst:167
msgid "Secondarily, the .snap file's records are ordered by primary key within space id."
msgstr ""

#: ../doc/2.2/dev_guide/internals/index.rst:39
msgid "Internals"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:39
msgid "The recovery process"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:41
msgid "The recovery process begins when box.cfg{} happens for the first time after the Tarantool server instance starts."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:44
msgid "The recovery process must recover the databases as of the moment when the instance was last shut down. For this it may use the latest snapshot file and any WAL files that were written after the snapshot. One complicating factor is that Tarantool has two engines -- the memtx data must be reconstructed entirely from the snapshot and the WAL files, while the vinyl data will be on disk but might require updating around the time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl engine to make a checkpoint, and the snapshot operation is rolled back if anything goes wrong, so vinyl's checkpoint is at least as fresh as the snapshot file.)"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:61
msgid "Step 1"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:57
msgid "Read the configuration parameters in the ``box.cfg{}`` request. Parameters which affect recovery may include :ref:`work_dir <cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`memtx_dir <cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>` and :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:81
msgid "Step 2"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:64
msgid "Find the latest snapshot file. Use its data to reconstruct the in-memory databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:67
msgid "There are actually two variations of the reconstruction procedure for memtx databases, depending on whether the recovery process is \"default\"."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:70
msgid "If the recovery process is default (``force_recovery`` is ``false``), memtx can read data in the snapshot with all indexes disabled. First, all tuples are read into memory. Then, primary keys are built in bulk, taking advantage of the fact that the data is already sorted by primary key within each space."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:76
msgid "If the recovery process is non-default (``force_recovery`` is ``true``), Tarantool performs additional checking. Indexes are enabled at the start, and tuples are added one by one. This means that any unique-key constraint violations will be caught, and any duplicates will be skipped. Normally there will be no constraint violations or duplicates, so these checks are only made if an error has occurred."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:88
msgid "Step 3"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:84
msgid "Find the WAL file that was made at the time of, or after, the snapshot file. Read its log entries until the log-entry LSN is greater than the LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. This is the recovery process's \"start position\"; it matches the current state of the engines."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:92
msgid "Step 4"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:91
msgid "Redo the log entries, from the start position to the end of the WAL. The engine skips a redo instruction if it is older than the engine's checkpoint."
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:94
msgid "Step 5"
msgstr ""

#: ../doc/2.2/dev_guide/internals/recovery_internals.rst:95
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:41
msgid "In addition to the recovery process described above, the server must take additional steps and precautions if :ref:`replication <replication>` is enabled."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:44
msgid "Once again the startup procedure is initiated by the ``box.cfg{}`` request. One of the ``box.cfg`` parameters may be :ref:`replication <cfg_replication-replication>` that specifies replication source(-s). We will refer to this replica, which is starting up due to ``box.cfg``, as the \"local\" replica to distinguish it from the other replicas in a replica set, which we will refer to as \"distant\" replicas."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:51
msgid "*#1. If there is no snapshot .snap file and the ``replication`` parameter is empty*: |br| then the local replica assumes it is an unreplicated \"standalone\" instance, or is the first replica of a new replica set. It will generate new UUIDs for itself and for the replica set. The replica UUID is stored in the ``_cluster`` space; the replica set UUID is stored in the ``_schema`` space. Since a snapshot contains all the data in all the spaces, that means the local replica's snapshot will contain the replica UUID and the replica set UUID. Therefore, when the local replica restarts on later occasions, it will be able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:61
msgid "*#2. If there is no snapshot .snap file and the ``replication`` parameter is not empty and the ``_cluster`` space contains no other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, but is not yet part of a replica set. It must now join the replica set. It will send its replica UUID to the first distant replica which is listed in ``replication`` and which will act as a master. This is called the \"join request\". When a distant replica receives a join request, it will send back:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:79
msgid "*#3. If there is no snapshot .snap file and the ``replication`` parameter is not empty and the ``_cluster`` space contains other replica UUIDs*: |br| then the local replica assumes it is not a standalone instance, and is already part of a replica set. It will send its replica UUID and replica set UUID to all the distant replicas which are listed in ``replication``. This is called the \"on-connect handshake\". When a distant replica receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:95
msgid "In the end ... the local replica knows what replica set it belongs to, the distant replica knows that the local replica is a member of the replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:101
msgid "*#4. If there is a snapshot file and replication source is not empty*: |br| first the local replica goes through the recovery process described in the previous section, using its own .snap and .xlog files. Then it sends a \"subscribe\" request to all the other replicas of the replica set. The subscribe request contains the server vector clock. The vector clock has a collection of pairs 'server id, lsn' for every replica in the ``_cluster`` system space. Each distant replica, upon receiving a subscribe request, will read its .xlog files' requests and send them to the local replica if (lsn of .xlog file request) is greater than (lsn of the vector clock in the subscribe request). After all the other replicas of the replica set have responded to the local replica's subscribe request, the replica startup is complete."
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:113
msgid "The following temporary limitations apply for versions 1.7 and 2.1:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/replication_internals.rst:117
msgid "The maximum number of entries in the ``_cluster`` space is 32. Tuples for out-of-date replicas are not automatically re-used, so if this 32-replica limit is reached, users may have to reorganize the ``_cluster`` space manually."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:39
msgid "SQL protocol"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:41
msgid "Tarantool's SQL protocol regulates how to build SQL requests and parse responses using Tarantool's common binary protocol."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:44
msgid "Special SQL keys:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:46
msgid "<metadata>      ::= 0x32\n"
"<sql_text>      ::= 0x40\n"
"<sql_bind>      ::= 0x41\n"
"<sql_info>      ::= 0x42"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:54
msgid "Special SQL commands:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:56
msgid "<execute> ::= 11"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:62
msgid "Request packet body"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:64
msgid "An SQL request has the type ``EXECUTE=11``."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:66
msgid "EXECUTE REQUEST BODY:\n"
"                         MAP\n"
"+=====================+===============================+\n"
"|                     |                               |\n"
"|   0x40: SQL_TEXT    |     0x41: SQL_BIND            |\n"
"| MP_STR: SQL request | MP_ARRAY: array of parameters |\n"
"|                     |                               |\n"
"+=====================+===============================+"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:77
msgid "**SQL_TEXT** is a single non-empty SQL statement. For SQL syntax, see https://sqlite.org/lang.html"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:79
msgid "**SQL_BIND** is an optional array of bindings (parameters). Each parameter value is a scalar: number, string, binary, null."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:82
msgid "A parameter can be *ordinal* or *named*. An ordinal parameter is encoded as a message pack scalar value (MP_UINT, INT, DOUBLE, FLOAT, STR, BIN, EXT, NIL). A named parameter is encoded as a map with one string key -- its name. For bindings syntax, see https://sqlite.org/lang_expr.html#varparam"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:90
msgid ":code:`[100, 'abc', NULL, -345.6] = MP_ARRAY[ MP_UINT, MP_STR, MP_NIL, MP_DOUBLE ]`"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:91
msgid ":code:`[1, 2, {'name': 300}] = MP_ARRAY[ MP_UINT, MP_UINT, MP_MAP{ MP_STR : MP_UINT } ]`"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:95
msgid "Response packet body"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:97
msgid "Body structure depends on the type of the SQL request."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:99
msgid "If the SQL request is SELECT, the response contains:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:101
msgid "metadata for columns (metadata for a single column contains only the column's name and type) and"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:103
msgid "result rows."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:105
msgid "EXECUTE SELECT RESPONSE BODY:\n"
"                              MAP\n"
"+======================================+===========================+\n"
"|                                      |                           |\n"
"|     0x32: METADATA                   |                           |\n"
"| MP_ARRAY: array of maps:             |                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~~~+ |                           |\n"
"|           | +~~~~~~~~~~~~~~~~~~~~+ | |     0x30: DATA            |\n"
"|           | |   0x00: FIELD_NAME | | | MP_ARRAY: array of tuples |\n"
"|           | | MP_STR: field name | | |                           |\n"
"|           | |   0x01: FIELD_TYPE | | |                           |\n"
"|           | | MP_STR: field type | | |                           |\n"
"|           | +~~~~~~~~~~~~~~~~~~~~+ | |                           |\n"
"|           |        MP_MAP          | |                           |\n"
"|           +~~~~~~~~~~~~~~~~~~~~~~~~+ |                           |\n"
"|                   MP_ARRAY           |                           |\n"
"|                                      |                           |\n"
"+======================================+===========================+"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:128
msgid "Request: :code:`SELECT x, y FROM test_space;`"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:130
msgid "Response:"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:132
msgid "BODY = {\n"
"    METADATA = [\n"
"    { FIELD_NAME: 'X', FIELD_TYPE: 'TEXT'}, { FIELD_NAME: 'Y', FIELD_TYPE: 'INTEGER'},\n"
"    DATA = [ ['a', 1], ['c', 2], ['e', 5], ... ]\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:140
msgid "If the SQL request is not SELECT, the response body contains only SQL_INFO. Usually SQL_INFO is a map with only one key -- SQL_INFO_ROW_COUNT (0) -- which is the number of changed rows. For example, if the request is :code:`INSERT INTO test VALUES (1), (2), (3)`, the response body contains an SQL_INFO map with SQL_INFO_ROW_COUNT = 3. SQL_INFO_ROW_COUNT can be 0 for statements that do not change rows, such as CREATE TABLE."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:147
msgid "The SQL_INFO map may contain a second key -- SQL_INFO_AUTO_INCREMENT_IDS (1) -- which is the new primary-key value for an INSERT in a table defined with PRIMARY KEY AUTOINCREMENT. In this case the MP_MAP will have two keys, and  one of the two keys will be 0x01: SQL_INFO_AUTO_INCREMENT_IDS, which is an MP_UINT number."
msgstr ""

#: ../doc/2.2/dev_guide/internals/sql_protocol.rst:152
msgid "EXECUTE NOT-SELECT RESPONSE BODY:\n"
"\n"
"+=========================================================+\n"
"|                                                         |\n"
"|   0x42: SQL_INFO                                        |\n"
"| MP_MAP: usually 1 key   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                         |                             | |\n"
"|                         |    0x00: SQL_INFO_ROW_COUNT | |\n"
"|                         | MP_UINT: changed row count  | |\n"
"|                         |                             | |\n"
"|                         +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ |\n"
"|                                                         |\n"
"+=========================================================+"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:37
msgid "Lua Style Guide"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:39
msgid "Inspiration:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:41
msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:42
msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:43
msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:45
msgid "Programming style is an art. There is some arbitrariness to the rules, but there are sound rationales for them. It is useful not only to provide sound advice on style but to understand the underlying rationale and human aspect of why the style recommendations are formed:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:50
msgid "http://mindprod.com/jgloss/unmain.html"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:51
msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:52
msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:54
msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Beautiful is better than ugly."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Explicit is better than implicit."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Simple is better than complex."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Complex is better than complicated."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Flat is better than nested."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Sparse is better than dense."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Readability counts."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Special cases aren't special enough to break the rules."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Although practicality beats purity."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Errors should never pass silently."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Unless explicitly silenced."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "There should be one -- and preferably only one -- obvious way to do it."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Now is better than never."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Although never is often better than *right* now."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "If the implementation is hard to explain, it's a bad idea."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "If the implementation is easy to explain, it may be a good idea."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:0
msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:80
msgid "Indentation and Formatting"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:82
msgid "4 spaces instead tabs. PIL suggests using of two spaces, but programmer looks at code 4 up to 8 hours a day, so it's simplier to distinguish indentation with 4 spaces. Why spaces? Similar representation everywhere."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:86
msgid "You can use vim modelines:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:88
msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:92
msgid "A file should ends w/ one newline symbol, but shouldn't ends w/ blank line (two newline symbols)."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:95
msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:97
msgid "related ``or``/``and`` in ``if`` must be enclosed in the round brackets (). Example:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:99
msgid "if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:112
msgid "Type conversion"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:114
msgid "Do not use concatenation to convert to string or addition to convert to number (use ``tostring``/``tonumber`` instead):"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:117
msgid "local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:135
msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:137
msgid "if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:155
msgid "Avoid multiple concatenations in one statement, use ``string.format`` instead:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:157
msgid "function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:175
msgid "Use ``and``/``or`` for default variable values"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:177
msgid "function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:189
msgid "``if``'s and return statements:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:191
msgid "if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:204
msgid "Using spaces:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:206
msgid "one shouldn't use spaces between function name and opening round bracket, but arguments must be splitted with one whitespace charachter"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:209
msgid "function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:217
msgid "use space after comment marker"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:219
msgid "while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:230
msgid "surrounding operators"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:232
msgid "local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:246
msgid "use space after commas in tables"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:248
msgid "local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:258
msgid "use space in map definitions around equality sign and commas"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:260
msgid "return {1,2,3,4} -- bad\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- bad\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:273
msgid "also, you may use alignment:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:275
msgid "return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:283
msgid "extra blank lines may be used (sparingly) to separate groups of related functions. Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:287
msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:289
msgid "if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:311
msgid "Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in vim to delete them)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:316
msgid "Avoid global variable"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:318
msgid "You must avoid global variables. If you have an exceptional case, use ``_G`` variable to set it, add prefix or add table instead of prefix:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:321
msgid "function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:332
msgid "Always use prefix to avoid name clash"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:336
msgid "Naming"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:338
msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:339
msgid "names of \"classes\": CamelCase"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:340
msgid "private variables/methods (properties in the future) of object starts with underscores ``<object>._<name>``. Avoid using of ``local function private_methods(self) end``"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:343
msgid "boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a good style."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:344
msgid "for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are for indexing - ``n`` is for counting - ``k``, ``v`` is what you get out of ``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what you get out of ``ipairs()`` (are acceptable, ``_`` if unused) - ``k``/``key`` is for table keys - ``v``/``val``/``value`` is for values that are passed around - ``x``/``y``/``z`` is for generic math quantities - ``s``/``str``/``string`` is for strings - ``c`` is for 1-char strings - ``f``/``func``/``cb`` are for functions - ``status, <rv>..`` or ``ok, <rv>..`` is what you get out of pcall/xpcall - ``buf, sz`` is a (buffer, size) pair - ``<name>_p`` is for pointers - ``t0``.. is for timestamps - ``err`` is for errors"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:361
msgid "abbrevations are acceptable if they're unambigous and if you'll document (or they're too common) them."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:363
msgid "global variables are written with ALL_CAPS. If it's some system variable, then they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:365
msgid "module naming snake_case (avoid underscores and dashes) - 'luasql', instead of 'Lua-SQL'"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:367
msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:371
msgid "Idioms and patterns"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:373
msgid "Always use round brackets in call of functions except multiple cases (common lua style idioms):"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:376
msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:377
msgid "``ffi.cdef[[ ]]`` function"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:379
msgid "Avoid these kind of constructions:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:381
msgid "<func>'<name>' (strongly avoid require'..')"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:382
msgid "``function object:method() end`` (use ``functon object.method(self) end`` instead)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:383
msgid "do not use semicolon as table separator (only comma)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:384
msgid "semicolons at the end of line (only to split multiple statements on one line)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:385
msgid "try to avoid unnecessary function creation (closures/..)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:389
msgid "Modules"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:391
msgid "Don't start modules with license/authors/descriptions, you can write it in LICENSE/AUTHORS/README files. For writing modules use one of the two patterns (dont use ``modules()``):"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:395
msgid "local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:409
msgid "or"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:411
msgid "local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:428
msgid "Commenting"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:430
msgid "You should write code the way it shouldn't be described, but don't forget about commenting it. You shouldn't comment Lua syntax (assume that reader already knows Lua language). Try to tell about functions/variable names/etc."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:434
msgid "Multiline comments: use matching (``--[[ ]]--``) instead of simple (``--[[ ]]``)."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:437
msgid "Public function comments (??):"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:439
msgid "--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:452
msgid "Testing"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:454
msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:456
msgid "#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:507
msgid "When you'll test your code output will be something like this:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:509
msgid "TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:523
msgid "Error Handling"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:525
msgid "Be generous in what you accept and strict in what you return."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:527
msgid "With error handling this means that you must provide an error object as second multi-return value in case of error. The error object can be a string, a Lua table or cdata, in the latter cases it must have ``__tostring`` metamethod defined."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:532
msgid "In case of error, use ``nil`` for the first return value. This makes the error hard to ignore."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:535
msgid "When checking function return values, check the first argument first. If it's ``nil``, look for error in the second argument:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:538
msgid "local data, err = foo()\n"
"if not data\n"
"    return nil, err\n"
"end\n"
"return bar(data)"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:546
msgid "Unless performance of your code is paramount, try to avoid using more than two return values."
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:549
msgid "In rare cases you may want to return ``nil`` as a legal return value. In this case it's OK to check for error first, and return second:"
msgstr ""

#: ../doc/2.2/dev_guide/lua_style_guide.rst:552
msgid "local data, err = foo()\n"
"if not err\n"
"    return data\n"
"end\n"
"return nil, err"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:37
msgid "Python Style Guide"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:41
msgid "Introduction"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:43
msgid "This document gives coding conventions for the Python code comprising the standard library in the main Python distribution.  Please see the companion informational PEP describing style guidelines for the C code in the C implementation of Python [1]_."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:48
msgid "This document and PEP 257 (Docstring Conventions) were adapted from Guido's original Python Style Guide essay, with some additions from Barry's style guide [2]_."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:55
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:57
msgid "One of Guido's key insights is that code is read much more often than it is written.  The guidelines provided here are intended to improve the readability of code and make it consistent across the wide spectrum of Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:62
msgid "A style guide is about consistency.  Consistency with this style guide is important.  Consistency within a project is more important. Consistency within one module or function is the most important."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:66
msgid "But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply.  When in doubt, use your best judgment.  Look at other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:71
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:73
msgid "When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:76
msgid "To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:83
msgid "Code lay-out"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:87
msgid "Indentation"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:89
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:91
msgid "For really old code that you don't want to mess up, you can continue to use 8-space tabs."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:94
msgid "Continuation lines should align wrapped elements either vertically using Python's implicit line joining inside parentheses, brackets and braces, or using a hanging indent.  When using a hanging indent the following considerations should be applied; there should be no arguments on the first line and further indentation should be used to clearly distinguish itself as a continuation line."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:101
#: ../doc/2.2/dev_guide/python_style_guide.rst:358
#: ../doc/2.2/dev_guide/python_style_guide.rst:387
#: ../doc/2.2/dev_guide/python_style_guide.rst:406
#: ../doc/2.2/dev_guide/python_style_guide.rst:419
msgid "Yes::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:103
msgid "# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:113
#: ../doc/2.2/dev_guide/python_style_guide.rst:364
#: ../doc/2.2/dev_guide/python_style_guide.rst:395
#: ../doc/2.2/dev_guide/python_style_guide.rst:411
msgid "No::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:115
msgid "# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:125
msgid "Optional::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:127
msgid "# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:132
msgid "The closing brace/bracket/parenthesis on multi-line constructs may either line up under the first non-whitespace character of the last line of list, as in::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:136
msgid "my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:145
msgid "or it may be lined up under the first character of the line that starts the multi-line construct, as in::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:148
msgid "my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:160
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:162
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:164
msgid "The most popular way of indenting Python is with spaces only.  The second-most popular way is with tabs only.  Code indented with a mixture of tabs and spaces should be converted to using spaces exclusively.  When invoking the Python command line interpreter with the ``-t`` option, it issues warnings about code that illegally mixes tabs and spaces.  When using ``-tt`` these warnings become errors. These options are highly recommended!"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:172
msgid "For new projects, spaces-only are strongly recommended over tabs. Most editors have features that make this easy to do."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:177
msgid "Maximum Line Length"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:179
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:181
msgid "There are still many devices around that are limited to 80 character lines; plus, limiting windows to 80 characters makes it possible to have several windows side-by-side.  The default wrapping on such devices disrupts the visual structure of the code, making it more difficult to understand.  Therefore, please limit all lines to a maximum of 79 characters.  For flowing long blocks of text (docstrings or comments), limiting the length to 72 characters is recommended."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:189
msgid "The preferred way of wrapping long lines is by using Python's implied line continuation inside parentheses, brackets and braces.  Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:195
msgid "Backslashes may still be appropriate at times.  For example, long, multiple ``with``-statements cannot use implicit continuation, so backslashes are acceptable::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:199
msgid "with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:203
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:205
msgid "Make sure to indent the continued line appropriately.  The preferred place to break around a binary operator is *after* the operator, not before it.  Some examples::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:209
msgid "class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:226
msgid "Blank Lines"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:228
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:231
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:234
msgid "Extra blank lines may be used (sparingly) to separate groups of related functions.  Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:238
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:240
msgid "Python accepts the control-L (i.e. ^L) form feed character as whitespace; Many tools treat these characters as page separators, so you may use them to separate pages of related sections of your file. Note, some editors and web-based code viewers may not recognize control-L as a form feed and will show another glyph in its place."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:248
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:250
msgid "Code in the core Python distribution should always use the ASCII or Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 is preferred over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:254
msgid "Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) should only be used when a comment or docstring needs to mention an author name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or ``\\U`` escapes is the preferred way to include non-ASCII data in string literals."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:260
msgid "For Python 3.0 and beyond, the following policy is prescribed for the standard library (see PEP 3131): All identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD use English words wherever feasible (in many cases, abbreviations and technical terms are used which aren't English). In addition, string literals and comments must also be in ASCII. The only exceptions are (a) test cases testing the non-ASCII features, and (b) names of authors. Authors whose names are not based on the latin alphabet MUST provide a latin transliteration of their names."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:271
msgid "Open source projects with a global audience are encouraged to adopt a similar policy."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:277
msgid "Imports"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:279
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:286
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:290
msgid "Imports are always put at the top of the file, just after any module comments and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:293
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:295
msgid "standard library imports"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:296
msgid "related third party imports"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:297
msgid "local application/library specific imports"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:299
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:301
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:303
msgid "Relative imports for intra-package imports are highly discouraged. Always use the absolute package path for all imports.  Even now that PEP 328 is fully implemented in Python 2.5, its style of explicit relative imports is actively discouraged; absolute imports are more portable and usually more readable."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:309
msgid "When importing a class from a class-containing module, it's usually okay to spell this::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:315
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:320
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:325
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:329
msgid "Pet Peeves"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:331
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:333
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:338
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:343
msgid "Immediately before the open parenthesis that starts the argument list of a function call::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:349
msgid "Immediately before the open parenthesis that starts an indexing or slicing::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:355
msgid "More than one space around an assignment (or other) operator to align it with another."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:373
msgid "Other Recommendations"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:375
msgid "Always surround these binary operators with a single space on either side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, ``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, ``not``)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:381
msgid "If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgement; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:403
msgid "Don't use spaces around the ``=`` sign when used to indicate a keyword argument or a default parameter value."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:416
msgid "Compound statements (multiple statements on the same line) are generally discouraged."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:427
#: ../doc/2.2/dev_guide/python_style_guide.rst:436
msgid "Rather not::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:432
msgid "While sometimes it's okay to put an if/for/while with a small body on the same line, never do this for multi-clause statements.  Also avoid folding such long lines!"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:442
msgid "Definitely not::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:457
msgid "Comments"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:459
msgid "Comments that contradict the code are worse than no comments.  Always make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:463
msgid "Comments should be complete sentences.  If a comment is a phrase or sentence, its first word should be capitalized, unless it is an identifier that begins with a lower case letter (never alter the case of identifiers!)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:468
msgid "If a comment is short, the period at the end can be omitted.  Block comments generally consist of one or more paragraphs built out of complete sentences, and each sentence should end in a period."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:472
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:474
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:476
msgid "Python coders from non-English speaking countries: please write your comments in English, unless you are 120% sure that the code will never be read by people who don't speak your language."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:482
msgid "Block Comments"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:484
msgid "Block comments generally apply to some (or all) code that follows them, and are indented to the same level as that code.  Each line of a block comment starts with a ``#`` and a single space (unless it is indented text inside the comment)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:489
msgid "Paragraphs inside a block comment are separated by a line containing a single ``#``."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:494
msgid "Inline Comments"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:496
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:498
msgid "An inline comment is a comment on the same line as a statement. Inline comments should be separated by at least two spaces from the statement.  They should start with a # and a single space."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:502
msgid "Inline comments are unnecessary and in fact distracting if they state the obvious.  Don't do this::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:505
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:507
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:509
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:513
msgid "Documentation Strings"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:515
msgid "Conventions for writing good documentation strings (a.k.a. \"docstrings\") are immortalized in PEP 257."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:518
msgid "Write docstrings for all public modules, functions, classes, and methods.  Docstrings are not necessary for non-public methods, but you should have a comment that describes what the method does.  This comment should appear after the ``def`` line."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:523
msgid "PEP 257 describes good docstring conventions.  Note that most importantly, the ``\"\"\"`` that ends a multiline docstring should be on a line by itself, and preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:533
msgid "For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the same line."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:539
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:541
msgid "If you have to have Subversion, CVS, or RCS crud in your source file, do it as follows. ::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:544
msgid "__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:547
msgid "These lines should be included after the module's docstring, before any other code, separated by a blank line above and below."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:553
msgid "Naming Conventions"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:555
msgid "The naming conventions of Python's library are a bit of a mess, so we'll never get this completely consistent -- nevertheless, here are the currently recommended naming standards.  New modules and packages (including third party frameworks) should be written to these standards, but where an existing library has a different style, internal consistency is preferred."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:564
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:566
msgid "There are a lot of different naming styles.  It helps to be able to recognize what naming style is being used, independently from what they are used for."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:570
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:572
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:573
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:574
msgid "``lowercase``"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:575
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:576
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:577
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:578
msgid "``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of the bumpy look of its letters [3]_).  This is also sometimes known as StudlyCaps."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:582
msgid "Note: When using abbreviations in CapWords, capitalize all the letters of the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:585
msgid "``mixedCase`` (differs from CapitalizedWords by initial lowercase character!)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:587
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:589
msgid "There's also the style of using a short unique prefix to group related names together.  This is not used much in Python, but it is mentioned for completeness.  For example, the ``os.stat()`` function returns a tuple whose items traditionally have names like ``st_mode``, ``st_size``, ``st_mtime`` and so on.  (This is done to emphasize the correspondence with the fields of the POSIX system call struct, which helps programmers familiar with that.)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:597
msgid "The X11 library uses a leading X for all its public functions.  In Python, this style is generally deemed unnecessary because attribute and method names are prefixed with an object, and function names are prefixed with a module name."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:602
msgid "In addition, the following special forms using leading or trailing underscores are recognized (these can generally be combined with any case convention):"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:606
msgid "``_single_leading_underscore``: weak \"internal use\" indicator. E.g. ``from M import *`` does not import objects whose name starts with an underscore."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:610
msgid "``single_trailing_underscore_``: used by convention to avoid conflicts with Python keyword, e.g. ::"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:615
msgid "``__double_leading_underscore``: when naming a class attribute, invokes name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; see below)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:619
msgid "``__double_leading_and_trailing_underscore__``: \"magic\" objects or attributes that live in user-controlled namespaces. E.g. ``__init__``, ``__import__`` or ``__file__``.  Never invent such names; only use them as documented."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:626
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:630
msgid "Names to Avoid"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:632
msgid "Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:636
msgid "In some fonts, these characters are indistinguishable from the numerals one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:641
msgid "Package and Module Names"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:643
msgid "Modules should have short, all-lowercase names.  Underscores can be used in the module name if it improves readability.  Python packages should also have short, all-lowercase names, although the use of underscores is discouraged."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:648
msgid "Since module names are mapped to file names, and some file systems are case insensitive and truncate long names, it is important that module names be chosen to be fairly short -- this won't be a problem on Unix, but it may be a problem when the code is transported to older Mac or Windows versions, or DOS."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:654
msgid "When an extension module written in C or C++ has an accompanying Python module that provides a higher level (e.g. more object oriented) interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:661
msgid "Class Names"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:663
msgid "Almost without exception, class names use the CapWords convention. Classes for internal use have a leading underscore in addition."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:668
msgid "Exception Names"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:670
msgid "Because exceptions should be classes, the class naming convention applies here.  However, you should use the suffix \"Error\" on your exception names (if the exception actually is an error)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:676
msgid "Global Variable Names"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:678
msgid "(Let's hope that these variables are meant for use inside one module only.)  The conventions are about the same as those for functions."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:681
msgid "Modules that are designed for use via ``from M import *`` should use the ``__all__`` mechanism to prevent exporting globals, or use the older convention of prefixing such globals with an underscore (which you might want to do to indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:689
msgid "Function Names"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:691
msgid "Function names should be lowercase, with words separated by underscores as necessary to improve readability."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:694
msgid "mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:700
msgid "Function and method arguments"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:702
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:704
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:706
msgid "If a function argument's name clashes with a reserved keyword, it is generally better to append a single trailing underscore rather than use an abbreviation or spelling corruption.  Thus ``class_`` is better than ``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:714
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:716
msgid "Use the function naming rules: lowercase with words separated by underscores as necessary to improve readability."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:719
msgid "Use one leading underscore only for non-public methods and instance variables."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:722
msgid "To avoid name clashes with subclasses, use two leading underscores to invoke Python's name mangling rules."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:725
msgid "Python mangles these names with the class name: if class Foo has an attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An insistent user could still gain access by calling ``Foo._Foo__a``.) Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:731
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:735
msgid "Constants"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:737
msgid "Constants are usually defined on a module level and written in all capital letters with underscores separating words.  Examples include ``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:743
msgid "Designing for inheritance"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:745
msgid "Always decide whether a class's methods and instance variables (collectively: \"attributes\") should be public or non-public.  If in doubt, choose non-public; it's easier to make it public later than to make a public attribute non-public."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:750
msgid "Public attributes are those that you expect unrelated clients of your class to use, with your commitment to avoid backward incompatible changes.  Non-public attributes are those that are not intended to be used by third parties; you make no guarantees that non-public attributes won't change or even be removed."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:756
msgid "We don't use the term \"private\" here, since no attribute is really private in Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:759
msgid "Another category of attributes are those that are part of the \"subclass API\" (often called \"protected\" in other languages).  Some classes are designed to be inherited from, either to extend or modify aspects of the class's behavior.  When designing such a class, take care to make explicit decisions about which attributes are public, which are part of the subclass API, and which are truly only to be used by your base class."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:767
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:769
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:771
msgid "If your public attribute name collides with a reserved keyword, append a single trailing underscore to your attribute name.  This is preferable to an abbreviation or corrupted spelling.  (However, not withstanding this rule, 'cls' is the preferred spelling for any variable or argument which is known to be a class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:779
#: ../doc/2.2/dev_guide/python_style_guide.rst:790
#: ../doc/2.2/dev_guide/python_style_guide.rst:812
msgid "Note 1:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:779
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:781
msgid "For simple public data attributes, it is best to expose just the attribute name, without complicated accessor/mutator methods.  Keep in mind that Python provides an easy path to future enhancement, should you find that a simple data attribute needs to grow functional behavior.  In that case, use properties to hide functional implementation behind simple data attribute access syntax."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:790
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:794
#: ../doc/2.2/dev_guide/python_style_guide.rst:817
msgid "Note 2:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:793
msgid "Try to keep the functional behavior side-effect free, although side-effects such as caching are generally fine."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:799
#: ../doc/2.2/dev_guide/python_style_guide.rst:822
msgid "Note 3:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:797
msgid "Avoid using properties for computationally expensive operations; the attribute notation makes the caller believe that access is (relatively) cheap."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:801
msgid "If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores.  This invokes Python's name mangling algorithm, where the name of the class is mangled into the attribute name.  This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:810
msgid "Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:815
msgid "Name mangling can make certain uses, such as debugging and ``__getattr__()``, less convenient.  However the name mangling algorithm is well documented and easy to perform manually."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:820
msgid "Not everyone likes name mangling.  Try to balance the need to avoid accidental name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:826
msgid "References"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:828
msgid "`PEP 7, Style Guide for C Code, van Rossum <https://www.python.org/dev/peps/pep-0007/>`_"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:829
msgid "`Barry's GNU Mailman style guide <http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:830
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:834
msgid "Copyright"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:836
msgid "Author:"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:838
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/2.2/dev_guide/python_style_guide.rst:839
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:37
#: ../doc/2.2/reference/reference_lua/box.rst:39
msgid "Module `box`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:41
msgid "Opaque structure passed to a C stored procedure"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:47
msgid "Return a tuple from a C stored procedure."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:49
msgid "The returned tuple is automatically reference-counted by Tarantool. An example program that uses ``box_return_tuple()`` is :ref:`write.c <f_c_tutorial-write>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:53
msgid "an opaque structure passed to the C stored procedure by Tarantool"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:55
msgid "a tuple to return"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/error.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:0
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:0
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:0
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:0
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:0
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
msgid "Returns"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:57
msgid "-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:59
#: ../doc/2.2/dev_guide/reference_capi/box.rst:107
#: ../doc/2.2/dev_guide/reference_capi/box.rst:124
#: ../doc/2.2/dev_guide/reference_capi/box.rst:140
#: ../doc/2.2/dev_guide/reference_capi/box.rst:161
#: ../doc/2.2/dev_guide/reference_capi/box.rst:182
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:99
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:112
msgid "0 otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:65
msgid "Find space id by name."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:67
msgid "This function performs a SELECT request on the ``_vspace`` system space."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:69
msgid "space name"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:70
#: ../doc/2.2/dev_guide/reference_capi/box.rst:86
msgid "length of ``name``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:72
#: ../doc/2.2/dev_guide/reference_capi/box.rst:88
msgid ":c:macro:`BOX_ID_NIL` on error or if not found (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:74
#: ../doc/2.2/dev_guide/reference_capi/box.rst:90
msgid "space_id otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:76
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:80
msgid "Find index id by name."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:82
msgid "This function performs a SELECT request on the ``_vindex`` system space."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:84
#: ../doc/2.2/dev_guide/reference_capi/box.rst:100
#: ../doc/2.2/dev_guide/reference_capi/box.rst:117
#: ../doc/2.2/dev_guide/reference_capi/box.rst:132
#: ../doc/2.2/dev_guide/reference_capi/box.rst:148
#: ../doc/2.2/dev_guide/reference_capi/box.rst:169
#: ../doc/2.2/dev_guide/reference_capi/box.rst:190
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:119
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:163
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:173
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:183
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:202
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:218
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:234
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:250
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:268
msgid "space identifier"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:85
msgid "index name"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:92
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:98
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:101
#: ../doc/2.2/dev_guide/reference_capi/box.rst:118
#: ../doc/2.2/dev_guide/reference_capi/box.rst:171
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:102
#: ../doc/2.2/dev_guide/reference_capi/box.rst:119
#: ../doc/2.2/dev_guide/reference_capi/box.rst:172
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:103
#: ../doc/2.2/dev_guide/reference_capi/box.rst:120
msgid "output argument. Resulting tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:106
#: ../doc/2.2/dev_guide/reference_capi/box.rst:123
#: ../doc/2.2/dev_guide/reference_capi/box.rst:139
#: ../doc/2.2/dev_guide/reference_capi/box.rst:160
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:109
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:115
msgid "Execute a REPLACE request."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:126
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:130
msgid "Execute a DELETE request."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:133
#: ../doc/2.2/dev_guide/reference_capi/box.rst:149
#: ../doc/2.2/dev_guide/reference_capi/box.rst:170
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:120
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:164
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:174
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:184
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:203
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:219
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:235
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:251
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:269
msgid "index identifier"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:134
#: ../doc/2.2/dev_guide/reference_capi/box.rst:150
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:135
#: ../doc/2.2/dev_guide/reference_capi/box.rst:151
msgid "end of a ``key``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:136
#: ../doc/2.2/dev_guide/reference_capi/box.rst:157
#: ../doc/2.2/dev_guide/reference_capi/box.rst:178
msgid "output argument. An old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:142
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:146
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:152
#: ../doc/2.2/dev_guide/reference_capi/box.rst:173
msgid "encoded operations in MsgPack Array format, e.g. ``[[ '=', field_id,  value ], ['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:154
msgid "end of an ``ops`` section"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:155
#: ../doc/2.2/dev_guide/reference_capi/box.rst:176
msgid "0 if field_ids are zero-based as in C, 1 if field ids are 1-based as in Lua"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:163
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:167
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:175
msgid "end of a ``ops``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:181
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:184
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box.rst:188
msgid "Truncate a space."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:37
msgid "Module `index`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:41
msgid "A space iterator"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:47
msgid "Controls how to iterate over tuples in an index. Different index types support different iterator types. For example, one can start iteration from a particular value (request key) and then retrieve all tuples where keys are greater or equal (= GE) to this key."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:52
msgid "If iterator type is not supported by the selected index type, iterator constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, an index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:56
msgid "NULL value of request key corresponds to the first or last key in the index, depending on iteration direction. (first key for GE and GT types, and last key for LE and LT). Therefore, to iterate over all tuples in an index, one can use ITER_GE or ITER_LE iteration types with start key equal to NULL. For ITER_EQ, the key must not be NULL."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:64
msgid "key == x ASC order"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:68
msgid "key == x DESC order"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:72
msgid "all tuples"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:76
msgid "key < x"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:80
msgid "key <= x"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:84
msgid "key >= x"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:88
msgid "key > x"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:92
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:96
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:100
msgid "all bits are not set"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:104
msgid "key overlaps x"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:108
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:114
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:116
msgid "The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-box_index-box_iterator_free>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:121
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:252
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:122
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:204
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:220
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:236
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:253
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:123
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:205
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:221
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:237
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:254
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:125
msgid "NULL on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:126
msgid "iterator otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:128
msgid "See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, :ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:135
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:137
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:151
msgid "an iterator returned by :ref:`box_index_iterator <c_api-box_index-box_index_iterator>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:139
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:142
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:166
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:176
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:209
msgid "-1 on error (check :ref:`box_error_last <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:143
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:149
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:156
msgid "Determine a direction of the given iterator type: -1 for REQ, LT, LE, and +1 for all others."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:161
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:167
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:177
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:171
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:181
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:185
msgid "random seed"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:186
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:206
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:222
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:238
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:189
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:195
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:197
msgid "Please note that this function works much more faster than :ref:`index_object.select<box_index-select>` or :ref:`box_index_iterator<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:210
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:226
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:242
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:257
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:206
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:52
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:61
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:99
msgid "0 on success"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:212
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:216
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:225
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:241
#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:256
msgid "-1 on error (check :ref:`box_error_last() <c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:228
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:232
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:244
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:248
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:259
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:264
msgid "Return :ref:`key definition <capi-tuple_key_def>` for an index"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:266
msgid "Returned object is valid until the next yield."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:271
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:203
msgid "key definition on success"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:272
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:204
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:222
msgid "NULL on error"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:274
msgid "See also: :ref:`box_tuple_compare() <capi-tuple_box_tuple_compare>`,"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/box_index.rst:275
msgid ":ref:`box_tuple_format_new() <capi-tuple_box_tuple_format_new>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/clock.rst:37
#: ../doc/2.2/reference/reference_lua/clock.rst:39
msgid "Module `clock`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:37
msgid "Module `coio`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:43
msgid "READ event"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:47
msgid "WRITE event"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:53
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:55
#: ../doc/2.2/dev_guide/reference_capi/coio.rst:104
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:56
msgid "requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit flags."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:58
msgid "timeout in seconds."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:60
msgid "0 - timeout"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:61
msgid ">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit flags."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:67
msgid "Create new eio task with specified function and arguments. Yield and wait until the task is complete or a timeout occurs. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:72
msgid "To avoid double error checking, this function does not throw exceptions. In most cases it is also necessary to check the return value of the called function and perform necessary actions. If func sets errno, the errno is preserved across the call."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:77
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:78
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:82
msgid "static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:97
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:101
msgid "Close the ``fd`` and wake any fiber blocked in :ref:`coio_wait() <c_api-coio-coio_wait>` call on this ``fd``."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/coio.rst:106
msgid "the result of ``close(fd)``, see :manpage:`close(2)`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:37
msgid "Module `error`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:187
msgid "Error - contains information about error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:191
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:193
#: ../doc/2.2/dev_guide/reference_capi/error.rst:200
#: ../doc/2.2/dev_guide/reference_capi/error.rst:207
msgid "error"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:194
#: ../doc/2.2/dev_guide/reference_capi/error.rst:208
msgid "not-null string"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:198
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:201
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:205
msgid "Return the error message"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:214
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:216
msgid "The Tarantool error handling works most like libc's errno. All API calls return -1 or NULL in the event of error. An internal pointer to box_error_t type is set by API functions to indicate what went wrong. This value is only significant if API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:221
msgid "Successful function can also touch the last error in some cases. You don't have to clear the last error before calling API functions. The returned object is valid only until next call to **any** API function."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:225
msgid "You must set the last error using box_error_set() in your stored C procedures if you want to return a custom error message. You can re-throw the last API error to IPROTO client by keeping the current value and returning -1 to Tarantool from your stored procedure."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:230
msgid "last error"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:234
msgid "Clear the last error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:238
msgid "Set the last error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:242
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:244
#: ../doc/2.2/dev_guide/reference_capi/say.rst:67
#: ../doc/2.2/dev_guide/reference_capi/say.rst:82
msgid "format arguments"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:246
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/error.rst:250
msgid "A backward-compatible API define."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:37
#: ../doc/2.2/reference/reference_lua/fiber.rst:39
msgid "Module `fiber`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:41
msgid "Fiber - contains information about a :ref:`fiber <atomic-threads_fibers_yields>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:45
msgid "Function to run inside a fiber."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:49
msgid "Create a new fiber."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:51
msgid "Takes a fiber from the fiber cache, if it's not empty. Can fail only if there is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:54
msgid "The created fiber automatically returns itself to the fiber cache when its \"main\" function completes."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:57
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:73
msgid "string with fiber name"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:58
msgid "func for run inside fiber"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:60
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:77
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:64
msgid "Create a new fiber with defined attributes."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:66
msgid "Can fail only if there is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:69
msgid "The created fiber automatically returns itself to the fiber cache if has a default stack size when its \"main\" function completes."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:74
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:197
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:203
msgid "fiber attributes container"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:75
msgid "function to run inside the fiber"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:83
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:85
msgid "fiber to start"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:86
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:90
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:92
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:98
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:100
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:138
msgid "fiber to be woken up"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:106
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:108
msgid "If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be woken up (maybe prematurely). Then current fiber yields until the target fiber is dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:112
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:116
msgid "Make it possible or not possible to wakeup the current fiber immediately when it's cancelled."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:119
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:130
msgid "fiber"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:120
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:131
msgid "status to set"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:122
msgid "previous state"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:128
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:135
msgid "Wait until the fiber is dead and then move its execution status to the caller. The fiber must not be detached."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:140
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:142
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:146
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:148
msgid "time to sleep"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:150
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:152
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:158
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:162
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:166
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:170
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:176
msgid "Return ``slab_cache`` suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:180
msgid "Return the current fiber."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:186
msgid "Create a new fiber attributes container and initialize it with default parameters."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:189
msgid "Can be used for creating many fibers: corresponding fibers will not take ownership."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:194
msgid "Delete the ``fiber_attr`` and free all allocated resources. This is safe when fibers created with this attribute still exist."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:201
msgid "Set the fiber's stack size in the fiber attributes container."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:204
msgid "stack size for new fibers (in bytes)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:207
msgid "-1 on failure (if ``stack_size`` is smaller than the minimum allowable fiber stack size)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:212
msgid "Get the fiber's stack size from the fiber attributes container."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:214
msgid "fiber attributes container, or NULL for default"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:217
msgid "stack size (in bytes)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:223
msgid "A conditional variable: a synchronization primitive that allow fibers in Tarantool's :ref:`cooperative multitasking <atomic-cooperative_multitasking>` environment to yield until some predicate is satisfied."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:227
msgid "Fiber conditions have two basic operations -- \"wait\" and \"signal\", -- where \"wait\" suspends the execution of a fiber (i.e. yields) until \"signal\" is called."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:231
msgid "Unlike ``pthread_cond``, ``fiber_cond`` doesn't require mutex/latch wrapping."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:235
msgid "Create a new conditional variable."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:239
msgid "Delete the conditional variable."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:241
msgid "Note: behavior is undefined if there are fibers waiting for the conditional variable."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:244
msgid "conditional variable to delete"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:250
msgid "Wake up **one** (any) of the fibers waiting for the conditional variable."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:252
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:260
msgid "Does nothing if no one is waiting."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:254
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:262
#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:278
msgid "conditional variable"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:258
msgid "Wake up **all** fibers waiting for the conditional variable."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:268
msgid "Suspend the execution of the current fiber (i.e. yield) until :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` is called."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:271
msgid "Like ``pthread_cond``, ``fiber_cond`` can issue spurious wake ups caused by explicit :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>` or :ref:`fiber_cancel()<c_api-fiber-fiber_cancel>` calls. It is highly recommended to wrap calls to this function into a loop and check the actual predicate and :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>` on every iteration."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:279
msgid "timeout in seconds"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:281
msgid "0 on :ref:`fiber_cond_signal() <c_api-fiber_cond_signal>` call or a spurious wake up"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:283
msgid "-1 on timeout, and the error code is set to 'TimedOut'"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/fiber.rst:287
msgid "Shortcut for :ref:`fiber_cond_wait_timeout() <c_api-fiber_cond_wait_timeout>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/index.rst:39
msgid "C API reference"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/index.rst:41
msgid "List of C API headers"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:37
msgid "Module `latch`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:41
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:45
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:47
msgid "allocated latch object"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
msgid "Return type"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:48
msgid "box_latch_t *"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:52
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:54
msgid "latch to destroy"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:58
msgid "Lock a latch. Waits indefinitely until the current fiber can gain access to the latch."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:0
msgid "param box_latch_t* latch"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:61
#: ../doc/2.2/dev_guide/reference_capi/latch.rst:67
msgid "latch to lock"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:65
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:68
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:69
msgid "int"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:73
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/latch.rst:75
msgid "latch to unlock"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:37
msgid "Module `say` (logging)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:45
msgid "do not use this value directly"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:63
#: ../doc/2.2/dev_guide/reference_capi/say.rst:79
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:65
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:66
#: ../doc/2.2/dev_guide/reference_capi/say.rst:81
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:69
#: ../doc/2.2/dev_guide/reference_capi/say.rst:84
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/say.rst:88
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:37
msgid "Module `schema`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:45
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:49
msgid "Space id of _schema."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:53
msgid "Space id of _space."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:57
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:61
msgid "Space id of _index."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:65
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:69
msgid "Space id of _func."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:73
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:77
msgid "Space id of _user."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:81
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:85
msgid "Space id of _priv."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:89
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:93
msgid "Space id of _cluster."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:97
msgid "Space id of _trigger."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:101
msgid "Space id of _truncate."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:105
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/schema.rst:109
msgid "NULL value, returned on error."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:37
msgid "Module `trivia/config`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:41
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:45
msgid "Package major version - 2 for 2.0.5."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:49
msgid "Package minor version - 0 for 2.0.5."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:53
msgid "Package patch version - 5 for 2.0.5."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:57
msgid "A string with major-minor-patch-commit-id identifier of the release, e.g. 2.0.5-75-gdd8e14ffb."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:62
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:66
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:70
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:74
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:78
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:82
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:86
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:90
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:94
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:98
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:102
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:106
msgid "A constant added to ``package.path`` in Lua to find ``*.lua`` module files."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/trivia.rst:110
msgid "A constant added to ``package.cpath`` in Lua to find ``*.so`` module files."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:37
msgid "Module `tuple`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:45
msgid "Tuple format."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:47
msgid "Each Tuple has an associated format (class). Default format is used to create tuples which are not attached to any particular space."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:58
msgid "Allocate and initialize a new tuple from raw MsgPack Array data."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:60
msgid "tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:63
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:64
msgid "the end of ``data``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:66
#: ../doc/2.2/dev_guide/reference_capi/txn.rst:83
msgid "NULL on out of memory"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:67
msgid "tuple otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:69
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:73
msgid "When working with tuples, it is the developer's responsibility to ensure that enough space is allocated, taking especial caution when writing to them with msgpuck functions such as ``mp_encode_array()``."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:82
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:84
msgid "Tuples are reference counted. All functions that return tuples guarantee that the last returned tuple is reference counted internally until the next call to API function that yields or returns another tuple."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:88
msgid "You should increase the reference counter before taking tuples for long processing in your code. The Lua garbage collector will not destroy a tuple that has references, even if another fiber removes them from a space. After processing, decrement the reference counter using :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`, otherwise the tuple will leak."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:96
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:109
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:122
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:128
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:147
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:162
msgid "a tuple"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:98
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:111
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:140
msgid "-1 on error"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:101
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:107
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:114
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:120
msgid "Return the number of fields in a tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:126
msgid "Return the number of bytes used to store internal tuple data (MsgPack Array)."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:132
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:134
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:136
msgid "Upon successful return, the function returns the number of bytes written. If buffer size is not enough then the return value is the number of bytes which would have been written if enough space had been available."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:141
msgid "number of bytes written on success."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:145
msgid "Return the associated format."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:149
msgid "tuple format"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:155
msgid "Return the raw tuple field in MsgPack format. The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:160
msgid "The buffer is valid until the next call to a ``box_tuple_*`` function."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:163
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:165
msgid "NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:166
msgid "msgpack otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:181
msgid "Possible data types for tuple fields."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:183
msgid "One cannot use STRS/ENUM macros for types because there is a mismatch between enum name (STRING) and type name literal (\"STR\"). STR is already used as a type in Objective C."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:191
msgid "Key definition"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:195
msgid "Create a key definition with the key fields with passed types on passed positions."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:197
msgid "May be used for tuple format creation and/or tuple comparison."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:199
msgid "array with key field identifiers"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:200
msgid "array with key :ref:`field types <capi-tuple_field_type>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:201
msgid "the number of key fields"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:208
msgid "Delete a key definition"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:210
msgid "key definition to delete"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:216
msgid "Return new in-memory tuple format based on passed key definitions"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:218
msgid "array of keys defined for the format"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:219
msgid "count of keys"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:221
msgid "new tuple format on success"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:226
msgid "Increment tuple format reference count"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:228
msgid "tuple format to ref"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:232
msgid "Decrement tuple format reference count"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:234
msgid "tuple format to unref"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:240
msgid "Compare tuples using key definition"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:242
msgid "the first tuple"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:243
msgid "the second tuple"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:244
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:258
msgid "key definition"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:246
msgid "0  if ``key_fields(tuple_a)`` == ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:247
msgid "<0 if ``key_fields(tuple_a)`` < ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:248
msgid ">0 if ``key_fields(tuple_a)`` > ``key_fields(tuple_b)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:250
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:264
msgid "See also: enum :ref:`field_type <capi-tuple_field_type>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:254
msgid "Compare a tuple with a key using key definition"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:257
msgid "key with MessagePack array header"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:260
msgid "0  if ``key_fields(tuple)`` == ``parts(key)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:261
msgid "<0 if ``key_fields(tuple)`` < ``parts(key)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:262
msgid ">0 if ``key_fields(tuple)`` > ``parts(key)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:268
msgid "Tuple iterator"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:272
msgid "Allocate and initialize a new tuple iterator. The tuple iterator allows iterating over fields at the root level of a MsgPack array."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:277
msgid "box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind the iterator to the first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:300
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:306
msgid "Return zero-based next position in iterator. That is, this function returnы the field id of the field that will be returned by the next call to :ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is zero after initialization or rewind and :ref:`box_tuple_field_count()<c_api-tuple-box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:313
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:320
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:335
#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:356
msgid "a tuple iterator"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:314
msgid "position"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:318
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:322
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:326
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:328
msgid "The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until the next call to ``box_tuple_*`` API. The requested ``field_no`` is returned by the next call to ``box_tuple_next(it)``."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:336
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:339
msgid "After:"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:341
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:342
msgid "``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value is NULL."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:349
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:351
msgid "The result is a pointer to raw MessagePack data which can be decoded with mp_decode functions, for an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until next call to ``box_tuple_*`` API."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:357
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:358
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:360
msgid "Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is zero-based ID of returned field."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/tuple.rst:363
msgid "After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value is NULL."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:37
msgid "Module `txn`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:41
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:47
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:49
msgid "A transaction is attached to caller fiber, therefore one fiber can have only one active transaction. See also :ref:`box.begin()<box-begin>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:53
msgid "-1 on error. Perhaps a transaction has already been started."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:59
msgid "Commit the current transaction. See also :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:62
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:66
msgid "Roll back the current transaction. See also :ref:`box.rollback() <box-rollback>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:70
msgid "Return a descriptor of a savepoint."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:74
msgid "Roll back the current transaction as far as the specified savepoint."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:78
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/txn.rst:80
msgid "The memory is automatically deallocated when the transaction is committed or rolled back."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:37
msgid "Module `lua/utils`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:43
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:45
msgid "CTypeID must be used from FFI at least once. Allocated memory returned uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:48
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:61
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:76
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:83
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:96
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:108
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:115
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:150
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:162
msgid "Lua State"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:49
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:51
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:65
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:53
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:59
msgid "Check whether the function argument ``idx`` is a cdata."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:62
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:77
msgid "stack index"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:63
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:67
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:71
msgid "Set finalizer function on a cdata object."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:73
msgid "Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on the top of the stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:81
msgid "Return CTypeID (FFI) of given СDATA type."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:84
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:87
msgid "CTypeID"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:89
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:94
msgid "Declare symbols for FFI."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:97
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:100
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:102
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:106
msgid "Push uint64_t onto the stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:109
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:116
msgid "value to push"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:113
msgid "Push int64_t onto the stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:120
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:134
msgid "Check whether the argument idx is a uint64 or a convertable string and returns this number."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:0
msgid "throws"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:123
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:130
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:127
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:141
msgid "Check whether the argument idx is a int64 or a convertable string and returns this number."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:137
#: ../doc/2.2/dev_guide/reference_capi/utils.rst:144
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:148
msgid "Push a tuple onto the stack."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:152
msgid "error on OOM"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:154
msgid "See also: :ref:`luaT_istuple <c_api-utils-luaT_istuple>`"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:160
msgid "Check whether ``idx`` is a tuple."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:163
msgid "the stack index"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:165
msgid "non-NULL if ``idx`` is a tuple"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:166
msgid "NULL if ``idx`` is not a tuple"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:170
msgid "Re-throw the last Tarantool error as a Lua object."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:172
msgid "See also: `lua_error() <https://www.lua.org/manual/5.1/manual.html#lua_error>`_,"
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:173
msgid ":ref:`box_error_last() <c_api-error-box_error_last>`."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:177
msgid "Similar to `lua_cpcall() <https://www.lua.org/manual/5.1/manual.html#lua_cpcall>`_, but with the proper support of Tarantool errors."
msgstr ""

#: ../doc/2.2/dev_guide/reference_capi/utils.rst:182
msgid "Get the global Lua state used by Tarantool."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:39
msgid "Release management"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:45
msgid "Release policy"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:47
msgid "A Tarantool release is identified by three digits, for example, 1.7.7. We use these digits according to their definitions provided at http://semver.org:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:50
msgid "The first digit stands for MAJOR release. A **major** release may contain *incompatible changes*."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:52
msgid "The second digit stands for MINOR release, it does not contain incompatible changes, and is used for introducing backward-compatible *features*."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:54
msgid "The third digit is for PATCH releases that contain only backward-compatible *bug fixes*."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:57
msgid "In MINOR digit, we reflect how stable a release is:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:59
msgid "0 meaning alpha,"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:60
msgid "1 meaning beta,"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:61
msgid "anything between 1 and 10 meaning stable, and"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:62
msgid "10 meaning LTS."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:64
msgid "So, each MAJOR release series goes through a development-maturity life cycle of MINOR releases, as follows:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:67
msgid "**Alpha**. Once in every few months we release a few alpha versions, e.g. 2.0.1, 2.0.2."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:70
msgid "Alpha versions may contain incompatible changes, crashes and other bugs."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:72
msgid "**Beta**. Once major changes necessary to introduce new flagship features are ready, we release a few beta versions, e.g. 2.1.3, 2.1.4."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:75
msgid "Beta versions may contain crashes, but do not have incompatible changes, so can be used to develop new applications."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:78
msgid "**Stable**. Finally, after we see our beta versions run successfully in production, usually in a few more months, during which we fix all incoming bugs and add some minor features, we declare this MAJOR release series stable."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:83
msgid "Like Ubuntu, we distinguish two kinds of stable releases:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:85
msgid "**LTS (Long Term Support)** releases that are supported for 3 years (community) and up to 5 years (paying customers). **LTS** release is identified by MINOR version 10."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:88
msgid "**Standard stable releases** are only supported a few months after the next stable is out."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:91
msgid "\"Support\" means that we continue fixing bugs in a release."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:93
msgid "We add commits simultaneously to three MAJOR releases:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:95
msgid "**LTS** is a stable release which does not receive new features, and only gets backward compatible fixes. Hence, following the rules of semver, LTS release never has its MAJOR or MINOR version increased, and only gets PATCH level releases."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:100
msgid "**STABLE** is our current stable release, which may receive new features. When the next STABLE version is published, MINOR version is incremented. Between MINOR releases, we may have intermediate PATCH level releases as well, which will contain only bug fixes. We maintain PATCH level releases for two STABLE releases, the current and the previous one, to preserve support continuity."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:107
msgid "**NEXT** is our next MAJOR release, and it follows the maturity cycle described in the beginning. While NEXT release is in alpha state, its MINOR is frozen at 0 and is only increased when the release reaches BETA status. Once the NEXT release becomes STABLE, we switch the vehicle for delivery of minor features, designating the previous stable release as LTS, and releasing it with MINOR set to 10."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:114
msgid "To sum up, once a quarter we release:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:116
msgid "the next LTS release, e.g. 2.10.6, 2.10.7 or 2.10.8"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:117
msgid "the next STABLE release, e.g. 3.6, 3.7 or 3.8"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:118
msgid "(optionally) an alpha or beta version of the NEXT release, e.g. 4.0.1, 4.0.2 or 4.0.3"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:121
msgid "In all supported releases, we also release a PATCH release as soon as we find and fix an outstanding CVE/vulnerability."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:124
msgid "We also publish nightly builds, and use the fourth slot in the version identifier to designate the nightly build number."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:127
msgid "Example version identifier:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:129
msgid "2.0.3 - third alpha of 2.x release"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:130
msgid "2.1.3 - a beta of 2.x release"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:131
msgid "2.2 - a stable version of 2.x series, but not an LTS yet"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:132
msgid "2.10 - an LTS release"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:138
msgid "How to make a minor release"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:140
msgid "$ git tag -a 2.4 -m \"Next minor in 2.x series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:146
msgid "A tag which is made on a git branch can be taken along with a merge, or left on the branch. The technique to \"keep the tag on the branch it was originally set on\" is to use ``--no-fast-forward`` when merging this branch."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:150
msgid "With ``--no-ff``, a merge changeset is created to represent the received changes, and only that merge changeset ends up in the destination branch. This technique can be useful when there are two active lines of development, e.g. \"stable\" and \"next\", and it's necessary to be able to tag both lines independently."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:156
msgid "To make sure that a tag doesn't end up in the destination branch, it is necessary to have the commit to which the tag is attached, \"stay on the original branch\". That's exactly what a merge with disabled \"fast-forward\" does -- creates a \"merge\" commit and adds it to both branches."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:161
msgid "Here's what it may look like:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:163
msgid "kostja@shmita:~/work/tarantool$ git checkout master\n"
"Already on 'master'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.4 -m \"Next development\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git checkout master-stable\n"
"Switched to branch 'master-stable'\n"
"kostja@shmita:~/work/tarantool$ git tag -a 2.3 -m \"Next stable\"\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.3\n"
"kostja@shmita:~/work/tarantool$ git checkout master\n"
"Switched to branch 'master'\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4\n"
"kostja@shmita:~/work/tarantool$ git merge --no-ff master-stable\n"
"Auto-merging CMakeLists.txt\n"
"Merge made by recursive.\n"
" CMakeLists.txt |    1 +\n"
" 1 files changed, 1 insertions(+), 0 deletions(-)\n"
"kostja@shmita:~/work/tarantool$ git describe\n"
"2.4.0-0-g0a98576"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:187
msgid "Also, don't forget this:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:189
msgid "Update all issues. Upload the ChangeLog based on ``git log`` output."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:191
msgid "The ChangeLog must only include items which are mentioned as issues on GitHub. If anything significant is there, which is not mentioned, something went wrong in release planning and the release should be held up until this is cleared."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:196
msgid "Click 'Release milestone'. Create a milestone for the next minor release. Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:201
msgid "How to release a Docker container"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:203
msgid "To bump a new version of a Docker container:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:205
msgid "On the ``master`` branch of `tarantool/docker <https://github.com/tarantool/docker>`_ repository, find the Dockerfile that corresponds to the commit's **major** version (e.g. https://github.com/tarantool/docker/blob/master/2.x/Dockerfile for Tarantool version 2.4) and specify the required commit in ``TARANTOOL_VERSION``, for example ``TARANTOOL_VERSION=2.4.0-11-gcd17b77f9``."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:213
msgid "Commit the Dockerfile back to ``master`` branch."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:215
msgid "In the same repository, create a branch named after the commit's ``<major>.<minor>`` versions, e.g. branch ``2.4`` for commit 2.4.0-11-gcd17b77f9."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:219
msgid "In Tarantool container build settings at ``hub.docker.com`` (https://hub.docker.com/r/tarantool/tarantool/~/settings/automated-builds/), add a new line:"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:223
msgid "Branch: x.y, /x, x.y"
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:227
msgid "where ``x`` and ``y`` correspond to the commit's major and minor versions."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:229
msgid "Click **Save changes**."
msgstr ""

#: ../doc/2.2/dev_guide/release_management.rst:231
msgid "Shortly after, a new Docker container will be built."
msgstr ""

#: ../doc/2.2/index.rst:40
msgid "Tarantool - Documentation"
msgstr ""

#: ../doc/2.2/index.rst:47
msgid "|nbspc|"
msgstr ""

#: ../doc/2.2/index.rst:119
msgid "Tarantool 2.2 manual  This manual embraces all aspects of using Tarantool: from introductory information and exercises for beginners -- to advanced instructions and detailed references for power users and contributors.  Документация находится в процессе перевода и может отставать от английской версии.  <div class=\"getting-started-button-container\">     <a href=\"book/getting_started/\">         <button class=\"getting-started-button btn\">             Руководство для начинающих         </button>     </a> </div>  <div class=\"getting-started-button-container\">     <a href=\"book/getting_started/\">         <button class=\"getting-started-button btn\">             Getting started         </button>     </a> </div>      <div class=\"badge-icon\"></div>  Other formats:  Single-page HTML  PDF  /Users/e.shebunyaeva/work/tarantool-doc/doc/2.2/index.rst:106: (WARNING/2) Bullet list ends without a blank line; unexpected unindent.  See also:  Documentation archive  Articles  /Users/e.shebunyaeva/work/tarantool-doc/doc/2.2/index.rst:109: (WARNING/2) Bullet list ends without a blank line; unexpected unindent.  Support:  Форум в Google  Чат в Telegram  Support:  Google forum  Telegram chat"
msgstr ""

#: ../doc/2.2/index.rst:56
msgid "Tarantool 2.2 manual"
msgstr ""

#: ../doc/2.2/index.rst:60
msgid "This manual embraces all aspects of using Tarantool: from introductory information and exercises for beginners -- to advanced instructions and detailed references for power users and contributors."
msgstr ""

#: ../doc/2.2/index.rst:103
msgid "**Other formats:**"
msgstr ""

#: ../doc/2.2/index.rst:104
msgid "`Single-page HTML <singlehtml.html>`_"
msgstr ""

#: ../doc/2.2/index.rst:105
msgid "`PDF <Tarantool.pdf>`_"
msgstr ""

#: ../doc/2.2/index.rst:106
msgid "**See also:**"
msgstr ""

#: ../doc/2.2/index.rst:107
msgid "`Documentation archive`_"
msgstr ""

#: ../doc/2.2/index.rst:108
msgid "`Articles`_"
msgstr ""

#: ../doc/2.2/index.rst:116
msgid "**Support:**"
msgstr ""

#: ../doc/2.2/index.rst:117
msgid "`Google forum`_"
msgstr ""

#: ../doc/2.2/index.rst:118
msgid "`Telegram chat`_"
msgstr ""

#: ../doc/2.2/intro.rst:41
msgid "An application server together with a database manager"
msgstr ""

#: ../doc/2.2/intro.rst:43
msgid "Tarantool is a Lua application server integrated with a database management system. It has a \"fiber\" model which means that many Tarantool applications can run simultaneously on a single thread, while each instance of the Tarantool server itself can run multiple threads for input-output and background maintenance. It incorporates the LuaJIT -- \"Just In Time\" -- Lua compiler, Lua libraries for most common applications, and the Tarantool Database Server which is an established NoSQL DBMS. Thus Tarantool serves all the purposes that have made node.js and Twisted popular, plus it supports data persistence."
msgstr ""

#: ../doc/2.2/intro.rst:51
msgid "The code is free. The open-source license is `BSD license`_. The supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""

#: ../doc/2.2/intro.rst:54
msgid "Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet company in Russia, with 30 million users, 25 million emails per day, and a web site whose Alexa global rank is in the `top 40`_ worldwide. Tarantool services Mail.Ru's hottest data, such as the session data of online users, the properties of online applications, the caches of the underlying data, the distribution and sharding algorithms, and much more. Outside Mail.Ru the software is used by a growing number of projects in online gaming, digital marketing, and social media industries. Although Mail.Ru is the sponsor for product development, the roadmap and the bugs database and the development process are fully open. The software incorporates patches from dozens of community contributors. The Tarantool community writes and maintains most of the drivers for programming languages.  The greater Lua community has hundreds of useful packages most of which can become Tarantool extensions."
msgstr ""

#: ../doc/2.2/intro.rst:68
msgid "Users can create, modify and drop **Lua functions** at runtime. Or they can define **Lua programs** that are loaded during startup for triggers, background tasks, and interacting with networked peers. Unlike popular application development frameworks based on a \"reactor\" pattern, networking in server-side Lua is sequential, yet very efficient, as it is built on top of the **cooperative multitasking** environment that Tarantool itself uses."
msgstr ""

#: ../doc/2.2/intro.rst:76
msgid "One of the built-in Lua packages provides an API for the Database Management System. Thus some developers see Tarantool as a DBMS with a popular stored procedure language, while others see it as a Lua interpreter, while still others see it as a replacement for many components of multi-tier Web applications. Performance can be a few hundred thousand transactions per second on a laptop, scalable upwards or outwards to server farms."
msgstr ""

#: ../doc/2.2/intro.rst:86
msgid "Database features"
msgstr ""

#: ../doc/2.2/intro.rst:88
msgid "Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a strong distinguishing feature."
msgstr ""

#: ../doc/2.2/intro.rst:91
msgid "The database API allows for permanently storing Lua objects, managing object collections, creating or dropping secondary keys, making changes atomically, configuring and monitoring replication, performing controlled fail-over, and executing Lua code triggered by database events. Remote database instances are accessible transparently via a remote-procedure-invocation API."
msgstr ""

#: ../doc/2.2/intro.rst:99
msgid "Tarantool's DBMS server uses the **storage engine** concept, where different sets of algorithms and data structures can be used for different situations. Two storage engines are built-in: an in-memory engine which has all the data and indexes in RAM, and a two-level B-tree engine for data sets whose size is 10 to 1000 times the amount of available RAM. All storage engines in Tarantool support transactions and replication by using a common **write ahead log** (WAL). This ensures consistency and crash safety of the persistent state. Changes are not considered complete until the WAL is written. The logging subsystem supports group commit."
msgstr ""

#: ../doc/2.2/intro.rst:110
msgid "**Tarantool's in-memory storage engine** (memtx) keeps all the data in random-access memory, and therefore has very low read latency. It also keeps persistent copies of the data in non-volatile storage, such as disk, when users request \"snapshots\". If an instance of the server stops and the random-access memory is lost, then restarts, it reads the latest snapshot and then replays the transactions that are in the log -- therefore no data is lost."
msgstr ""

#: ../doc/2.2/intro.rst:119
msgid "**Tarantool's in-memory engine is lock-free** in typical situations. Instead of the operating system's concurrency primitives, such as mutexes, Tarantool uses cooperative multitasking to handle thousands of connections simultaneously. There is a fixed number of independent execution threads. The threads do not share state. Instead they exchange data using low-overhead message queues. While this approach limits the number of cores that the instance will use, it removes competition for the memory bus and ensures peak scalability of memory access and network throughput. CPU utilization of a typical highly-loaded Tarantool instance is under 10%. Searches are possible via **secondary index keys** as well as primary keys."
msgstr ""

#: ../doc/2.2/intro.rst:129
msgid "**Tarantool's disk-based storage engine** is a fusion of ideas from modern filesystems, log-structured merge trees and classical B-trees. All data is organized into **ranges**. Each range is represented by a file on disk. Range size is a configuration option and normally is around 64MB. Each range is a collection of pages, serving different purposes. Pages in a fully merged range contain non-overlapping ranges of keys. A range can be partially merged if there were a lot of changes in its key range recently. In that case some pages represent new keys and values in the range. The disk-based storage engine is append only: new data never overwrites old data. The disk-based storage engine is named *vinyl*."
msgstr ""

#: ../doc/2.2/intro.rst:140
msgid "Tarantool supports **multi-part index keys**. The possible index types are HASH, TREE, BITSET, and RTREE."
msgstr ""

#: ../doc/2.2/intro.rst:143
msgid "Tarantool supports **asynchronous replication**, locally or to remote hosts. The replication architecture can be **master-master**, that is, many nodes may both handle the loads and receive what others have handled, for the same data sets."
msgstr ""

#: ../doc/2.2/intro.rst:148
msgid "Tarantool supports **basic SQL structures** and **persistence for SQL operations** (with acceptable limitations). All tables and triggers created in SQL are available after server restart."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:39
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1032
msgid "Configuration reference"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:41
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an :ref:`initialization file <index-init_label>`."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:44
msgid "Tarantool is started by entering either of the following command:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:49
msgid "$ **tarantool**\n"
"\n"
"$ **tarantool** *options*\n"
"\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:57
msgid "Command options"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:61
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:67
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:69
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:76
#: ../doc/2.2/reference/reference_sql/sql.rst:2300
msgid "In this example:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:78
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:81
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:89
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:94
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:104
msgid "URI"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:106
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:125
msgid "URI fragment"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:127
msgid "port"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:127
msgid "3301"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:129
msgid "host:port"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:129
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:131
msgid "username:password@host:port"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:131
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:134
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:138
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:144
msgid "Initialization file"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:146
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:154
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    memtx_memory        = 100000,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:165
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:169
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:183
msgid "If you wish to start an interactive session on the same terminal after initialization is complete, you can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:199
msgid "Configuration parameters"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:201
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:203
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:205
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:210
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:215
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:218
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, for logging, and for feedback."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:224
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1038
msgid "Basic parameters"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:4
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:5
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:6
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:7
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:8
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:9
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:10
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:11
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:12
msgid ":ref:`worker_pool_threads <cfg_basic-worker_pool_threads>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:13
msgid ":ref:`strip_core <cfg_basic-strip_core>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:19
msgid "Run the server as a background task. The :ref:`log <cfg_logging-log>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:23
#: ../doc/2.2/reference/configuration/cfg_basic.rst:112
#: ../doc/2.2/reference/configuration/cfg_basic.rst:233
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:22
#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/2.2/reference/configuration/cfg_replication.rst:124
#: ../doc/2.2/reference/configuration/cfg_logging.rst:134
#: ../doc/2.2/reference/configuration/cfg_logging.rst:291
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:25
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:55
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:66
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1121
msgid "Type: boolean"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:24
#: ../doc/2.2/reference/configuration/cfg_basic.rst:113
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:49
#: ../doc/2.2/reference/configuration/cfg_replication.rst:125
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:26
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1057
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1068
msgid "Default: false"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:25
#: ../doc/2.2/reference/configuration/cfg_basic.rst:87
#: ../doc/2.2/reference/configuration/cfg_basic.rst:98
#: ../doc/2.2/reference/configuration/cfg_basic.rst:142
#: ../doc/2.2/reference/configuration/cfg_basic.rst:169
#: ../doc/2.2/reference/configuration/cfg_basic.rst:183
#: ../doc/2.2/reference/configuration/cfg_basic.rst:208
#: ../doc/2.2/reference/configuration/cfg_basic.rst:235
#: ../doc/2.2/reference/configuration/cfg_storage.rst:43
#: ../doc/2.2/reference/configuration/cfg_storage.rst:55
#: ../doc/2.2/reference/configuration/cfg_storage.rst:69
#: ../doc/2.2/reference/configuration/cfg_storage.rst:93
#: ../doc/2.2/reference/configuration/cfg_storage.rst:115
#: ../doc/2.2/reference/configuration/cfg_storage.rst:139
#: ../doc/2.2/reference/configuration/cfg_storage.rst:152
#: ../doc/2.2/reference/configuration/cfg_storage.rst:164
#: ../doc/2.2/reference/configuration/cfg_storage.rst:175
#: ../doc/2.2/reference/configuration/cfg_storage.rst:186
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:24
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:52
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:98
#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:50
#: ../doc/2.2/reference/configuration/cfg_replication.rst:216
#: ../doc/2.2/reference/configuration/cfg_replication.rst:238
#: ../doc/2.2/reference/configuration/cfg_logging.rst:112
#: ../doc/2.2/reference/configuration/cfg_logging.rst:136
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:27
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:57
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:95
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:110
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1079
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1103
msgid "Dynamic: no"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:31
msgid "Add the given string to the server's process title (what’s shown in the COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:35
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:38
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:43
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:46
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:51
#: ../doc/2.2/reference/configuration/cfg_basic.rst:85
#: ../doc/2.2/reference/configuration/cfg_basic.rst:96
#: ../doc/2.2/reference/configuration/cfg_basic.rst:140
#: ../doc/2.2/reference/configuration/cfg_basic.rst:167
#: ../doc/2.2/reference/configuration/cfg_basic.rst:181
#: ../doc/2.2/reference/configuration/cfg_basic.rst:206
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:84
#: ../doc/2.2/reference/configuration/cfg_replication.rst:44
#: ../doc/2.2/reference/configuration/cfg_replication.rst:214
#: ../doc/2.2/reference/configuration/cfg_replication.rst:236
#: ../doc/2.2/reference/configuration/cfg_logging.rst:110
#: ../doc/2.2/reference/configuration/cfg_logging.rst:189
#: ../doc/2.2/reference/configuration/cfg_logging.rst:302
msgid "Type: string"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:52
#: ../doc/2.2/reference/configuration/cfg_basic.rst:74
#: ../doc/2.2/reference/configuration/cfg_basic.rst:97
#: ../doc/2.2/reference/configuration/cfg_basic.rst:168
#: ../doc/2.2/reference/configuration/cfg_basic.rst:207
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../doc/2.2/reference/configuration/cfg_replication.rst:45
#: ../doc/2.2/reference/configuration/cfg_replication.rst:104
#: ../doc/2.2/reference/configuration/cfg_replication.rst:215
#: ../doc/2.2/reference/configuration/cfg_replication.rst:237
#: ../doc/2.2/reference/configuration/cfg_networking.rst:15
#: ../doc/2.2/reference/configuration/cfg_logging.rst:111
msgid "Default: null"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:53
#: ../doc/2.2/reference/configuration/cfg_basic.rst:75
#: ../doc/2.2/reference/configuration/cfg_basic.rst:114
#: ../doc/2.2/reference/configuration/cfg_basic.rst:159
#: ../doc/2.2/reference/configuration/cfg_basic.rst:222
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:100
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:112
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:68
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1058
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1069
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1113
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1123
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1135
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1150
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1171
msgid "Dynamic: yes"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:59
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <admin-security>`. Connections made with :samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" connections."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:66
msgid "A typical value is 3301."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:70
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:73
msgid "Type: integer or string"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:81
msgid "A directory where memtx stores snapshot (.snap) files. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:86
#: ../doc/2.2/reference/configuration/cfg_basic.rst:141
#: ../doc/2.2/reference/configuration/cfg_basic.rst:182
msgid "Default: \".\""
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:93
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:104
msgid "Say ``box.cfg{read_only=true...}`` to put the server instance in read-only mode. After this, any requests that try to change persistent data will fail with error :errcode:`ER_READONLY`. Read-only mode should be used for master-replica :ref:`replication <replication>`. Read-only mode does not affect data-change requests for spaces defined as :ref:`temporary <box_schema-space_create>`. Although read-only mode prevents the server from writing to the :ref:`WAL <internals-wal>`, it does not prevent writing diagnostics with the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:116
msgid "Setting ``read_only == true`` affects spaces differently depending on the options that were used during :ref:`box.schema.space.create <box_schema-space_create>`, as summarized by this chart:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:123
msgid "Can be created?"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:123
msgid "Can be written to?"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:123
msgid "Is replicated?"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:123
msgid "Is persistent?"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:125
msgid "(default)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:125
#: ../doc/2.2/reference/configuration/cfg_basic.rst:125
#: ../doc/2.2/reference/configuration/cfg_basic.rst:127
#: ../doc/2.2/reference/configuration/cfg_basic.rst:127
#: ../doc/2.2/reference/configuration/cfg_basic.rst:127
#: ../doc/2.2/reference/configuration/cfg_basic.rst:129
#: ../doc/2.2/reference/configuration/cfg_basic.rst:129
msgid "no"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:125
#: ../doc/2.2/reference/configuration/cfg_basic.rst:125
#: ../doc/2.2/reference/configuration/cfg_basic.rst:127
#: ../doc/2.2/reference/configuration/cfg_basic.rst:129
#: ../doc/2.2/reference/configuration/cfg_basic.rst:129
msgid "yes"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:136
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:148
msgid "The vinyl storage engine has a scheduler which does compaction. When vinyl is low on available memory, the compaction scheduler may be unable to keep up with incoming update requests. In that situation, queries may time out after ``vinyl_timeout`` seconds. This should rarely occur, since normally vinyl would throttle inserts when it is running low on compaction bandwidth. Compaction can also be ordered manually with :ref:`index_object:compact() <box_index-compact>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:157
#: ../doc/2.2/reference/configuration/cfg_storage.rst:28
#: ../doc/2.2/reference/configuration/cfg_storage.rst:67
#: ../doc/2.2/reference/configuration/cfg_storage.rst:162
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:68
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:96
#: ../doc/2.2/reference/configuration/cfg_replication.rst:75
#: ../doc/2.2/reference/configuration/cfg_replication.rst:148
#: ../doc/2.2/reference/configuration/cfg_replication.rst:165
#: ../doc/2.2/reference/configuration/cfg_networking.rst:14
#: ../doc/2.2/reference/configuration/cfg_logging.rst:146
#: ../doc/2.2/reference/configuration/cfg_logging.rst:312
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:93
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:108
msgid "Type: float"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:158
msgid "Default: 60"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:165
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:175
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:189
msgid "A directory where database working files will be stored. The server instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to ``work_dir``, for example:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:195
msgid "box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:203
msgid "will put xlog files in ``/home/user/A/B``, snapshot files in ``/home/user/A/C``, and all other files or subdirectories in ``/home/user/A``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:215
msgid "The maximum number of threads to use during execution of certain internal processes (currently :ref:`socket.getaddrinfo() <socket-getaddrinfo>` and :ref:`coio_call() <c_api-coio-coio_call>`)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:220
#: ../doc/2.2/reference/configuration/cfg_storage.rst:41
#: ../doc/2.2/reference/configuration/cfg_storage.rst:53
#: ../doc/2.2/reference/configuration/cfg_storage.rst:78
#: ../doc/2.2/reference/configuration/cfg_storage.rst:91
#: ../doc/2.2/reference/configuration/cfg_storage.rst:101
#: ../doc/2.2/reference/configuration/cfg_storage.rst:113
#: ../doc/2.2/reference/configuration/cfg_storage.rst:137
#: ../doc/2.2/reference/configuration/cfg_storage.rst:150
#: ../doc/2.2/reference/configuration/cfg_storage.rst:173
#: ../doc/2.2/reference/configuration/cfg_storage.rst:184
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:98
#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:110
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:35
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:50
#: ../doc/2.2/reference/configuration/cfg_replication.rst:58
#: ../doc/2.2/reference/configuration/cfg_replication.rst:103
#: ../doc/2.2/reference/configuration/cfg_networking.rst:50
#: ../doc/2.2/reference/configuration/cfg_networking.rst:67
#: ../doc/2.2/reference/configuration/cfg_logging.rst:28
msgid "Type: integer"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:221
#: ../doc/2.2/reference/configuration/cfg_replication.rst:76
msgid "Default: 4"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:228
msgid "Whether coredump files should include memory allocated for tuples. (This can be large if Tarantool runs under heavy load.) Setting to ``true`` means \"do not include\". In an older version of Tarantool the default value of this parameter was ``false``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_basic.rst:234
#: ../doc/2.2/reference/configuration/cfg_logging.rst:292
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:56
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:67
msgid "Default: true"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:230
msgid "Configuring the storage"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:1
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:2
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:3
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:4
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:5
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:6
msgid ":ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:7
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:8
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:9
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:10
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:11
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:12
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:13
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:19
msgid "How much memory Tarantool allocates to actually store tuples, in bytes. When the limit is reached, :ref:`INSERT <box_space-insert>` or :ref:`UPDATE <box_space-insert>` requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. The server does not go beyond the ``memtx_memory`` limit to allocate tuples, but there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the ``memtx_memory`` limit."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:29
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:30
#: ../doc/2.2/reference/configuration/cfg_storage.rst:103
msgid "Dynamic: **yes** but it cannot be decreased"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:36
msgid "Size of the largest allocation unit, in bytes, for the memtx storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`vinyl_max_tuple_size <cfg_storage-vinyl_max_tuple_size>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:42
#: ../doc/2.2/reference/configuration/cfg_storage.rst:92
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:49
msgid "Size of the smallest allocation unit, in bytes. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:54
msgid "Default: 16"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:61
msgid "Bloom filter false positive rate -- the suitable probability of the `bloom filter <https://en.wikipedia.org/wiki/Bloom_filter>`_ to give a wrong result. The ``vinyl_bloom_fpr`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:68
msgid "Default = 0.05"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:75
msgid "The cache size for the vinyl storage engine, in bytes. The cache can be resized dynamically."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:79
#: ../doc/2.2/reference/configuration/cfg_storage.rst:102
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:80
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:70
#: ../doc/2.2/reference/configuration/cfg_replication.rst:46
#: ../doc/2.2/reference/configuration/cfg_replication.rst:60
#: ../doc/2.2/reference/configuration/cfg_replication.rst:77
#: ../doc/2.2/reference/configuration/cfg_replication.rst:105
#: ../doc/2.2/reference/configuration/cfg_replication.rst:126
#: ../doc/2.2/reference/configuration/cfg_replication.rst:150
#: ../doc/2.2/reference/configuration/cfg_replication.rst:167
#: ../doc/2.2/reference/configuration/cfg_networking.rst:16
#: ../doc/2.2/reference/configuration/cfg_networking.rst:52
#: ../doc/2.2/reference/configuration/cfg_networking.rst:69
#: ../doc/2.2/reference/configuration/cfg_logging.rst:30
#: ../doc/2.2/reference/configuration/cfg_logging.rst:148
#: ../doc/2.2/reference/configuration/cfg_logging.rst:191
#: ../doc/2.2/reference/configuration/cfg_logging.rst:293
#: ../doc/2.2/reference/configuration/cfg_logging.rst:304
#: ../doc/2.2/reference/configuration/cfg_logging.rst:314
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:86
msgid "Size of the largest allocation unit, in bytes, for the vinyl storage engine. It can be increased if it is necessary to store large tuples. See also: :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:99
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:109
msgid "Page size, in bytes. Page is a read/write unit for vinyl disk operations. The ``vinyl_page_size`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:114
msgid "Default = 8 * 1024 = 8192"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:121
msgid "The default maximum range size for a vinyl index, in bytes. The maximum range size affects the decision whether to :ref:`split <engines-vinyl_split>` a range."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:125
msgid "If ``vinyl_range_size`` is not nil and not 0, then it is used as the default value for the ``range_size`` option in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:130
msgid "If ``vinyl_range_size`` is nil or 0, and ``range_size`` is not specified when the index is created, then Tarantool sets a value later depending on performance considerations. To see the actual value, use :ref:`index_object:stat().range_size <box_index-stat>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:135
msgid "In Tarantool versions prior to 1.10.2, ``vinyl_range_size`` default value was 1073741824."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:138
msgid "Default = nil"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:145
msgid "The maximal number of runs per level in vinyl LSM tree. If this number is exceeded, a new level is created. The ``vinyl_run_count_per_level`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:151
#: ../doc/2.2/reference/configuration/cfg_storage.rst:185
msgid "Default = 2"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:158
msgid "Ratio between the sizes of different levels in the LSM tree. The ``vinyl_run_size_ratio`` setting is a default value for one of the options in the :ref:`Options for space_object:create_index() <box_space-create_index>` chart."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:163
msgid "Default = 3.5"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:170
msgid "The maximum number of read threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:174
msgid "Default = 1"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_storage.rst:181
msgid "The maximum number of write threads that vinyl can use for some concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:238
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:3
msgid ":ref:`checkpoint_wal_threshold <cfg_checkpoint_daemon-checkpoint_wal_threshold>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:5
msgid "The checkpoint daemon is a fiber which is constantly running. At intervals, it may make new :ref:`snapshot (.snap) files <index-box_persistence>` and then may delete old snapshot files."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:9
msgid "The :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before deletions occur."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:16
msgid "**Tarantool garbage collector**"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:18
msgid "The checkpoint daemon may activate the Tarantool garbage collector which deletes old files. This garbage collector is distinct from the `Lua garbage collector <https://www.lua.org/manual/5.1/manual.html#2.10>`_ which is for Lua objects, and distinct from a Tarantool garbage collector which specializes in :ref:`handling shard buckets <vshard-gc>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:25
msgid "If the checkpoint daemon deletes an old snapshot file, then the Tarantool garbage collector will also delete any :ref:`write-ahead log (.xlog) <internals-wal>` files which are older than the snapshot file and which contain information that is present in the snapshot file. It will also delete obsolete vinyl ``.run`` files."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:31
msgid "The checkpoint daemon and the Tarantool garbage collector will not delete a file if:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:33
msgid "a **backup** is ongoing and the file has not been backed up (see :ref:`\"Hot backup\" <admin-backups-hot_backup_vinyl_memtx>`), or"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:36
msgid "**replication** is ongoing and the file has not been relayed to a replica (see :ref:`\"Replication architecture\" <replication-architecture>`),"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:39
msgid "a replica is connecting, or"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:41
msgid "a replica has fallen behind. The progress of each replica is tracked; if a replica's position is far from being up to date, then the server stops to give it a chance to catch up. If an administrator concludes that a replica is permanently down, then the correct procedure is to restart the server, or (preferably) :ref:`remove the replica from the cluster <replication-remove_instances>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:53
msgid "The interval between actions by the checkpoint daemon, in seconds. If ``checkpoint_interval`` is set to a value greater than zero, and there is activity which causes change to a database, then the checkpoint daemon will call :ref:`box.snapshot <box-snapshot>` every ``checkpoint_interval`` seconds, creating a new snapshot file each time. If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is disabled."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:62
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:66
msgid "will cause the checkpoint daemon to create a new database snapshot once per minute, if there is activity."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:70
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:77
msgid "The maximum number of snapshots that may exist on the :ref:`memtx_dir <cfg_basic-memtx_dir>` directory before the checkpoint daemon will delete old snapshots. If ``checkpoint_count`` equals zero, then the checkpoint daemon does not delete old snapshots. For example:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:83
msgid "box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:90
msgid "will cause the checkpoint daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will delete the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:94
msgid "Remember that, as noted earlier, snapshots will not be deleted if replication is ongoing and the file has not been relayed to a replica. Therefore ``checkpoint_count`` has no effect unless all replicas are alive."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:99
#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:97
msgid "Default: 2"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:106
msgid "The threshold for the total size in bytes of all WAL files created since the last checkpoint. Once the configured threshold is exceeded, the WAL thread notifies the checkpoint daemon that it must make a new checkpoint and delete old WAL files."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:111
msgid "Default: 10^18 (a large number so in effect there is no limit by default)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_snapshot_daemon.rst:114
msgid "This parameter was added in version 2.1. It enables administrators to handle a problem that could occur with calculating how much disk space to allocate for a partition containing WAL files. For example, suppose :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>` = 2 and :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>` = 5 and the average amount that Tarantool writes between each checkpoint interval = 1 GB. Then one could calculate that the necessary amount is (2*5*1) 10GB. But this calculation would be wrong if, instead of writing 1 GB during one checkpoint interval, Tarantool encounters an unusual spike and tries to write 11 GB, causing an operating-system ENOSPC (\"no space\") error. By setting checkpoint_wal_threshold to a lower value, say 9 GB, an administrator could prevent the error."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:244
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`wal_max_size <cfg_binary_logging_snapshots-wal_max_size>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If ``force_recovery`` equals true, Tarantool tries to continue if there is an error while reading a :ref:`snapshot file<index-box_persistence>` (at server instance start) or a :ref:`write-ahead log file<internals-wal>` (at server instance start or when applying an update at a replica): skips invalid records, reads as much data as possible and lets the process finish with a warning. Users can prevent the error from recurring by writing to the database and executing :ref:`box.snapshot() <box-snapshot>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:20
msgid "Otherwise, Tarantool aborts recovery if there is an error while reading."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:36
msgid "Default: 500000"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:43
msgid "The maximum number of bytes in a single write-ahead log file. When a request would cause an .xlog file to become larger than ``wal_max_size``, Tarantool creates another WAL file -- the same effect that happens when the :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` limit is reached."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Default: 268435456 (256 * 1024 * 1024)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:58
msgid "Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-memtx_dir>` locations and moving snapshots to a separate disk. The limit also affects what :ref:`box.stat.vinyl().regulator <box_introspection-box_stat_vinyl_regulator>` may show for the write rate of dumps to .run and .index files."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:76
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:78
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "``write``: :ref:`fibers <fiber-fibers>` wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:85
msgid "Default: \"write\""
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_binary_logging_snapshots.rst:92
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of :ref:`replication <replication>` or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:252
msgid "Hot standby"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:3
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:5
msgid "Hot standby is a feature which provides a simple form of failover without :ref:`replication <replication>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:8
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:12
msgid "To initiate the standby instance, start a second instance of the Tarantool server on the same computer with the same :ref:`box.cfg <box_introspection-box_cfg>` configuration settings -- including the same directories and same non-null URIs -- and with the additional configuration setting ``hot_standby = true``. Expect to see a notification ending with the words ``I> Entering hot standby mode``. This is fine. It means that the standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:22
msgid "The standby instance will initialize and will try to take a lock on :ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary instance has made a lock on ``wal_dir``. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in sync), and trying to take the lock. If the primary instance goes down for any reason, the lock will be released. In this case, the standby instance will succeed in taking the lock, will connect on the :ref:`listen <cfg_basic-listen>` address and will become the primary instance. Expect to see a notification ending with the words ``I> ready to accept requests``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:35
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:37
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:39
msgid "if :ref:`wal_dir_rescan_delay = a large number <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and FreeBSD); on these platforms, it is designed so that the loop repeats every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:43
msgid "if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it is designed to work with ``wal_mode = 'write'`` or ``wal_mode = 'fsync'``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_hot_standby.rst:45
msgid "for spaces created with :ref:`engine = 'vinyl' <box_schema-space_create>`; it is designed to work for spaces created with ``engine = 'memtx'``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:1
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:2
msgid ":ref:`replication_timeout <cfg_replication-replication_timeout>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:3
msgid ":ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:4
msgid ":ref:`replication_connect_quorum <cfg_replication-replication_connect_quorum>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:5
msgid ":ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:6
msgid ":ref:`replication_sync_lag <cfg_replication-replication_sync_lag>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:7
msgid ":ref:`replication_sync_timeout <cfg_replication-replication_sync_timeout>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:8
msgid ":ref:`replicaset_uuid <cfg_replication-replicaset_uuid>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:9
msgid ":ref:`instance_uuid <cfg_replication-instance_uuid>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:15
msgid "If ``replication`` is not an empty string, the instance is considered to be a Tarantool :ref:`replica <replication>`. The replica will try to connect to the master specified in ``replication`` with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:20
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:22
msgid "If there is more than one replication source in a replica set, specify an array of URIs, for example (replace 'uri' and 'uri2' in this example with valid URIs):"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:26
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:28
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the instance where ``box.cfg{}`` is being executed on -- then it is ignored. Thus it is possible to use the same ``replication`` specification on multiple server instances, as shown in :ref:`these examples <replication-bootstrap>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:34
msgid "The default user name is 'guest'."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:36
msgid "A read-only replica does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:39
msgid "The ``replication`` parameter is dynamic, that is, to enter master mode, simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:42
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:52
msgid "A replica sends heartbeat messages to the master every second, and the master is programmed to reconnect automatically if it doesn’t see heartbeat messages more often than ``replication_timeout`` seconds."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:56
msgid "See more in :ref:`Monitoring a replica set <replication-monitoring>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:59
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1134
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1149
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1200
msgid "Default: 1"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:66
msgid "The number of seconds that a replica will wait when trying to connect to a master in a cluster. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:70
msgid "This parameter is different from :ref:`replication_timeout <cfg_replication-replication_timeout>`, which is only used to automatically reconnect replication when it gets no heartbeats."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:83
msgid "By default a replica will try to connect to all the masters, or it will not start. (The default is recommended so that all replicas will receive the same replica set UUID.)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:87
msgid "However, by specifying ``replication_connect_quorum = N``, where N is a number greater than or equal to zero, users can state that the replica only needs to connect to N masters."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:91
msgid "This parameter has effect during bootstrap and during :ref:`configuration update <replication-configuration_update>`. Setting ``replication_connect_quorum = 0`` makes Tarantool require no immediate reconnect only in case of recovery. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:97
#: ../doc/2.2/reference/configuration/cfg_replication.rst:118
#: ../doc/2.2/reference/configuration/cfg_replication.rst:208
#: ../doc/2.2/reference/configuration/cfg_replication.rst:230
#: ../doc/2.2/reference/reference_lua/other.rst:197
#: ../doc/2.2/reference/reference_lua/swim.rst:163
#: ../doc/2.2/reference/reference_lua/swim.rst:246
#: ../doc/2.2/reference/reference_lua/swim.rst:259
#: ../doc/2.2/reference/reference_lua/swim.rst:357
#: ../doc/2.2/reference/reference_lua/swim.rst:538
#: ../doc/2.2/reference/reference_lua/swim.rst:570
#: ../doc/2.2/reference/reference_lua/swim.rst:732
#: ../doc/2.2/reference/reference_lua/swim.rst:757
#: ../doc/2.2/reference/reference_lua/swim.rst:934
#: ../doc/2.2/reference/reference_sql/sql.rst:792
#: ../doc/2.2/reference/reference_sql/sql.rst:1369
#: ../doc/2.2/reference/reference_sql/sql.rst:1457
#: ../doc/2.2/reference/reference_sql/sql.rst:2287
#: ../doc/2.2/reference/reference_sql/sql.rst:2312
#: ../doc/2.2/reference/reference_sql/sql.rst:2364
#: ../doc/2.2/reference/reference_sql/sql.rst:2442
#: ../doc/2.2/reference/reference_sql/sql.rst:2483
#: ../doc/2.2/reference/reference_sql/sql.rst:2513
#: ../doc/2.2/reference/reference_sql/sql.rst:2542
#: ../doc/2.2/reference/reference_sql/sql.rst:2663
#: ../doc/2.2/reference/reference_sql/sql.rst:2705
msgid "Example:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:99
msgid "box.cfg{replication_connect_quorum=2}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:111
msgid "By default, if a replica adds a unique key that another replica has added, replication :ref:`stops <replication-replication_stops>` with error = ER_TUPLE_FOUND."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:115
msgid "However, by specifying ``replication_skip_conflict = true``, users can state that such errors may be ignored."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:120
msgid "box.cfg{replication_skip_conflict=true}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:133
msgid "The maximum :ref:`lag <box_info_replication_upstream_lag>` allowed for a replica. When a replica :ref:`syncs <replication-orphan_status>` (gets updates from a master), it may not catch up completely. The number of seconds that the replica is behind the master is called the \"lag\". Syncing is considered to be complete when the replica's lag is less than or equal to ``replication_sync_lag``."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:140
msgid "If a user sets ``replication_sync_lag`` to nil or to 365 * 100 * 86400 (TIMEOUT_INFINITY), then lag does not matter -- the replica is always considered to be \"synced\". Also, the lag is ignored (assumed to be infinite) in case the master is running Tarantool older than 1.7.7, which does not send :ref:`heartbeat messages <heartbeat>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:145
msgid "This parameter is ignored during bootstrap. See :ref:`orphan status <replication-orphan_status>` for details."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:149
msgid "Default: 10"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:156
msgid "The number of seconds that a replica will wait when trying to sync with a master in a cluster, or a :ref:`quorum <cfg_replication-replication_connect_quorum>` of masters, after connecting or during :ref:`configuration update <replication-configuration_update>`. This could fail indefinitely if ``replication_sync_lag`` is smaller than network latency, or if the replica cannot keep pace with master updates. If ``replication_sync_timeout`` expires, the replica enters :ref:`orphan status <replication-orphan_status>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:166
msgid "Default: 300"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:173
msgid "As described in section :ref:`\"Replication architecture\" <replication-architecture>`, each replica set is identified by a `universally unique identifier <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ called **replica set UUID**, and each instance is identified by an **instance UUID**."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:180
msgid "Ordinarily it is sufficient to let the system generate and format the UUID strings which will be permanently stored."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:183
msgid "However, some administrators may prefer to store Tarantool configuration information in a central repository, for example `Apache ZooKeeper <https://zookeeper.apache.org>`_. Such administrators can assign their own UUID values for either -- or both -- instances (:ref:`instance_uuid <cfg_replication-instance_uuid>`) and replica set (``replicaset_uuid``), when starting up for the first time."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:190
msgid "General rules:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:192
msgid "The values must be true unique identifiers, not shared by other instances or replica sets within the common infrastructure."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:195
msgid "The values must be used consistently, not changed after initial setup (the initial values are stored in :ref:`snapshot files <index-box_persistence>` and are checked whenever the system is restarted)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:199
msgid "The values must comply with `RFC 4122 <https://tools.ietf.org/html/rfc4122>`_. The `nil UUID <https://tools.ietf.org/html/rfc4122#section-4.1.7>`_ is not allowed."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:203
msgid "The UUID format includes sixteen octets represented as 32 hexadecimal (base 16) digits, displayed in five groups separated by hyphens, in the form ``8-4-4-4-12`` for a total of 36 characters (32 alphanumeric characters and four hyphens)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:210
msgid "box.cfg{replicaset_uuid='7b853d13-508b-4b8e-82e6-806f088ea6e9'}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:222
msgid "For replication administration purposes, it is possible to set the `universally unique identifiers <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_ of the instance (``instance_uuid``) and the replica set (``replicaset_uuid``), instead of having the system generate the values."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:227
msgid "See the description of :ref:`replicaset_uuid <cfg_replication-replicaset_uuid>` parameter for details."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_replication.rst:232
msgid "box.cfg{instance_uuid='037fec43-18a9-4e12-a684-a42b716fcd02'}"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:264
msgid "Networking"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:2
msgid ":ref:`net_msg_max <cfg_networking-net_msg_max>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:3
msgid ":ref:`readahead <cfg_networking-readahead>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:9
msgid "The instance will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:22
msgid "To handle messages, Tarantool allocates fibers. To prevent fiber overhead from affecting the whole system, Tarantool restricts how many messages the fibers handle, so that some pending requests are blocked."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:27
msgid "On powerful systems, increase ``net_msg_max`` and the scheduler will immediately start processing pending requests."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:30
msgid "On weaker systems, decrease ``net_msg_max`` and the overhead may decrease although this may take some time because the scheduler must wait until already-running requests finish."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:34
msgid "When ``net_msg_max`` is reached, Tarantool suspends processing of incoming packages until it has processed earlier messages. This is not a direct restriction of the number of fibers that handle network messages, rather it is a system-wide restriction of channel bandwidth. This in turn causes restriction of the number of incoming network messages that the :ref:`transaction processor thread <atomic-threads_fibers_yields>` handles, and therefore indirectly affects the fibers that handle network messages. (The number of fibers is smaller than the number of messages because messages can be released as soon as they are delivered, while incoming requests might not be processed until some time after delivery.)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:48
msgid "On typical systems, the default value (768) is correct."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:51
msgid "Default: 768"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:58
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_networking.rst:68
msgid "Default: 16320"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:4
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:5
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:7
msgid ":ref:`log_format <cfg_logging-log_format>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:13
msgid "What level of detail the :ref:`log <admin-logs>` will have. There are seven levels:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:15
#: ../doc/2.2/reference/reference_lua/log.rst:125
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:16
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:17
#: ../doc/2.2/reference/reference_lua/log.rst:127
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:18
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:19
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:20
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:21
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:23
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:29
msgid "Default: 5"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:32
msgid "Warning: prior to Tarantool 1.7.5 there were only six levels and ``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring repetitive events which would cause too much log writing if ``INFO`` were used instead."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:41
msgid "By default, Tarantool sends the log to the standard error stream (``stderr``). If ``log`` is specified, Tarantool sends the log to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:45
msgid "Example setting for sending the log to a file:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:47
msgid "box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file:tarantool.log'}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:53
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``log`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:57
msgid "Example setting for sending the log to a pipe:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:59
msgid "box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:65
msgid "This will start the program `cronolog <https://linux.die.net/man/1/cronolog>`_ when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``log`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:71
msgid "Example setting for sending the log to syslog:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:73
msgid "box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:server=unix:/dev/log'}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:83
msgid "If the ``log`` string begins with \"syslog:\", then it is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. The setting can be 'syslog:', 'syslog:facility=...', 'syslog:identity=...', 'syslog:server=...', or a combination."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:90
msgid "The ``syslog:identity`` setting is an arbitrary string which will be placed at the beginning of all messages. The default value is: tarantool."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:93
msgid "The ``syslog:facility`` setting is currently ignored but will be used in the future. The value must be one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ keywords, which tell syslogd where the message should go. The possible values are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7. The default value is: user."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:100
msgid "The ``syslog:server`` setting is the locator for the syslog server. It can be a Unix socket path beginning with \"unix:\", or an ipv4 port number. The default socket value is: dev/log (on Linux) or /var/run/syslog (on Mac OS). The default port value is: 514, the UDP port."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:105
msgid "When logging to a file, Tarantool reopens the log on `SIGHUP <https://en.wikipedia.org/wiki/SIGHUP>`_. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:118
msgid "If ``log_nonblock`` equals true, Tarantool does not block during logging when the system is not ready for writing, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and many messages go to the log, setting ``log_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:124
msgid "This parameter has effect only if the output is going to \"syslog:\" or \"pipe:\". Setting ``log_nonblock`` to true is illegal if the output is going to a file."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:129
msgid "The default ``log_nonblock`` value is nil, which means that blocking behavior corresponds to the type of logger. This is a behavior change: in earlier versions of the Tarantool server, the default value was true."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:135
msgid "Default: nil"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:142
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:147
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1112
msgid "Default: 0.5"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:154
msgid "Log entries have two possible formats:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:156
#: ../doc/2.2/reference/reference_lua/log.rst:55
msgid "'plain' (the default), or"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:157
#: ../doc/2.2/reference/reference_lua/log.rst:56
msgid "'json' (with more detail and with JSON labels)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:159
#: ../doc/2.2/reference/reference_lua/log.rst:58
msgid "Here is what a log entry looks like after ``box.cfg{log_format='plain'}``:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:161
#: ../doc/2.2/reference/reference_lua/log.rst:60
msgid "2017-10-16 11:36:01.508 [18081] main/101/interactive I> set 'log_format' configuration option to \"plain\""
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:165
#: ../doc/2.2/reference/reference_lua/log.rst:64
msgid "Here is what a log entry looks like after ``box.cfg{log_format='json'}``:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:167
#: ../doc/2.2/reference/reference_lua/log.rst:66
msgid "{\"time\": \"2017-10-16T11:36:17.996-0600\",\n"
"\"level\": \"INFO\",\n"
"\"message\": \"set 'log_format' configuration option to \\\"json\\\"\",\n"
"\"pid\": 18081,|\n"
"\"cord_name\": \"main\",\n"
"\"fiber_id\": 101,\n"
"\"fiber_name\": \"interactive\",\n"
"\"file\": \"builtin\\/box\\/load_cfg.lua\",\n"
"\"line\": 317}"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:179
msgid "The ``log_format='plain'`` entry has time, process id, cord name, :ref:`fiber_id <fiber_object-id>`, :ref:`fiber_name <fiber_object-name_get>`, :ref:`log level <cfg_logging-log_level>`, and message."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:184
msgid "The ``log_format='json'`` entry has the same things along with their labels, and in addition has the file name and line number of the Tarantool source."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:187
msgid "Setting ``log_format`` to 'json' is illegal if the output is going to \"syslog:\"."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:190
msgid "Default: 'plain'"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:197
msgid "Logging example"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:199
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server instance is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:202
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:204
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:207
msgid "box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:213
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:1517
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:221
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:223
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:227
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:1530
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:234
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool instance. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:1540
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:244
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:246
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:250
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:1554
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:259
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:1562
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:269
msgid "Feedback"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:271
msgid ":ref:`feedback_enabled <cfg_logging-feedback_enabled>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:272
msgid ":ref:`feedback_host <cfg_logging-feedback_host>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:273
msgid ":ref:`feedback_interval <cfg_logging-feedback_interval>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:275
msgid "By default a Tarantool daemon sends a small packet once per hour, to https://feedback.tarantool.io. The packet contains three values from :ref:`box.info <box_introspection-box_info>`: ``box.info.version``, ``box.info.uuid``, and ``box.info.cluster_uuid``. By changing the feedback configuration parameters, users can adjust or turn off this feature."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:286
msgid "Whether to send feedback."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:288
msgid "If this is set to ``true``, feedback will be sent as described above. If this is set to ``false``, no feedback will be sent."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:299
msgid "The address to which the packet is sent. Usually the recipient is Tarantool, but it can be any URL."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:303
msgid "Default: 'https://feedback.tarantool.io'"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:310
msgid "The number of seconds between sendings, usually 3600 (1 hour)."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_logging.rst:313
msgid "Default: 3600"
msgstr ""

#: ../doc/2.2/reference/configuration/index.rst:276
msgid "Deprecated parameters"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:3
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:5
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:6
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:7
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:8
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:9
msgid ":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:10
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:11
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:12
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:13
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:14
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:15
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:16
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:17
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:23
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:101
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:33
msgid "**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:41
msgid "**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-log_nonblock>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:49
#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:63
msgid "**Deprecated** in favor of :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:52
msgid "If there is an error while reading a snapshot file (at server instance start), abort."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:74
msgid "**Deprecated** in favor of :ref:`replication <cfg_replication-replication>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:83
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:86
msgid "How much memory Tarantool allocates to actually store tuples, **in gigabytes**. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:94
msgid "Default: 1.0"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:103
msgid "The multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:109
msgid "Default: 1.1"
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:116
msgid "**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:125
msgid "**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:134
msgid "**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:142
msgid "**Deprecated** in favor of :ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/configuration/cfg_deprecated.rst:151
msgid "**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`. The parameter was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/2.2/reference/index.rst:39
msgid "Reference"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:39
msgid "Interactive console"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:41
msgid "The \"interactive console\" is Tarantool's basic \"command-line interface\" for entering requests and seeing results. It is what users see when they start the server without an :ref:`instance file <admin-instance_file>`, or start :ref:`tarantoolctl <tarantoolctl>` with ``enter``. It is often called the Lua console to distinguish it from the administrative console, but in fact it can handle both Lua and SQL input. The majority of examples in this manual show what users see with the interactive console, including the prompt (which can be \"tarantool> \"), the instruction (which can be a Lua request or an SQL statement), and the response (which can be a display in either YAML format or Lua format)."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:52
msgid "-- Typical interactive console example with Lua input and YAML output\n"
"tarantool> box.info().replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: a5d22f66-2d28-4a35-b78f-5bf73baf6c8a\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:63
msgid "The **input language** can be changed to SQL with ``\\set language sql`` or changed to Lua (the default) with ``\\set language lua``."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:66
msgid "The **delimiter** can be changed to any character with :samp:`\\set delimiter <character>`. The default is nothing, which means input does not need to end with a delimiter. But a common recommendation is to say ``set delimiter ;`` especially if input is SQL."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:70
msgid "The **output format** can be changed to Lua with ``\\set output lua`` or changed to YAML (the default) with ``\\set output yaml``."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:73
msgid "Ordinarily. output from the console has `YAML format <http://yaml.org/spec>`_. That means that there is a line for document-start \"``---``\", and each item begins on a separate line starting with \"``- ``\", and each sub-item in a nested structure is indented, and there is a line for document-end \"``...``\"."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:79
msgid "Optionally, output from the console can have Lua format. That means that there are no lines for document-start or document-end, and items are not on separate lines (they are only separated by commas), and each sub-item in a nested structure is placed inside \"``{}``\" braces. So, when input is a Lua object description, output will equal input."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:85
msgid "YAML is good for readability. Lua is good for re-using results as requests. A third format, MsgPack, is good for database storage. Currently the default output format is YAML but it may be Lua in a future version."
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:98
msgid "Lua input"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:98
msgid "Lua output"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:98
msgid "YAML output"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:98
msgid "MsgPack storage"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:100
#: ../doc/2.2/reference/interactive_console.rst:100
msgid ":code:`1`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:100
msgid ":code:`---` |br| :code:`- 1` |br| :code:`...`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:100
msgid ":code:`\\x01`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:104
msgid "scalar sequence"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:104
#: ../doc/2.2/reference/interactive_console.rst:104
msgid ":code:`1,2,3`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:104
msgid ":code:`---` |br| :code:`- 1` |br| :code:`- 2` |br| :code:`- 3` |br| :code:`...`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:104
msgid ":code:`\\x01 \\x02 \\x03`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:110
msgid "2-element table"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:110
#: ../doc/2.2/reference/interactive_console.rst:110
msgid ":code:`{1,2}`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:110
msgid ":code:`---` |br| :code:`- - 1` |br| :code:`- - 2` |br| :code:`...`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:110
msgid ":code:`0x92 0x01 0x02`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:115
#: ../doc/2.2/reference/interactive_console.rst:115
msgid ":code:`{key=1}`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:115
msgid ":code:`---` |br| :code:`- key: 1` |br| :code:`...`"
msgstr ""

#: ../doc/2.2/reference/interactive_console.rst:115
msgid ":code:`\\x81 \\xa3 \\x6b \\x65 \\x79 \\x01`"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:39
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:41
msgid "The Lua syntax for :ref:`data-manipulation functions <index-box_data-operations>` can vary. Here are examples of the variations with ``select()`` requests. The same rules exist for the other data-manipulation functions."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:45
msgid "Every one of the examples does the same thing: select a tuple set from a space named 'tester' where the primary-key field value equals 1. For these examples, we assume that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:54
msgid "Object reference variations"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:56
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:58
msgid "-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:68
msgid "Examples in this manual usually have the \":samp:`box.space.{tester}:`\" form (#1). However, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:72
msgid "Also, descriptions in this manual use the syntax \"``space_object:``\" for references to objects which are spaces, and \"``index_object:``\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:81
msgid "Parameter variations"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:83
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:85
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:104
msgid "Lua allows to omit parentheses ``()`` when invoking a function if its only argument is a Lua table, and we use it sometimes in our examples. This is why ``select{1}`` is equivalent to ``select({1})``. Literal values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may be replaced by variable names, as in examples #6 and #7."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:110
msgid "Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the ``{1}`` form. However, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:119
msgid "Rules for object names"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:121
msgid "Database objects have loose **rules for names**: the maximum length is 65000 bytes (not characters), and almost any legal Unicode character is allowed, including spaces, ideograms and punctuation."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:126
msgid "In those cases, to prevent confusion with Lua operators and separators, object references should have the literal-in-square-brackets form (#2), or the variable form (#3). For example:"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:130
msgid "tarantool> box.space['1*A']:select{1}\n"
"tarantool> s = box.space['1*A !@$%^&*()_+12345678901234567890']\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:136
msgid "Disallowed:"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:138
msgid "characters which are unassigned code points,"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:139
msgid "line and paragraph separators,"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:140
msgid "control characters,"
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:141
msgid "the replacement character (U+FFFD)."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:143
msgid "Not recommended: characters which cannot be displayed."
msgstr ""

#: ../doc/2.2/reference/lua_tips.rst:145
msgid "Names are \"case sensitive\", so 'A' and 'a' are not the same."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box.rst:41
msgid "As well as executing Lua chunks or defining your own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box.rst:44
msgid "Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box.rst:49
msgid "To catch errors that functions in ``box`` submodules may throw, use :ref:`pcall <error_handling>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box.rst:51
msgid "The contents of the ``box`` module can be inspected at runtime with ``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:37
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:45
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in `error <https://www.lua.org/pil/8.3.html>`_ function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:55
msgid "Below is a list of all ``box.error`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:65
msgid ":ref:`box.error() <box_error-error>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:65
msgid "Throw an error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:68
msgid ":ref:`box.error.last() <box_error-last>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:68
msgid "Get a description of the last error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:71
msgid ":ref:`box.error.clear() <box_error-clear>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:71
msgid "Clear the record of errors"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:74
msgid ":ref:`box.error.new() <box_error-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:74
msgid "Create an error but do not throw"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:80
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:88
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:95
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/2.1/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:101
#: ../doc/2.2/reference/reference_lua/box_error.rst:191
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:102
#: ../doc/2.2/reference/reference_lua/box_error.rst:192
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:106
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:0
msgid "except"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:112
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:116
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:135
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:145
msgid "rtype: table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:151
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:156
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:186
msgid "Create an error object, but do not throw. This is useful when error information should be saved for later retrieval. The parameters are the same as for :ref:`box.error() <box_error-error>`, see the description there."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_error.rst:196
msgid "tarantool> e = box.error.new{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"...\n"
"tarantool> e:unpack()\n"
"---\n"
"- type: ClientError\n"
"  code: 555\n"
"  message: Arbitrary message\n"
"  trace:\n"
"  - file: '[string \"e = box.error.new{code = 555, reason = ''Arbit...\"]'\n"
"    line: 1\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:39
msgid "Function `box.once`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:43
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:48
msgid "See an example of using ``box.once()`` while :ref:`bootstrapping a replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:51
msgid "If an error occurs inside ``box.once()`` when initializing a database, you can re-execute the failed ``box.once()`` block without stopping the database. The solution is to delete the ``once`` object from the system space :ref:`_schema <box_space-schema>`. Say ``box.space._schema:select{}``, find your ``once`` object there and delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:58
msgid "When ``box.once()`` is used for initialization, it may be useful to wait until the database is in an appropriate state (read-only or read-write). In that case, see the functions in the :ref:`box.ctl submodule <box_ctl>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:62
msgid "tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:82
msgid "a value that will be checked"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:83
msgid "a function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_once.rst:84
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:39
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:43
msgid "Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, the :ref:`Tarantool garbage collector <cfg_checkpoint_daemon-garbage-collector>` will not remove files which were created before the snapshot started, it will not remove them until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:57
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Users may restrict the speed by changing :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:65
msgid "As long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore you need to have some extra free memory to run this command. 10% of :ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:73
msgid "**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and this view is written to the snapshot file by a separate thread (the \"Write Ahead Log\" thread)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:79
msgid "Although ``box.snapshot()`` does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:85
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:100
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicated data is up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/box_snapshot.rst:106
msgid "An alternative way to save a snapshot is to send a SIGUSR1 signal to the instance. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:39
msgid "Module `buffer`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:41
msgid "The ``buffer`` module returns a dynamically resizable buffer which is solely for use as an option for methods of the :ref:`net.box module <net_box-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:44
msgid "Ordinarily the ``net.box`` methods return a Lua table. If a ``buffer`` option is used, then the ``net.box`` methods return a raw MsgPack_ string. This saves time on the server, if the client application has its own routine for decoding MsgPack strings."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:54
msgid "a descriptor of a buffer."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:55
#: ../doc/2.2/reference/reference_lua/uuid.rst:95
#: ../doc/2.2/reference/reference_lua/uuid.rst:117
#: ../doc/2.2/reference/reference_lua/uuid.rst:125
msgid "cdata"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:59
msgid "Assume a Tarantool server is listening on farhost:3301. Assume it has a space ``T`` with one tuple: ``'ABCDE', 12345``. In this example we start up a server on localhost:3302 and then use ``net.box`` routines to connect to farhost. Then we create a buffer, and use it as an option for a ``conn.space...select()`` call. The result will be in MsgPack_ format. To show this, we will use :ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>` on ``ibuf.rpos`` (the \"read position\" of the buffer). Thus we do not decode on the remote server, but we do decode on the local server."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:72
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:84
#: ../doc/2.2/reference/reference_lua/buffer.rst:144
msgid "The result of the final request looks like this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:86
#: ../doc/2.2/reference/reference_lua/buffer.rst:107
msgid "tarantool> msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- {48: [['ABCDE', 12345]]}\n"
"- 'cdata<char *>: 0x7f97ba10c041'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:96
msgid "Before Tarantool version 1.7.7, the function to use for this case is ``msgpack.ibuf_decode(ibuf.rpos)``. Starting with Tarantool version 1.7.7, ``ibuf_decode`` is deprecated."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:103
msgid "**Module buffer and skip-header**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:105
msgid "The example in the previous section"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:115
msgid "showed that, ordinarily, the response from net.box includes a header -- 48 (hexadecimal 30) is the :ref:`key <internals-unified_packet_structure>` for IPROTO_DATA. But in some situations, for example when passing the buffer to a C function that expects a MsgPack byte array without a header, the header can be skipped. This is done by specifying ``skip-header=true`` as an option to :ref:`conn.space.space-name:select{...} <conn-select>` or :ref:`conn.space.space-name:insert{...} <conn-insert>` or :ref:`conn.space.space-name:replace{...} <conn-replace>` or :ref:`conn.space.space-name:update{...} <conn-update>` or :ref:`conn.space.space-name:upsert{...} <conn-upsert>` or :ref:`conn.space.space-name:delete{...} <conn-delete>`. The default is ``skip-header=false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:130
msgid "Now here is the same example, except that ``skip_header=true`` is used."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:132
msgid "box.cfg{listen=3302}\n"
"buffer = require('buffer')\n"
"ibuf = buffer.ibuf()\n"
"net_box = require('net.box')\n"
"conn = net_box.connect('farhost:3301')\n"
"buffer = require('buffer')\n"
"conn.space.T:select({},{buffer=ibuf, skip_header=true})\n"
"msgpack = require('msgpack')\n"
"msgpack.decode_unchecked(ibuf.rpos)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:146
msgid "tarantool>         msgpack.decode_unchecked(ibuf.rpos)\n"
"---\n"
"- [['ABCDE', 12345]]\n"
"- 'cdata<char *>: 0x7f8fd102803f'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:154
msgid "Notice that the IPROTO_DATA header (48) is gone."
msgstr ""

#: ../doc/2.2/reference/reference_lua/buffer.rst:156
msgid "The result is still inside an array, as is clear from the fact that it is shown inside square brackets. It is possible to skip the array header too, with :ref:`msgpack.decode_array_header() <msgpack-decode_array_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:45
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:54
msgid "Below is a list of all ``clock`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:64
msgid ":ref:`clock.time() <clock-time>` |br| :ref:`clock.realtime() <clock-time>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:65
msgid "Get the wall clock time in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:69
msgid ":ref:`clock.time64() <clock-time>` |br| :ref:`clock.realtime64() <clock-time>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:70
msgid "Get the wall clock time in nanoseconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:74
msgid ":ref:`clock.monotonic() <clock-monotonic>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:74
msgid "Get the monotonic time in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:77
msgid ":ref:`clock.monotonic64() <clock-monotonic>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:77
msgid "Get the monotonic time in nanoseconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:80
msgid ":ref:`clock.proc() <clock-proc>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:80
msgid "Get the processor time in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:83
msgid ":ref:`clock.proc64() <clock-proc>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:83
msgid "Get the processor time in nanoseconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:86
msgid ":ref:`clock.thread() <clock-thread>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:86
msgid "Get the thread time in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:89
msgid ":ref:`clock.thread64() <clock-thread>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:89
msgid "Get the thread time in nanoseconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:92
msgid ":ref:`clock.bench() <clock-bench>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:92
msgid "Measure the time a function takes within a processor"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:105
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:109
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:110
#: ../doc/2.2/reference/reference_lua/clock.rst:135
#: ../doc/2.2/reference/reference_lua/clock.rst:156
#: ../doc/2.2/reference/reference_lua/clock.rst:177
msgid "number or number64"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:114
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:120
msgid "See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:128
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:134
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:139
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:150
msgid "The processor time. Derived from C function ``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:155
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:160
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:171
msgid "The thread time. Derived from C function ``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:176
msgid "seconds or nanoseconds since the transaction processor thread started."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:181
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:191
msgid "The time that a function takes within a processor. This function uses ``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:195
msgid "function or function reference"
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:196
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:198
msgid "**table**. first element - seconds of CPU time, second element - whatever the function returns."
msgstr ""

#: ../doc/2.2/reference/reference_lua/clock.rst:203
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:39
msgid "Module `console`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:45
msgid "The console module allows one Tarantool instance to access another Tarantool instance, and allows one Tarantool instance to start listening on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:53
msgid "Below is a list of all ``console`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:63
msgid ":ref:`console.connect() <console-connect>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:63
msgid "Connect to an instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:66
msgid ":ref:`console.listen() <console-listen>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:66
msgid "Listen for incoming requests"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:69
msgid ":ref:`console.start() <console-start>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:69
msgid "Start the console"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:72
msgid ":ref:`console.ac() <console-ac>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:72
msgid "Set the auto-completion flag"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:75
msgid ":ref:`console.delimiter() <console-delimiter>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:75
msgid "Set a delimiter"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:85
msgid "Connect to the instance at :ref:`URI <index-uri>`, change the prompt from '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:89
msgid "The console.connect function allows one Tarantool instance, in interactive mode, to access another Tarantool instance. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote instance and the local instance is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote instance. Results are displayed on the local instance. To return to local mode, enter ``control-D``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:97
msgid "If the Tarantool instance at :samp:`uri` requires authentication, the connection might look something like: ``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:101
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote instance is done with user name = 'guest'. The remote instance could allow for this by granting at least one privilege: ``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:107
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:110
msgid "Possible errors: the connection will fail if the target Tarantool instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:115
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:129
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in ``box.cfg{listen=...}``. The alternative way of listening is via the URI specified in ``console.listen(...)``. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <admin-security>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:136
msgid "the URI of the local instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:138
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:146
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:167
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:171
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the Tarantool instance with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:176
msgid "local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:185
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using Tarantool as a client or the user is using Tarantool via ``console.connect()``, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:194
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:196
msgid "The default end-of-request marker is a newline (line feed). Custom markers are not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an end keyword). Nonetheless for special needs, or for entering multi-line requests in older Tarantool versions, you can change the end-of-request marker. As a result, newline alone is not treated as end of request."
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:204
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:206
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/2.2/reference/reference_lua/console.rst:210
msgid "tarantool> console = require('console'); console.delimiter('!')\n"
"---\n"
"...\n"
"tarantool> function f ()\n"
"         > statement_1 = 'a'\n"
"         > statement_2 = 'b'\n"
"         > end!\n"
"---\n"
"...\n"
"tarantool> console.delimiter('')!\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:39
msgid "Module `crypto`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:47
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``crypto`` module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:58
msgid "Below is a list of all ``crypto`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:68
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.encrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:68
msgid "Encrypt a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:71
msgid ":ref:`crypto.cipher.{algorithm}.{cipher_mode}.decrypt() <crypto-cipher>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:71
msgid "Decrypt a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:74
msgid ":ref:`crypto.digest.{algorithm}() <crypto-digest>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:74
msgid "Get a digest"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:84
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:87
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:88
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:89
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:90
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:93
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:95
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:96
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:97
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:98
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:100
msgid "For more information, read the article about `Encryption Modes`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:104
msgid "_16byte_iv='1234567890123456'\n"
"_16byte_pass='1234567890123456'\n"
"e=crypto.cipher.aes128.cbc.encrypt('string', _16byte_pass, _16byte_iv)\n"
"crypto.cipher.aes128.cbc.decrypt(e,  _16byte_pass, _16byte_iv)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:119
msgid "Pass or return a digest derived from the string. The eleven algorithm choices:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:122
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:123
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:124
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:125
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:126
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:127
msgid "ripemd160 - ripemd (with 160-bit binary strings using RIPEMD-160)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:128
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:129
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:130
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:131
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:132
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:136
msgid "crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:143
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:145
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:151
msgid "crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"key = 'key/key/key/key/key/key/'\n"
"iv =  'iviviviviviviviv'\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', key, iv))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new(key)\n"
"c:init(nil, iv)\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:177
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:179
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/2.2/reference/reference_lua/crypto.rst:182
msgid "crypto.cipher.aes256.cbc.encrypt('x',b32,b16)==digest.aes256cbc.encrypt('x',b32,b16)\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:37
msgid "Module `csv`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:45
msgid "The ``csv`` module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:48
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:50
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:52
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:53
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:54
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:55
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:56
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:62
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:64
msgid ":samp:`delimiter = {string}` (default: comma) -- single-byte character to designate end-of-field"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:66
msgid ":samp:`quote_char = {string}` (default: quote mark) -- single-byte character to designate encloser of string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:68
msgid ":samp:`chunk_size = {number}` (default: 4096) -- number of characters to read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:70
msgid ":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to skip at the start (usually for a header)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:77
msgid "Below is a list of all ``csv`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:87
msgid ":ref:`csv.load() <csv-load>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:87
msgid "Load a CSV file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:90
msgid ":ref:`csv.dump() <csv-dump>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:90
msgid "Transform input into a CSV-formatted string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:93
msgid ":ref:`csv.iterate() <csv-iterate>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:93
msgid "Iterate over CSV records"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:101
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:105
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:107
#: ../doc/2.2/reference/reference_lua/csv.rst:233
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:108
msgid "loaded_value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:113
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:116
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:128
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:131
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:138
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:140
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:148
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:152
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:179
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:185
#: ../doc/2.2/reference/reference_lua/csv.rst:231
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:187
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:188
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:190
msgid "dumped_value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:191
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:195
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:197
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:209
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:211
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:227
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:235
msgid "Lua iterator function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:236
msgid "iterator function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:240
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/csv.rst:245
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:39
msgid "Debug facilities"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:45
msgid "Tarantool users can benefit from built-in debug facilities that are part of:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:47
msgid "Lua (`debug <https://www.lua.org/manual/5.1/manual.html#5.9>`_ library, see details below) and"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:49
msgid "LuaJit (`debug.* <http://luajit.org/extensions.html>`_ functions)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:53
msgid "The ``debug`` library provides an interface for debugging Lua programs. All functions in this library reside in the ``debug`` table. Those functions that operate on a thread have an optional first parameter that specifies the thread to operate on. The default is always the current thread."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:60
msgid "This library should be used only for debugging and profiling and not as a regular programming tool, as the functions provided here can take too long to run. Besides, several of these functions can compromise otherwise secure code."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:69
msgid "Below is a list of all ``debug`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:79
msgid ":ref:`debug.debug() <debug-debug>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:79
msgid "Enter an interactive mode"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:82
msgid ":ref:`debug.getfenv() <debug-getfenv>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:82
msgid "Get an object's environment"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:85
msgid ":ref:`debug.gethook() <debug-gethook>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:85
msgid "Get a thread's current hook settings"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:88
msgid ":ref:`debug.getinfo() <debug-getinfo>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:88
msgid "Get information about a function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:91
msgid ":ref:`debug.getlocal() <debug-getlocal>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:91
msgid "Get a local variable's name and value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:94
msgid ":ref:`debug.getmetatable() <debug-getmetatable>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:94
msgid "Get an object's metatable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:97
msgid ":ref:`debug.getregistry() <debug-getregistry>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:97
msgid "Get the registry table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:100
msgid ":ref:`debug.getupvalue() <debug-getupvalue>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:100
msgid "Get an upvalue's name and value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:103
msgid ":ref:`debug.setfenv() <debug-setfenv>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:103
msgid "Set an object's environment"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:106
msgid ":ref:`debug.sethook() <debug-sethook>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:106
msgid "Set a given function as a hook"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:109
msgid ":ref:`debug.setlocal() <debug-setlocal>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:109
msgid "Assign a value to a local variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:112
msgid ":ref:`debug.setmetatable() <debug-setmetatable>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:112
msgid "Set an object's metatable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:115
msgid ":ref:`debug.setupvalue() <debug-setupvalue>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:115
msgid "Assign a value to an upvalue"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:118
msgid ":ref:`debug.sourcedir() <debug-sourcedir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:118
msgid "Get the source directory name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:121
msgid ":ref:`debug.sourcefile() <debug-sourcefile>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:121
msgid "Get the source file name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:124
msgid ":ref:`debug.traceback() <debug-traceback>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:124
msgid "Get a traceback of the call stack"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:133
msgid "Enters an interactive mode and runs each string that the user types in. The user can, among other things, inspect global and local variables, change their values and evaluate expressions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:137
msgid "Enter ``cont`` to exit this function, so that the caller can continue its execution."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:142
msgid "Commands for ``debug.debug()`` are not lexically nested within any function and so have no direct access to local variables."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:149
msgid "object to get the environment of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:152
msgid "the environment of the ``object``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:158
msgid "the current hook settings of the ``thread`` as three values:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:160
msgid "the current hook function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:161
msgid "the current hook mask"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:162
msgid "the current hook count as set by the ``debug.sethook()`` function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:168
msgid "function to get information on"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:170
msgid "what information on the ``function`` to return"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:172
msgid "a table with information about the ``function``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:174
msgid "You can pass in a ``function`` directly, or you can give a number that specifies a function running at level ``function`` of the call stack of the given ``thread``: level 0 is the current function (``getinfo()`` itself), level 1 is the function that called ``getinfo()``, and so on. If ``function`` is a number larger than the number of active functions, ``getinfo()`` returns ``nil``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:181
msgid "The default for ``what`` is to get all information available, except the table of valid lines. If present, the option ``f`` adds a field named ``func`` with the function itself. If present, the option ``L`` adds a field named ``activelines`` with the table of valid lines."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:190
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:267
msgid "level of the stack"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:191
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:268
msgid "index of the local variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:193
msgid "the name and the value of the local variable with the index ``local`` of the function at level ``level`` of the stack or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:200
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:278
msgid "You can call ``debug.getinfo()`` to check whether the level is valid."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:206
msgid "object to get the metatable of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:209
msgid "a metatable of the ``object`` or ``nil`` if it does not have a metatable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:216
msgid "the registry table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:222
msgid "function to get the upvalue of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:223
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:298
msgid "index of the function upvalue"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:225
msgid "the name and the value of the upvalue with the index ``up`` of the function ``func`` or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:233
msgid "Sets the environment of the ``object`` to the ``table``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:235
msgid "object to change the environment of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:237
msgid "table to set the object environment to"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:239
msgid "the ``object``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:245
msgid "Sets the given function as a hook.  When called without arguments, turns the hook off."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:248
msgid "function to set as a hook"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:249
msgid "describes when the ``hook`` will be called; may have the following values:  * ``c`` - the ``hook`` is called every time Lua calls a function * ``r`` - the ``hook`` is called every time Lua returns from a function * ``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:249
msgid "describes when the ``hook`` will be called; may have the following values:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:252
msgid "``c`` - the ``hook`` is called every time Lua calls a function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:253
msgid "``r`` - the ``hook`` is called every time Lua returns from a function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:254
msgid "``l`` - the ``hook`` is called every time Lua enters a new line of code"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:256
msgid "describes when the ``hook`` will be called; when different from zero, the ``hook`` is called after every ``count`` instructions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:264
msgid "Assigns the value ``value`` to the local variable with the index ``local`` of the function at level ``level`` of the stack."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:269
msgid "value to assign to the local variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:272
msgid "the name of the local variable or ``nil`` if there is no local variable with the given index; raises an error if ``level`` is out of range"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:284
msgid "Sets the metatable of the ``object`` to the ``table``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:286
msgid "object to change the metatable of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:288
msgid "table to set the object metatable to"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:294
msgid "Assigns the value ``value`` to the upvalue with the index ``up`` of the function ``func``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:297
msgid "function to set the upvalue of"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:299
msgid "value to assign to the function upvalue"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:302
msgid "the name of the upvalue or ``nil`` if there is no upvalue with the given index"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:309
#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:328
msgid "the level of the call stack which should contain the path (default is 2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:312
msgid "a string with the relative path to the source file directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:314
msgid "Instead of ``debug.sourcedir()`` one can say ``debug.__dir__`` which means the same thing."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:316
msgid "Determining the real path to a directory is only possible if the function was defined in a Lua file (this restriction may not apply for `loadstring() <https://www.lua.org/pil/8.html>`_ since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:321
msgid "If ``debug.sourcedir()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcedir())``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:331
msgid "a string with the relative path to the source file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:333
msgid "Instead of ``debug.sourcefile()`` one can say ``debug.__file__`` which means the same thing."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:335
msgid "Determining the real path to a file is only possible if the function was defined in a Lua file (this restriction may not apply to ``loadstring()`` since Lua will store the entire string in debug info)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:340
msgid "If ``debug.sourcefile()`` is part of a ``return`` argument, then it should be inside parentheses: ``return (debug.sourcefile())``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:347
msgid "an optional message prepended to the traceback"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:348
msgid "specifies at which level to start the traceback (default is 1)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:351
msgid "a string with a traceback of the call stack"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:353
msgid "**Debug example:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:355
msgid "Make a file in the /tmp directory named example.lua, containing:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:357
msgid "function w()\n"
"  print(debug.sourcedir())\n"
"  print(debug.sourcefile())\n"
"  print(debug.traceback())\n"
"  print(debug.getinfo(1)['currentline'])\n"
"end\n"
"w()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:367
msgid "Execute ``tarantool /tmp/example.lua``. Expect to see this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/debug_facilities.rst:369
msgid "/tmp\n"
"/tmp/example.lua\n"
"stack traceback:\n"
"    /tmp/example.lua:4: in function 'w'\n"
"    /tmp/example.lua:7: in main chunk\n"
"5"
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:39
msgid "Module `decimal`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:43
msgid "The ``decimal`` module has functions for working with exact numbers. This is important when numbers are large or even the slighest inaccuracy is unacceptable. For example Lua calculates ``0.16666666666667 * 6`` with floating-point so the result is 1. But with the decimal module (using ``decimal.new`` to convert the number to decimal type) ``decimal.new('0.16666666666667') * 6`` is 1.00000000000002."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:52
msgid "To construct a decimal number, bring in the module with ``require('decimal')`` and then use ``decimal.new(n)`` or any function in the decimal module: :ref:`abs(n) <decimal-abs>` :ref:`exp(n) <decimal-exp>` :ref:`ln(n) <decimal-ln>` :ref:`log10(n) <decimal-log10>` :ref:`new(n) <decimal-new>` :ref:`precision(n) <decimal-precision>` :ref:`rescale(decimal-number, new-scale) <decimal-rescale>` :ref:`scale(n) <decimal-scale>` :ref:`sqrt(n) <decimal-sqrt>` :ref:`trim(decimal-number) <decimal-trim>`, where n can be a string or a non-decimal number or a decimal number. If it is a string or a non-decimal number, Tarantool converts it to a decimal number before working with it. It is best to construct from strings, and to convert back to strings after calculations, because Lua numbers have only 15 digits of precision. Decimal numbers have 38 digits of precision, that is, the total number of digits before and after the decimal point can be 38. Tarantool supports the usual arithmetic and comparison operators + - * / % ^ < > <= >= ~= ==. If an operation has both decimal and non-decimal operands, then the non-decimal operand is converted to decimal before the operation happens."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:80
msgid "Use ``tostring(decimal-number)`` to convert back to a string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:82
msgid "A decimal operation will fail if overflow happens (when a number is greater than 10^38 - 1 or less than -10^38 - 1). A decimal operation will fail if arithmetic is impossible (such as division by zero or square root of minus 1). A decimal operation will not fail if rounding of post-decimal digits is necessary to get 38-digit precision."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:93
msgid "Returns absolute value of a decimal number. For example if a is -1 then ``decimal.abs(a)`` returns 1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:100
msgid "Returns *e* raised to the power of a decimal number. For example if a is 1 then ``decimal.exp(a)`` returns 2.7182818284590452353602874713526624978. Compare ``math.exp(1)`` from the `Lua math library <https://www.lua.org/pil/18.html>`_, which returns 2.718281828459."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:111
msgid "Returns natural logarithm of a decimal number. For example if a is 1 then ``decimal.ln(a)`` returns 0."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:118
msgid "Returns base-10 logarithm of a decimal number. For example if a is 100 then ``decimal.log10(a)`` returns 2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:125
msgid "Returns the value of the input as a decimal number. For example if a is 1E-1 then ``decimal.new(a)`` returns 0.1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:133
msgid "Returns the number of digits in a decimal number. For example if a is 123.4560 then ``decimal.precision(a)`` returns 7."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:140
msgid "Returns the number after possible rounding or padding. If the number of post-decimal digits is greater than new-scale, then rounding occurs. The rounding rule is: round half away from zero. If the number of post-decimal digits is less than new-scale, then padding of zeros occurs. For example if a is -123.4550 then ``decimal.rescale(a, 2)`` returns -123.46, and ``decimal.rescale(a, 5)`` returns -123.45500."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:152
msgid "Returns the number of post-decimal digits in a decimal number. For example if a is 123.4560 then ``decimal.scale(a)`` returns 4."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:159
msgid "Returns the square root of a decimal number. For example if a is 2 then ``decimal.sqrt(a)`` returns 1.4142135623730950488016887242096980786."
msgstr ""

#: ../doc/2.2/reference/reference_lua/decimal.rst:167
msgid "Returns a decimal number after possible removing of trailing post-decimal zeros. For example if a is 2.20200 then ``decimal.trim(a)`` returns 2.202."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:39
msgid "Module `digest`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:47
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's ``digest`` module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-1_, SHA-2_, PBKDF2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:58
msgid "Below is a list of all ``digest`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:68
msgid ":ref:`digest.aes256cbc.encrypt() <digest-aes>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:68
msgid "Encrypt a string using AES"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:71
msgid ":ref:`digest.aes256cbc.decrypt() <digest-aes>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:71
msgid "Decrypt a string using AES"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:74
msgid ":ref:`digest.md4() <digest-md4>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:74
msgid "Get a digest made with MD4"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:77
msgid ":ref:`digest.md4_hex() <digest-md4_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:77
msgid "Get a hexadecimal digest made with MD4"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:80
msgid ":ref:`digest.md5() <digest-md5>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:80
msgid "Get a digest made with MD5"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:83
msgid ":ref:`digest.md5_hex() <digest-md5_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:83
msgid "Get a hexadecimal digest made with MD5"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:86
msgid ":ref:`digest.pbkdf2() <digest-pbkdf2>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:86
msgid "Get a digest made with PBKDF2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:89
msgid ":ref:`digest.sha1() <digest-sha1>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:89
msgid "Get a digest made with SHA-1"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:92
msgid ":ref:`digest.sha1_hex() <digest-sha1_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:92
msgid "Get a hexadecimal digest made with SHA-1"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:95
msgid ":ref:`digest.sha224() <digest-sha224>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:95
msgid "Get a 224-bit digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:98
msgid ":ref:`digest.sha224_hex() <digest-sha224_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:98
msgid "Get a 56-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:101
msgid ":ref:`digest.sha256() <digest-sha256>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:101
msgid "Get a 256-bit digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:104
msgid ":ref:`digest.sha256_hex() <digest-sha256_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:104
msgid "Get a 64-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:107
msgid ":ref:`digest.sha384() <digest-sha384>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:107
msgid "Get a 384-bit digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:110
msgid ":ref:`digest.sha384_hex() <digest-sha384_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:110
msgid "Get a 96-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:113
msgid ":ref:`digest.sha512() <digest-sha512>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:113
msgid "Get a 512-bit digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:116
msgid ":ref:`digest.sha512_hex() <digest-sha512_hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:116
msgid "Get a 128-byte hexadecimal digest made with SHA-2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:119
msgid ":ref:`digest.base64_encode() <digest-base64_encode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:119
msgid "Encode a string to Base64"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:122
msgid ":ref:`digest.base64_decode() <digest-base64_decode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:122
msgid "Decode a Base64-encoded string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:125
msgid ":ref:`digest.urandom() <digest-urandom>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:125
msgid "Get an array of random bytes"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:128
msgid ":ref:`digest.crc32() <digest-crc32>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:128
msgid "Get a 32-bit checksum made with CRC32"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:131
msgid ":ref:`digest.crc32.new() <digest-crc32_new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:131
msgid "Initiate incremental CRC32"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:134
msgid ":ref:`digest.guava() <digest-guava>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:134
msgid "Get a number made with a consistent hash"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:137
msgid ":ref:`digest.murmur() <digest-murmur>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:137
msgid "Get a digest made with MurmurHash"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:140
msgid ":ref:`digest.murmur.new() <digest-murmur_new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:140
msgid "Initiate incremental MurmurHash"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:149
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:155
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:161
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:167
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:173
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:179
msgid "Returns binary string = digest made with PBKDF2. |br| For effective encryption the ``iterations`` value should be at least several thousand. The ``digest-length`` value determines the length of the resulting binary string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:188
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:194
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:200
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:206
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:212
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:218
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:224
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:230
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:236
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:242
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:248
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:252
msgid "``nopad`` -- result must not include '=' for padding at the end,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:253
msgid "``nowrap`` -- result must not include line feed for splitting lines after 72 characters,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:255
msgid "``urlsafe`` -- result must not include '=' or line feed, and may contain '-' or '_' instead of '+' or '/' for positions 62 and 63 in the index table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:259
msgid "Options may be ``true`` or ``false``, the default value is ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:263
msgid "digest.base64_encode(string_variable,{nopad=true})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:271
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:277
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:283
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:285
msgid "The ``crc32`` and ``crc32_update`` functions use the `Cyclic Redundancy Check`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. (Other settings are: input = reflected, output = reflected, initial value = 0xFFFFFFFF, final xor value = 0x0.) If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:292
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:294
msgid ">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:301
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:303
msgid "use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:310
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:316
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:323
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:325
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:330
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:341
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:347
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:351
msgid "murmur.new({seed=0})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:359
msgid "Incremental methods in the ``digest`` module"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:361
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:367
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:389
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:393
msgid "tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:419
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/digest.rst:422
msgid "tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:39
msgid "Database error codes"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:41
msgid "In the current version of the binary protocol, error messages, which are normally more descriptive than error codes, are not present in server responses. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below are general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:52
msgid "**List of error codes**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:60
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:60
msgid "(In replication) A server instance cannot modify data unless it is a master."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:63
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:63
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:66
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:66
msgid "Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has been reached."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:70
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:70
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:74
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:74
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:77
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:77
msgid "The specified space does not exist."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:80
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:80
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:83
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:83
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:86
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:86
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:91
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:91
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:94
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:94
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:102
msgid "Handling errors"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:104
msgid "Here are some procedures that can make Lua functions more robust when there are errors, particularly database errors."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:107
msgid "Invoke with pcall."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid "Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, instead of simply invoking with"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid "say"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid ":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-name}) ...`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid "For some Tarantool box functions, pcall also returns error details including a file-name and line-number within Tarantool's source code. This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:0
msgid "``y:unpack()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:122
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:125
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:127
msgid "To make a new error and pass it on, the box.error module provides :ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:130
msgid "To find the last error, the box.error module provides :ref:`box.error.last() <box_error-last>`. (There is also a way to find the text of the last operating-system error for certain functions -- :ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:135
msgid "Log."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:137
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:139
msgid "And filter messages that are automatically generated, with the :ref:`log <cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:143
msgid "Generally, for Tarantool built-in functions which are designed to return objects: the result will be an object, or nil, or `a Lua error <https://www.lua.org/pil/8.3.html>`_. For example consider the :ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:161
msgid "After a function call that might fail, like fio.open() above, it is common to see syntax like ``if not f then ...`` or ``if f == nil then ...``, which check for common failures. But if there had been a syntax error, for example fio.opex instead of fio.open, then there would have been a Lua error and f would not have been changed. If checking for such an obvious error had been a concern, the programmer would probably have used pcall()."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errcodes.rst:171
msgid "All functions in Tarantool modules should work this way, unless the manual explicitly says otherwise."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:39
msgid "Module `errno`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:47
msgid "The ``errno`` module is typically used within a function or within a Lua program, in association with a module whose functions can return operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:55
msgid "Below is a list of all ``errno`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:65
msgid ":ref:`errno() <errno-errno>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:65
msgid "Get an error number for the last OS-related function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:68
msgid ":ref:`errno.strerror() <errno-strerror>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:68
msgid "Get an error message for the corresponding error number"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:76
msgid "Return an error number for the last operating-system-related function, or 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:85
msgid "Return a string, given an error number. The string will contain the text of the conventional error message for the current operating system. If ``code`` is not supplied, the error message will be for the last operating-system-related function, or 0."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:90
msgid "number of an operating-system error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:96
msgid "This function displays the result of a call to :ref:`fio.open() <fio-open>` which causes error 2 (``errno.ENOENT``). The display includes the error number, the associated error string, and the error name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:100
msgid "tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:125
msgid "To see all possible error names stored in the ``errno`` metatable, say ``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/2.2/reference/reference_lua/errno.rst:128
msgid "tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:45
msgid "With the ``fiber`` module, you can:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:47
msgid "create, run and manage :ref:`fibers <fiber-fibers>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:48
msgid "send and receive messages between different processes (i.e. different connections, sessions, or fibers) via :ref:`channels <fiber_ipc-channel>`, and"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:50
msgid "use a :ref:`synchronization mechanism <fiber_ipc-cond_var>` for fibers, similar to \"condition variables\" and similar to operating-system functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:58
msgid "Below is a list of all ``fiber`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:68
msgid ":ref:`fiber.create() <fiber-create>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:68
msgid "Create and start a fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:71
msgid ":ref:`fiber.new() <fiber-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:71
msgid "Create but do not start a fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:74
msgid ":ref:`fiber.self() <fiber-self>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:74
msgid "Get a fiber object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:77
msgid ":ref:`fiber.find() <fiber-find>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:77
msgid "Get a fiber object by ID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:80
msgid ":ref:`fiber.sleep() <fiber-sleep>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:80
msgid "Make a fiber go to sleep"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:83
msgid ":ref:`fiber.yield() <fiber-yield>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:83
msgid "Yield control"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:86
msgid ":ref:`fiber.status() <fiber-status>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:86
msgid "Get the current fiber's status"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:89
msgid ":ref:`fiber.info() <fiber-info>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:89
msgid "Get information about all fibers"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:92
msgid ":ref:`fiber.kill() <fiber-kill>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:92
#: ../doc/2.2/reference/reference_lua/fiber.rst:110
msgid "Cancel a fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:95
msgid ":ref:`fiber.testcancel() <fiber-testcancel>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:95
msgid "Check if the current fiber has been cancelled"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:98
msgid ":ref:`fiber_object:id() <fiber_object-id>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:98
msgid "Get a fiber's ID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:101
msgid ":ref:`fiber_object:name() <fiber_object-name_get>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:101
msgid "Get a fiber's name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:104
msgid ":ref:`fiber_object:name(name) <fiber_object-name_set>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:104
msgid "Set a fiber's name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:107
msgid ":ref:`fiber_object:status() <fiber_object-status>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:107
msgid "Get a fiber's status"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:110
msgid ":ref:`fiber_object:cancel() <fiber_object-cancel>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:113
msgid ":ref:`fiber_object.storage <fiber_object-storage>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:113
msgid "Local storage within the fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:116
msgid ":ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:116
msgid "Make it possible for a new fiber to join"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:119
msgid ":ref:`fiber_object:join() <fiber_object-join>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:119
msgid "Wait for a fiber's state to become 'dead'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:122
msgid ":ref:`fiber.time() <fiber-time>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:122
msgid "Get the system time in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:125
msgid ":ref:`fiber.time64() <fiber-time64>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:125
msgid "Get the system time in microseconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:128
msgid ":ref:`fiber.channel() <fiber-channel>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:128
msgid "Create a communication channel"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:131
msgid ":ref:`channel_object:put() <channel_object-put>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:131
msgid "Send a message via a channel"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:134
msgid ":ref:`channel_object:close() <channel_object-close>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:134
msgid "Close a channel"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:137
msgid ":ref:`channel_object:get() <channel_object-get>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:137
msgid "Fetch a message from a channel"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:140
msgid ":ref:`channel_object:is_empty() <channel_object-is_empty>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:140
msgid "Check if a channel is empty"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:143
msgid ":ref:`channel_object:count() <channel_object-count>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:143
msgid "Count messages in a channel"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:146
msgid ":ref:`channel_object:is_full() <channel_object-is_full>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:146
msgid "Check if a channel is full"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:149
msgid ":ref:`channel_object:has_readers() <channel_object-has_readers>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:149
msgid "Check if an empty channel has any readers waiting"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:152
msgid ":ref:`channel_object:has_writers() <channel_object-has_writers>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:152
msgid "Check if a full channel has any writers waiting"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:155
msgid ":ref:`channel_object:is_closed() <channel_object-is_closed>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:155
msgid "Check if a channel is closed"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:158
msgid ":ref:`fiber.cond() <fiber-cond>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:158
msgid "Create a condition variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:161
msgid ":ref:`cond_object:wait() <cond_object-wait>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:161
msgid "Make a fiber go to sleep until woken by another fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:164
msgid ":ref:`cond_object:signal() <cond_object-signal>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:164
msgid "Wake up a single fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:167
msgid ":ref:`cond_object:broadcast() <cond_object-broadcast>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:167
msgid "Wake up all fibers"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:178
msgid "A **fiber** is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:182
msgid "A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber is created with :ref:`fiber.new() <fiber-new>` or yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:188
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:192
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:203
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:210
msgid "Like all Lua objects, dead fibers are garbage collected. The Lua garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:215
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:227
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:229
#: ../doc/2.2/reference/reference_lua/fiber.rst:268
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/table.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
msgid "Return"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:232
#: ../doc/2.2/reference/reference_lua/fiber.rst:271
msgid "created fiber object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/fiber.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/string.rst:0
#: ../doc/2.2/reference/reference_lua/table.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:0
msgid "Rtype"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:237
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:255
msgid "Create but do not start a fiber: the fiber is created but does not begin to run immediately -- it starts after the fiber creator (that is, the job that is calling ``fiber.new()``) yields, under :ref:`transaction control <atomic-atomic_execution>`. The initial fiber state is 'suspended'. Thus ``fiber.new()`` differs slightly from :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:263
msgid "Ordinarily ``fiber.new()`` is used in conjunction with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>` and :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:276
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.new(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:294
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:299
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:312
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:314
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:319
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:332
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:335
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:339
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:349
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`, except that `fiber.sleep(0)` depends on a timer, `fiber.yield()` does not."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:354
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:364
msgid "Return the status of the current fiber. Or, if optional fiber_object is passed, return the status of the specified fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:368
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:373
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:384
msgid "Return information about all fibers."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:386
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:392
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:410
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:414
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:0
msgid "Exception"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:415
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:419
msgid "tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:431
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:436
msgid "Even if you catch the exception, the fiber will remain cancelled. Most types of calls will check ``fiber.testcancel()``. However, some functions (``id``, ``status``, ``join`` etc.) will return no error. We recommend application developers to implement occasional checks with :ref:`fiber.testcancel() <fiber-testcancel>` and to end fiber's execution as soon as possible in case it has been cancelled."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:445
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:458
#: ../doc/2.2/reference/reference_lua/fiber.rst:483
#: ../doc/2.2/reference/reference_lua/fiber.rst:511
#: ../doc/2.2/reference/reference_lua/fiber.rst:533
#: ../doc/2.2/reference/reference_lua/fiber.rst:560
msgid "generally this is an object referenced in the return from :ref:`fiber.create <fiber-create>` or :ref:`fiber.self <fiber-self>` or :ref:`fiber.find <fiber-find>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:462
msgid "id of the fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:465
msgid "``fiber.self():id()`` can also be expressed as ``fiber.id()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:469
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:487
msgid "name of the fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:490
msgid "``fiber.self():name()`` can also be expressed as ``fiber.name()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:494
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:505
msgid "Change the fiber name. By default a Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:515
msgid "the new name of the fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:521
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:531
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:537
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:540
msgid "``fiber.self():status(`` can also be expressed as ``fiber.status()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:544
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:555
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:name() <fiber_object-name_get>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:566
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:570
msgid "tarantool> fiber.self():cancel() -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:581
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The Lua garbage collector will mark or free the local storage when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:590
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:616
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:622
msgid "``fiber_object:set_joinable(true)`` makes a fiber joinable; ``fiber_object:set_joinable(false)`` makes a fiber not joinable; the default is false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:626
msgid "A joinable fiber can be waited for, with :ref:`fiber_object:join() <fiber_object-join>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:629
msgid "Best practice is to call ``fiber_object:set_joinable()`` before the fiber function begins to execute, because otherwise the fiber could become 'dead' before ``fiber_object:set_joinable()`` takes effect. The usual sequence could be:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:634
msgid "Call ``fiber.new()`` instead of ``fiber.create()`` to create a new fiber_object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:637
msgid "Do not yield at this point, because that will cause the fiber function to begin."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:640
msgid "Call ``fiber_object:set_joinable(true)`` to make the new fiber_object joinable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:643
msgid "Now it is safe to yield."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:645
msgid "Call ``fiber_object:join()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:647
msgid "Usually ``fiber_object:join()`` should be called, otherwise the fiber's status may become 'suspended' when the fiber function ends, instead of 'dead'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:651
msgid "the boolean value that changes the ``set_joinable`` flag"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:658
#: ../doc/2.2/reference/reference_lua/fiber.rst:708
msgid "The result of the following sequence of requests is:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:660
msgid "the global variable ``d`` will be 6 (which proves that the function was not executed until after ``d`` was set to 1, when ``fiber.sleep(1)`` caused a yield);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:663
msgid "``fiber.status(fi2)`` will be 'suspended' (which proves that after the function was executed the fiber status did not change to 'dead')."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:666
msgid "fiber=require('fiber')\n"
"d=0\n"
"function fu2() d=d+5 end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true) d=1 fiber.sleep(1)\n"
"print(d)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:679
msgid "\"Join\" a joinable fiber. That is, let the fiber's function run and wait until the fiber's status is 'dead' (normally a status becomes 'dead' when the function execution finishes). Joining will cause a yield, therefore, if the fiber is currently in a suspended state, execution of its fiber function will resume."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:687
msgid "This kind of waiting is more convenient than going into a loop and periodically checking the status; however, it works only if the fiber was created with :ref:`fiber.new() <fiber-new>` and was made joinable with :ref:`fiber_object:set_joinable() <fiber_object-set_joinable>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:694
msgid "two values. The first value is boolean. If the first value is true, then the join succeeded because the fiber's function ended normally and the second result has the return value from the fiber's function. If the first value is false, then the join succeeded because the fiber's function ended abnormally and the second result has the details about the error, which one can unpack in the same way that one unpacks :ref:`a pcall result <error_handling>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:704
msgid "boolean +result type, or boolean + struct error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:710
msgid "the first ``fiber.status()`` call returns 'suspended',"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:711
msgid "the ``join()`` call returns true,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:712
msgid "the elapsed time is usually 5 seconds, and"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:713
msgid "the second ``fiber.status()`` call returns 'dead'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:715
msgid "This proves that the ``join()`` does not return until the function -- which sleeps 5 seconds -- is 'dead'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:718
msgid "fiber=require('fiber')\n"
"function fu2() fiber.sleep(5) end\n"
"fi2=fiber.new(fu2) fi2:set_joinable(true)\n"
"start_time = os.time()\n"
"fiber.status(fi2)\n"
"fi2:join()\n"
"print('elapsed = ' .. os.time() - start_time)\n"
"fiber.status(fi2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:733
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:737
#: ../doc/2.2/reference/reference_lua/fiber.rst:756
msgid "num"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:741
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:753
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:760
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:772
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop. Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:777
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:790
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:793
msgid "tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:801
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:803
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:809
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:814
msgid "tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:821
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:826
msgid "tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:842
msgid "Channels"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:844
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:847
msgid "Call the other routines, via channel, to send messages, receive messages, or check channel status."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:850
msgid "Message exchange is synchronous. The Lua garbage collector will mark or free the channel when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:859
msgid "Create a new communication channel."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:861
msgid "the maximum number of slots (spaces for ``channel:put`` messages) that can be in use at once. The default is 0."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:865
msgid "new channel."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:866
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:874
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` waits until there is a free slot in the channel."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:877
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:878
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:879
msgid "If timeout is specified, and there is no free slot in the channel for the duration of the timeout, then the return value is ``false``. If the channel is closed, then the return value is ``false``. Otherwise, the return value is ``true``, indicating success."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:889
msgid "Close the channel. All waiters in the channel will stop waiting. All following ``channel:get()`` operations will return ``nil``, and all following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:897
msgid "Fetch and remove a message from a channel. If the channel is empty, ``channel:get()`` waits for a message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:900
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:901
msgid "If timeout is specified, and there is no message in the channel for the duration of the timeout, then the return value is ``nil``. If the channel is closed, then the return value is ``nil``. Otherwise, the return value is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:906
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:912
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:914
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:921
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:923
msgid "the number of messages."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:930
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:932
msgid "``true`` if the channel is full (the number of messages in the channel equals the number of slots so there is no room for a new message). Otherwise ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:941
msgid "Check whether readers are waiting for a message because they have issued ``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:944
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:951
msgid "Check whether writers are waiting because they have issued ``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:954
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:961
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:969
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:973
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1039
msgid "Condition variables"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1041
msgid "Call ``fiber.cond()`` to create a named condition variable, which will be called 'cond' for examples in this section."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1044
msgid "Call ``cond:wait()`` to make a fiber wait for a signal via a condition variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1046
msgid "Call ``cond:signal()`` to send a signal to wake up a single fiber that has executed ``cond:wait()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1049
msgid "Call ``cond:broadcast()`` to send a signal to all fibers that have executed ``cond:wait()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1056
msgid "Create a new condition variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1058
msgid "new condition variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1067
msgid "Make the current fiber go to sleep, waiting until another fiber invokes the ``signal()`` or ``broadcast()`` method on the cond object. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1071
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1072
msgid "If timeout is provided, and a signal doesn't happen for the duration of the timeout, ``wait()`` returns false. If a signal or broadcast happens, ``wait()`` returns true."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1081
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1090
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1098
msgid "Assume that a tarantool instance is running and listening for connections on localhost port 3301. Assume that guest users have privileges to connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1102
msgid "On terminal #1, say"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1104
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1111
msgid "The job will hang because ``cond:wait()`` -- without an optional timeout argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1114
msgid "On terminal #2, say"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1116
msgid "$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1121
msgid "Now look again at terminal #1. It will show that the waiting stopped, and the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fiber.rst:1124
msgid "This example depended on the use of a global conditional variable with the arbitrary name ``cond``. In real life, programmers would make sure to use different conditional variable names for different applications."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:39
msgid "Module `fio`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:47
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:51
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:53
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:54
msgid "functions for :ref:`directory or file existence and type checks<fio-checks>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:55
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:56
msgid ":ref:`constants <fio-c>` which are the same as POSIX flag values (for example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:63
msgid "Below is a list of all ``fio`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:75
msgid ":ref:`fio.pathjoin() <fio-pathjoin>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:75
msgid "Form a path name from one or more partial strings"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:78
msgid ":ref:`fio.basename() <fio-basename>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:78
msgid "Get a file name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:81
msgid ":ref:`fio.dirname() <fio-dirname>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:81
msgid "Get a directory name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:84
msgid ":ref:`fio.abspath() <fio-abspath>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:84
msgid "Get a directory and file name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:87
msgid ":ref:`fio.path.exists() <fio-path_exists>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:87
#: ../doc/2.2/reference/reference_lua/fio.rst:99
msgid "Check if file or directory exists"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:90
msgid ":ref:`fio.path.is_dir() <fio-path_is_dir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:90
msgid "Check if file or directory is a directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:93
msgid ":ref:`fio.path.is_file() <fio-path_is_file>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:93
msgid "Check if file or directory is a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:96
msgid ":ref:`fio.path.is_link() <fio-path_is_link>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:96
msgid "Check if file or directory is a link"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:99
msgid ":ref:`fio.path.lexists() <fio-path_lexists>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:102
msgid ":ref:`fio.umask() <fio-umask>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:102
msgid "Set mask bits"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:105
msgid ":ref:`fio.lstat() <fio-stat>` |br| :ref:`fio.stat() <fio-stat>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:106
msgid "Get information about a file object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:110
msgid ":ref:`fio.mkdir() <fio-mkdir>` |br| :ref:`fio.rmdir() <fio-mkdir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:111
msgid "Create or delete a directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:115
msgid ":ref:`fio.chdir() <fio-chdir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:115
msgid "Change working directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:118
msgid ":ref:`fio.listdir() <fio-listdir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:118
msgid "List files in a directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:121
msgid ":ref:`fio.glob() <fio-glob>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:121
msgid "Get files whose names match a given string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:124
msgid ":ref:`fio.tempdir() <fio-tempdir>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:124
msgid "Get the name of a directory for storing temporary files"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:127
msgid ":ref:`fio.cwd() <fio-cwd>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:127
msgid "Get the name of the current working directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:130
msgid ":ref:`fio.copytree() <fio-copytree>` |br| :ref:`fio.mktree() <fio-mktree>` |br| :ref:`fio.rmtree() <fio-rmtree>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:133
msgid "Create and delete directories"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:137
msgid ":ref:`fio.link() <fio-link>` |br| :ref:`fio.symlink() <fio-link>` |br| :ref:`fio.readlink() <fio-link>` |br| :ref:`fio.unlink() <fio-link>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:140
msgid "Create and delete links"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:146
msgid ":ref:`fio.rename() <fio-rename>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:146
#: ../doc/2.2/reference/reference_lua/osmodule.rst:77
msgid "Rename a file or directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:149
msgid ":ref:`fio.utime() <fio-utime>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:149
msgid "Change file update time"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:152
msgid ":ref:`fio.copyfile() <fio-copyfile>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:152
msgid "Copy a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:155
msgid ":ref:`fio.chown() <fio-chown>` |br| :ref:`fio.chmod() <fio-chown>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:156
msgid "Manage rights to and ownership of file objects"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:160
msgid ":ref:`fio.truncate() <fio-truncate>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:160
msgid "Reduce the file size"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:163
msgid ":ref:`fio.sync() <fio-sync>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:163
msgid "Ensure that changes are written to disk"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:166
msgid ":ref:`fio.open() <fio-open>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:166
msgid "Open a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:169
msgid ":ref:`file-handle:close() <file_handle-close>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:169
msgid "Close a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:172
msgid ":ref:`file-handle:pread() <file_handle-pread>` |br| :ref:`file-handle:pwrite() <file_handle-pwrite>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:173
msgid "Perform random-access read or write on a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:177
msgid ":ref:`file-handle:read() <file_handle-read>` |br| :ref:`file-handle:write() <file_handle-write>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:178
msgid "Perform non-random-access read or write on a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:182
msgid ":ref:`file-handle:truncate() <file_handle-truncate>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:182
msgid "Change the size of an open file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:185
msgid ":ref:`file-handle:seek() <file_handle-seek>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:185
msgid "Change position in a file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:188
msgid ":ref:`file-handle:stat() <file_handle-stat>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:188
msgid "Get statistics about an open file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:191
msgid ":ref:`file-handle:fsync() <file_handle-fsync>` |br| :ref:`file-handle:fdatasync() <file_handle-fsync>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:192
msgid "Ensure that changes made to an open file are written to disk"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:196
msgid ":ref:`fio.c <fio-c_table>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:196
msgid "Table of constants similar to POSIX flag values"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:206
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:212
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:214
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:215
#: ../doc/2.2/reference/reference_lua/fio.rst:234
#: ../doc/2.2/reference/reference_lua/fio.rst:255
msgid "path name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:220
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:231
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:235
msgid "suffix"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:237
#: ../doc/2.2/reference/reference_lua/fio.rst:274
msgid "file name"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:242
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:253
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:257
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:262
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:272
msgid "Given a final part (the file name), return the full path name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:276
msgid "directory name, that is, path name including file name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:281
msgid "tarantool> fio.abspath('my.lua')\n"
"---\n"
"- 'path/to/my.lua'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:292
msgid "Directory or file existence and type checks"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:294
msgid "Functions in this section are similar to some `Python os.path <https://docs.python.org/2/library/os.path.htmll>`_ functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:302
#: ../doc/2.2/reference/reference_lua/fio.rst:310
#: ../doc/2.2/reference/reference_lua/fio.rst:318
#: ../doc/2.2/reference/reference_lua/fio.rst:326
#: ../doc/2.2/reference/reference_lua/fio.rst:334
msgid "path to directory or file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:303
msgid "true if path-name refers to a directory or file that exists and is not a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:311
msgid "true if path-name refers to a directory; otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:319
msgid "true if path-name refers to a file; otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:327
msgid "true if path-name refers to a symbolic link; otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:335
msgid "true if path-name refers to a directory or file that exists or is a broken symbolic link; otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:342
msgid "Common file manipulations"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:348
msgid "Set the mask bits used when creating files or directories. For a detailed description type ``man 2 umask``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:351
msgid "mask bits."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:352
msgid "previous mask bits."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:357
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:369
msgid "Returns information about a file object. For details type ``man 2 lstat`` or ``man 2 stat``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:372
msgid "path name of file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:373
msgid "(If no error) table of fields which describe the file's block size, creation time, size, and other attributes. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:376
msgid "table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:378
msgid "Additionally, the result of ``fio.stat('file-name')`` will include methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:381
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:382
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:383
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:384
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:385
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:386
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:387
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:389
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:393
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:419
msgid "Create or delete a directory. For details type ``man 2 mkdir`` or ``man 2 rmdir``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:422
#: ../doc/2.2/reference/reference_lua/fio.rst:446
#: ../doc/2.2/reference/reference_lua/fio.rst:466
msgid "path of directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:423
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:426
#: ../doc/2.2/reference/reference_lua/fio.rst:546
#: ../doc/2.2/reference/reference_lua/fio.rst:568
#: ../doc/2.2/reference/reference_lua/fio.rst:643
#: ../doc/2.2/reference/reference_lua/fio.rst:667
#: ../doc/2.2/reference/reference_lua/fio.rst:690
#: ../doc/2.2/reference/reference_lua/fio.rst:738
msgid "(If no error) true. |br| (If error) two return values: false, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:432
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:443
msgid "Change working directory. For details type ``man 2 chdir``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:447
msgid "(If success) true. (If failure) false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:452
msgid "tarantool> fio.chdir('/etc')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:463
msgid "List files in directory. The result is similar to the result from the ``ls`` command."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:467
msgid "(If no error) a list of files. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:473
msgid "tarantool> fio.listdir('/usr/lib/tarantool')\n"
"---\n"
"- - mysql\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:484
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: ``GLOB_NOESCAPE``. For details type ``man 3 glob``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:488
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:489
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:492
#: ../doc/2.2/reference/reference_lua/fio.rst:822
#: ../doc/2.2/reference/reference_lua/fio.rst:1055
msgid "**Possible errors:** nil."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:496
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:509
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:513
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:524
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:528
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:539
msgid "Copy everything in the from-path, including subdirectory contents, to the to-path. The result is similar to the result that one gets from the ``cp -r`` command. The to-path should be empty."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:544
#: ../doc/2.2/reference/reference_lua/fio.rst:545
#: ../doc/2.2/reference/reference_lua/fio.rst:567
#: ../doc/2.2/reference/reference_lua/fio.rst:590
msgid "path-name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:552
msgid "tarantool> fio.copytree('/home/original','/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:563
msgid "Create the path, including subdirectories, but without file contents. The result is similar to the result that one gets from the ``mkdir`` command."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:574
msgid "tarantool> fio.mktree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:585
msgid "Remove the directory indicated by path-name, including subdirectories. The result is similar to the result that one gets from the ``rmdir`` command, recursively. The directory must be empty."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:591
msgid "(If no error) true. |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:597
msgid "tarantool> fio.rmtree('/home/archives')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:611
msgid "Functions to create and delete links. For details type ``man readlink``, ``man 2 link``, ``man 2 symlink``, ``man 2 unlink``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:614
msgid "existing file name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:615
msgid "linked name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:617
msgid "(If no error) ``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true, ``fio.readlink`` returns the link value. |br| (If error) two return values: false|null, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:623
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:638
msgid "Rename a file or directory. For details type ``man 2 rename``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:640
msgid "original name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:641
msgid "new name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:649
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:660
msgid "Change the access time and possibly also change the update time of a file. For details type ``man 2 utime``. Times should be expressed as number of seconds since the epoch."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:663
msgid "name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:664
msgid "time of last access. default current time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:665
msgid "time of last update. default = access time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:673
msgid "tarantool> fio.utime('/home/username/tmp.txt')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:684
msgid "Copy a file. The effect is similar to the effect that one gets with the ``cp`` command."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:687
msgid "path to original file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:688
msgid "path to new file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:696
msgid "tarantool> fio.copyfile('/home/user/tmp.txt', '/home/usern/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:708
msgid "Manage the rights to file objects, or ownership of file objects. For details type ``man 2 chown`` or ``man 2 chmod``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:711
msgid "new user uid."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:712
msgid "new group uid."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:713
msgid "new permissions"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:718
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:733
msgid "Reduce file size to a specified value. For details type ``man 2 truncate``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:744
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:755
msgid "Ensure that changes are written to disk. For details type ``man 2 sync``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:757
#: ../doc/2.2/reference/reference_lua/fio.rst:858
#: ../doc/2.2/reference/reference_lua/fio.rst:917
#: ../doc/2.2/reference/reference_lua/fio.rst:1002
#: ../doc/2.2/reference/reference_lua/fio.rst:1029
#: ../doc/2.2/reference/reference_lua/fio.rst:1109
msgid "true if success, false if failure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:762
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:777
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:779
msgid "Full path to the file to open."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:780
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:  * O_APPEND (start at end of file), * O_ASYNC (signal when IO is possible), * O_CLOEXEC (enable a flag related to closing), * O_CREAT (create file if it doesn't exist), * O_DIRECT (do less caching or no caching), * O_DIRECTORY (fail if it's not a directory), * O_EXCL (fail if file cannot be created), * O_LARGEFILE (allow 64-bit file offsets), * O_NOATIME (no access-time updating), * O_NOCTTY (no console tty), * O_NOFOLLOW (no following symbolic links), * O_NONBLOCK (no blocking), * O_PATH (get a path for low-level use), * O_SYNC (force writing if it's possible), * O_TMPFILE (the file will be temporary and nameless), * O_TRUNC (truncate)  ... and, always, one of:  * O_RDONLY (read only), * O_WRONLY (write only), or * O_RDWR (either read or write)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:780
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces. On Linux the full set of flags as described on the `Linux man page <http://man7.org/linux/man-pages/man2/open.2.html>`_ is:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:789
msgid "O_APPEND (start at end of file),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:790
msgid "O_ASYNC (signal when IO is possible),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:791
msgid "O_CLOEXEC (enable a flag related to closing),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:792
msgid "O_CREAT (create file if it doesn't exist),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:793
msgid "O_DIRECT (do less caching or no caching),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:794
msgid "O_DIRECTORY (fail if it's not a directory),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:795
msgid "O_EXCL (fail if file cannot be created),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:796
msgid "O_LARGEFILE (allow 64-bit file offsets),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:797
msgid "O_NOATIME (no access-time updating),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:798
msgid "O_NOCTTY (no console tty),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:799
msgid "O_NOFOLLOW (no following symbolic links),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:800
msgid "O_NONBLOCK (no blocking),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:801
msgid "O_PATH (get a path for low-level use),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:802
msgid "O_SYNC (force writing if it's possible),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:803
msgid "O_TMPFILE (the file will be temporary and nameless),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:804
msgid "O_TRUNC (truncate)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:806
msgid "... and, always, one of:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:808
msgid "O_RDONLY (read only),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:809
msgid "O_WRONLY (write only), or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:810
msgid "O_RDWR (either read or write)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:812
msgid "Mode bits can be passed as a number or as string constants, for example ``S_IWUSR``. Mode bits are significant if flags include ``O_CREAT`` or ``O_TMPFILE``. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:817
msgid "(If no error) file handle (abbreviated as 'fh' in later description). |br| (If error) two return values: null, error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:824
#: ../doc/2.2/reference/reference_lua/http.rst:213
msgid "**Example 1:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:826
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:836
#: ../doc/2.2/reference/reference_lua/http.rst:242
msgid "**Example 2:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:838
msgid "Using ``fio.open()`` with ``tonumber('N', 8)`` to set permissions as an octal number:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:841
msgid "tarantool> fio.open('x.txt', {'O_WRONLY', 'O_CREAT'}, tonumber('644',8))\n"
"---\n"
"- fh: 12\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:854
msgid "Close a file that was opened with ``fio.open``. For details type ``man 2 close``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:857
#: ../doc/2.2/reference/reference_lua/fio.rst:879
#: ../doc/2.2/reference/reference_lua/fio.rst:912
#: ../doc/2.2/reference/reference_lua/fio.rst:953
#: ../doc/2.2/reference/reference_lua/fio.rst:998
#: ../doc/2.2/reference/reference_lua/fio.rst:1028
#: ../doc/2.2/reference/reference_lua/fio.rst:1048
#: ../doc/2.2/reference/reference_lua/fio.rst:1074
#: ../doc/2.2/reference/reference_lua/fio.rst:1108
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:863
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:875
msgid "Perform random-access read operation on a file, without affecting the current seek position of the file. For details type ``man 2 pread``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:880
msgid "where to read into (if the format is ``pread(buffer, count, offset)``)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:882
#: ../doc/2.2/reference/reference_lua/fio.rst:956
msgid "number of bytes to read"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:883
msgid "offset within file where reading begins"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:885
msgid "If the format is ``pread(count, offset)`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:888
msgid "If the format is ``pread(buffer, count, offset)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:894
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:908
msgid "Perform random-access write operation on a file, without affecting the current seek position of the file. For details type ``man 2 pwrite``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:913
#: ../doc/2.2/reference/reference_lua/fio.rst:999
msgid "value to write"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:914
msgid "number of bytes to write (if the format is ``pwrite(buffer, count, offset)``)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:916
msgid "offset within file where writing begins"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:920
msgid "If the format is ``pwrite(new-string, offset)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:923
msgid "If the format is ``pwrite(buffer, count, offset)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:927
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:pwrite(ibuf, 1, 0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:943
msgid "Perform non-random-access read on a file. For details type ``man 2 read`` or ``man 2 write``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:948
#: ../doc/2.2/reference/reference_lua/fio.rst:993
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:954
msgid "where to read into (if the format is ``read(buffer, count)``)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:958
msgid "If the format is ``read()`` -- omitting ``count`` -- then read all bytes in the file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:961
msgid "If the format is ``read()``  or ``read([count])`` then return a string containing the data that was read from the file, or nil if failure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:964
msgid "If the format is ``read(buffer, count)`` then return the data to the buffer. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:968
msgid "ibuf = require('buffer').ibuf()\n"
"---\n"
"...\n"
"\n"
"tarantool> fh:read(ibuf:reserve(5), 5)\n"
"---\n"
"- 5\n"
"...\n"
"\n"
"tarantool> require('ffi').string(ibuf:alloc(5),5)\n"
"---\n"
"- abcde"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:988
msgid "Perform non-random-access write on a file. For details type ``man 2 write``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1000
msgid "number of bytes to write (if the format is ``write(buffer, count)``)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1005
msgid "If the format is ``write(new-string)`` then the returned string is written to the file, as far as the end of the string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1008
msgid "If the format is ``write(buffer, count)`` then the buffer contents are written to the file, for ``count`` bytes. (Buffers can be acquired with :ref:`buffer.ibuf <buffer-module>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1014
msgid "tarantool> fh:write(\"new data\")\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1025
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1034
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1045
msgid "Shift position in the file to the specified position. For details type ``man 2 seek``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1049
msgid "position to seek to"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1050
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1052
msgid "the new position if success"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1059
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1070
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type ``man 2 stat``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1075
msgid "details about the file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1080
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1104
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type ``man 2 fsync`` or ``man 2 fdatasync``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1113
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1124
msgid "FIO constants"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1130
msgid "Table with constants which are the same as POSIX flag values on the target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fio.rst:1135
msgid "tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fun.rst:39
msgid "Module `fun`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fun.rst:41
msgid "Luafun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as ``map``, ``filter``, ``reduce``, ``zip`` -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/2.2/reference/reference_lua/fun.rst:51
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual ``require`` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the ``require`` request. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/fun.rst:57
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:39
msgid "Module `http`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:47
msgid "The ``http`` module, specifically the ``http.client`` submodule, provides the functionality of an HTTP client with support for HTTPS and keepalive. It uses routines in the `libcurl <https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:55
msgid "Below is a list of all ``http`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:65
msgid ":ref:`http.client.new() <http-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:65
msgid "Create an HTTP client instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:68
msgid ":ref:`client_object:request() <client_object-request>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:68
msgid "Perform an HTTP request"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:71
msgid ":ref:`client_object:stat() <client_object-stat>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:71
msgid "Get a table with statistics"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:79
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:81
msgid "the maximum number of entries in the connection cache."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:83
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:88
msgid "tarantool> http_client = require('http.client').new({max_connections = 5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:100
msgid "If ``http_client`` is an HTTP client instance, ``http_client:request()`` will perform an HTTP request and, if there is a successful connection, will return a table with connection information."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:104
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:105
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:106
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:107
msgid "table of connection options, with any of these components:   * ``timeout`` - number of seconds to wait for a curl API read request    before timing out  * ``ca_path`` - path to a directory holding one or more certificates to    verify the peer with  * ``ca_file`` - path to an SSL certificate file to verify the peer with  * ``verify_host`` - set on/off verification of the certificate's name    (CN) against host. See also    `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_  * ``verify_peer`` - set on/off verification of the peer's SSL    certificate. See also    `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_  * ``ssl_key`` - path to a private key file for a TLS and SSL client    certificate. See also    `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_  * ``ssl_cert`` - path to a SSL client certificate file. See also    `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_  * ``headers`` - table of HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the operating system    will wait while the connection is idle before sending keepalive    probes. See also    `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_    and the note below about keepalive_interval.  * ``keepalive_interval`` - the interval, in seconds, that the operating    system will wait between sending keepalive probes. See also    `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_.    If both keepalive_idle and keepalive_interval are set, then    Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive    and Keep-Alive:timeout=<keepalive_idle>.    Otherwise Tarantool will send Connection:close  * ``low_speed_time`` - set the \"low speed time\" -- the time that the    transfer speed should be below the \"low speed limit\" for the library    to consider it too slow and abort. See also    `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * ``low_speed_limit`` - set the \"low speed limit\" -- the average    transfer speed in bytes per second that the transfer should be below    during \"low speed time\" seconds for the library to consider it to be    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * ``verbose`` - set on/off verbose mode  * ``unix_socket`` - a socket name to use instead of an Internet address,    for a local connection. The Tarantool server must be built with    ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>`    later in this section.  * ``max_header_name_len`` - the maximal length of a header name. If a header    name is bigger than this value, it is truncated to this length.    The default value is '32'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:107
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:110
msgid "``timeout`` - number of seconds to wait for a curl API read request before timing out"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:112
msgid "``ca_path`` - path to a directory holding one or more certificates to verify the peer with"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:114
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:115
msgid "``verify_host`` - set on/off verification of the certificate's name (CN) against host. See also `CURLOPT_SSL_VERIFYHOST <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:118
msgid "``verify_peer`` - set on/off verification of the peer's SSL certificate. See also `CURLOPT_SSL_VERIFYPEER <https://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:121
msgid "``ssl_key`` - path to a private key file for a TLS and SSL client certificate. See also `CURLOPT_SSLKEY <https://curl.haxx.se/libcurl/c/CURLOPT_SSLKEY.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:124
msgid "``ssl_cert`` - path to a SSL client certificate file. See also `CURLOPT_SSLCERT <https://curl.haxx.se/libcurl/c/CURLOPT_SSLCERT.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:126
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:127
msgid "``keepalive_idle`` - delay, in seconds, that the operating system will wait while the connection is idle before sending keepalive probes. See also `CURLOPT_TCP_KEEPIDLE <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPIDLE.html>`_ and the note below about keepalive_interval."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:132
msgid "``keepalive_interval`` - the interval, in seconds, that the operating system will wait between sending keepalive probes. See also `CURLOPT_TCP_KEEPINTVL <https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPINTVL.html>`_. If both keepalive_idle and keepalive_interval are set, then Tarantool will also set HTTP keepalive headers: Connection:Keep-Alive and Keep-Alive:timeout=<keepalive_idle>. Otherwise Tarantool will send Connection:close"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:139
msgid "``low_speed_time`` - set the \"low speed time\" -- the time that the transfer speed should be below the \"low speed limit\" for the library to consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:143
msgid "``low_speed_limit`` - set the \"low speed limit\" -- the average transfer speed in bytes per second that the transfer should be below during \"low speed time\" seconds for the library to consider it to be too slow and abort. See also `CURLOPT_LOW_SPEED_LIMIT <https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:148
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:149
msgid "``unix_socket`` - a socket name to use instead of an Internet address, for a local connection. The Tarantool server must be built with ``libcurl`` 7.40 or later. See the :ref:`second example <http-example2>` later in this section."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:153
msgid "``max_header_name_len`` - the maximal length of a header name. If a header name is bigger than this value, it is truncated to this length. The default value is '32'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:157
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:159
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:160
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:161
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:162
msgid "``body`` - response body"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:163
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:167
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:169
msgid "``http_client:get(url, options)`` - shortcut for ``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:171
msgid "``http_client:post (url, body, options)`` - shortcut for ``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:173
msgid "``http_client:put(url, body, options)`` - shortcut for ``http_client:request(\"PUT\", url, body, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:175
msgid "``http_client:patch(url, body, options)`` - shortcut for ``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:177
msgid "``http_client:options(url, options)`` - shortcut for ``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:179
msgid "``http_client:head(url, options)`` - shortcut for ``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:181
msgid "``http_client:delete(url, options)`` - shortcut for ``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:183
msgid "``http_client:trace(url, options)`` - shortcut for ``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:185
msgid "``http_client:connect:(url, options)`` - shortcut for ``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:188
msgid "Requests may be influenced by environment variables, for example users can set up an http proxy by setting :samp:`HTTP_PROXY={proxy}` before initiating any requests. See the web page document `Environment variables libcurl understands <https://curl.haxx.se/libcurl/c/libcurl-env.html>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:198
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:200
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:201
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:202
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:203
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:204
msgid "``http_200_responses`` - total number of requests which have returned code HTTP 200"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:206
msgid "``http_other_responses`` - total number of requests which have not returned code HTTP 200"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:208
msgid "``failed_requests`` - total number of requests which have failed including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:215
msgid "Connect to an HTTP server, look at the size of the response for a 'GET' request, and look at the statistics for the session."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:218
msgid "tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:244
msgid "Start two Tarantool instances on the same computer."
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:246
msgid "On the first Tarantool instance, listen on a Unix socket:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:248
msgid "box.cfg{listen='/tmp/unix_domain_socket.sock'}"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:252
msgid "On the second Tarantool instance, send via ``http_client``:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:254
msgid "box.cfg{}\n"
"http_client = require('http.client').new({5})\n"
"http_client:put('http://localhost/','body',{unix_socket = '/tmp/unix_domain_socket.sock'})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/http.rst:260
msgid "Terminal #1 will show an error message: \"Invalid MsgPack\". This is not useful but demonstrates the syntax and demonstrates that was sent was received."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:39
msgid "Module `iconv`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:47
msgid "The ``iconv`` module provides a way to convert a string with one encoding to a string with another encoding, for example from ASCII to UTF-8. It is based on the POSIX iconv routines."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:51
msgid "An exact list of the available encodings may depend on environment. Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, and about 100 others. For a complete list, type ``iconv --list`` on a terminal."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:60
msgid "Below is a list of all ``iconv`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:70
msgid ":ref:`iconv.new() <iconv-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:70
msgid "Create an iconv instance"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:73
msgid ":ref:`iconv.converter() <iconv-converter>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:73
msgid "Perform conversion on a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:81
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:83
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:84
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:86
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:89
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:93
msgid "tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:103
msgid "Convert."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:0
msgid "param string input-string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:105
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:107
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:109
msgid "If anything in input-string cannot be converted, there will be an error message and the result string will be unchanged."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:114
msgid "We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER DE) is hexadecimal 0414 according to the character database of Unicode_. Therefore that is what it will look like in UTF-16. We know that Tarantool typically uses the UTF-8 character set. So make a from-UTF-8-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks like in the UTF-8 source, and use string.hex('Д'-after-conversion) to show what it looks like in the UTF-16 target. Since the result is 0414, we see that iconv conversion works."
msgstr ""

#: ../doc/2.2/reference/reference_lua/iconv.rst:123
msgid "tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/index.rst:37
msgid "Built-in modules reference"
msgstr ""

#: ../doc/2.2/reference/reference_lua/index.rst:41
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/index.rst:45
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/index.rst:49
msgid "List of Lua modules"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:39
msgid "Module `json`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:45
msgid "The ``json`` module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford <http://www.kyne.com.au/~mark/software/lua-cjson.php>`_. For a complete manual on Lua-CJSON please read `the official documentation <http://www.kyne.com.au/~mark/software/lua-cjson-manual.html>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:54
msgid "Below is a list of all ``json`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:64
msgid ":ref:`json.encode() <json-encode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:64
msgid "Convert a Lua object to a JSON string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:67
msgid ":ref:`json.decode() <json-decode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:67
msgid "Convert a JSON string to a Lua object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:70
msgid ":ref:`json.NULL <json-null>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:70
#: ../doc/2.2/reference/reference_lua/msgpack.rst:73
#: ../doc/2.2/reference/reference_lua/yaml.rst:68
msgid "Analog of Lua's \"nil\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:73
msgid ":ref:`json.cfg() <json-module_cfg>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:73
msgid "Set global flags"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:83
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:85
#: ../doc/2.2/reference/reference_lua/msgpack.rst:94
#: ../doc/2.2/reference/reference_lua/yaml.rst:80
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:86
#: ../doc/2.2/reference/reference_lua/json.rst:125
msgid "see :ref:`json.cfg <json-module_cfg>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:87
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:92
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:122
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:124
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:126
#: ../doc/2.2/reference/reference_lua/yaml.rst:91
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:131
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:149
msgid "See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>` to see how ``json.decode()`` can fit in an application."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:157
#: ../doc/2.2/reference/reference_lua/msgpack.rst:145
#: ../doc/2.2/reference/reference_lua/yaml.rst:98
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:162
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:184
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:186
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:187
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:189
#: ../doc/2.2/reference/reference_lua/yaml.rst:135
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:192
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:215
msgid "Set values affecting behavior of :ref:`json.encode <json-encode>` and :ref:`json.decode <json-decode>`. The values are all either integers or boolean ``true``/``false`` values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:219
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:220
msgid "``cfg.encode_use_tostring`` (default is false) -- use tostring for unrecognizable types"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:222
#: ../doc/2.2/reference/reference_lua/json.rst:236
msgid "``cfg.encode_invalid_as_nil`` (default is false) -- use null for all unrecognizable types"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:224
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:225
msgid "``cfg.encode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:226
msgid "``cfg.encode_number_precision`` (default is 14) -- maximum post-decimal digits"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:227
msgid "``cfg.encode_sparse_ratio`` (default is 2) -- how sparse an array can be"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:228
msgid "``cfg.encode_sparse_safe`` (default is 10) -- how much can safely be sparse"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:229
msgid "``cfg.encode_use_tostring`` (default is false) -- use ``tostring`` for unrecognizable types"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:231
msgid "``cfg.decode_save_metatables`` (default is true) -- like ``encode_load_metatables``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:232
msgid "``cfg.decode_sparse_convert`` (default is true) -- like ``encode_sparse_convert``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:233
msgid "``cfg.decode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:234
msgid "``cfg.decode_use_tostring`` (default is false) -- use tostring for unrecognizable types"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:238
msgid "``cfg.decode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:239
msgid "``cfg.decode_max_depth`` (default is 32) -- maximum nesting depth in a structure"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:241
msgid "For example, the following code will encode 0/0 as nan (\"not a number\") and 1/0 as inf (\"infinity\"), rather than returning nil or an error message:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:244
msgid "json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:252
msgid "The result of the ``json.encode()`` request will look like this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:254
msgid "tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:261
msgid "To achieve the same effect for only one call to ``json.encode()`` without changing the configuration persistently, one could say ``json.encode({1, x, y, 2}, {encode_invalid_numbers = true})``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/json.rst:265
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:39
msgid "Module `key_def`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:43
msgid "The `key_def` module has a function for making a definition of the field numbers and types of a tuple. The definition is usually used in conjunction with an index definition to extract or compare the index key values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:52
msgid "Create a new key_def instance."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:54
msgid "field numbers and types. There must be at least one part and it must have at least fieldno and type."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:0
#: ../doc/2.2/reference/reference_lua/xlog.rst:0
msgid "returns"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:58
msgid "key_def-object :ref:`a key_def object <key_def-object>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:60
msgid "The parts table has components which are the same as the ``parts`` option in :ref:`Options for space_object:create_index() <box_space-create_index-options>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:64
msgid "fieldno (integer) for example fieldno=1"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:66
msgid "type (string) for example type='string'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:68
msgid "Other components are optional."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:70
msgid "Example: ``key_def.new({{type = 'unsigned', fieldno = 1}})``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:76
msgid "A key_def object is an object returned by :ref:`key_def.new() <key_def-new>`. It has methods :ref:`extract_key() <key_def-extract_key>`, :ref:`compare() <key_def-compare>`, :ref:`compare_with_key() <key_def-compare_with_key>`, :ref:`merge() <key_def-merge>`, :ref:`totable() <key_def-totable>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:88
msgid "Return a tuple containing only the fields of the key_def object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:90
#: ../doc/2.2/reference/reference_lua/key_def.rst:165
#: ../doc/2.2/reference/reference_lua/key_def.rst:166
#: ../doc/2.2/reference/reference_lua/key_def.rst:191
#: ../doc/2.2/reference/reference_lua/key_def.rst:192
#: ../doc/2.2/reference/reference_lua/merger.rst:194
msgid "tuple or Lua table with field contents"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:92
msgid "the fields that were defined for the key_def object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:96
msgid "-- Suppose that an item has five fields\n"
"-- 1, 99.5, 'X', nil, 99.5\n"
"-- and the fields that we care about are\n"
"-- #3 (a string) and #1 (an integer).\n"
"-- We can define those fields with k = key_def.new\n"
"-- and extract the values with k:extract_key.\n"
"\n"
"tarantool> key_def = require('key_def')\n"
"---\n"
"...\n"
"\n"
"tarantool> k = key_def.new({{type = 'string', fieldno = 3},\n"
">                           {type = 'unsigned', fieldno =1 }})\n"
"---\n"
"...\n"
"\n"
"tarantool> k:extract_key({1, 99.5, 'X', nil, 99.5})\n"
"---\n"
"- ['X', 1]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:121
msgid "-- Now suppose that the item is a tuple in a space which\n"
"-- has an index on field #3 plus field #1.\n"
"-- We can use key_def.new with the index definition\n"
"-- instead of filling it out as we did with Example #1.\n"
"-- The result will be the same.\n"
"key_def = require('key_def')\n"
"box.schema.space.create('T')\n"
"i = box.space.T:create_index('I',{parts={3,'string',1,'unsigned'}})\n"
"box.space.T:insert{1, 99.5, 'X', nil, 99.5}\n"
"k = key_def.new(i.parts)\n"
"k:extract_key(box.space.T:get({'X', 1}))"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:135
msgid "**Example #3**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:137
msgid "-- Iterate through the tuples in a secondary non-unique index.\n"
"-- extracting the tuples' primary-key values so they can be deleted\n"
"-- using a unique index. This code should be part of a Lua function.\n"
"local key_def_lib = require('key_def')\n"
"local s = box.schema.space.create('test')\n"
"local pk = s:create_index('pk')\n"
"local sk = s:create_index('test', {unique = false, parts = {\n"
"    {2, 'number', path = 'a'}, {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"local key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1})) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:159
msgid "Compare the key fields of tuple_1 to the key fields of tuple_2. This is a tuple-by-tuple comparison so users do not have to write code which compares a field at a time. Each field's type and collation wll be taken into account. In effect it is a comparison of extract_key(tuple_1) with extract_key(tuple_2)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:168
msgid "> 0 if tuple_1 key fields > tuple_2 key fields, = 0 if tuple_1 key fields = tuple_2 key fields, < 0 if tuple_1 key fields < tuple_2 key fields"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:174
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare({1, 99.5, 'X', nil, 99.5}, {1, 99.5, 'x', nil, 99.5})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:186
msgid "Compare the key fields of tuple_1 to all the fields of tuple_2. This is the same as :ref:`key_def_object:compare() <key_def-compare>` except that tuple_2 contains only the key fields. In effect it is a comparison of extract_key(tuple_1) with tuple_2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:194
msgid "> 0 if tuple_1 key fields > tuple_2 fields, = 0 if tuple_1 key fields = tuple_2 fields, < 0 if tuple_1 key fields < tuple_2 fields"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:200
msgid "-- This will return 0\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type='string',fieldno=3,collation='unicode_ci'},\n"
"                 {type='unsigned',fieldno=1}})\n"
"k:compare_with_key({1, 99.5, 'X', nil, 99.5}, {'x', 1})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:212
msgid "Combine the main key_def_object with other_key_def_object. The return value is a new key_def_object containing all the fields of the main key_def_object, then all the fields of other_key_def_object which are not in the main key_def_object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:217
msgid "definition of fields to add"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:219
msgid "key_def_object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:223
msgid "-- This will return a key definition with fieldno=3 and fieldno=1.\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k2= key_def.new({{type = 'unsigned', fieldno = 1},\n"
"                 {type = 'string', fieldno = 3}})\n"
"k:merge(k2)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:236
msgid "Return a table containing what is in the key_def_object. This is the reverse of ``key_def.new()`` -- ``key_def.new()`` takes a table and returns a key_def object, ``key_def_object:totable()`` takes a key_def object and returns a table. This is useful for input to ``_serialize`` methods."
msgstr ""

#: ../doc/2.2/reference/reference_lua/key_def.rst:246
msgid "-- This will return a table with type='string', fieldno=3\n"
"key_def = require('key_def')\n"
"k = key_def.new({{type = 'string', fieldno = 3}})\n"
"k:totable()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:39
msgid "Module `log`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:47
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the :samp:`log.{log_level_function_name}` function."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:52
msgid "As explained in the description of :ref:`log_format <cfg_logging-log_format>` configuration setting, there are two possible formats for log entries:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:82
msgid "Below is a list of all ``log`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:92
msgid ":ref:`log.error() <log-ug_message>` |br| :ref:`log.warn() <log-ug_message>` |br| :ref:`log.info() <log-ug_message>` |br| :ref:`log.verbose() <log-ug_message>` |br| :ref:`log.debug() <log-ug_message>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:96
msgid "Write a user-generated message to a log file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:103
msgid ":ref:`log.logger_pid() <log-logger_pid>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:103
msgid "Get the PID of a logger"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:106
msgid ":ref:`log.rotate() <log-rotate>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:106
msgid "Rotate a log file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:118
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-log>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``verbose`` or ``debug``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:122
msgid "As explained in the description of the configuration setting for :ref:`log_level <cfg_logging-log_level>`, there are seven levels of detail:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:126
msgid "2 – ``ERROR`` -- this corresponds to ``log.error(...)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:128
msgid "4 – ``WARNING``  -- this corresponds to ``log.warn(...)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:129
msgid "5 – ``INFO`` -- this corresponds to ``log.info(...)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:130
msgid "6 – ``VERBOSE``  -- this corresponds to ``log.verbose(...)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:131
msgid "7 – ``DEBUG`` -- this corresponds to ``log.debug(...)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:133
msgid "For example, if ``box.cfg.log_level`` is currently 5 (the default value), then ``log.error(...)``, ``log.warn(...)`` and ``log.info(...)`` messages will go to the log file. However, ``log.verbose(...)`` and ``log.debug(...)`` messages will not go to the log file, because they correspond to higher levels of detail."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:139
msgid "The actual output will be a line containing:  * the current timestamp, * a module name, * 'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and * ``message``.  Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`.  Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:139
msgid "The actual output will be a line containing:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:141
msgid "the current timestamp,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:142
msgid "a module name,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:143
msgid "'E', 'W', 'I', 'V' or 'D' depending on ``log_level_function_name``, and"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:144
msgid "``message``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:146
msgid "Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:150
msgid "Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if ``x`` is a number and ``y`` is a string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:160
msgid "PID of a logger"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:166
msgid "Rotate the log."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:174
msgid "$ tarantool\n"
"tarantool> box.cfg{log_level=3, log='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:183
msgid "$ less tarantool.txt\n"
"2017-09-20 ... [68617] main/101/interactive C> version 1.7.5-31-ge939c6ea6\n"
"2017-09-20 ... [68617] main/101/interactive C> log level 3\n"
"2017-09-20 ... [68617] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:190
msgid "The 'Error' line is visible in ``tarantool.txt`` preceded by the letter E."
msgstr ""

#: ../doc/2.2/reference/reference_lua/log.rst:192
msgid "The 'Info' line is not present because the ``log_level`` is 3."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:39
msgid "Module `merger`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:45
msgid "The ``merger`` module takes a stream of tuples and provides access to them as tables."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:52
msgid "The four functions for creating a merger object instance are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:54
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:55
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:56
msgid ":ref:`merger.new_table_source <merger-new_table_source>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:57
#: ../doc/2.2/reference/reference_lua/merger.rst:145
msgid ":ref:`merger.new(merger_source...) <merger-new_merger_source>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:59
msgid "The methods for using a merger object are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:61
msgid ":ref:`merger_object:select() <merger-select>`,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:62
#: ../doc/2.2/reference/reference_lua/merger.rst:150
msgid ":ref:`merger_object:pairs() <merger-pairs>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:70
msgid "Create a new merger instance from a tuple source."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:72
msgid "A tuple source just returns one tuple."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:74
msgid "The generator function ``gen()`` allows creation of multiple tuples via an iterator."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:77
msgid "The ``gen()`` function should return:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:79
msgid "state, tuple each time it is called and a new tuple is available,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:80
msgid "nil when no more tuples are available."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:82
msgid "function for iteratively returning tuples"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:83
msgid "parameter for the gen function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:85
#: ../doc/2.2/reference/reference_lua/merger.rst:129
msgid "merger-object :ref:`a merger object <merger-object>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:87
#: ../doc/2.2/reference/reference_lua/merger.rst:134
msgid "Example: see :ref:`merger_object:pairs() <merger-pairs>` method."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:93
msgid "Create a new merger instance from a buffer source."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:95
#: ../doc/2.2/reference/reference_lua/merger.rst:107
msgid "Parameters and return: same as for :ref:`merger.new_tuple_source <merger-new_tuple_source>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:98
msgid "To set up a buffer, or a series of buffers, use :ref:`the buffer module <buffer-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:105
msgid "Create a new merger instance from a table source."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:110
msgid "Example: see :ref:`merger_object:select() <merger-select>` method."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:116
msgid "Create a new merger instance from a merger source."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:118
msgid "A merger source is created from a :ref:`key_def <key_def-module>` object and a set of (tuple or buffer or table or merger) sources. It performs a kind of merge sort. It chooses a source with a minimal / maximal tuple on each step, consumes a tuple from this source, and repeats."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:125
msgid "object created with ``key_def``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:126
msgid "parameter for the ``gen()`` function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:127
msgid "``reverse=true`` if descending, false or nil if ascending"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:131
msgid "A ``key_def`` can be cached across requests with the same ordering rules (typically these would be requests accessing the same space)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:140
msgid "A merger object is an object returned by:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:142
msgid ":ref:`merger.new_tuple_source() <merger-new_tuple_source>` or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:143
msgid ":ref:`merger.new_buffer_source() <merger-new_buffer_source>` or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:144
msgid ":ref:`merger.new_table_source <merger-new_table_source>` or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:147
msgid "It has methods:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:149
msgid ":ref:`merger_object:select() <merger-select>` or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:156
msgid "Access the contents of a merger object with familiar ``select`` syntax."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:158
#: ../doc/2.2/reference/reference_lua/merger.rst:159
msgid "as in ``net.box`` client :ref:`conn:select <conn-select>` method"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:161
msgid "a table of tuples, similar to what ``select`` would return"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:163
msgid "**Example with new_table_source():**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:165
msgid "-- Source via new_table_source, simple generator function\n"
"-- tarantool> s:select()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger=require('merger')\n"
"k=0\n"
"function merger_function(param)\n"
"  k = k + 1\n"
"  if param[k] == nil then return nil end\n"
"  return box.NULL, param[k]\n"
"  end\n"
"chunks={}\n"
"chunks[1] = {{100}} chunks[2] = {{200}} chunks[3] = nil\n"
"s = merger.new_table_source(merger_function, chunks)\n"
"s:select()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:189
msgid "The ``pairs()`` method (or the equivalent ``ipairs() alias`` method) returns a luafun iterator. It is a Lua iterator, but also provides a set of handy methods to operate in functional style."
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:196
msgid "the tuples that can be found with a standard ``pairs()`` function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:198
msgid "**Example with new_tuple_source():**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:200
msgid "-- Source via new_tuple_source, from a space of tables\n"
"-- The result will look like this:\n"
"-- tarantool> so:pairs():totable()\n"
"-- ---\n"
"-- - - [100]\n"
"--   - [200]\n"
"-- ...\n"
"merger = require('merger')\n"
"box.schema.space.create('s')\n"
"box.space.s:create_index('i')\n"
"box.space.s:insert({100})\n"
"box.space.s:insert({200})\n"
"so = merger.new_tuple_source(box.space.s:pairs())\n"
"so:pairs():totable()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:217
msgid "**Example with two mergers:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:219
msgid "-- Source via key_def, and table data\n"
"\n"
"-- Create the key_def object\n"
"merger = require('merger')\n"
"key_def_lib = require('key_def')\n"
"key_def = key_def_lib.new({{\n"
"    fieldno = 1,\n"
"    type = 'string',\n"
"}})\n"
"-- Create the table source\n"
"data = {{'a'}, {'b'}, {'c'}}\n"
"source = merger.new_source_fromtable(data)\n"
"i1 = merger.new(key_def, {source}):pairs()\n"
"i2 = merger.new(key_def, {source}):pairs()\n"
"-- t1 will be 'a' (tuple 1 from merger 1)\n"
"t1 = i1:head():totable()\n"
"-- t3 will be 'c' (tuple 3 from merger 2)\n"
"t3 = i2:head():totable()\n"
"-- t2 will be 'b' (tuple 2 from merger 1)\n"
"t2 = i1:head():totable()\n"
"-- i1:is_null() will be true (merger 1 ends)\n"
"i1:is_null()\n"
"-- i2:is_null() will be true (merger 2 ends)\n"
"i2:is_null()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:246
msgid "**More examples:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/merger.rst:248
msgid "See `https://github.com/Totktonada/tarantool-merger-examples <https://github.com/Totktonada/tarantool-merger-examples>`_ which, in addition to discussing the merger API in detail, shows Lua code for handling many more situations than are in this manual's brief examples."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:39
msgid "Module `msgpack`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:45
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them. Tarantool makes heavy internal use of MsgPack because tuples in Tarantool are :ref:`stored <index-box_lua-vs-msgpack>` as MsgPack arrays."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:54
msgid "Below is a list of all ``msgpack`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:64
msgid ":ref:`msgpack.encode() <msgpack-encode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:64
msgid "Convert a Lua object to an MsgPack string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:67
msgid ":ref:`msgpack.decode() <msgpack-decode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:67
#: ../doc/2.2/reference/reference_lua/msgpack.rst:70
msgid "Convert a MsgPack string to a Lua object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:70
msgid ":ref:`msgpack.decode_unchecked() <msgpack-decode_unchecked>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:73
msgid ":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:76
msgid ":ref:`msgpack.decode_array_header <msgpack-decode_array_header>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:76
msgid "Skip array header in a MsgPack string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:79
msgid ":ref:`msgpack.decode_map_header <msgpack-decode_map_header>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:79
msgid "Skip map header in a MsgPack string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:82
msgid ":ref:`msgpack.cfg <msgpack-cfg>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:82
msgid "Change configuration"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:92
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:95
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:102
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:104
#: ../doc/2.2/reference/reference_lua/msgpack.rst:132
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:105
msgid "where to start, minimum = 1, maximum = string length, default = 1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:110
msgid "(if ``msgpack_string`` is in valid MsgPack format) the original contents of ``msgpack_string``, formatted as a Lua table, (otherwise) a scalar value, such as a string or a number;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:113
msgid "\"next_start_position\". If ``decode`` stops after parsing as far as byte N in ``msgpack_string``, then \"next_start_position\" will equal N + 1, and ``decode(msgpack_string, next_start_position)`` will continue parsing from where the previous ``decode`` stopped, plus 1. Normally ``decode`` parses all of ``msgpack_string``, so \"next_start_position\" will equal ``string.len(msgpack_string)`` + 1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:120
msgid "table and number"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:126
msgid "Convert a MsgPack string to a Lua object. Because checking is skipped, ``decode_unchecked()`` can operate with string pointers to buffers which ``decode()`` cannot handle. For an example see the :ref:`buffer <buffer-module>` module."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:136
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:137
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:139
msgid "lua object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:152
msgid "Call the mp_decode_array function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the array size and a pointer to the first array component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole array."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:156
#: ../doc/2.2/reference/reference_lua/msgpack.rst:184
msgid "a pointer to a byte array formatted as MsgPack."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:157
msgid "a number greater than or equal to the string's length"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:161
msgid "the size of the array;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:162
msgid "a pointer to after the array header."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:164
msgid "-- Example of decode_array_header\n"
"-- Suppose we have the raw data '\\x93\\x01\\x02\\x03'.\n"
"-- \\x93 is MsgPack encoding for a header of a three-item array.\n"
"-- We want to skip it and decode the next three items.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_array_header(ffi.cast('char*','\\x93\\x01\\x02\\x03'),4)\n"
"a=msgpack.decode(y,1);b=msgpack.decode(y+1,1);c=msgpack.decode(y+2,1);\n"
"a,b,c\n"
"-- The result will be: 1,2,3."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:180
msgid "Call the mp_decode_map function in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library and return the map size and a pointer to the first map component. A subsequent call to ``msgpack_decode`` can decode the component instead of the whole map."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:185
msgid "a number greater than or equal to the byte array's length"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:189
msgid "the size of the map;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:190
msgid "a pointer to after the map header."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:192
msgid "-- Example of decode_map_header\n"
"-- Suppose we have the raw data '\\x81\\xa2\\x41\\x41\\xc3'.\n"
"-- \\x81 is MsgPack encoding for a header of a one-item map.\n"
"-- We want to skip it and decode the next map item.\n"
"msgpack=require('msgpack'); ffi=require('ffi')\n"
"x,y=msgpack.decode_map_header(ffi.cast('char*','\\x81\\xa2\\x41\\x41\\xc3'),5)\n"
"a=msgpack.decode(y,3);b=msgpack.decode(y+3,1)\n"
"x,a,b\n"
"-- The result will be: 1,\"AA\", true."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:208
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:233
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:235
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:236
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:238
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:242
msgid "function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:262
msgid "**Result:**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:267
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:270
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:275
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:277
msgid "and the second encoding means:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:282
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:284
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:292
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:300
msgid "{}"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:300
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:303
msgid "'a'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:303
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:305
msgid "'false' = c2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:307
msgid "'true' = c3"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:309
msgid "127"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:309
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:311
msgid "65535"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:311
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:313
msgid "4294967295"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:313
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:315
msgid "'nil' = c0"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:317
msgid "same as nil"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:319
msgid "[0] = 5"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:319
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:322
msgid "[0] = nil"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:322
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:325
msgid "1.5"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:325
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:332
msgid "Some MsgPack configuration settings can be changed, in the same way that they can be changed for json. See :ref:`Module JSON <json-module_cfg>` for a list of some configuration settings. (The same configuration settings exist for json, for MsgPack, and for  :ref:`YAML <yaml-module>`.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:337
msgid "For example, if ``msgpack.cfg.encode_invalid_numbers = true`` (the default), then nan and inf are legal values. If that is not desirable, then ensure that ``msgpack.encode()`` will not accept them, by saying ``msgpack.cfg{encode_invalid_numbers = false}``, thus:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/msgpack.rst:342
msgid " tarantool> msgpack = require('msgpack'); msgpack.cfg{encode_invalid_numbers = true}\n"
" ---\n"
" ...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - [1, -nan, inf, false]\n"
" - 22\n"
" ...\n"
" tarantool> msgpack.cfg{encode_invalid_numbers = false}\n"
"---\n"
"...\n"
" tarantool> msgpack.decode(msgpack.encode{1, 0 / 0, 1 / 0, false})\n"
" ---\n"
" - error: ... number must not be NaN or Inf'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:39
msgid "Module `net.box`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:45
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other variant, which is discussed in this section, is for connecting to Tarantool server instances via a network."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:51
msgid "You can call the following methods:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:53
msgid "``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for examples in this section),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:55
msgid "``net_box.connect()`` to connect and get a connection object (named ``conn`` for examples in this section),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:57
msgid "other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote database system,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:59
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:61
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact that is perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. However for some cases a single connection is not enough —- for example, when it is necessary to prioritize requests or to use different authentication IDs."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:70
msgid "Most ``net.box`` methods allow a final ``{options}`` argument, which can be:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:72
msgid "``{timeout=...}``. For example, a method whose final argument is ``{timeout=1.5}`` will stop after 1.5 seconds on the local node, although this does not guarantee that execution will stop on the remote server node."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:75
msgid "``{buffer=...}``. For an example see :ref:`buffer module <buffer-module>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:76
msgid "``{is_async=...}``. For example, a method whose final argument is ``{is_async=true}`` will not wait for the result of a request. See the :ref:`is_async <net_box-is_async>` description."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:79
msgid "``{on_push=... on_push_ctx=...}``. For receiving out-of-band messages. See the :ref:`box.session.push <box_session-push>` description."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:82
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:90
msgid "On this diagram:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:92
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:94
msgid "``net_box.connect()`` method changes the state to 'connecting' and spawns a worker fiber."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:96
msgid "If authentication and schema upload are required, it's possible later on to re-enter the 'fetch_schema' state from 'active' if a request fails due to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:100
msgid "``conn.close()`` method sets the state to 'closed' and kills the worker. If the transport is already in the 'error' state, ``close()`` does nothing."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:107
msgid "Below is a list of all ``net.box`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:117
msgid ":ref:`net_box.connect() <net_box-connect>` |br| :ref:`net_box.new() <net_box-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:118
msgid "Create a connection"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:122
msgid ":ref:`conn:ping() <conn-ping>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:122
msgid "Execute a PING command"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:125
msgid ":ref:`conn:wait_connected() <conn-wait_connected>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:125
msgid "Wait for a connection to be active or closed"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:128
msgid ":ref:`conn:is_connected() <conn-is_connected>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:128
msgid "Check if a connection is active or closed"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:131
msgid ":ref:`conn:wait_state() <conn-wait_state>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:131
msgid "Wait for a target state"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:134
msgid ":ref:`conn:close() <conn-close>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:134
msgid "Close a connection"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:137
msgid ":ref:`conn.space.space-name:select{field-value} <conn-select>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:140
msgid ":ref:`conn.space.space-name:get{field-value} <conn-get>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:143
msgid ":ref:`conn.space.space-name:insert{field-value} <conn-insert>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:146
msgid ":ref:`conn.space.space-name:replace{field-value} <conn-replace>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:149
msgid ":ref:`conn.space.space-name:update{field-value} <conn-update>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:152
msgid ":ref:`conn.space.space-name:upsert{field-value} <conn-upsert>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:155
msgid ":ref:`conn.space.space-name:delete{field-value} <conn-delete>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:158
msgid ":ref:`conn:eval() <net_box-eval>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:158
msgid "Evaluate and execute the expression in a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:161
msgid ":ref:`conn:call() <net_box-call>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:161
msgid "Call a stored procedure"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:164
msgid ":ref:`conn:timeout() <conn-timeout>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:164
msgid "Set a timeout"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:180
msgid "The names ``connect()`` and ``new()`` are synonyms: ``connect()`` is preferred; ``new()`` is retained for backward compatibility."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:183
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It can be re-established automatically after a disconnect (see ``reconnect_after`` option below). The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:189
msgid "For a local Tarantool server, there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:201
msgid "Possible options:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:203
msgid "`wait_connected`: by default, connection creation is blocked until the connection is established, but passing ``wait_connected=false`` makes it return immediately. Also, passing a timeout makes it wait before returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 seconds)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:209
msgid "In the presence of ``reconnect_after``, ``wait_connected`` ignores transient failures. The wait completes once the connection is established or is closed explicitly."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:212
msgid "`reconnect_after`: a ``net.box`` instance automatically reconnects any time the connection is broken or if a connection attempt fails. This makes transient network failures become transparent to the application. Reconnect happens automatically in the background, so queries/requests that suffered due to connectivity loss are transparently retried. The number of retries is unlimited, connection attempts are done over the specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed, or once the Lua garbage collector removes it, reconnects stop."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:222
msgid "`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a new binary protocol command for CALL, which is not backward compatible with previous versions. The new CALL no longer restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. To connect to a Tarantool instance that uses the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:231
msgid "`console`: depending on the option's value, the connection supports different methods (as if instances of different classes were returned). With ``console = true``, you can use ``conn`` methods ``close()``, ``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both binary and Lua console network protocols are supported). With ``console = false`` (default), you can also use ``conn`` database methods (in this case, only the binary protocol is supported). Deprecation notice: ``console = true`` is deprecated, users should use :ref:`console.connect() <console-connect>` instead."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:239
msgid "`connect_timeout`: number of seconds to wait before returning \"error: Connection timed out\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:241
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:242
msgid "possible options are `wait_connected`, `reconnect_after`, `call_16` and `console`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:243
msgid "conn object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:248
msgid "conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:260
msgid "Execute a PING command."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:262
msgid "true on success, false on error"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:267
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:275
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:277
#: ../doc/2.2/reference/reference_lua/net_box.rst:309
msgid "in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:278
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:283
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:291
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:293
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:298
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:306
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:308
msgid "target states"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:310
msgid "true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:315
msgid "-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:330
msgid "Close a connection."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:332
msgid "Connection objects are destroyed by the Lua garbage collector, just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:339
msgid "conn:close()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:347
msgid ":samp:`conn.space.{space-name}:select`:code:`({...})` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:353
msgid "conn.space.testspace:select({1,'B'}, {timeout=1})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:359
msgid "Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:370
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:375
msgid "conn.space.testspace:get({1})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:383
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:389
msgid "conn.space.testspace:insert({2,3,4,5}, {timeout=1.1})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:397
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:403
msgid "conn.space.testspace:replace({5,6,7,8})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:411
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:417
msgid "conn.space.Q:update({1},{{'=',2,5}}, {timeout=0})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:425
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:433
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`. For an additional option see :ref:`Module buffer and skip-header <buffer-module_and_skip_header>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:441
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-owners_privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:447
msgid "To ensure that the return from ``conn:eval`` is whatever the Lua expression returns, begin the Lua-string with the word \"return\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:452
msgid "tarantool> --Lua-string\n"
"tarantool> conn:eval('function f5() return 5+5 end; return f5();')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> --Lua-string, {arguments}\n"
"tarantool> conn:eval('return ...', {1,2,{3,'x'}})\n"
"---\n"
"- 1\n"
"- 2\n"
"- [3, 'x']\n"
"...\n"
"tarantool> --Lua-string, {arguments}, {options}\n"
"tarantool> conn:eval('return {nil,5}', {}, {timeout=0.1})\n"
"---\n"
"- [null, 5]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:476
msgid "``conn:call('func', {'1', '2', '3'})`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call. The return from ``conn:call`` is whatever the function returns."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:480
msgid "Limitation: the called function cannot return a function, for example if ``func2`` is defined as ``function func2 () return func end`` then ``conn:call(func2)`` will return \"error: unsupported Lua type 'function'\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:486
msgid "tarantool> -- create 2 functions with conn:eval()\n"
"tarantool> conn:eval('function f1() return 5+5 end;')\n"
"tarantool> conn:eval('function f2(x,y) return x,y end;')\n"
"tarantool> -- call first function with no parameters and no options\n"
"tarantool> conn:call('f1')\n"
"---\n"
"- 10\n"
"...\n"
"tarantool> -- call second function with two parameters and one option\n"
"tarantool> conn:call('f2',{1,'B'},{timeout=99})\n"
"---\n"
"- 1\n"
"- B\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:509
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it. Since version 1.7.4 this method is deprecated -- it is better to pass a timeout value for a method's ``{options}`` parameter."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:515
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:519
msgid "Although ``timeout(...)`` is deprecated, all remote calls support its use. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:531
msgid "``{is_async=true|false}`` is an option which is applicable for all ``net_box`` requests including ``conn:call``, ``conn:eval``, and the ``conn.space.space-name`` requests."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:535
msgid "The default is ``is_async=false``, meaning requests are synchronous for the fiber. The fiber is blocked, waiting until there is a reply to the request or until timeout expires. Before Tarantool version 1.10, the only way to make asynchronous requests was to put them in separate fibers."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:541
msgid "The non-default is ``is_async=true``, meaning requests are asynchronous for the fiber. The request causes a yield but there is no waiting. The immediate return is not the result of the request, instead it is an object that the calling program can use later to get the result of the request."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:547
msgid "This immediately-returned object, which we'll call \"future\", has its own methods:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:550
msgid "``future:is_ready()`` which will return true when the result of the request is available,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:552
msgid "``future:result()`` to get the result of the request (returns the response or **nil** in case it's not ready yet or there has been an error),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:554
msgid "``future:wait_result(timeout)`` to wait until the result of the request is available and then get it,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:556
msgid "``future:discard()`` to abandon the object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:558
msgid "Typically a user would say ``future=request-name(...{is_async=true})``, then either loop checking ``future:is_ready()`` until it is true and then say ``request_result=future:result()``, or say ``request_result=future:wait_result(...)``. Alternatively the client could check for \"out-of-band\" messages from the server by calling ``pairs()`` in a loop -- see :ref:`box.session.push() <box_session-push>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:567
msgid "tarantool> future = conn.space.tester:insert({900},{is_async=true})\n"
"---\n"
"...\n"
"tarantool> future\n"
"---\n"
"- method: insert\n"
"  response: [900]\n"
"  cond: cond\n"
"  on_push_ctx: []\n"
"  on_push: 'function: builtin#91'\n"
"...\n"
"tarantool> future:is_ready()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> future:result()\n"
"---\n"
"- [900]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:589
msgid "Typically ``{is_async=true}`` is used only if the load is large (more than 100,000 requests per second) and latency is large (more than 1 second), or when it is necessary to send multiple requests in parallel then collect responses (sometimes called a \"map-reduce\" scenario)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:597
msgid "Although the final result of an async request is the same as the result of a sync request, it is structured differently: as a table, instead of as the unpacked values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:605
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:607
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:609
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:610
msgid "there is a space named ``tester`` with a numeric primary key and with a tuple that contains a key value = 800,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:612
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:614
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:616
msgid "box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:624
msgid "And here starts the example:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/net_box.rst:626
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert({800, 'data'})\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select({800})\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete({800})\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace({800, 'New data', 'Extra data'})\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn.space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:39
msgid "Module `os`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:47
msgid "The ``os`` module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:64
msgid "Below is a list of all ``os`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:74
msgid ":ref:`os.execute() <os-execute>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:74
msgid "Execute by passing to the shell"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:77
msgid ":ref:`os.rename() <os-rename>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:80
msgid ":ref:`os.getenv() <os-getenv>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:80
msgid "Get an environment variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:83
msgid ":ref:`os.remove() <os-remove>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:83
msgid "Remove a file or directory"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:86
msgid ":ref:`os.date() <os-date>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:86
msgid "Get a formatted date"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:89
msgid ":ref:`os.exit() <os-exit>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:89
msgid "Exit the program"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:92
msgid ":ref:`os.time() <os-time>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:92
msgid "Get the number of seconds since the epoch"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:95
msgid ":ref:`os.clock() <os-clock>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:95
msgid "Get the number of CPU seconds since the program start"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:98
msgid ":ref:`os.tmpname() <os-tmpname>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:98
msgid "Get the name of a temporary file"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:101
msgid ":ref:`os.environ() <os-environ>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:101
msgid "Get a table with all environment variables"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:104
msgid ":ref:`os.setenv() <os-setenv>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:104
msgid "Set an environment variable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:107
msgid ":ref:`os.setlocale() <os-setlocale>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:107
msgid "Change the locale"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:110
msgid ":ref:`os.difftime() <os-difftime>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:110
msgid "Get the number of seconds between two times"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:118
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:120
msgid "what to execute."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:124
msgid "tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:140
msgid "Rename a file or directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:142
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:143
msgid "changed name of file or directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:147
msgid "tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:160
msgid "Get environment variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:162
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:166
msgid "tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:177
msgid "Remove file or directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:179
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:183
msgid "tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:194
msgid "Return a formatted date."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:196
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:201
msgid "tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:212
msgid "Exit the program. If this is done on a server instance, then the instance stops."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:216
msgid "tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:225
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:229
msgid "tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:240
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:244
msgid "tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:255
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:259
msgid "tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:270
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:274
msgid "tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:285
msgid "Set an environment variable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:289
msgid "tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:300
msgid "Change the locale. If new-locale-string is not specified, return the current locale."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:305
msgid "tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:316
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/2.2/reference/reference_lua/osmodule.rst:320
msgid "tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:37
msgid "Other package components"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:39
msgid "All the Tarantool modules are, at some level, inside a package which, appropriately, is named ``package``. There are also miscellaneous functions and variables which are outside all modules."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:51
msgid ":ref:`tonumber64() <other-tonumber64>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:51
msgid "Convert a string or a Lua number to a 64-bit integer"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:54
msgid ":ref:`dostring() <other-dostring>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:54
msgid "Parse and execute an arbitrary chunk of Lua code"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:57
msgid ":ref:`package.path <other-package_path>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:57
msgid "Where Tarantool looks for Lua additions"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:60
msgid ":ref:`package.cpath <other-package_cpath>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:60
msgid "Where Tarantool looks for C additions"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:63
msgid ":ref:`package.loaded <other-package_loaded>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:63
msgid "What Tarantool has already looked for and found"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:66
msgid ":ref:`package.setsearchroot <other-package_setsearchroot>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:66
msgid "Set the root path for a directory search"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:69
msgid ":ref:`package.searchroot <other-package_searchroot>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:69
msgid "Get the root path for a directory search"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:78
msgid "Convert a string or a Lua number to a 64-bit integer. The input value can be expressed in decimal, binary (for example 0b1010), or hexadecimal (for example -0xffff). The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:88
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:113
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:117
msgid "Lua code"
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:118
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:121
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:123
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:128
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:161
msgid "This is a string that Tarantool uses to search for Lua modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:169
msgid "This is a string that Tarantool uses to search for C modules, especially imporant for ``require()``. See :ref:`Modules, rocks and applications <app_server-modules>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:177
msgid "This is a string that shows what Lua or C modules Tarantool has loaded, so that their functions and members are available. Initially it has all the pre-loaded modules, which don't need ``require()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:186
msgid "Set the search root. The search root is the root directory from which dependencies are loaded."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:189
msgid "the path. Default = current directory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:191
msgid "The search-root string must contain a relative or absolute path. If it is a relative path, then it will be expanded to an absolute path. If search-root is omitted, or is box.NULL, then the search root is reset to the current directory, which is found with debug.sourcedir()."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:199
msgid "Suppose that a Lua file ``myapp/init.lua`` is the project root. |br| Suppose the current path is ``/home/tara``. |br| Add this as the first line of ``myapp/init.lua``: |br| :code:`package.setsearchroot()` |br| Start the project with |br| :code:`$ tarantool myapp/init.lua` |br| The search root will be the default, made absolute: ``/home/tara/myapp``. Within the Lua application all dependencies will be searched relative to ``/home/tara/myapp``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/other.rst:213
msgid "Return a string with the current search root. After ``package.setsearchroot('/home')`` the returned string will be ``/home'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:37
msgid "Module `pickle`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:43
msgid "Below is a list of all ``pickle`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:53
msgid ":ref:`pickle.pack() <pickle-pack>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:53
msgid "Convert Lua variables to binary format"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:56
msgid ":ref:`pickle.unpack() <pickle-unpack>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:56
msgid "Convert Lua variables back from binary format"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:66
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:72
msgid "**Format specifiers**"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:77
msgid "b, B"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:77
msgid "converts Lua scalar value to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:80
msgid "s, S"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:80
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:84
msgid "i, I"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:84
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:88
msgid "l, L"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:88
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:92
msgid "n"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:92
msgid "converts Lua scalar value to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:96
msgid "N"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:96
msgid "converts Lua scalar value to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:99
msgid "q, Q"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:99
msgid "converts Lua scalar value to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:103
msgid "f"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:103
msgid "converts Lua scalar value to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:106
msgid "d"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:106
msgid "converts Lua scalar value to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:109
msgid "a, A"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:109
msgid "converts Lua scalar value to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:113
msgid "string containing format specifiers"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:114
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:115
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:119
msgid "A scalar value can be either a variable or a literal. Remember that large integers should be entered with :ref:`tonumber64() or LL or ULL suffixes <index-box_number>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:123
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:127
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:163
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:169
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/2.2/reference/reference_lua/pickle.rst:174
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:39
msgid "Module `socket`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:45
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:51
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:64
msgid "Below is a list of all ``socket`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:74
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:74
msgid "Create a socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:76
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:76
#: ../doc/2.2/reference/reference_lua/socket.rst:85
msgid "Connect a socket to a remote host"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:79
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:79
msgid "Get information about a remote site"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:82
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:82
msgid "Make Tarantool act as a TCP server"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:send() <socket-send>` |br| :ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:88
msgid "Send data over a connected socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:91
msgid "Write data to the socket buffer if non-blocking"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:94
msgid "Read from a connected socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:96
msgid ":ref:`socket_object:sysread() <socket-sysread>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:96
msgid "Read data from the socket buffer if non-blocking"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:bind() <socket-bind>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:99
msgid "Bind a socket to the given host/port"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:102
msgid "Start listening for incoming connections"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:105
msgid "Accept a client connection + create a connected socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:108
msgid "Send a message on a UDP socket to a specified host"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:111
msgid "Receive a message on a UDP socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:114
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:114
msgid "Shut down a reading end, a writing end, or both"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:117
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:117
msgid "Close a socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:119
msgid ":ref:`socket_object:error() <socket-error>` |br| :ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:119
msgid "Get information about the last error on a socket"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:122
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:122
msgid "Set socket flags"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:124
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:124
msgid "Get socket flags"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:126
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:126
msgid "Set/clear the SO_LINGER flag"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:128
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:128
msgid "Set/get the flag value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:130
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:130
msgid "Wait until something is readable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:133
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:133
msgid "Wait until something is writable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:136
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:136
msgid "Wait until something is either readable or writable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:139
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:139
msgid "Get information about the connection's near side"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:142
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:142
msgid "Get information about the connection's far side"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:145
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:145
msgid "Wait for read/write activity"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:148
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-implicit-yields>` will cause a yield so that other processes may take over, as is the norm for :ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:157
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:166
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:169
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:174
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:182
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:184
#: ../doc/2.2/reference/reference_lua/socket.rst:389
#: ../doc/2.2/reference/reference_lua/socket.rst:429
msgid "URL or IP address"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:185
#: ../doc/2.2/reference/reference_lua/socket.rst:390
#: ../doc/2.2/reference/reference_lua/socket.rst:430
msgid "port number"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:186
msgid "timeout"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:187
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:192
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:200
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed. This function may use the :ref:`worker_pool_threads <cfg_basic-worker_pool_threads>` configuration parameter."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:206
#: ../doc/2.2/reference/reference_lua/socket.rst:594
#: ../doc/2.2/reference/reference_lua/socket.rst:606
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:211
msgid "tarantool> socket.getaddrinfo('tarantool.org', 'http')\n"
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:231
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with :ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:235
msgid "host name or IP"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:236
msgid "host port, may be 0"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:237
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:239
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:242
msgid "The handler-function-or-table parameter may be simply a function name / function declaration: :code:`handler_function`. Or it may be a table: :code:`{handler =` :samp:`{handler_function} [, prepare = {prepare_function}] [, name = {name}]` :code:`}`. ``handler_function`` is mandatory; it may have a single parameter = the socket; it is for continuous operation after the connection is made. ``prepare_function`` is optional; it is executed once before any connection is made. Examples:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:254
msgid "socket.tcp_server('localhost', 3302, function (s) loop_loop() end)\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, name='name'})\n"
"socket.tcp_server('localhost', 3302, {handler=hfunc, prepare=pfunc})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:260
msgid "For a fuller example see :ref:`Use tcp_server to accept file contents sent with socat <socket_socat>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:269
msgid "Connect an existing socket to a remote host. The argument values are the same as in :ref:`tcp_connect() <socket-tcp_connect>`. The host must be an IP address."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:286
msgid "Parameters:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:276
msgid "Either:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:275
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:277
msgid "port - a number."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:279
#: ../doc/2.2/reference/reference_lua/socket.rst:286
msgid "Or:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:279
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:280
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:282
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:284
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:288
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:293
msgid "socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:304
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:306
#: ../doc/2.2/reference/reference_lua/socket.rst:431
msgid "what is to be sent"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:307
#: ../doc/2.2/reference/reference_lua/socket.rst:433
msgid "the number of bytes sent."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:310
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:316
msgid "Write as much data as possible to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:323
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:326
#: ../doc/2.2/reference/reference_lua/socket.rst:444
msgid "maximum number of bytes to receive. See :ref:`Recommended size <socket-recommended>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:327
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:330
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:341
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired. Unlike ``socket_object:recv`` (which uses an internal read-ahead buffer), ``socket_object:read`` depends on the socket's buffer."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:348
#: ../doc/2.2/reference/reference_lua/socket.rst:373
msgid "maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:350
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:352
msgid "maximum number of seconds to wait, for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:354
msgid ":samp:`chunk={limit}` and/or :samp:`delimiter={delimiter}`, for example :code:`{chunk=5,delimiter='x'}`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:358
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:368
msgid "Return data from the socket buffer if non-blocking. In case the socket is blocking, ``sysread()`` can block the calling process. Rarely used. For details, see also `this description <https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:376
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:384
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:392
msgid "true for success, false for error. If return is false, use :ref:`socket_object:errno() <socket-error>` or :ref:`socket_object:error() <socket-error>` to see details."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:401
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:403
msgid "on Linux the listen ``backlog`` backlog may be from ``/proc/sys/net/core/somaxconn``, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:407
msgid "true for success, false for error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:408
msgid "boolean."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:414
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:418
msgid "new socket if success."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:421
msgid "Possible errors: nil."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:427
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:436
msgid "Possible errors: on error, returns nil and may return status, errno, errstr."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:442
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:445
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:446
msgid "string, table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:448
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:452
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:456
msgid "message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:466
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:468
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:470
#: ../doc/2.2/reference/reference_lua/tap.rst:188
#: ../doc/2.2/reference/reference_lua/tap.rst:211
#: ../doc/2.2/reference/reference_lua/tap.rst:245
#: ../doc/2.2/reference/reference_lua/tap.rst:280
#: ../doc/2.2/reference/reference_lua/tap.rst:293
#: ../doc/2.2/reference/reference_lua/tap.rst:303
#: ../doc/2.2/reference/reference_lua/tap.rst:318
#: ../doc/2.2/reference/reference_lua/tap.rst:339
#: ../doc/2.2/reference/reference_lua/tap.rst:358
msgid "true or false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:477
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when the Lua garbage collector removes its user data."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:481
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:490
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:493
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:495
msgid "number, string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:501
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:505
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:506
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:507
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:508
msgid "SO_DEBUG"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:509
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:510
msgid "SO_ERROR"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:511
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:512
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:513
msgid "SO_MARK"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:514
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:515
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:516
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:517
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:518
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:519
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:520
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:521
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:522
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:523
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:524
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:525
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:526
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:527
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:528
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:529
msgid "SO_TYPE"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:531
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:537
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:543
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:548
msgid "new active and timeout values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:554
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:555
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:556
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:558
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:565
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:567
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:573
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:575
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:581
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:583
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:589
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:601
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:613
msgid "The ``socket.iowait()`` function is used to wait until read-or-write activity occurs for a file descriptor."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:616
msgid "file descriptor"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:617
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:618
msgid "number of seconds to wait"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:620
msgid "If the fd parameter is nil, then there will be a sleep until the timeout. If the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:623
msgid "Ordinarily the return value is the activity that occurred ('R' or 'W' or 'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:627
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:633
msgid "Recommended size"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:635
msgid "For ``recv`` and ``recvfrom``: use the optional ``size`` parameter to limit the number of bytes to receive. A fixed size such as 512 is often reasonable; a pre-calculated size that depends on context -- such as the message format or the state of the network -- is often better. For ``recvfrom``, be aware that a size greater than the `Maximum Transmission Unit <https://en.wikipedia.org/wiki/Maximum_transmission_unit>`_ can cause inefficient transport. For Mac OS X, be aware that the size can be tuned by changing ``sysctl net.inet.udp.maxdgram``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:646
msgid "If ``size`` is not stated: Tarantool will make an extra call to calculate how many bytes are necessary. This extra call takes time, therefore not stating ``size`` may be inefficient."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:650
msgid "If ``size`` is stated: on a UDP socket, excess bytes are discarded. On a TCP socket, excess bytes are not discarded and can be received by the next call."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:660
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:662
msgid "In this example a connection is made over the internet between a Tarantool instance and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something else if the site has moved. This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:668
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:699
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:701
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:707
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> message = sock_1:recvfrom(512)\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:746
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:748
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:753
msgid "Start two shells. The first shell will be a server instance. The second shell will be the client."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:756
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:758
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302,\n"
"{\n"
"  handler = function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end,\n"
"  prepare = function()\n"
"    print('Initialized')\n"
"  end\n"
"}\n"
")"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:780
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:787
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:792
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server instance's host and port:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:795
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/2.2/reference/reference_lua/socket.rst:799
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/strict.rst:39
msgid "Module `strict`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/strict.rst:43
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../doc/2.2/reference/reference_lua/strict.rst:48
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/strict.rst:54
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:39
msgid "Module `string`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:47
msgid "The :code:`string` module has everything in the `standard Lua string library <https://www.lua.org/pil/20.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:51
msgid "In this section we only discuss the additional functions that the Tarantool developers have added."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:58
msgid "Below is a list of all additional ``string`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:68
msgid ":ref:`string.ljust() <string-ljust>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:68
msgid "Left-justify a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:71
msgid ":ref:`string.rjust() <string-rjust>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:71
msgid "Right-justify a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:74
msgid ":ref:`string.hex() <string-hex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:74
msgid "Given a string, return hexadecimal values"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:77
msgid ":ref:`string.fromhex() <string-fromhex>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:77
msgid "Given hexadecimal values, return a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:80
msgid ":ref:`string.startswith() <string-startswith>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:80
msgid "Check if a string starts with a given substring"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:83
msgid ":ref:`string.endswith() <string-endswith>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:83
msgid "Check if a string ends with a given substring"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:86
msgid ":ref:`string.lstrip() <string-lstrip>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:86
msgid "Remove characters from the left of a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:89
msgid ":ref:`string.rstrip() <string-rstrip>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:89
msgid "Remove characters from the right of a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:92
msgid ":ref:`string.split() <string-split>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:92
msgid "Split a string into a table of strings"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:95
msgid ":ref:`string.strip() <string-strip>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:95
msgid "Remove spaces on the left and right of a string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:103
msgid "Return the string left-justified in a string of length ``width``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:105
msgid "(string) the string to left-justify"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:106
msgid "(integer) the width of the string after left-justifying"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:107
#: ../doc/2.2/reference/reference_lua/string.rst:132
msgid "(string) a single character, default = 1 space"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:109
msgid "left-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:114
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.ljust(' A', 5)\n"
"---\n"
"- ' A   '\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:128
msgid "Return the string right-justified in a string of length ``width``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:130
msgid "(string) the string to right-justify"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:131
msgid "(integer) the width of the string after right-justifying"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:134
msgid "right-justified string (unchanged if width <= string length)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:139
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rjust('', 5, 'X')\n"
"---\n"
"- 'XXXXX'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:153
msgid "Return the hexadecimal value of the input string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:155
#: ../doc/2.2/reference/reference_lua/string.rst:266
#: ../doc/2.2/reference/reference_lua/string.rst:292
#: ../doc/2.2/reference/reference_lua/string.rst:346
msgid "(string) the string to process"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:157
msgid "hexadecimal, 2 hex-digit characters for each input character"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:162
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.hex('ABC ')\n"
"---\n"
"- '41424320'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:176
msgid "Given a string containing pairs of hexadecimal digits, return a string with one byte for each pair. This is the reverse of ``string.hex()``. The hexadecimal-input-string must contain an even number of hexadecimal digits."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:180
msgid "(string) string with pairs of hexadecimal digits"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:182
msgid "string with one byte for each pair of hexadecimal digits"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:187
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.fromhex('41424320')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:201
msgid "Return True if ``input-string`` starts with ``start-string``, otherwise return False."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:204
msgid "(string) the string where ``start-string`` should be looked for"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:205
#: ../doc/2.2/reference/reference_lua/string.rst:235
msgid "(string) the string to look for"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:206
#: ../doc/2.2/reference/reference_lua/string.rst:236
msgid "(integer) position: where to start looking within ``input-string``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:207
#: ../doc/2.2/reference/reference_lua/string.rst:237
msgid "(integer) position: where to end looking within ``input-string``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:212
#: ../doc/2.2/reference/reference_lua/string.rst:242
msgid "``start-pos`` and ``end-pos`` may be negative, meaning the position should be calculated from the end of the string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:217
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.startswith(' A', 'A', 2, 5)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:231
msgid "Return True if ``input-string`` ends with ``end-string``, otherwise return False."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:234
msgid "(string) the string where ``end-string`` should be looked for"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:247
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.endswith('Baa', 'aa')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:262
msgid "Return the value of the input string, after removing characters on the left. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.lstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:267
#: ../doc/2.2/reference/reference_lua/string.rst:293
#: ../doc/2.2/reference/reference_lua/string.rst:347
msgid "(string) what characters can be stripped. Default = space."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:269
#: ../doc/2.2/reference/reference_lua/string.rst:295
#: ../doc/2.2/reference/reference_lua/string.rst:349
msgid "result after stripping characters from input string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:274
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.lstrip(' ABC ')\n"
"---\n"
"- 'ABC '\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:288
msgid "Return the value of the input string, after removing characters on the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.rstrip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:300
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.rstrip(' ABC ')\n"
"---\n"
"- ' ABC'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:314
msgid "Split ``input-string`` into one or more output strings in a table. The places to split are the places where ``split-string`` occurs."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:318
msgid "(string) the string to split"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:319
msgid "(string) the string to find within ``input-string``. Default = space."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:322
msgid "table of strings that were split from ``input-string``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:327
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.split(\"A*BXX C\", \"XX\")\n"
"---\n"
"- - A*B\n"
"  - ' C'\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:342
msgid "Return the value of the input string, after removing characters on the left and the right. The optional ``list-of-characters`` parameter is a set not a sequence, so ``string.strip(...,'ABC')`` does not mean strip ``'ABC'``, it means strip ``'A'`` or ``'B'`` or ``'C'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/string.rst:354
msgid "tarantool> string = require('string')\n"
"---\n"
"...\n"
"tarantool> string.strip(' ABC ')\n"
"---\n"
"- ABC\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:39
msgid "Module `swim`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:45
msgid "The ``swim`` module contains Tarantool's implementation of SWIM -- Scalable Weakly-consistent Infection-style Process Group Membership Protocol. It is recommended for any type of Tarantool cluster where the number of nodes can be large. Its job is to discover and monitor the other members in the cluster and keep their information in a \"member table\". It works by sending and receiving, in a background event loop, periodically, via UDP, messages."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:53
msgid "Each message has several parts, including:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:55
msgid "the ping such as \"I am checking whether you are alive\","
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:56
msgid "the event such as \"I am joining\","
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:57
msgid "the anti-entropy such as \"I know that another member exists\","
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:58
msgid "the payload such as \"I or another member could have user-generated data\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:60
msgid "The maximum message size is about 1500 bytes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:62
msgid "SWIM sends messages periodically to a random subset of the member table. SWIM processes replies from those members asynchronously."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:65
msgid "Each entry in the member table has:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:67
msgid "a UUID,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:68
msgid "a status (\"alive\", \"suspected\", \"dead\", or \"left\")."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:70
msgid "When a member fails to acknowledge a certain number of pings, its status is changed from \"alive\" to \"suspected\", that is, suspected of being dead. But SWIM tries to **avoid false positives** (misidentifying members as dead) which could happen when a member is overloaded and responds to pings too slowly, or when there is network trouble and packets can not go through some channels. When a member is suspected, SWIM randomly chooses other members and sends requests to them: \"please ping this suspected member\". This is called an **indirect ping**. Thus via different routes and additional hops the suspected member gets additional chances to reply, and thus \"refute\" the suspicion."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:81
msgid "Because selection is random there is an **even network load** of about one message per member per protocol step, regardless of the cluster size. This is a major feature of SWIM. Because the protocol depends on members passing information on, also known as \"gossiping\", members do not need to broadcast messages to every member, which would cause a network load of N messages per member per protocol step, where N is the number of members in the cluster. However, selection is not entirely random, there is a preference for selecting least-recently-pinged members, like a round-robin."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:90
msgid "Regarding the **anti-entropy** part of a message: this is necessary for maintaining the status in entries of the member table. Consider an example where two members, #1 and #2, are both alive. No events happen so only pings are being sent periodically. Then a third member, #3 appears. It knows about one of the existing members, #2. How can it discover the other member? Certainly #1 could notify #2 and #2 could notify #3, but messages go via UDP, so any notification event can be lost. However, regular messages containing \"ping\" and/or \"event\" also can contain an \"anti-entropy\" section, which is taken from a randomly-chosen part of the member table. So for this example, #2 will eventually randomly add to a regular message the anti-entropy note that #1 is alive, and thus #3 will discover #1 even though it did not receive a direct \"I am alive\" event message from #1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:106
msgid "Regarding the **UUID** part of an entry in the member table: this is necessary for stable identification, because UUID changes more rarely than URI (a combination of IP and port number). But if the UUID does change, SWIM will include both the new and old UUID in messages, so all other members will eventually learn about the new UUID and change the member table accordingly."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:114
msgid "Regarding the **payload** part of a message: this is not always necessary, it is a feature which allows passing user-generated information via SWIM instead of via node-to-node communication. The swim module has methods for specifying a \"payload\", which is arbitrary user data with a maximum size of about 1.2 KB. The payload can be anything, and it will be eventually disseminated over the cluster and available at other members. Each member can have its own payload."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:124
msgid "Messages can be **encrypted**. Encryption may not be necessary in a closed network but is necessary for safety if the cluster is on the public Internet. Users can specify an encryption algorithm, an encryption mode, and a private key. All parts of all messages (including ping, acknowledgment, event, payload, URI, and UUID) will be encrypted with that private key, as well as a random public key generated for each message to prevent pattern attacks."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:132
msgid "In theory the event dissemination speed (the number of hops to pass information throughout the cluster) is ``O(log(cluster_size))``. For that and other theoretical information see the Cornell University `paper <https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf>`_ which originally described SWIM."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:144
msgid "Create a new SWIM instance. A SWIM instance maintains a member table and interacts with other members. Multiple SWIM instances can be created in a single Tarantool process."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:148
msgid "an optional configuration parameter.  If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-cfg>` is called.  If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``. For configuration description see :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:148
msgid "an optional configuration parameter."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:150
msgid "If ``cfg`` is not specified or is nil, then the new SWIM instance is not bound to a socket and has nil attributes, so it cannot interact with other members and only a few methods are valid until :ref:`swim_object:cfg() <swim-cfg>` is called."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:156
msgid "If ``cfg`` is specified, then the effect is the same as calling ``s = swim.new() s:cfg()``. For configuration description see :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:161
msgid "swim-object :ref:`a swim object <swim-object>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:165
msgid "swim_object = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:173
msgid "A swim object is an object returned by :ref:`swim.new() <swim-new>`. It has methods: :ref:`cfg() <swim-cfg>`, :ref:`delete() <swim-delete>`, :ref:`is_configured() <swim-is_configured>`, :ref:`size() <swim-size>`, :ref:`quit() <swim-quit>`, :ref:`add_member() <swim-add_member>`, :ref:`remove_member() <swim-remove_member>`, :ref:`probe_member() <swim-probe_member>`, :ref:`broadcast() <swim-broadcast>`, :ref:`set_payload() <swim-set_payload>`, :ref:`set_payload_raw() <swim-set_payload_raw>`, :ref:`set_codec() <swim-set_codec>`, :ref:`self() <swim-self>`, :ref:`member_by_uuid() <swim-member_by_uuid>`, :ref:`pairs() <swim-pairs>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:195
msgid "Configure or reconfigure a SWIM instance."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:197
msgid "the options to describe instance behavior"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:199
msgid "The ``cfg`` table may have these components:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:201
msgid "``heartbeat_rate`` (double) -- rate of sending round messages, in seconds. Setting ``heartbeat_rate`` to X does not mean that every member will be checked every X seconds, instead X is the protocol speed. Protocol period depends on member count and heartbeat_rate. Default = 1."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:207
msgid "``ack_timeout`` (double) -- time in seconds after which a ping is considered to be unacknowledged. Default = 30."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:210
msgid "``gc_mode`` (enum) -- dead member collection mode."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:212
msgid "If ``gc_mode == 'off'`` then SWIM never removes dead members from the member table (though users may remove them with :ref:`swim_object:remove_member() <swim-remove_member>`), and SWIM will continue to ping them as if they were alive."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:217
msgid "If ``gc_mode == 'on'`` then SWIM removes dead members from the member table after one round."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:220
msgid "Default = ``'on'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:222
msgid "``uri`` (string or number) -- either an ``'ip:port'`` address, or just a port number (if ip is omitted then 127.0.0.1 is assumed). If ``port == 0``, then the kernel will select any free port for the IP address."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:227
msgid "``uuid`` (string or cdata struct tt_uuid) -- a value which should be unique among SWIM instances. Users may choose any value but the recommendation is: use :ref:`box.cfg.instance_uuid <cfg_replication-instance_uuid>`, the Tarantool instance's UUID."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:233
msgid "All the ``cfg`` components are dynamic -- ``swim_object:cfg()`` may be called more than once. If it is not being called for the first time and a component is not specified, then the component retains its previous value. If it is being called for the first time then uri and uuid are mandatory, since a SWIM instance cannot operate without URI and UUID."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:240
msgid "``swim_object:cfg()`` is atomic -- if there is an error, then nothing changes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:243
msgid "true if configuration succeeds"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:244
#: ../doc/2.2/reference/reference_lua/swim.rst:355
#: ../doc/2.2/reference/reference_lua/swim.rst:536
#: ../doc/2.2/reference/reference_lua/swim.rst:568
msgid "nil, ``err`` if an error occurred. ``err`` is an error object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:248
msgid "swim_object:cfg({heartbeat_rate = 0.5})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:252
msgid "After ``swim_object:cfg()``, all other ``swim_object`` methods are callable."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:256
msgid "Expose all non-nil components of the read-only table which was set up or changed by :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:261
msgid "tarantool> swim_object.cfg\n"
"---\n"
"- gc_mode: off\n"
"  uri: 3333\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:274
msgid "Delete a SWIM instance immediately. Its memory is freed, its member table entry is deleted, and it can no longer be used. Other members will treat this member as 'dead'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:279
msgid "After ``swim_object:delete()`` any attempt to use the deleted instance will cause an exception to be thrown."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:282
msgid "none, this method does not fail"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:284
msgid "Example: ``swim_object:delete()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:290
msgid "Return false if a SWIM instance was created via :ref:`swim.new() <swim-new>` without an optional ``cfg`` argument, and was not configured with :ref:`swim_object:cfg() <swim-cfg>`. Otherwise return true."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:296
msgid "boolean result, true if configured, otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:298
msgid "Example: ``swim_object:is_configured()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:304
msgid "Return the size of the member table. It will be at least 1 because the \"self\" member is included."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:307
msgid "integer size"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:309
msgid "Example: ``swim_object:size()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:315
msgid "Leave the cluster."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:317
msgid "This is a graceful equivalent of :ref:`swim_object:delete() <swim-delete>` -- the instance is deleted, but before deletion it sends to each member in its member table a message, that this instance has left the cluster, and should not be considered dead."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:323
msgid "Other instances mark such member in their tables as 'left', and drop it after one round of dissemination."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:327
msgid "Consequences to the caller are the same as after ``swim_object:delete()`` -- the instance is no longer usable, and an error will be thrown if there is an attempt to use it."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:331
msgid "none, the method does not fail"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:333
msgid "Example: ``swim_object:quit()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:339
msgid "Explicitly add a member into the member table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:341
msgid "This method is useful when a new member is joining the cluster and does not yet know what members already exist. In that case it can start interaction explicitly by adding the details about an already-existing member into its member table. Subsequently SWIM will discover other members automatically via messages from the already-existing member."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:349
msgid "description of the member"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:351
msgid "The ``cfg`` table has two mandatory components, ``uuid`` and ``uri``, which have the same format as ``uuid`` and ``uri`` in the table for :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:354
msgid "true if member is added"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:359
msgid "swim_member_object = swim_object:add_member({uuid = ..., uri = ...})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:367
msgid "Explicitly and immediately remove a member from the member table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:370
#: ../doc/2.2/reference/reference_lua/swim.rst:728
msgid "UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:372
msgid "true if member is removed"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:373
#: ../doc/2.2/reference/reference_lua/swim.rst:395
#: ../doc/2.2/reference/reference_lua/swim.rst:415
msgid "nil, ``err`` if an error occurred. ``err`` is an error object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:375
msgid "Example: ``swim_object:delete('00000000-0000-1000-8000-000000000001')``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:381
msgid "Send a ping request to the specified ``uri`` address. If another member is listening at that address, it will receive the ping, and respond with an ACK (acknowledgment) message containing information such as UUID. That information will be added to the member table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:387
msgid "``swim_object:probe_member()`` is similar to :ref:`swim_object:add_member() <swim-add_member>`, but it does not require UUID, and it is not reliable because it uses UDP."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:391
msgid "URI. Format is the same as for ``uri`` in :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:394
msgid "true if member is pinged"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:397
msgid "Example: ``swim_object:probe_member(3333)``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:403
msgid "Broadcast a ping request to all the network interfaces in the system."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:406
msgid "``swim_object:broadcast()`` is like :ref:`swim_object:probe_member() <swim-probe_member>` to many members at once."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:410
msgid "All the sent ping requests have this port as destination port in their UDP headers. By default a currently bound port is used."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:414
msgid "true if broadcast is sent"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:419
msgid "tarantool> tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 3333, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 3334, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"\n"
"tarantool> s1:probe_member(s2:self():uri())\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s2:size()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> s1:broadcast(3334)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.1)\n"
"---\n"
"...\n"
"tarantool> s1:size()\n"
"---\n"
"- 2\n"
"...\n"
"\n"
"tarantool> s2:size()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:520
msgid "Set a payload, as formatted data."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:522
msgid "Payload is arbitrary user defined data up to 1200 bytes in size and disseminated over the cluster. So each cluster member will eventually learn what is the payload of other members in the cluster, because it is stored in the member table and can be queried with :ref:`swim_member_object:payload() <swim-payload>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:528
msgid "Different members may have different payloads."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:530
msgid "Arbitrary Lua object to disseminate. Set to nil to remove the payload, in which case it will be eventually removed on other instances. The object is serialized in MessagePack."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:535
#: ../doc/2.2/reference/reference_lua/swim.rst:567
msgid "true if payload is set"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:540
msgid "swim_object:set_payload({field1 = 100, field2 = 200})"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:548
msgid "Set a payload, as raw data."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:550
msgid "Sometimes a payload does not need to be a Lua object. For example, a user may already have a well formatted MessagePack object and just wants to set it as a payload. Or cdata needs to be exposed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:555
msgid "``set_payload_raw`` allows setting a payload as is, without MessagePack serialization."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:558
msgid "any value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:560
msgid "Payload size in bytes. If ``payload`` is string then ``size`` is optional, and if specified, then should not be larger than actual ``payload`` size. If ``size`` is less than actual ``payload`` size, then only the first ``size`` bytes of ``payload`` are used. If ``payload`` is cdata then ``size`` is mandatory."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:572
msgid "tarantool> tarantool> ffi = require('ffi')\n"
"---\n"
"...\n"
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s1:set_payload({a = 100, b = 200})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> s2:set_payload('any payload')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1_view = s2:member_by_uuid(s1:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s2_view = s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"...\n"
"tarantool> s1_view:payload()\n"
"---\n"
"- {'a': 100, 'b': 200}\n"
"...\n"
"tarantool> s2_view:payload()\n"
"---\n"
"- any payload\n"
"...\n"
"tarantool> cdata = ffi.new('char[?]', 2)\n"
"---\n"
"...\n"
"tarantool> cdata[0] = 1\n"
"---\n"
"...\n"
"tarantool> cdata[1] = 2\n"
"---\n"
"...\n"
"tarantool> s1:set_payload_raw(cdata, 2)\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> cdata, size = s1_view:payload_cdata()\n"
"---\n"
"...\n"
"tarantool> cdata[0]\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> cdata[1]\n"
"---\n"
"- 2\n"
"...\n"
"tarantool> size\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:654
msgid "Enable encryption for all following messages."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:656
msgid "For a brief description of encryption algorithms see \"enum_crypto_algo\" and \"enum crypto_mode\" in the Tarantool source code file `crypto.h <https://github.com/tarantool/tarantool/blob/master/src/lib/crypto/crypto.h>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:661
msgid "When encryption is enabled, all the messages are encrypted with a chosen private key, and a randomly generated and updated public key."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:665
msgid "description of the encryption"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:667
msgid "The components of the ``codec_cfg`` table may be:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:669
msgid "``algo`` (string) -- encryption algorithm name. All the names in :ref:`module crypto <crypto>` are supported: 'aes128', 'aes192', 'aes256', 'des'. Specify 'none' to disable encryption."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:674
msgid "``mode`` (string) -- encryption algorithm mode. All the modes in module ``crypto`` are supported: 'ecb', 'cbc', 'cfb', 'ofb'. Default = 'cbc'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:678
msgid "``key`` (cdata or string) -- a private secret key which is kept secret and should never be stored hard-coded in source code."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:681
msgid "``key_size`` (integer) -- size of the key in bytes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:683
msgid "``key_size`` is mandatory if key is cdata."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:685
msgid "``key_size`` is optional if key is string, and if ``key_size`` is shorter than than actual key size then the key is truncated."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:689
msgid "All of ``algo``, ``mode``, ``key``, and ``key_size`` should be the same for all SWIM instances, so that members can understand each others' messages."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:693
msgid "Example;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:695
msgid "tarantool> tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> s1:set_codec({algo = 'aes128', mode = 'cbc', key = '1234567812345678'})\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:712
msgid "Return a :ref:`swim member object <swim-member_object>` (of self) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:716
msgid ":ref:`swim member object <swim-member_object>`, not nil because self() will not fail"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:718
msgid "Example: ``swim_member_object = swim_object:self()``"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:724
msgid "Return a :ref:`swim member object <swim-member_object>` (given UUID) from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:730
msgid ":ref:`swim member object <swim-member_object>`, or nil if not found"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:734
msgid "swim_member_object = swim_object:member_by_uuid('00000000-0000-1000-8000-000000000001')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:742
msgid "Set up an iterator for returning :ref:`swim member objects <swim-member_object>` from the member table, or from a cache containing earlier results of ``swim_object:self()`` or ``swim_object:member_by_uuid()`` or ``swim_object:pairs()``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:747
msgid "``swim_object:pairs()`` should be in a 'for' loop, and there should only be one iterator in operation at one time. (The iterator is implemented in an extra light fashion so only one iterator object is available per SWIM instance.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:752
msgid "as for any Lua pairs() iterators. generator function, iterator object (a swim member object), and initial key (a UUID)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:759
msgid "tarantool> tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s1 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s2 = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000002', heartbeat_rate = 0.1})\n"
"---\n"
"...\n"
"tarantool> s1:add_member({uri = s2:self():uri(), uuid = s2:self():uuid()})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fiber.sleep(0.2)\n"
"---\n"
"...\n"
"tarantool> s1:self()\n"
"---\n"
"- uri: 127.0.0.1:62341\n"
"  status: alive\n"
"  incarnation: 1\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s1:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:62341\n"
"  status: alive\n"
"  incarnation: 1\n"
"  uuid: 00000000-0000-1000-8000-000000000001\n"
"  payload_size: 0\n"
"...\n"
"tarantool> s1:member_by_uuid(s2:self():uuid())\n"
"---\n"
"- uri: 127.0.0.1:55435\n"
"  status: alive\n"
"  incarnation: 1\n"
"  uuid: 00000000-0000-1000-8000-000000000002\n"
"  payload_size: 0\n"
"...\n"
"tarantool> t = {}\n"
"---\n"
"...\n"
"tarantool> for k, v in s1:pairs() do table.insert(t, {k, v}) end\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- - - 00000000-0000-1000-8000-000000000002\n"
"    - uri: 127.0.0.1:55435\n"
"      status: alive\n"
"      incarnation: 1\n"
"      uuid: 00000000-0000-1000-8000-000000000002\n"
"      payload_size: 0\n"
"  - - 00000000-0000-1000-8000-000000000001\n"
"    - uri: 127.0.0.1:62341\n"
"      status: alive\n"
"      incarnation: 1\n"
"      uuid: 00000000-0000-1000-8000-000000000001\n"
"      payload_size: 0\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:830
msgid "Methods :ref:`swim_object:member_by_uuid() <swim-member_by_uuid>`, :ref:`swim_object:self() <swim-self>`, and :ref:`swim_object:pairs() <swim-pairs>` return swim member objects."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:836
msgid "A swim member object has methods for reading its attributes: :ref:`status() <swim-status>`, :ref:`uuid <swim-uuid>`, :ref:`uri() <swim-uri>`, :ref:`incarnation() <swim-incarnation>`, :ref:`payload_cdata <swim-payload_cdata>`, :ref:`payload_str() <swim-payload_str>`, :ref:`payload() <swim-payload>`, :ref:`is_dropped() <swim-is_dropped>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:851
msgid "Return the status, which may be 'alive', 'suspected', 'left', or 'dead'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:854
msgid "string 'alive' | 'suspected' | 'left' | dead'"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:860
msgid "Return the UUID as cdata struct tt_uuid."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:862
msgid "cdata-struct-tt-uuid UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:868
msgid "Return the URI as a string 'ip:port'. Via this method a user can learn a real assigned port, if port = 0 was specified in :ref:`swim_object:cfg() <swim-cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:873
msgid "string ip:port"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:879
msgid "Return a number (unsigned integer) which is incremented each time a member is updated."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:881
msgid "unsigned-integer incarnation"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:887
msgid "Return member's payload."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:889
msgid "pointer-to-cdata payload and size in bytes"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:895
msgid "Return payload as a string object. Payload is not decoded. It is just returned as a string instead of cdata. If payload was not specified by :ref:`swim_object:set_payload() <swim-set_payload>` or by :ref:`swim_object:set_payload_raw() <swim-set_payload_raw>`, then its size is 0 and nil is returned."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:902
msgid "string-object payload, or nil if there is no payload"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:908
msgid "Since the ``swim`` module is a Lua module, a user is likely to use Lua objects as a payload -- tables, numbers, strings etc. And it is natural to expect that :ref:`swim_member_object:payload() <swim-payload>` should return the same object which was passed into :ref:`swim_object:set_payload() <swim-set_payload>` by another instance. ``swim_member_object:payload()`` tries to interpret payload as MessagePack, and if that fails then it returns the payload as a string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:919
msgid "``swim_member_object:payload()`` caches its result. Therefore only the first call actually decodes cdata payload. All following calls return a pointer to the same result, unless payload is changed with a new incarnation. If payload was not specified (its size is 0), then nil is returned."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:929
msgid "Returns true if this member object is a stray reference to a member which has already been dropped from the member table."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:932
msgid "boolean true if member is dropped, otherwise false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:936
msgid "tarantool> swim = require('swim')\n"
"---\n"
"...\n"
"tarantool> s = swim.new({uri = 0, uuid = '00000000-0000-1000-8000-000000000001'})\n"
"---\n"
"...\n"
"tarantool> self = s:self()\n"
"---\n"
"...\n"
"tarantool> self:status()\n"
"---\n"
"- alive\n"
"...\n"
"tarantool> self:uuid()\n"
"---\n"
"- 00000000-0000-1000-8000-000000000001\n"
"...\n"
"tarantool> self:uri()\n"
"---\n"
"- 127.0.0.1:56367\n"
"...\n"
"tarantool> self:incarnation()\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> self:is_dropped()\n"
"---\n"
"- false\n"
"...\n"
"tarantool> s:set_payload_raw('123')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 3\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> s:set_payload({a = 100})\n"
"---\n"
"- true\n"
"...\n"
"tarantool> self:payload_cdata()\n"
"---\n"
"- 'cdata<const char *>: 0x0103500050'\n"
"- 4\n"
"...\n"
"tarantool> self:payload_str()\n"
"---\n"
"- !!binary gaFhZA==\n"
"...\n"
"tarantool> self:payload()\n"
"---\n"
"- {'a': 100}\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1002
msgid "Create an \"on_member :ref:`trigger <triggers>`\". The ``trigger-function`` will be executed when a member in the member table is updated."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1005
msgid "this will become the trigger function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1006
msgid "(optional) this will be passed to trigger-function"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1008
msgid "nil or function pointer."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1010
msgid "The **trigger-function** should have three parameter declarations (Tarantool will pass values for them when it invokes the function):"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1013
msgid "the member which is having the member event,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1014
msgid "the event object,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1015
msgid "the ``ctx`` which will be the same value as what is passed to ``swim_object:on_member_event``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1018
msgid "A **member event** is any of:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1020
msgid "appearance of a new member,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1021
msgid "drop of an existing member, or"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1022
msgid "update of an existing member."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1024
msgid "An **event object** is an object which the trigger-function can use for determining what type of member event has happened. The object's methods -- such as ``is_new_status()``, ``is_new_uri()``, ``is_new_incarnation()``, ``is_new_payload()``, ``is_drop()`` -- return boolean values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1030
msgid "A member event may have more than one associated **trigger**. Triggers are executed sequentially. Therefore if a trigger function causes yields or sleeps, other triggers may be forced to wait. However, since trigger execution is done in a separate fiber, SWIM itself is not forced to wait."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1037
msgid "Example of an on-member trigger function:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1039
msgid "tarantool> swim = require('swim')\n"
"\n"
"local function on_event(member, event, ctx)\n"
"    if event:is_new() then\n"
"        ...\n"
"    elseif event:is_drop() then\n"
"        ...\n"
"    end\n"
"\n"
"    if event:is_update() then\n"
"        -- All next conditions can be\n"
"        -- true simultaneously.\n"
"        if event:is_new_status() then\n"
"...\n"
"        end\n"
"        if event:is_new_uri() then\n"
"...\n"
"        end\n"
"        if event:is_new_incarnation() then\n"
"...\n"
"        end\n"
"        if event:is_new_payload() then\n"
"...\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1068
msgid "Notice in the above example that the function is ready for the possibility that multiple events can happen simultaneously for a single trigger activation. ``is_new()`` and ``is_drop()`` can not both be true, but ``is_new()`` and ``is_update()`` can both be true, or ``is_drop()`` and ``is_update()`` can both be true. Multiple simultaneous events are especially likely if there are many events and trigger functions are slow -- in that case, for example, a member might be added and then updated after a while, and then after a while there will be a single trigger activation."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1080
msgid "Also: ``is_new()`` and ``is_new_payload()`` can both be true. This case is not due to trigger functions that are slow. It occurs because \"omitted payload\" and \"size-zero payload\" are not the same thing. For example: when a ping is received, a new member might be added, but ping messages do not include payload. The payload will appear later in a different message. If that is important for the application, then the function should not assume when ``is_new()`` is true that the member already has a payload, and should not assume that payload size says something about the payload's presence or absence."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1091
msgid "Also: functions should not assume that ``is_new()`` and ``is_drop()`` will always be seen. If a new member appears but then is dropped before its appearance has caused a trigger activation, then there will be no trigger activation."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1099
msgid "Delete an on-member trigger."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1101
msgid "old-trigger"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1103
#: ../doc/2.2/reference/reference_lua/swim.rst:1118
msgid "The old-trigger value should be the value returned by ``on_member_event(trigger-function[, ctx])``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1108
msgid "This is a variation of ``on_member_event(new-trigger, [, ctx])``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1110
msgid "The additional parameter is ``old-trigger``. Instead of adding the new-trigger at the end of a list of triggers, this function will replace the entry in the list of triggers that matches old-trigger. The position within a list may be important because triggers are activated sequentially starting with the first trigger in the list."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1123
msgid "Return the list of on-member triggers."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1127
msgid "SWIM internals"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1129
msgid "The SWIM internals section is not necessary for programmers who wish to use the SWIM module, it is for programmers who wish to change or replace the SWIM module."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1132
msgid "The SWIM wire protocol is open, will be backward compatible in case of any changes, and can be implemented by users who wish to simulate their own SWIM cluster members because they use another language than Lua, or another environment unrelated to Tarantool. The protocol is encoded as `MsgPack <https://en.wikipedia.org/wiki/MessagePack>`_."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1139
msgid "SWIM packet structure:\n"
"\n"
"+-----------------Public data, not encrypted------------------+\n"
"|                                                             |\n"
"|      Initial vector, size depends on chosen algorithm.      |\n"
"|                   Next data is encrypted.                   |\n"
"|                                                             |\n"
"+----------Meta section, handled by transport level-----------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_META_TARANTOOL_VERSION: uint, Tarantool        |\n"
"|                                      version ID,            |\n"
"|     1 = SWIM_META_SRC_ADDRESS: uint, ip,                    |\n"
"|     2 = SWIM_META_SRC_PORT: uint, port,                     |\n"
"|     3 = SWIM_META_ROUTING: map {                            |\n"
"|         0 = SWIM_ROUTE_SRC_ADDRESS: uint, ip,               |\n"
"|         1 = SWIM_ROUTE_SRC_PORT: uint, port,                |\n"
"|         2 = SWIM_ROUTE_DST_ADDRESS: uint, ip,               |\n"
"|         3 = SWIM_ROUTE_DST_PORT: uint, port                 |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------Protocol logic section--------------------+\n"
"| map {                                                       |\n"
"|     0 = SWIM_SRC_UUID: 16 byte UUID,                        |\n"
"|                                                             |\n"
"|                 AND                                         |\n"
"|                                                             |\n"
"|     2 = SWIM_FAILURE_DETECTION: map {                       |\n"
"|         0 = SWIM_FD_MSG_TYPE: uint, enum swim_fd_msg_type,  |\n"
"|         1 = SWIM_FD_INCARNATION: uint                       |\n"
"|     },                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     3 = SWIM_DISSEMINATION: array [                         |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_INCARNATION: uint,              |\n"
"|             5 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     1 = SWIM_ANTI_ENTROPY: array [                          |\n"
"|         map {                                               |\n"
"|             0 = SWIM_MEMBER_STATUS: uint,                   |\n"
"|                                     enum member_status,     |\n"
"|             1 = SWIM_MEMBER_ADDRESS: uint, ip,              |\n"
"|             2 = SWIM_MEMBER_PORT: uint, port,               |\n"
"|             3 = SWIM_MEMBER_UUID: 16 byte UUID,             |\n"
"|             4 = SWIM_MEMBER_INCARNATION: uint,              |\n"
"|             5 = SWIM_MEMBER_PAYLOAD: bin                    |\n"
"|         },                                                  |\n"
"|         ...                                                 |\n"
"|     ],                                                      |\n"
"|                                                             |\n"
"|               OR/AND                                        |\n"
"|                                                             |\n"
"|     4 = SWIM_QUIT: map {                                    |\n"
"|         0 = SWIM_QUIT_INCARNATION: uint                     |\n"
"|     }                                                       |\n"
"| }                                                           |\n"
"+-------------------------------------------------------------+"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1210
msgid "The **Initial vector section** appears only when encryption is enabled. This section contains a public key. For example, for AES algorithms it is a 16-byte initial vector stored as is. When no encryption is used, the section size is 0."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1215
msgid "The later sections (Meta and Protocol Logic) are encrypted as one big data chunk if encryption is enabled."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1218
msgid "The **Meta section** handles routing and protocol versions compatibility. It works at the 'transport' level of the SWIM protocol, and is always present. Keys in the meta section are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1222
msgid "SWIM_META_TARANTOOL_VERSION -- mandatory field. Tarantool sets here its version as a 3 byte integer:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1225
msgid "1 byte for major,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1226
msgid "1 byte for minor,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1227
msgid "1 byte for patch."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1229
msgid "For example, Tarantool version 2.1.3 would be encoded like this: ``(((2 << 8) | 1) << 8) | 3;``. This field will be used to support multiple versions of the protocol."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1233
msgid "SWIM_META_SRC_ADDRESS and SWIM_META_SRC_PORT -- mandatory. source IP address and port. IP is encoded as 4 bytes. \"xxx.xxx.xxx.xxx\" where each 'xxx' is encoding of one byte. Port is encoded as an integer. Example of how to encode \"127.0.0.1:3313\":"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1238
msgid "struct in_addr addr;\n"
"inet_aton(\"127.0.0.1\", &addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_ADDRESS);\n"
"pos = mp_encode_uint(pos, addr->s_addr);\n"
"pos = mp_encode_uint(pos, SWIM_META_SRC_PORT);\n"
"pos = mp_encode_uint(pos, 3313);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1247
msgid "SWIM_META_ROUTING subsection -- not mandatory. Responsible for packet forwarding. Used by SWIM suspicion mechanism. Read about suspicion in the SWIM paper."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1251
msgid "If this subsection is present then the following fields are mandatory:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1254
msgid "SWIM_ROUTE_SRC_ADDRESS and SWIM_ROUTE_SRC_PORT (source IP address and port) (should be an address of the message originator (can differ from"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1257
msgid "SWIM_META_SRC_ADDRESS and from SWIM_META_SRC_ADDRESS_PORT);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1258
msgid "SWIM_ROUTE_DST_ADDRESS and SWIM_ROUTE_DST_PORT (destination IP address and port, for the the message's final destination)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1261
msgid "If a message was sent indirectly with the help of SWIM_META_ROUTING, then the reply should be sent back by the same route."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1264
msgid "For an example of how SWIM uses routing for indirect pings ... Assume there are 3 nodes: S1, S2, S3. S1 sends a message to S3 via S2. The following steps are executed in order to deliver the message:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1269
msgid "S1 -> S2\n"
"{ src: S1, routing: {src: S1, dst: S3}, body: ... }"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1274
msgid "S2 receives the message and sees that routing.dst is not equal to S2, so it is a foreign packet. S2 forwards the packet to S3 preserving all the data including body and routing sections."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1278
msgid "S2 -> S3"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1282
msgid "S3 receives the message and sees that routing.dst is equal to S3, so the message is delivered. If S3 wants to answer, it sends a response via the same proxy. It knows that the message was delivered from S2, so it sends an answer via S2."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1287
msgid "The **Protocol logic section** handles SWIM logical protocol steps and actions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1289
msgid "SWIM_SRC_UUID -- mandatory field. SWIM uses UUID as a unique identifier of a member, not IP/port. This field stores UUID of sender. Its type is MP_BIN. Size is always 16 bytes. UUID is encoded in host byte order, no bswaps are needed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1294
msgid "Next sections can all be present, or only some of them. A connector should be ready to handle any combinations."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1297
msgid "In each section a member or the section as a whole has an incarnation number. This number is used so that old messages will be ignored, and false messages will be refuted. If the member incarnation is less than the locally stored incarnation, then the message is outdated. This can happen because UDP allows reordering and duplication."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1306
msgid "Refutation usually happens when a false-positive failure detection has happened. In such a case the member thought to be dead receives that information from other members, increases its own incarnation, and spreads a message saying the member is alive (a \"refutation\")."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1312
msgid "When a member's incarnation number in a message is larger than the local number, all its attributes  (IP, port, status) should be updated with the values received in the message. Payload is a bit different. Payload can be updated only if it is present in the message. Because of its huge size (in comparison with UDP packet max size) payload is not always sent with every message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1320
msgid "SWIM_FAILURE_DETECTION subsection -- describes a ping or ACK. In the SWIM_FAILURE_DETECTION subsection are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1323
msgid "SWIM_FD_MSG_TYPE (0 is ping, 1 is ack);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1324
msgid "SWIM_FD_INCARNATION (incarnation number of the sender)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1326
msgid "SWIM_DISSEMINATION subsection -- a list of changed cluster members. It may include only a subset of changed cluster members if there are too many changes to fit into one UDP packet."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1330
msgid "In the SWIM_DISSEMINATION subsection are:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1332
msgid "SWIM_MEMBER_STATUS (mandatory) (0 = alive, 1 = suspected, 2 = dead, 3 = left);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1333
msgid "SWIM_MEMBER_ADDRESS and SWIM_MEMBER_PORT (mandatory) member IP and port;"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1334
msgid "SWIM_MEMBER_UUID (mandatory) (member UUID);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1335
msgid "SWIM_MEMBER_INCARNATION (mandatory) (member incarnation number);"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1336
msgid "SWIM_MEMBER_PAYLOAD (not mandatory) (member payload) (MessagePack type is MP_BIN)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1339
msgid "Note that absence of SWIM_MEMBER_PAYLOAD means nothing - it is not the same as a payload with zero size."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1342
msgid "SWIM_ANTI_ENTROPY subsection -- a helper for the dissemination. It contains all the same fields as the dissemination, but all of them are mandatory, including payload even when payload size is 0. Anti-entropy eventually spreads changes which for any reason are not spread by the dissemination."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1348
msgid "SWIM_QUIT subsection -- statement that the sender has left the cluster gracefully, for example via :ref:`swim_object:quit() <swim-quit>`, and should not be considered dead. Sender status should be changed to 'left'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1353
msgid "In the SWIM_QUIT subsection is:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/swim.rst:1355
msgid "SWIM_QUIT_INCARNATION (sender incarnation number)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:39
msgid "Module `table`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:43
msgid "The :code:`table` module has everything in the `standard Lua table library <https://www.lua.org/pil/19.html>`_, and some Tarantool extensions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:47
msgid "You can see this by saying \"table\": you will see this list of functions: ``clear`` (LuaJIT extension = erase all elements), `concat <https://www.lua.org/manual/5.1/manual.html#pdf-table.concat>`_ (concatenate), ``copy`` (make a copy of an array), ``deepcopy`` (see description below), ``foreach``, ``foreach1``, `getn <https://www.lua.org/pil/19.1.html>`_ (get the number of elements in an array), `insert <https://www.lua.org/manual/5.1/manual.html#pdf-table.insert>`_ (insert an element into an array), `maxn <https://www.lua.org/manual/5.1/manual.html#pdf-table.maxn>`_ (get largest index) `move <https://www.lua.org/manual/5.3/manual.html#pdf-table.move>`_ (move elements between tables), ``new`` (LuaJIT extension = return a new table with pre-allocated elements), `remove <https://www.lua.org/manual/5.1/manual.html#pdf-table.remove>`_ (remove an element from an array), `sort <https://www.lua.org/manual/5.1/manual.html#pdf-table.sort>`_ (sort the elements of an array)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:62
msgid "In this section we only discuss the additional function that the Tarantool developers have added: ``deepcopy``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:69
msgid "Return a \"deep\" copy of the table -- a copy which follows nested structures to any depth and does not depend on pointers, it copies the contents."
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:73
msgid "(table) the table to copy"
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:75
msgid "the copy of the table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/table.rst:80
msgid "tarantool> input_table = {1,{'a','b'}}\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table = table.deepcopy(input_table)\n"
"---\n"
"...\n"
"\n"
"tarantool> output_table\n"
"---\n"
"- - 1\n"
"  - - a\n"
"    - b\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:37
msgid "Module `tap`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:43
msgid "The ``tap`` module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:61
msgid ":ref:`tap.test() <tap-test>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:61
#: ../doc/2.2/tutorials/sql_tutorial.rst:58
msgid "Initialize"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:64
msgid ":ref:`taptest:test() <taptest-test>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:64
msgid "Create a subtest and print the results"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:67
msgid ":ref:`taptest:plan() <taptest-plan>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:67
msgid "Indicate how many tests to perform"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:70
msgid ":ref:`taptest:check() <taptest-check>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:70
msgid "Check the number of tests performed"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:73
msgid ":ref:`taptest:diag() <taptest-diag>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:73
msgid "Display a diagnostic message"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:76
msgid ":ref:`taptest:ok() <taptest-ok>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:76
#: ../doc/2.2/reference/reference_lua/tap.rst:79
#: ../doc/2.2/reference/reference_lua/tap.rst:82
msgid "Evaluate the condition and display the message"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:79
msgid ":ref:`taptest:fail() <taptest-fail>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:82
msgid ":ref:`taptest:skip() <taptest-skip>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:85
msgid ":ref:`taptest:is() <taptest-is>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:85
msgid "Check if the two arguments are equal"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:88
msgid ":ref:`taptest:isnt() <taptest-isnt>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:88
msgid "Check if the two arguments are different"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:91
msgid ":ref:`taptest:is_deeply() <taptest-is_deeply>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:91
msgid "Recursively check if the two arguments are equal"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:94
msgid ":ref:`taptest:like() <taptest-like>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:94
msgid "Check if the argument matches a pattern"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:97
msgid ":ref:`taptest:unlike() <taptest-unlike>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:97
msgid "Check if the argument does not match a pattern"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:100
msgid ":ref:`taptest:isnil() <taptest-istype>` |br| :ref:`taptest:isstring() <taptest-istype>` |br| :ref:`taptest:isnumber() <taptest-istype>` |br| :ref:`taptest:istable() <taptest-istype>` |br| :ref:`taptest:isboolean() <taptest-istype>` |br| :ref:`taptest:isudata() <taptest-istype>` |br| :ref:`taptest:iscdata() <taptest-istype>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:106
msgid "Check if a value has a particular type"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:115
msgid ":ref:`taptest.strict <taptest-strict>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:115
msgid "Flag, true if comparisons with nil should be strict"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:125
msgid "Initialize."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:127
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:131
#: ../doc/2.2/reference/reference_lua/tap.rst:152
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:132
#: ../doc/2.2/reference/reference_lua/tap.rst:154
msgid "taptest"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:135
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:146
msgid "Create a subtest (if no ``func`` argument specified), or (if all arguments are specified) create a subtest, run the test function and print the result."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:150
msgid "See the :ref:`example <tap-example>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:153
msgid "the test logic to run."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:155
msgid "userdata or string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:161
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:170
msgid "Checks the number of tests performed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:172
msgid "The result will be a display saying ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``. (This is a purely Tarantool feature: \"bad plan\" messages are out of the TAP13 standard.)"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:177
msgid "This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script. However, as a Tarantool extension, ``taptest:check()`` may appear at the end of any subtest. Therefore there are three ways to cause the check:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:182
msgid "by calling ``taptest:check()`` at the end of a script,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:183
msgid "by calling a function which ends with a call to ``taptest:check()``,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:184
msgid "or by calling taptest:test('...', subtest-function-name) where subtest-function-name does not need to end with ``taptest:check()`` because it can be called after the subtest is complete."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:195
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:197
msgid "the message to be displayed."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:204
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:208
msgid "an expression which is true or false"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:209
#: ../doc/2.2/reference/reference_lua/tap.rst:243
#: ../doc/2.2/reference/reference_lua/tap.rst:256
#: ../doc/2.2/reference/reference_lua/tap.rst:279
#: ../doc/2.2/reference/reference_lua/tap.rst:291
#: ../doc/2.2/reference/reference_lua/tap.rst:308
#: ../doc/2.2/reference/reference_lua/tap.rst:323
#: ../doc/2.2/reference/reference_lua/tap.rst:337
#: ../doc/2.2/reference/reference_lua/tap.rst:356
msgid "name of the test"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:216
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:240
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:252
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:262
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:274
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:277
#: ../doc/2.2/reference/reference_lua/tap.rst:289
#: ../doc/2.2/reference/reference_lua/tap.rst:306
#: ../doc/2.2/reference/reference_lua/tap.rst:321
#: ../doc/2.2/reference/reference_lua/tap.rst:335
msgid "actual result"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:278
#: ../doc/2.2/reference/reference_lua/tap.rst:290
#: ../doc/2.2/reference/reference_lua/tap.rst:307
msgid "expected result"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:287
msgid "This is the negation of :ref:`taptest:is() <taptest-is>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:300
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:314
msgid "Verify a string against a `pattern <http://lua-users.org/wiki/PatternsTutorial>`_. Ok if match is found."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:322
#: ../doc/2.2/reference/reference_lua/tap.rst:336
msgid "pattern"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:325
msgid "test:like(tarantool.version, '^[1-9]', \"version\")"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:333
msgid "This is the negation of :ref:`taptest:like() <taptest-like>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:352
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:365
msgid "Set ``taptest.strict=true`` if :ref:`taptest:is() <taptest-is>` and :ref:`taptest:isnt() <taptest-isnt>` and :ref:`taptest:is_deeply() <taptest-is_deeply>` must be compared strictly with ``nil``. Set ``taptest.strict=false`` if ``nil`` and ``box.NULL`` both have the same effect. The default is false. For example, if and only if ``taptest.strict=true`` has happened, then ``taptest:is_deeply({a = box.NULL}, {})`` will return ``false``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:384
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:388
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:402
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tap.rst:404
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tarantool.rst:39
msgid "Module `tarantool`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/tarantool.rst:43
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tarantool.rst:49
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info() <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/2.2/reference/reference_lua/tarantool.rst:56
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:37
msgid "Module `uri`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:43
msgid "A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard <https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:47
msgid "[scheme:]scheme-specific-part[#fragment]"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:51
msgid "A common type, a hierarchical URI, looks like this:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:53
msgid "[scheme:][//authority][path][?query][#fragment]"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:57
msgid "For example the string ``'https://tarantool.org/x.html#y'`` has three components:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:60
msgid "``https`` is the scheme,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:61
msgid "``tarantool.org/x.html`` is the path,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:62
msgid "``y`` is the fragment."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:64
msgid "Tarantool's URI module provides routines which convert URI strings into their components, or turn components into URI strings."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:71
msgid "Below is a list of all ``uri`` functions."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:81
msgid ":ref:`uri.parse() <uri-parse>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:81
msgid "Get a table of URI components"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:84
msgid ":ref:`uri.format() <uri-format>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:84
msgid "Construct a URI from components"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:94
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:95
msgid "URI-components-table. Possible components are fragment, host, login, password, path, query, scheme, service."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:97
msgid "Table"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:101
msgid "tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:118
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:120
msgid "boolean. If this is supplied and is ``true``, then the password component is rendered in clear text, otherwise it is omitted."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:123
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uri.rst:128
msgid "tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:39
msgid "Module `utf8`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:45
msgid "``utf8`` is Tarantool's module for handling UTF-8 strings. It includes some functions which are compatible with ones in `Lua 5.3 <https://www.lua.org/manual/5.3/manual.html#6.5>`_ but Tarantool has much more. For example, because internally Tarantool contains a complete copy of the \"International Components For Unicode\" library, there are comparison functions which understand the default ordering for Cyrillic (Capital Letter Zhe Ж = Small Letter Zhe ж) and Japanese (Hiragana A = Katakana A)."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:55
msgid "The module is fully built-in so ``require('utf8')`` is not necessary."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:65
msgid ":ref:`casecmp <utf8-casecmp>` and |br| :ref:`cmp <utf8-cmp>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:65
msgid "Comparisons"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:68
msgid ":ref:`lower <utf8-lower>` and |br| :ref:`upper <utf8-upper>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:68
msgid "Case conversions"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:71
msgid ":ref:`isalpha <utf8-isalpha>`, |br| :ref:`isdigit <utf8-isdigit>`, |br| :ref:`islower <utf8-islower>` and |br| :ref:`isupper <utf8-isupper>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:71
msgid "Determine character types"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:76
msgid ":ref:`sub <utf8-sub>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:76
msgid "Substrings"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:78
msgid ":ref:`len <utf8-len>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:78
msgid "Length in characters"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:80
msgid ":ref:`next <utf8-next>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:80
msgid "Character-at-a-time iterations"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:89
#: ../doc/2.2/reference/reference_lua/utf8.rst:150
#: ../doc/2.2/reference/reference_lua/utf8.rst:271
#: ../doc/2.2/reference/reference_lua/utf8.rst:308
#: ../doc/2.2/reference/reference_lua/utf8.rst:325
#: ../doc/2.2/reference/reference_lua/utf8.rst:384
msgid "a string encoded with UTF-8"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:90
#: ../doc/2.2/reference/reference_lua/utf8.rst:151
msgid "-1 meaning \"less\", 0 meaning \"equal\", +1 meaning \"greater\""
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:93
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code-point values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:100
msgid "The comparison is done with primary weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are ignored. If asked \"is this like a Microsoft case-insensitive accent-insensitive collation\" we tend to answer \"yes\", though the Unicode Collation Algorithm is far more sophisticated than those terms imply."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:110
msgid "tarantool> utf8.casecmp('é','e'),utf8.casecmp('E','e')\n"
"---\n"
"- 0\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:122
msgid "a Unicode code point value, repeatable"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:123
msgid "a UTF-8 string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:126
msgid "The code-point number is the value that corresponds to a character in the `Unicode Character Database <http://www.unicode.org/Public/5.2.0/ucd/UnicodeData.txt>`_ This is not the same as the byte values of the encoded character, because the UTF-8 encoding scheme is more complex than a simple copy of the code-point number."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:133
msgid "Another way to construct a string with Unicode characters is with the \\\\u{hex-digits} escape mechanism, for example '\\\\u{41}\\\\u{42}' and ``utf8.char(65,66)`` both produce the string 'AB'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:139
msgid "tarantool> utf8.char(229)\n"
"---\n"
"- å\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:154
msgid "Compare two strings with the Default Unicode Collation Element Table (DUCET) for the `Unicode Collation Algorithm <http://www.unicode.org/Public/UCA/10.0.0/allkeys.txt>`_. Thus 'å' is less than 'B', even though the code-point value of å (229) is greater than the code-point value of B (66), because the algorithm depends on the values in the Collation Element Table, not the code values."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:161
msgid "The comparison is done with at least three weights. Therefore the elements which affect secondary or later weights (such as \"case\" in Latin or Cyrillic alphabets, or \"kana differentiation\" in Japanese) are not ignored. and upper case comes after lower case."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:168
msgid "tarantool> utf8.cmp('é','e'),utf8.cmp('E','e')\n"
"---\n"
"- 1\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:180
#: ../doc/2.2/reference/reference_lua/utf8.rst:205
#: ../doc/2.2/reference/reference_lua/utf8.rst:227
#: ../doc/2.2/reference/reference_lua/utf8.rst:249
msgid "a single UTF8 character, expressed as a one-byte string or a code point value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:185
msgid "Return true if the input character is an \"alphabetic-like\" character, otherwise return false. Generally speaking a character will be considered alphabetic-like provided it is typically used within a word, as opposed to a digit or punctuation. It does not have to be a character in an alphabet."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:192
msgid "tarantool> utf8.isalpha('Ж'),utf8.isalpha('å'),utf8.isalpha('9')\n"
"---\n"
"- true\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:210
msgid "Return true if the input character is a digit, otherwise return false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:214
msgid "tarantool> utf8.isdigit('Ж'),utf8.isdigit('å'),utf8.isdigit('9')\n"
"---\n"
"- false\n"
"- false\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:232
msgid "Return true if the input character is lower case, otherwise return false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:236
msgid "tarantool> utf8.islower('Ж'),utf8.islower('å'),utf8.islower('9')\n"
"---\n"
"- false\n"
"- true\n"
"- false\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:254
msgid "Return true if the input character is upper case, otherwise return false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:258
msgid "tarantool> utf8.isupper('Ж'),utf8.isupper('å'),utf8.isupper('9')\n"
"---\n"
"- true\n"
"- false\n"
"- false\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:272
msgid "byte position of the first character"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:273
msgid "byte position where to stop"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:274
msgid "the number of characters in the string, or between start and end"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:277
msgid "Byte positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:280
msgid "If the string contains a byte sequence which is not valid in UTF-8, each byte in the invalid byte sequence will be counted as one character."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:283
msgid "UTF-8 is a variable-size encoding scheme. Typically a simple Latin letter takes one byte, a Cyrillic letter takes two bytes, a Chinese/Japanese character takes three bytes, and the maximum is four bytes."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:290
msgid "tarantool> utf8.len('G'),utf8.len('ж')\n"
"---\n"
"- 1\n"
"- 1\n"
"...\n"
"\n"
"tarantool> string.len('G'),string.len('ж')\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:309
msgid "the same string, lower case"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:314
msgid "tarantool> utf8.lower('ÅΓÞЖABCDEFG')\n"
"---\n"
"- åγþжabcdefg\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:326
msgid "byte position where to start within the string, default is 1"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:327
msgid "byte position of the next character and the code point value of the next character"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:330
msgid "The ``next`` function is often used in a loop to get one character at a time from a UTF-8 string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:335
msgid "In the string 'åa' the first character is 'å', it starts at position 1, it takes two bytes to store so the character after it will be at position 3, its Unicode code point value is (decimal) 229."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:340
msgid "tarantool> -- show next-character position + first-character codepoint\n"
"tarantool> utf8.next('åa', 1)\n"
"---\n"
"- 3\n"
"- 229\n"
"...\n"
"tarantool> -- (loop) show codepoint of every character\n"
"tarantool> for position,codepoint in utf8.next,'åa' do print(codepoint) end\n"
"229\n"
"97\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:358
msgid "a string encoded as UTF-8"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:359
msgid "the position of the first character"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:360
msgid "the position of the last character"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:361
msgid "a UTF-8 string, the \"substring\" of the input value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:364
msgid "Character positions for start and end can be negative, which indicates \"calculate from end of string\" rather than \"calculate from start of string\"."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:367
msgid "The default value for end-character is the length of the input string. Therefore, saying ``utf8.sub(1, 'abc')`` will return 'abc', the same as the input string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:373
msgid "tarantool> utf8.sub('åγþжabcdefg', 5, 8)\n"
"---\n"
"- abcd\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:385
msgid "the same string, upper case"
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:390
msgid "In rare cases the upper-case result may be longer than the lower-case input, for example ``utf8.upper('ß')`` is 'SS'."
msgstr ""

#: ../doc/2.2/reference/reference_lua/utf8.rst:395
msgid "tarantool> utf8.upper('åγþжabcdefg')\n"
"---\n"
"- ÅΓÞЖABCDEFG\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:37
msgid "Module `uuid`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:43
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:53
msgid "Below is list of all ``uuid`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:63
msgid ":ref:`uuid.nil <uuid-nil>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:63
#: ../doc/2.2/reference/reference_lua/uuid.rst:88
msgid "A nil object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:65
msgid ":ref:`uuid() <uuid-__call>` |br| :ref:`uuid.bin() <uuid-bin>` |br| :ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:66
msgid "Get a UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:69
msgid ":ref:`uuid.fromstr() <uuid-fromstr>` |br| :ref:`uuid.frombin() <uuid-frombin>` |br| :ref:`uuid_object:bin() <uuid-object_bin>` |br| :ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:72
msgid "Get a converted UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:78
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:78
msgid "Check if a UUID is an all-zero value"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:94
#: ../doc/2.2/reference/reference_lua/uuid.rst:101
#: ../doc/2.2/reference/reference_lua/uuid.rst:108
msgid "a UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:102
msgid "16-byte string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:109
msgid "36-byte binary string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:115
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:116
#: ../doc/2.2/reference/reference_lua/uuid.rst:124
msgid "converted UUID"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:123
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:133
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:135
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:136
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:137
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:138
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:140
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:142
#: ../doc/2.2/reference/reference_lua/uuid.rst:149
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:143
msgid "16-byte binary string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:150
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:156
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:161
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/2.2/reference/reference_lua/uuid.rst:168
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:39
msgid "Module `xlog`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:41
msgid "The xlog module contains one function: ``pairs()``. It can be used to read Tarantool's :ref:`snapshot files<index-box_persistence>` or :ref:`write-ahead-log (WAL) <internals-wal>` files. A description of the file format is in section :ref:`Data persistence and the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:53
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:55
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:56
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:58
msgid "Possible errors: File does not contain properly formatted snapshot or write-ahead-log information."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:63
msgid "This will read the first write-ahead-log (WAL) file that was created in the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting started\" exercises <getting_started>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:67
msgid "Each result from ``pairs()`` is formatted with MsgPack so its structure can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:70
msgid "xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:79
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/xlog.rst:81
msgid "(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:39
msgid "Module `yaml`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:45
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:52
msgid "Below is a list of all ``yaml`` functions and members."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:62
msgid ":ref:`yaml.encode() <yaml-encode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:62
msgid "Convert a Lua object to a YAML string"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:65
msgid ":ref:`yaml.decode() <yaml-decode>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:65
msgid "Convert a YAML string to a Lua object"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:68
msgid ":ref:`yaml.NULL <yaml-null>`"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:78
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:81
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:88
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:90
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:104
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:127
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:130
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:131
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:132
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:133
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:138
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_lua/yaml.rst:174
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:39
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:41
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:45
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:50
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:53
msgid "The Tarantool rocks allow for connecting to SQL servers and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:64
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:72
msgid "MySQL Example"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:74
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:81
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server instance. After that, one can pass any MySQL statement to the server instance and receive results, including multiple result sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:87
#: ../doc/2.2/reference/reference_rock/dbms.rst:440
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:91
msgid "Installation"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:89
#: ../doc/2.2/reference/reference_rock/dbms.rst:442
msgid "Check the instructions for `downloading and installing a binary package <http://tarantool.org/download.html>`_ that apply for the environment where Tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:99
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:103
#: ../doc/2.2/reference/reference_rock/dbms.rst:456
msgid "With LuaRocks"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:105
#: ../doc/2.2/reference/reference_rock/dbms.rst:458
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:118
msgid "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:124
#: ../doc/2.2/reference/reference_rock/dbms.rst:477
msgid "With GitHub"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:126
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:128
msgid "$ git clone https://github.com/tarantool/mysql.git\n"
"$ cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:135
#: ../doc/2.2/reference/reference_rock/dbms.rst:488
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:141
#: ../doc/2.2/reference/reference_rock/dbms.rst:494
msgid "Connecting"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:143
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:146
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:150
#: ../doc/2.2/reference/reference_rock/dbms.rst:503
msgid "Now, say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:157
#: ../doc/2.2/reference/reference_rock/dbms.rst:510
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:159
#: ../doc/2.2/reference/reference_rock/dbms.rst:512
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:160
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:161
#: ../doc/2.2/reference/reference_rock/dbms.rst:514
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:162
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:163
#: ../doc/2.2/reference/reference_rock/dbms.rst:516
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:164
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:166
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:173
#: ../doc/2.2/reference/reference_rock/dbms.rst:520
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:175
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:191
#: ../doc/2.2/reference/reference_rock/dbms.rst:532
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:193
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:209
#: ../doc/2.2/reference/reference_rock/dbms.rst:551
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:213
#: ../doc/2.2/reference/reference_rock/dbms.rst:555
msgid "How to ping"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:215
#: ../doc/2.2/reference/reference_rock/dbms.rst:557
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:220
#: ../doc/2.2/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:224
#: ../doc/2.2/reference/reference_rock/dbms.rst:566
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:233
#: ../doc/2.2/reference/reference_rock/dbms.rst:575
msgid "Executing a statement"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:235
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:240
#: ../doc/2.2/reference/reference_rock/dbms.rst:582
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:242
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:248
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:261
#: ../doc/2.2/reference/reference_rock/dbms.rst:602
msgid "Closing connection"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:263
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:268
#: ../doc/2.2/reference/reference_rock/dbms.rst:609
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:272
#: ../doc/2.2/reference/reference_rock/dbms.rst:613
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:278
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:285
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:289
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.1/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.1\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.1.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.1.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:370
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:373
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:381
msgid "Create a Lua function that will connect to the MySQL server instance, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:386
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:410
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:417
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:419
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:424
msgid "$ sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:428
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:434
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server instance. After that, one can pass any PostgreSQL statement to the server instance and receive results."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:452
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:471
msgid "$ luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:479
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:481
msgid "$ git clone https://github.com/tarantool/pg.git\n"
"$ cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:496
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:499
msgid "pg = require('pg')"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:513
msgid ":samp:`port = {port-number}` - number, default value = 5432"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:515
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:518
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:522
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:534
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:577
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:584
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any placeholders ($1 $2 $3 etc.) in the SQL statement."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:590
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:604
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:619
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:626
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server instance is already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:630
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/2.0/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 2.0\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (2.0.4.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 2.0.4-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:704
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:707
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:715
msgid "Create a Lua function that will connect to a PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:720
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/dbms.rst:745
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:39
msgid "Module `expirationd`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:41
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at the source code of ``expirationd``, which Tarantool supplies on GitHub_ with an Artistic license. The ``expirationd.lua`` program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:47
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:55
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:60
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"    expiration_process(task, tuple)\n"
"...\n"
"    /* expiration_process() contains:\n"
"    if task.is_tuple_expired(task.args, tuple) then\n"
"    task.expired_tuples_count = task.expired_tuples_count + 1\n"
"    task.process_expired_tuple(task.space_id, task.args, tuple) */"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:71
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:76
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    box.space[space_id]:delete(construct_key(space_id, tuple))\n"
"end\n"
"    /* construct_key() contains:\n"
"    local function construct_key(space_id, tuple)\n"
"        return fun.map(\n"
"            function(x) return tuple[x.fieldno] end,\n"
"           box.space[space_id].index[0].parts\n"
"        ):totable()\n"
"    end */"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:90
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:100
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:105
msgid "At this point, if the above explanation is worthwhile, it is clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and -- whenever it finds a tuple that has expired -- deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:114
msgid "For those who like to see things run, here are the exact steps to get ``expirationd`` through the test."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:117
msgid "Get ``expirationd.lua``. There are standard ways -- it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_ -- but for this purpose just copy the contents of ``expirationd.lua`` to a directory on the Lua path (type ``print(package.path)`` to see the Lua path)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:122
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:123
msgid "Execute these requests:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:125
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:148
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:153
msgid "The function which will be supplied to ``expirationd`` is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:158
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The require_ function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel, but is on the Lua path (``package.path``) or the C path (``package.cpath``). After the Lua variable expd has been assigned the value of the ``expirationd`` module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:167
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:172
msgid "After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the ``is_tuple_expired()`` function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:179
msgid "Of course, ``expirationd`` can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code. Particularly important are ``{options}`` which can be added as a final parameter in ``expirationd.run_task``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:184
msgid "``force`` (boolean) -- run task even on replica. Default: ``force=false`` so ordinarily ``expirationd`` ignores replicas."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:186
msgid "``tuples_per_iteration`` (integer) -- number of tuples that will be checked by one iteration Default: ``tuples_per_iteration=1024``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:189
msgid "``full_scan_time`` (number) -- number of seconds required for full index scan Default: ``full_scan_time=3600``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:191
msgid "``vinyl_assumed_space_len`` (integer) -- assumed size of vinyl space, for the first iteration only. Default: ``vinyl_assumed_space_len=10000000``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/expirationd.rst:194
msgid "``vinyl_assumed_space_len_factor`` (integer) -- factor for recalculation of size of vinyl space. Default: ``vinyl_assumed_space_len_factor=2``. (The size of a vinyl space cannot be easily calculated, so on the first iteration it will be the \"assumed\" size, on the second iteration it will be \"assumed\" times \"factor\", on the third iteration it will be \"assumed\" times \"factor\" times factor\", and so on.)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/index.rst:37
msgid "Rocks reference"
msgstr ""

#: ../doc/2.2/reference/reference_rock/index.rst:39
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:39
msgid "Module `shard`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:43
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server instance on each node. With this arrangement, each instance is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:48
msgid "The Tarantool `shard` module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:52
msgid "First some terminology:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:55
msgid "**Consistent hash**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:57
msgid "The `shard` module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent <https://en.wikipedia.org/wiki/Consistent_hashing>`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the `shard` module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:64
msgid "**Instance**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:66
msgid "A currently-running in-memory copy of the Tarantool server, sometimes called a \"server instance\". Usually each shard is associated with one instance, or, if both sharding and replicating are going on, each shard is associated with one replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:70
msgid "**Queue**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:72
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on every node. The `shard` module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:78
msgid "**Redundancy**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:80
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:81
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2122
msgid "**Replica**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:83
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:84
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2111
msgid "**Replica set**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:86
msgid "Often a single shard is associated with a single instance; however, often the shard is replicated. When a shard is replicated, the multiple instances (\"replicas\"), which handle the shard's replicated data, are a \"replica set\"."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:90
msgid "**Replicated data**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:92
msgid "A complete copy of the data. The `shard` module handles both sharding and replication. One shard can contain one or more replicated data copies. When a write occurs, the write is attempted on every replicated data copy in turn. The `shard` module does not use the built-in replication feature."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:96
msgid "**Shard**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:98
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:102
msgid "**Zone**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:104
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single Tarantool-server instance. A shard's replicated data copies should be in different zones."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:109
msgid "The `shard` package is distributed separately from the main `tarantool` package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:112
msgid "with Tarantool 1.7.4+, say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:114
msgid "$ tarantoolctl rocks install shard"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:118
msgid "install with `yum` or `apt`, for example on Ubuntu say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:124
msgid "or download from GitHub `tarantool/shard` and use the Lua files as described in the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:127
msgid "Then, before using the module, say ``shard = require('shard')``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:129
msgid "The most important function is:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:134
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:136
msgid "This must be called for every shard."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:138
msgid "The shard configuration is a table with these fields:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:140
msgid "`servers` (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:141
msgid "`login` (the user name which applies for accessing via the `shard` module)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:142
msgid "`password` (the password for the login)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:143
msgid "`redundancy` (a number, minimum 1)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:144
msgid "`binary` (a port number that this host is listening on, on the current host, (distinguishable from the 'listen' port specified by `box.cfg`)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:147
msgid "Possible errors:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:149
msgid "redundancy should not be greater than the number of servers;"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:150
msgid "the servers must be alive;"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:151
msgid "two replicated data copies of the same shard should not be in the same zone."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:155
msgid "Example: `shard.init` syntax for one shard"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:157
msgid "The number of replicated data copies per shard (redundancy) is 3."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:158
msgid "The number of instances is 3."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:159
msgid "The `shard` module will conclude that there is only one shard."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:161
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:182
msgid "Example: `shard.init` syntax for three shards"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:184
msgid "This describes three shards. Each shard has two replicated data copies. Since the number of servers is 7, and the number of replicated data copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:189
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:212
msgid "Every data-access function in the `box` module has an analogue in the `shard` module:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:218
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:225
msgid "For example, to insert in table T in a sharded database you simply say ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:228
msgid "A ``shard.T:select{}`` request without a primary key will cause an error."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:230
msgid "Every queued data-access function has an analogue in the `shard` module:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:235
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:242
msgid "The user must add an `operation_id`. For details of queued data-access functions, and of maintenance-related functions, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:248
msgid "Example: shard, minimal configuration"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:250
msgid "There is only one shard, and that shard contains only one replicated data copy. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:256
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:283
msgid "If you cut and paste the above, then the result, showing only the requests and responses for `shard.init` and `shard.tester`, should look approximately like this:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:287
msgid "<...>\n"
"tarantool> shard.init(cfg)\n"
"2017-09-06 ... I> Sharding initialization started...\n"
"2017-09-06 ... I> establishing connection to cluster servers...\n"
"2017-09-06 ... I> connected to all servers\n"
"2017-09-06 ... I> started\n"
"2017-09-06 ... I> redundancy = 1\n"
"2017-09-06 ... I> Adding localhost:3301 to shard 1\n"
"2017-09-06 ... I> shards = 1\n"
"2017-09-06 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:312
msgid "Example: shard, scaling out"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:314
msgid "There are two shards, and each shard contains one replicated data copy. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:319
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:321
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'test_user',\n"
"         >   password = 'pass',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:350
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:352
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.create('test_user', {password = 'pass'})\n"
"tarantool> box.schema.user.grant('test_user', 'read,write,execute', 'universe')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'test_user';\n"
"         >   password = 'pass';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:381
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:385
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:387
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:394
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the `shard` module."
msgstr ""

#: ../doc/2.2/reference/reference_rock/shard.rst:397
msgid "For details, see the `README <https://github.com/tarantool/shard>`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:37
msgid "Module `tdb`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:39
msgid "The Tarantool Debugger (abbreviation = ``tdb``) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:45
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:48
msgid "$ git clone --recursive https://github.com/Sulverus/tdb\n"
"$ cd tdb\n"
"$ make\n"
"$ sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:55
msgid "To initiate ``tdb`` within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:58
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:63
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:68
msgid "Debugger Commands"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:72
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:71
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:75
msgid ":codebold:`c`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:75
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:82
msgid ":codebold:`e`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:78
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:85
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:85
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:89
msgid ":codebold:`f`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:88
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:92
msgid ":codebold:`n`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:92
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:95
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:95
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:98
msgid ":codebold:`h`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:98
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:102
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:101
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:105
msgid ":codebold:`q`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:105
msgid "Quit immediately."
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:109
msgid "Example Session"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:111
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:113
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:121
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:123
msgid "$ tarantool example.lua"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:127
#: ../doc/2.2/reference/reference_rock/tdb.rst:152
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:132
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:139
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:143
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:157
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/2.2/reference/reference_rock/tdb.rst:174
msgid "Another debugger example can be found `here <https://github.com/sulverus/tdb>`_."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:39
msgid "Module `vshard`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:45
msgid "Summary"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:47
msgid "The ``vshard`` module introduces the sharding feature, which enables horizontal scaling in Tarantool."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:50
msgid "While a project is growing, scaling the databases may become the most challenging issue. Once a single server cannot withstand the load, scaling methods should be applied."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:54
msgid "There are two different approaches for scaling data, `vertical and horizontal scaling <https://en.wikipedia.org/wiki/Scalability#Horizontal_and_vertical_scaling>`_:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:57
msgid "*Vertical scaling* implies that the hardware capacities of a single server would be increased."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:60
msgid "*Horizontal scaling* implies that a dataset is partitioned and distributed over multiple servers. In case new servers are added, the dataset is re-distributed evenly across all servers, both the original and new ones."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:64
msgid "Sharding is a database architecture that allows for horizontal scaling."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:66
msgid "With ``vshard``, the tuples of a dataset are distributed across multiple nodes, with a Tarantool database server instance on each node. Each instance handles only a subset of the total data, so larger loads can be handled by simply adding more servers. The initial dataset is partitioned into multiple parts, so each part is stored on a separate server. The dataset is partitioned using sharding keys."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:72
msgid "The ``vshard`` module is based on the concept of virtual buckets, where a tuple set is partitioned into a large number of abstract virtual nodes (virtual buckets, or buckets) rather than into a smaller number of physical nodes."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:76
msgid "Hashing a sharding key into a large number of virtual buckets allows seamlessly changing the number of servers in the cluster. The rebalancing mechanism distributes buckets evenly among all shards in case some servers were added or removed."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:80
msgid "The buckets have states, so it is easy to monitor the server states. For example, a server instance is active and available for all types of requests, or a failover occurred and the instance accepts only read requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:84
msgid "The ``vshard`` module provides analogs for the data-manipulation functions of the Tarantool ``box`` library (select, insert, replace, update, delete)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:93
msgid "The ``vshard`` module is distributed separately from the main Tarantool package. To acquire it, do a separate installation:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:96
msgid "$ tarantoolctl rocks install vshard"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:102
msgid "The ``vshard`` module requires Tarantool version 1.9+."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:108
msgid "Quick start"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:110
msgid "The ``vshard/example/`` directory includes a pre-configured development cluster of 1 ``router`` and 2 replica sets of 2 nodes (2 ``storages``) each, making 5 Tarantool instances in total:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:114
msgid "``router_1`` – a ``router`` instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:115
msgid "``storage_1_a`` – a ``storage`` instance, the master of the first replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:116
msgid "``storage_1_b`` – a ``storage`` instance, the replica of the first replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:117
msgid "``storage_2_a`` – a ``storage`` instance, the master of the second replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:118
msgid "``storage_2_b`` – a ``storage`` instance, the replica of the second replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:120
msgid "All instances are managed using the ``tarantoolctl`` utility which comes with Tarantool."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:122
msgid "Change the directory to ``example/`` and use make to run the development cluster:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:124
msgid "$ cd example/\n"
"$ make\n"
"tarantoolctl stop storage_1_a  # stop the first storage instance\n"
"Stopping instance storage_1_a...\n"
"tarantoolctl stop storage_1_b\n"
"<...>\n"
"rm -rf data/\n"
"tarantoolctl start storage_1_a # start the first storage instance\n"
"Starting instance storage_1_a...\n"
"Starting configuration of replica 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"I am master\n"
"Taking on replicaset master role...\n"
"Run console at unix/:./data/storage_1_a.control\n"
"started\n"
"mkdir ./data/storage_1_a\n"
"<...>\n"
"tarantoolctl start router_1 # start the router\n"
"Starting instance router_1...\n"
"Starting router configuration\n"
"Calling box.cfg()...\n"
"<...>\n"
"Run console at unix/:./data/router_1.control\n"
"started\n"
"mkdir ./data/router_1\n"
"Waiting cluster to start\n"
"echo \"vshard.router.bootstrap()\" | tarantoolctl enter router_1\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control> vshard.router.bootstrap()\n"
"---\n"
"- true\n"
"...\n"
"unix/:./data/router_1.control>\n"
"tarantoolctl enter router_1 # enter the admin console\n"
"connected to unix/:./data/router_1.control\n"
"unix/:./data/router_1.control>"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:162
msgid "Some ``tarantoolctl`` commands:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:164
msgid "``tarantoolctl start router_1`` – start the router instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:165
msgid "``tarantoolctl enter router_1``  – enter the admin console"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:167
msgid "The full list of ``tarantoolctl`` commands for managing Tarantool instances is available in the :ref:`tarantoolctl reference <tarantoolctl>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:170
msgid "Essential make commands you need to know:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:172
msgid "``make start`` – start all Tarantool instances"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:173
msgid "``make stop`` – stop all Tarantool instances"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:174
msgid "``make logcat`` – show logs from all instances"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:175
msgid "``make enter`` – enter the admin console on router_1"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:176
msgid "``make clean`` – clean up all persistent data"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:177
msgid "``make test`` – run the test suite (you can also run test-run.py in the test directory)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:178
msgid "``make`` – execute ``make stop``, ``make clean``, ``make start`` and ``make enter``"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:180
msgid "For example, to start all instances, use ``make start``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:182
msgid "$ make start\n"
"$ ps x|grep tarantool\n"
"46564   ??  Ss     0:00.34 tarantool storage_1_a.lua <running>\n"
"46566   ??  Ss     0:00.19 tarantool storage_1_b.lua <running>\n"
"46568   ??  Ss     0:00.35 tarantool storage_2_a.lua <running>\n"
"46570   ??  Ss     0:00.20 tarantool storage_2_b.lua <running>\n"
"46572   ??  Ss     0:00.25 tarantool router_1.lua <running>"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:192
msgid "To perform commands in the admin console, use the ``router`` API:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:194
msgid "unix/:./data/router_1.control> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:228
msgid "Architecture"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:230
msgid "A sharded cluster in Tarantool consists of storages, routers, and a rebalancer."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:232
msgid "A **storage** is a node storing a subset of a dataset. Multiple replicated storages are deployed as replica sets to provide redundancy (a replica set can also be called a shard)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:236
msgid "A **router** is a standalone software component that routes read and write requests from the client application to shards."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:239
msgid "A **rebalancer** is an internal component that distributes the dataset among all shards evenly in case some servers are added or removed. It also balances the load considering the capacities of existing replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:250
msgid "Storage"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:252
msgid "**Storage** is a node storing a subset of a dataset. Multiple replicated storages comprise a replica set. Each storage in a replica set has a role, **master** or **replica**. A master processes read and write requests. A replica processes read requests but cannot process write requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:264
msgid "Virtual buckets"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:266
msgid "The sharded dataset is partitioned into a large number of abstract nodes called **virtual buckets** (further referred to as **buckets**)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:269
msgid "The dataset is partitioned using the sharding key (or **bucket id**, in Tarantool terminology). Bucket id is a number from 1 to N, where N is the total number of buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:276
msgid "Each replica set stores a unique subset of buckets. One bucket cannot belong to multiple replica sets at a time."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:282
msgid "The total number of buckets is determined by the administrator who sets up the initial cluster configuration."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:285
msgid "Every Tarantool space you plan to shard must have a bucket id field indexed by the bucket id ``index``. Spaces without the bucket id indexes don’t participate in sharding but can be used as regular spaces. By default, the name of the index coincides with the bucket id."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:294
msgid "Migration of buckets"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:296
msgid "A **rebalancer** is a background rebalancing process that ensures an even distribution of buckets across the shards. During rebalancing, buckets are being migrated among replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:300
msgid "A replica set from which the bucket is being migrated is called a **source**; a target replica set to which the bucket is being migrated is called a **destination**."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:303
msgid "A **replica set lock** makes a replica set invisible to the rebalancer. A locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:306
msgid "While a bucket is being migrated, it can have different states:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:308
msgid "ACTIVE – the bucket is available for read and write requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:309
msgid "PINNED – the bucket is locked for migrating to another replica set. Otherwise pinned buckets are similar to buckets in the ACTIVE state."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:311
msgid "SENDING – the bucket is currently being copied to the destination replica set; read requests to the source replica set are still processed."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:313
msgid "RECEIVING – the bucket is currently being filled; all requests to it are rejected."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:314
msgid "SENT – the bucket was migrated to the destination replica set. The `router` uses the SENT state to calculate the new location of the bucket. A bucket in the SENT state goes to the GARBAGE state automatically after BUCKET_SENT_GARBAGE_DELAY seconds, which by default is :ref:`0.5 seconds <cfg_basic-collect_bucket_garbage_interval>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:318
msgid "GARBAGE – the bucket was already migrated to the destination replica set during rebalancing; or the bucket was initially in the RECEIVING state, but some error occurred during the migration."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:322
msgid "Buckets in the GARBAGE state are deleted by the garbage collector."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:327
msgid "Migration is performed as follows:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:329
msgid "At the destination replica set, a new bucket is created and assigned the RECEIVING state, the data copying starts, and the bucket rejects all requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:331
msgid "The source bucket in the source replica set is assigned the SENDING state, and the bucket continues to process read requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:333
msgid "Once the data is copied, the bucket on the source replica set is assigned the SENT and it starts rejecting all requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:335
msgid "The bucket on the destination replica set is assigned the ACTIVE state and starts accepting all requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:342
msgid "The `_bucket` system space"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:344
msgid "The ``_bucket`` system space of each replica set stores the ids of buckets present in the replica set. The space contains the following fields:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:347
msgid "``bucket`` – bucket id"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:348
msgid "``status`` – state of the bucket"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:349
msgid "``destination`` – UUID of the destination replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:351
msgid "An example of ``_bucket.select{}``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:353
msgid "---\n"
"- - [1, ACTIVE, abfe2ef6-9d11-4756-b668-7f5bc5108e2a]\n"
"  - [2, SENT, 19f83dcb-9a01-45bc-a0cf-b0c5060ff82c]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:360
msgid "Once the bucket is migrated, the destination replica set identified by UUID is filled in the table. While the bucket is still located on the source replica set, the value of the destination replica set UUID is equal to ``NULL``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:368
msgid "Router"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:370
msgid "All requests from the application come to the sharded cluster through a ``router``. The ``router`` keeps the topology of a sharded cluster transparent for the application, thus keeping the application unaware of:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:374
msgid "the number and location of shards,"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:375
msgid "data rebalancing process,"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:376
msgid "the fact and the process of a failover that occurred after a replica's failure."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:378
msgid "The ``router`` does not have a persistent state, nor does it store the cluster topology or balance the data. The ``router`` is a standalone software component that can run in the storage layer or application layer depending on the application features."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:386
msgid "The routing table"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:388
msgid "А routing table on the ``router`` stores the map of all bucket ids to replica sets. It ensures the consistency of sharding in case of failover."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:391
msgid "The ``router`` keeps a persistent pool of connections to all the storages that are created at startup. This helps prevent configuration errors. Once the connection pool is created, the ``router`` caches the current state of the routing table in order to speed up routing. If a bucket migrated to another ``storage`` after rebalancing, or a failover occurred and caused one of the shards switching to another replica, the ``discovery fiber`` on the ``router`` updates the routing table automatically."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:398
msgid "As the bucket id is explicitly indicated both in the data and in the mapping table on the ``router``, the data is consistent regardless of the application logic. It also makes rebalancing transparent for the application."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:406
msgid "Processing requests"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:408
msgid "Requests to the database can be performed by the application or using stored procedures. Either way, the bucket id should be explicitly specified in the request."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:411
msgid "All requests are forwarded to the ``router`` first. The only operation supported by the ``router`` is ``call``. The operation is performed via the ``vshard.router.call()`` function:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:415
msgid "result = vshard.router.call(<bucket_id>, <mode>, <function_name>, {<argument_list>}, {<opts>})"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:419
msgid "Requests are processed as follows:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:421
msgid "The ``router`` uses the bucket id to search for a replica set with the corresponding bucket in the routing table."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:424
msgid "If the map of the bucket id to the replica set is not known to the ``router`` (the discovery fiber hasn’t filled the table yet), the ``router`` makes requests to all ``storages`` to find out where the bucket is located."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:427
msgid "Once the bucket is located, the shard checks:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:429
msgid "whether the bucket is stored in the ``_bucket`` system space of the replica set;"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:430
msgid "whether the bucket is ACTIVE or PINNED (for a read request, it can also be SENDING)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:431
msgid "If all the checks succeed, the request is executed. Otherwise, it is terminated with the error: ``“wrong bucket”``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:438
msgid "Administration"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:444
msgid "Configuring a sharded cluster"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:446
msgid "A minimal viable sharded cluster should consist of:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:448
msgid "one or more replica sets, each containing two or more ``storage`` instances"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:449
msgid "one or more ``router`` instances"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:451
msgid "The number of ``storage`` instances in a replica set defines the redundancy factor of the data. The recommended value is 3 or more. The number of ``router`` instances is not limited, because routers are completely stateless. We recommend increasing the number of routers when an existing ``router`` instance becomes CPU or I/O bound."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:456
msgid "``vshard`` supports multiple ``router`` instances on a single Tarantool instance. Each ``router`` can be connected to any ``vshard`` cluster. Multiple ``router`` instances can be connected to the same cluster."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:460
msgid "As the ``router`` and ``storage`` applications perform completely different sets of functions, they should be deployed to different Tarantool instances. Although it is technically possible to place the router application on every ``storage`` node, this approach is highly discouraged and should be avoided on production deployments."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:465
msgid "All ``storage`` instances can be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:468
msgid "Self-identification is currently performed using ``tarantoolctl``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:470
msgid "$ tarantoolctl instance_name"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:474
msgid "All ``router`` instances can also be deployed using identical instance (configuration) files."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:477
msgid "All cluster nodes must share a common topology. An administrator must ensure that the configurations are identical. We suggest using a configuration management tool like Ansible or Puppet to deploy the cluster."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:481
msgid "Sharding is not integrated into any system for centralized configuration management. It is expected that the application itself is responsible for interacting with such a system and passing the sharding parameters."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:489
msgid "Sample configuration"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:491
msgid "The configuration of a simple sharded cluster can look like this:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:493
msgid "local cfg = {\n"
"    memtx_memory = 100 * 1024 * 1024,\n"
"    replication_connect_quorum = 0,\n"
"    bucket_count = 10000,\n"
"    rebalancer_disbalance_threshold = 10,\n"
"    rebalancer_max_receiving = 100,\n"
"    sharding = {\n"
"        ['cbf06940-0790-498b-948d-042b62cf3d29'] = {\n"
"            replicas = {\n"
"                ['8a274925-a26d-47fc-9e1b-af88ce939412'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3301',\n"
"                    name = 'storage_1_a',\n"
"                    master = true\n"
"                },\n"
"                ['3de2e3e1-9ebe-4d0d-abb1-26d301b84633'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3302',\n"
"                    name = 'storage_1_b'\n"
"                }\n"
"            },\n"
"        },\n"
"        ['ac522f65-aa94-4134-9f64-51ee384f1a54'] = {\n"
"            replicas = {\n"
"                ['1e02ae8a-afc0-4e91-ba34-843a356b8ed7'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3303',\n"
"                    name = 'storage_2_a',\n"
"                    master = true\n"
"                },\n"
"                ['001688c3-66f8-4a31-8e19-036c17d489c2'] = {\n"
"                    uri = 'storage:storage@127.0.0.1:3304',\n"
"                    name = 'storage_2_b'\n"
"                }\n"
"            },\n"
"        },\n"
"    },\n"
"}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:531
msgid "This cluster includes one ``router`` instance and two ``storage`` instances. Each ``storage`` instance includes one master and one replica."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:534
msgid "The sharding field defines the logical topology of a sharded Tarantool cluster. All the other fields are passed to ``box.cfg()`` as they are, without modifications. See the :ref:`Configuration reference <vshard-config-reference>` section for details."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:538
msgid "On routers call ``vshard.router.cfg(cfg)``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:540
msgid "cfg.listen = 3300\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.router.cfg(cfg)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:548
msgid "On storages call ``vshard.storage.cfg(cfg, instance_uuid)``:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:550
msgid "-- Get instance name\n"
"local MY_UUID = \"de0ea826-e71d-4a82-bbf3-b04a6413e417\"\n"
"\n"
"-- Call a configuration provider\n"
"local cfg = require('localcfg')\n"
"\n"
"-- Start the database with sharding\n"
"vshard = require('vshard')\n"
"vshard.storage.cfg(cfg, MY_UUID)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:562
msgid "``vshard.storage.cfg()`` automatically calls ``box.cfg()`` and configures the listen port and replication parameters."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:565
msgid "See ``router.lua`` and ``storage.lua`` in the ``vshard/example`` directory for a sample configuration."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:572
msgid "Replica weights"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:574
msgid "The ``router`` sends all requests to the master instance only. Setting replica weights allows sending read requests not only to the master instance, but to any available replica that is the 'nearest' to the ``router``. Weights are used to define distances between replicas within a replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:579
msgid "Weights can be used, for example, to define the physical distance between the ``router`` and each replica in each replica set. In such a case read requests are sent to the nearest replica."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:583
msgid "Setting weights can also help to define the most powerful replicas: the ones that can process the largest number of requests per second."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:586
msgid "The idea is to specify the zone for every ``router`` and every replica, therefore filling a matrix of relative zone weights. This approach allows setting different weights in different zones for the same replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:590
msgid "To set weights, use the zone attribute for each replica during configuration:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:592
msgid "local cfg = {\n"
"   sharding = {\n"
"      ['...replicaset_uuid...'] = {\n"
"         replicas = {\n"
"            ['...replica_uuid...'] = {\n"
"                 ...,\n"
"                 zone = <number or string>\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:607
msgid "Then, specify relative weights for each zone pair in the weights parameter of ``vshard.router.cfg``. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:610
msgid "weights = {\n"
"    [1] = {\n"
"        [2] = 1, -- routers of the 1st zone see the weight of the 2nd zone as 1\n"
"        [3] = 2, -- routers of the 1st zone see the weight of the 3rd zone as 2\n"
"\n"
"\n"
"   [4] = 3, -- ...\n"
"    },\n"
"    [2] = {\n"
"        [1] = 10,\n"
"        [2] = 0,\n"
"        [3] = 10,\n"
"        [4] = 20,\n"
"    },\n"
"    [3] = {\n"
"        [1] = 100,\n"
"        [2] = 200, -- routers of the 3rd zone see the weight of the 2nd zone as 200. Mind that it is not equal to the weight of the 2nd zone = 2 visible from the 1st zone\n"
"        [4] = 1000,\n"
"    }\n"
"}\n"
"\n"
"local cfg = vshard.router.cfg({weights = weights, sharding = ...})"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:639
msgid "Replica set weights"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:641
msgid "A replica set weight is not the same as the replica weight. The weight of a replica set defines the capacity of the replica set: the larger the weight, the more buckets the replica set can store. The total size of all sharded spaces in the replica set is also its capacity metric."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:646
msgid "You can consider replica set weights as the relative amount of data within a replica set. For example, if ``replicaset_1 = 100``, and ``replicaset_2 = 200``, the second replica set stores twice as many buckets as the first one. By default, all weights of all replica sets are equal."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:651
msgid "You can use weights, for example, to store the prevailing amount of data on a replica set with more memory space."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:658
msgid "Rebalancing process"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:660
msgid "There is an **etalon number** of buckets for a replica set. (Etalon in this context means \"ideal\".) If there is no deviation from this number in the whole replica set, then the buckets are distributed evenly."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:665
msgid "The etalon number is calculated automatically considering the number of buckets in the cluster and weights of the replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:668
msgid "For example: The user specified the number of buckets is 3000, and weights of 3 replica sets are 1, 0.5, and 1.5. The resulting etalon numbers of buckets for the replica sets are: 1st replica set – 1000, 2nd replica set – 500, 3rd replica set – 1500."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:673
msgid "This approach allows assigning a zero weight to a replica set, which initiates migration of its buckets to the remaining cluster nodes. It also allows adding a new zero-load replica set, which initiates migration of the buckets from the loaded replica sets to the zero-load replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:680
msgid "A new zero-load replica set should be assigned a weight for rebalancing to start."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:682
msgid "The ``rebalancer`` wakes up periodically and redistributes data from the most loaded nodes to less loaded nodes. Rebalancing starts if the disbalance threshold of a replica set exceeds a disbalance threshold specified in the configuration."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:686
msgid "The disbalance threshold is calculated as follows:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:688
msgid "|etalon_bucket_number - real_bucket_number| / etalon_bucket_number * 100"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:692
msgid "When a new shard is added, the configuration can be updated dynamically:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:694
msgid "The configuration should be updated on all the ``routers`` first, and then on all the ``storages``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:696
msgid "The new shard becomes available for rebalancing in the ``storage`` layer."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:697
msgid "As a result of rebalancing, buckets are migrated to the new shard."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:698
msgid "If a migrated bucket is requested, ``router`` receives an error code containing information about the new location of the bucket."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:701
msgid "At this time, the new shard is already present in the ``router``'s pool of connections, so redirection is transparent for the application."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:708
msgid "Replica set lock and bucket pin"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:710
msgid "A replica set lock makes a replica set invisible to the ``rebalancer``: a locked replica set can neither receive new buckets nor migrate its own buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:713
msgid "A bucket pin blocks a specific bucket from migrating: a pinned bucket stays on the replica set to which it is pinned, until it is unpinned."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:716
msgid "Pinning all replica set buckets is not equivalent to locking a replica set. Even if you pin all buckets, a non-locked replica set can still receive new buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:719
msgid "Replica set lock is helpful, for example, to separate a replica set from production replica sets for testing, or to preserve some application metadata that must not be sharded for a while. A bucket pin is used for similar cases but in a smaller scope."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:724
msgid "By both locking a replica set and pinning all buckets, one can isolate an entire replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:727
msgid "Locked replica sets and pinned buckets affect the rebalancing algorithm as the ``rebalancer`` must ignore locked replica sets and consider pinned buckets when attempting to reach the best possible balance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:731
msgid "The issue is not trivial as a user can pin too many buckets to a replica set, so a perfect balance becomes unreachable. For example, consider the following cluster (assume all replica set weights are equal to 1)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:735
msgid "The initial configuration:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:737
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:742
msgid "Adding a new replica set:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:744
msgid "rs1: bucket_count = 150\n"
"rs2: bucket_count = 150, pinned_count = 120\n"
"rs3: bucket_count = 0"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:750
msgid "The perfect balance would be ``100 - 100 - 100``, which is impossible since the ``rs2`` replica set has 120 pinned buckets. The best possible balance here is the following:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:754
msgid "rs1: bucket_count = 90\n"
"rs2: bucket_count = 120, pinned_count 120\n"
"rs3: bucket_count = 90"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:760
msgid "The ``rebalancer`` moved as many buckets as possible from ``rs2`` to decrease the disbalance. At the same time it respected equal weights of ``rs1`` and ``rs3``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:763
msgid "The algorithms for implementing locks and pins are completely different, although they look similar in terms of functionality."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:770
msgid "Replica set lock and rebalancing"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:772
msgid "Locked replica sets simply do not participate in rebalancing. This means that even if the actual total number of buckets is not equal to the etalon number, the disbalance cannot be fixed due to the lock. When the rebalancer detects that one of the replica sets is locked, it recalculates the etalon number of buckets of the non-locked replica sets as if the locked replica set and its buckets did not exist at all."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:783
msgid "Bucket pin and rebalancing"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:785
msgid "Rebalancing replica sets with pinned buckets requires a more complex algorithm. Here pinned_count[o] is the number of pinned buckets, and ``etalon_count`` is the etalon number of buckets for a replica set:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:789
msgid "The ``rebalancer`` calculates the etalon number of buckets as if all buckets were not pinned. Then the rebalancer checks each replica set and compares the etalon number of buckets with the number of pinned buckets in a replica set. If ``pinned_count < etalon_count``, non-locked replica sets (at this point all locked replica sets already are filtered out) with pinned buckets can receive new buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:795
msgid "If ``pinned_count > etalon_count``, the disbalance cannot be fixed, as the ``rebalancer`` cannot move pinned buckets out of this replica set. In such a case the etalon number is updated and set equal to the number of pinned buckets. The replica sets with ``pinned_count > etalon_count`` are not processed by the ``rebalancer``, and the number of pinned buckets is subtracted from the total number of buckets. The rebalancer tries to move out as many buckets as possible from such replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:802
msgid "This procedure is restarted from step 1 for replica sets with ``pinned_count >= etalon_count`` until ``pinned_count <= etalon_count`` on all replica sets. The procedure is also restarted when the total number of buckets is changed."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:807
msgid "Here is the pseudocode for the algorithm:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:809
msgid "function cluster_calculate_perfect_balance(replicasets, bucket_count)\n"
"        -- rebalance the buckets using weights of the still viable replica sets --\n"
"end;\n"
"\n"
"cluster = <all of the non-locked replica sets>;\n"
"bucket_count = <the total number of buckets in the cluster>;\n"
"can_reach_balance = false\n"
"while not can_reach_balance do\n"
"        can_reach_balance = true\n"
"        cluster_calculate_perfect_balance(cluster, bucket_count);\n"
"        foreach replicaset in cluster do\n"
"                if replicaset.perfect_bucket_count <\n"
"                   replicaset.pinned_bucket_count then\n"
"                        can_reach_balance = false\n"
"                        bucket_count -= replicaset.pinned_bucket_count;\n"
"                        replicaset.perfect_bucket_count =\n"
"                                replicaset.pinned_bucket_count;\n"
"                end;\n"
"        end;\n"
"end;\n"
"cluster_calculate_perfect_balance(cluster, bucket_count);"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:833
msgid "The complexity of the algorithm is ``O(N^2)``, where N is the number of replica sets. On each step, the algorithm either finishes the calculation, or ignores at least one new replica set overloaded with the pinned buckets, and updates the etalon number of buckets on other replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:842
msgid "Bucket ref"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:844
msgid "Bucket ref is an in-memory counter that is similar to the :ref:`bucket pin <vshard-lock-pin>`, but has the following differences:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:847
msgid "Bucket ref is not persistent. Refs are intended for forbidding bucket transfer during request execution, but on restart all requests are dropped."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:850
msgid "There are two types of bucket refs: read-only (RO) and read-write (RW)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:852
msgid "If a bucket has RW refs, it can not be moved. However, when the rebalancer needs it to be sent, it locks the bucket for new write requests, waits until all current requests are finished, and then sends the bucket."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:857
msgid "If a bucket has RO refs, it can be sent, but cannot be dropped. Such a bucket can even enter GARBAGE or SENT state, but its data is kept until the last reader is gone."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:861
msgid "A single bucket can have both RO and RW refs."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:863
msgid "Bucket ref is countable."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:865
msgid "The :ref:`vshard.storage.bucket_ref/unref()<storage_api-bucket_ref>` methods are called automatically when :ref:`vshard.router.call() <router_api-call>` or :ref:`vshard.storage.call() <storage_api-call>` is used. For raw API like ``r = vshard.router.route() r:callro/callrw`` you should explicitly call the ``bucket_ref()`` method inside the function. Also, make sure that you call ``bucket_unref()`` after ``bucket_ref()``, otherwise the bucket cannot be moved from the storage until the instance restart."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:873
msgid "To see how many refs there are for a bucket, use :ref:`vshard.storage.buckets_info([bucket_id]) <storage_api-buckets_info>` (the ``bucket_id`` parameter is optional)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:879
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1891
msgid "vshard.storage.buckets_info(1)\n"
"---\n"
"- 1:\n"
"    status: active\n"
"    ref_rw: 1\n"
"    ref_ro: 1\n"
"    ro_lock: true\n"
"    rw_lock: true\n"
"    id: 1"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:895
msgid "Defining spaces"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:897
msgid "Spaces should be defined within a storage application using ``box.once()``. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:900
msgid "box.once(\"testapp:schema:1\", function()\n"
"    local customer = box.schema.space.create('customer')\n"
"    customer:format({\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    customer:create_index('customer_id', {parts = {'customer_id'}})\n"
"    customer:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"\n"
"    local account = box.schema.space.create('account')\n"
"    account:format({\n"
"        {'account_id', 'unsigned'},\n"
"        {'customer_id', 'unsigned'},\n"
"        {'bucket_id', 'unsigned'},\n"
"        {'balance', 'unsigned'},\n"
"        {'name', 'string'},\n"
"    })\n"
"    account:create_index('account_id', {parts = {'account_id'}})\n"
"    account:create_index('customer_id', {parts = {'customer_id'}, unique = false})\n"
"    account:create_index('bucket_id', {parts = {'bucket_id'}, unique = false})\n"
"    box.snapshot()\n"
"\n"
"    box.schema.func.create('customer_lookup')\n"
"    box.schema.role.grant('public', 'execute', 'function', 'customer_lookup')\n"
"    box.schema.func.create('customer_add')\n"
"end)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:934
msgid "Bootstrapping and restarting a storage"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:936
msgid "If a replica set master fails, it is recommended to:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:938
msgid "Switch one of the replicas into the master mode. This allows the new master to process all the incoming requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:940
msgid "Update the configuration of all the cluster members. This forwards all the requests to the new master."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:943
msgid "Monitoring the master and switching the instance modes can be handled by any external utility."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:946
msgid "To perform a scheduled downtime of a replica set master, it is recommended to:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:948
msgid "Update the configuration of the master and wait for the replicas to get into sync. All the requests then are forwarded to a new master."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:950
msgid "Switch another instance into the master mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:951
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:957
msgid "Update the configuration of all the nodes."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:952
msgid "Shut down the old master."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:954
msgid "To perform a scheduled downtime of a replica set, it is recommended to:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:956
msgid "Migrate all the buckets to the other cluster storages."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:958
msgid "Shut down the replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:960
msgid "In case a whole replica set fails, some part of the dataset becomes inaccessible. Meanwhile, the ``router`` tries to reconnect to the master of the failed replica set. This way, once the replica set is up and running again, the cluster is automatically restored."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:971
msgid "Searches for buckets, buckets recovery, and buckets rebalancing are performed automatically and do not require human intervention."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:974
msgid "Technically, there are multiple fibers responsible for different types of operations:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:977
msgid "a **discovery** fiber on the ``router`` searches for buckets in the background"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:978
msgid "a **failover** fiber on the ``router`` maintains replica connections"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:979
msgid "a **garbage collector** fiber on each master ``storage`` removes the contents of buckets that were moved"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:981
msgid "a **bucket recovery** fiber on each master ``storage`` recovers buckets in the SENDING and RECEIVING states in case of reboot"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:983
msgid "a **rebalancer** on a single master ``storage`` among all replica sets executes the rebalancing process."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:986
msgid "See the :ref:`Rebalancing process <vshard-rebalancing>` section for details."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:992
msgid "Garbage collector"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:994
msgid "A **garbage collector** fiber runs in the background on the master storages of each replica set. It starts deleting the contents of the bucket in the GARBAGE state part by part. Once the bucket is empty, its record is deleted from the ``_bucket`` system space."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1003
msgid "Bucket recovery"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1005
msgid "A **bucket recovery** fiber runs on the master storages. It helps to recover buckets in the SENDING and RECEIVING states in case of reboot."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1008
msgid "Buckets in the SENDING state are recovered as follows:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1010
msgid "The system first searches for buckets in the SENDING state."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1011
msgid "If such a bucket is found, the system sends a request to the destination replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1013
msgid "If the bucket on the destination replica set is ACTIVE, the original bucket is deleted from the source node."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1016
msgid "Buckets in the RECEIVING state are deleted without extra checks."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1022
msgid "Failover"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1024
msgid "A **failover** fiber runs on every ``router``. If a master of a replica set becomes unavailable, the failover fiber redirects read requests to the replicas. Write requests are rejected with an error until the master becomes available."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1040
msgid ":ref:`sharding <cfg_basic-sharding>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1041
msgid ":ref:`weights <cfg_basic-weights>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1042
msgid ":ref:`shard_index <cfg_basic-shard_index>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1043
msgid ":ref:`bucket_count <cfg_basic-bucket_count>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1044
msgid ":ref:`collect_bucket_garbage_interval <cfg_basic-collect_bucket_garbage_interval>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1045
msgid ":ref:`collect_lua_garbage <cfg_basic-collect_lua_garbage>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1046
msgid ":ref:`sync_timeout <cfg_basic-sync_timeout>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1047
msgid ":ref:`rebalancer_disbalance_threshold <cfg_basic-rebalancer_disbalance_threshold>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1048
msgid ":ref:`rebalancer_max_receiving <cfg_basic-rebalancer_max_receiving>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1054
msgid "A field defining the logical topology of the sharded Tarantool cluster."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1056
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1067
msgid "Type: table"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1064
msgid "A field defining the configuration of relative weights for each zone pair in a replica set. See the :ref:`Replica weights <vshard-replica-weights>` section."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1075
msgid "An index over the bucket id."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1077
msgid "Type: non-empty string or non-negative integer"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1078
msgid "Default: coincides with the bucket id number"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1085
msgid "The total number of buckets in a cluster."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1087
msgid "This number should be several orders of magnitude larger than the potential number of cluster nodes, considering potential scaling out in the foreseeable future."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1092
msgid "If the estimated number of nodes is M, then the data set should be divided into 100M or even 1000M buckets, depending on the planned scaling out. This number is certainly greater than the potential number of cluster nodes in the system being designed."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1097
msgid "Keep in mind that too many buckets can cause a need to allocate more memory to store routing information. On the other hand, an insufficient number of buckets can lead to decreased granularity when rebalancing."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1101
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1111
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1133
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1148
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1169
msgid "Type: number"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1102
msgid "Default: 3000"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1109
msgid "The interval between garbage collector actions, in seconds."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1119
msgid "If set to true, the Lua collectgarbage() function is called periodically."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1122
msgid "Default: no"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1129
msgid "Timeout to wait for synchronization of the old master with replicas before demotion. Used when switching a master or when manually calling the ``sync()`` function."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1141
msgid "A maximum bucket disbalance threshold, in percent. The threshold is calculated for each replica set using the following formula:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1144
msgid "|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1156
msgid "The maximum number of buckets that can be received in parallel by a single replica set. This number must be limited, because when a new replica set is added to a cluster, the rebalancer sends a very large amount of buckets from the existing replica sets to the new replica set. This produces a heavy load on a new replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1163
msgid "Suppose ``rebalancer_max_receiving`` is equal to 100, ``bucket_count`` is equal to 1000. There are 3 replica sets with 333, 333 and 334 buckets on each respectively. When a new replica set is added, each replica set’s ``etalon_bucket_count`` becomes equal to 250. Rather than receiving all 250 buckets at once, the new replica set receives 100, 100 and 50 buckets sequentially."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1170
msgid "Default: 100"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1177
msgid "Replica set functions"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1179
msgid ":ref:`uuid <cfg_replica_set-uuid>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1180
msgid ":ref:`weight <cfg_replica_set-weight>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1186
msgid "A unique identifier of a replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1188
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1199
msgid "Type:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1189
msgid "Default:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1190
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1201
msgid "Dynamic:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1196
msgid "A weight of a replica set. See the :ref:`Replica set weights <vshard-replica-set-weights>` section for details."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1207
msgid "API reference"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1213
msgid "Router public API"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1215
msgid ":ref:`vshard.router.bootstrap() <router_api-bootstrap>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1216
msgid ":ref:`vshard.router.cfg(cfg) <router_api-cfg>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1217
msgid ":ref:`vshard.router.new(name, cfg) <router_api-new>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1218
msgid ":ref:`vshard.router.call(bucket_id, mode, function_name, {argument_list}, {options}) <router_api-call>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1219
msgid ":ref:`vshard.router.callro(bucket_id, function_name, {argument_list}, {options}) <router_api-callro>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1220
msgid ":ref:`vshard.router.callrw(bucket_id, function_name, {argument_list}, {options}) <router_api-callrw>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1221
msgid ":ref:`vshard.router.callre(bucket_id, function_name, {argument_list}, {options}) <router_api-callre>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1222
msgid ":ref:`vshard.router.callbro(bucket_id, function_name, {argument_list}, {options}) <router_api-callbro>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1223
msgid ":ref:`vshard.router.callbre(bucket_id, function_name, {argument_list}, {options}) <router_api-callbre>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1224
msgid ":ref:`vshard.router.route(bucket_id) <router_api-route>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1225
msgid ":ref:`vshard.router.routeall() <router_api-routeall>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1226
msgid ":ref:`vshard.router.bucket_id(key) <router_api-bucket_id>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1227
msgid ":ref:`vshard.router.bucket_count() <router_api-bucket_count>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1228
msgid ":ref:`vshard.router.sync(timeout) <router_api-sync>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1229
msgid ":ref:`vshard.router.discovery_wakeup() <router_api-discovery_wakeup>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1230
msgid ":ref:`vshard.router.info() <router_api-info>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1231
msgid ":ref:`vshard.router.buckets_info() <router_api-buckets_info>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1232
msgid ":ref:`replicaset.call() <router_api-replicaset_call>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1233
msgid ":ref:`replicaset.callro() <router_api-replicaset_callro>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1234
msgid ":ref:`replicaset.callrw() <router_api-replicaset_callrw>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1235
msgid ":ref:`replicaset.callre() <router_api-replicaset_callre>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1241
msgid "Perform the initial cluster bootstrap and distribute all buckets across the replica sets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1248
msgid "Configure the database and start sharding for the specified ``router`` instance. See the :ref:`sample configuration <vshard-config-cluster-example>` above."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1252
msgid "a configuration table"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1258
msgid "Create a new router instance. ``vshard`` supports multiple routers in a single Tarantool instance. Each router can be connected to any ``vshard`` cluster, and multiple routers can be connected to the same cluster."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1262
msgid "A router created via ``vshard.router.new()`` works in the same way as a static router, but the method name is preceded by a colon (``vshard.router:method_name(...)``), while for a static router the method name is preceded by a period (``vshard.router.method_name(...)``)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1267
msgid "A static router can be obtained via the ``vshard.router.static()`` method and then used like a router created via the ``vshard.router.new()`` method."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1273
msgid "``box.cfg`` is shared among all the routers of a single instance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1275
msgid "a router instance name. This name is used as a prefix in logs of the router and must be unique within the instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1277
msgid "a configuration table. The :ref:`sample configuration <vshard-config-cluster-example>` is described above."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1281
msgid "a router instance, if created successfully; otherwise, nil and an error object"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1288
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id. See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1292
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1347
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1378
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1411
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1455
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1488
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1695
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1775
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1803
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1814
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1825
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1851
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1970
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1990
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1999
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2024
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2042
msgid "a bucket identifier"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1293
msgid "either a string = 'read'|'write', or a map with mode='read'|'write' and/or prefer_replica=true|false and/or balance=true|false."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1294
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1348
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1379
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1412
msgid "a function to execute"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1295
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1349
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1380
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1413
msgid "an array of the function's arguments"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1296
msgid "* ``timeout`` – a request timeout, in seconds. If the router cannot identify a   shard with the specified bucket_id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1298
msgid "``timeout`` – a request timeout, in seconds. If the router cannot identify a shard with the specified bucket_id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1302
msgid "The mode parameter has two possible forms: a string or a map. Examples of the string form are: 'read', 'write'. Examples of the map form are: {mode='read'}, {mode='write'}, {mode='read', prefer_replica=true}, {mode='read', balance=true}, {mode='read', prefer_replica=true, balance=true}. If 'write' is specified then the target is the master. If prefer_replica=true is specified then the preferred target is one of the replicas, but the target is the master if there is no conveniently available replica. It may be good to specify prefer_replica=true for functions which are expensive in terms of resource use, to avoid slowing down the master. If balance=true then there is load balancing -- reads are distributed over all the nodes in the replica set in round-robin fashion, with a preference for replicas if prefer_replica=true is also set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1316
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1358
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1389
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1422
msgid "The original return value of the executed function, or ``nil`` and error object. The error object has a type attribute equal to ``ShardingError`` or one of the regular Tarantool errors (``ClientError``, ``OutOfMemory``, ``SocketError``, etc.)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1321
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for the error code."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1329
msgid "To call ``customer_add`` function from ``vshard/example``, say:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1331
msgid "vshard.router.call(100, 'write', 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})\n"
"-- or, the same thing but with a map for the second argument\n"
"vshard.router.call(100, {mode='write'}, 'customer_add', {{customer_id = 2, bucket_id = 100, name = 'name2', accounts = {}}}, {timeout = 100})"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1341
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1350
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1381
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1414
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1611
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1632
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1651
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1673
msgid "* ``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a   shard with the bucket id, the operation will be repeated until the   timeout is reached."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1352
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1383
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1416
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1613
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1634
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1653
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1675
msgid "``timeout`` – a request timeout, in seconds. In case the ``router`` cannot identify a shard with the bucket id, the operation will be repeated until the timeout is reached."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1363
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1394
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1427
msgid "``ShardingError`` is returned on errors specific for sharding: the replica set is not available, the master is missing, wrong bucket id, etc. It has an attribute code containing one of the values from the ``vshard.error.code.*`` LUA table, an optional attribute containing a message with the human-readable error description, and other attributes specific for this error code."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1373
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-write mode (similar to calling vshard.router.call with mode='write'). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1404
msgid "Call the function identified by function-name on the shard storing the bucket identified by bucket_id, in read-only mode (similar to calling vshard.router.call with mode='read'), with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). See the :ref:`Processing requests <vshard-process-requests>` section for details on function operation."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1437
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true}."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1445
msgid "This has the same effect as :ref:`vshard.router.call() <router_api-call>` with mode parameter = {mode='read', balance=true, prefer_replica=true}."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1453
msgid "Return the replica set object for the bucket with the specified bucket id value."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1457
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1472
msgid "a replica set object"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1461
msgid "replicaset = vshard.router.route(123)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1469
msgid "Return all available replica set objects."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1471
msgid "a map of the following type: ``{UUID = replicaset}``"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1476
msgid "replicaset = vshard.router.routeall()"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1484
msgid "Calculate the bucket id using a simple built-in hash function."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1486
msgid "a hash key. This can be any Lua object (number, table, string)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1493
msgid "bucket_id = vshard.router.bucket_id(18374927634039)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1501
msgid "Return the total number of buckets specified in ``vshard.router.cfg()``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1503
msgid "the total number of buckets"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1510
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1789
msgid "Wait until the dataset is synchronized on replicas."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1512
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1791
msgid "a timeout, in seconds"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1514
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1793
msgid "``true`` if the dataset was synchronized successfully; or ``nil`` and ``err`` explaining why the dataset cannot be synchronized."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1521
msgid "Force wakeup of the bucket discovery fiber."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1527
msgid "Return information about each instance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1531
msgid "Replica set parameters:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1533
msgid "replica set uuid"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1534
msgid "master instance parameters"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1535
msgid "replica instance parameters"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1537
msgid "Instance parameters:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1539
msgid "``uri`` — URI of the instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1540
msgid "``uuid`` — UUID of the instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1541
msgid "``status`` – status of the instance (``available``, ``unreachable``, ``missing``)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1542
msgid "``network_timeout`` – a timeout for the request. The value is updated automatically on each 10th successful request and each 2nd failed request."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1545
msgid "Bucket parameters:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1547
msgid "``available_ro`` – the number of buckets known to the ``router`` and available for read requests"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1548
msgid "``available_rw`` – the number of buckets known to the router and available for read and write requests"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1549
msgid "``unavailable`` – the number of buckets known to the ``router`` but unavailable for any requests"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1550
msgid "``unreachable`` – the number of buckets whose replica sets are not known to the ``router``"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1554
msgid "tarantool> vshard.router.info()\n"
"---\n"
"- replicasets:\n"
"    ac522f65-aa94-4134-9f64-51ee384f1a54:\n"
"      replica: &0\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3303\n"
"        uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7\n"
"      uuid: ac522f65-aa94-4134-9f64-51ee384f1a54\n"
"      master: *0\n"
"    cbf06940-0790-498b-948d-042b62cf3d29:\n"
"      replica: &1\n"
"        network_timeout: 0.5\n"
"        status: available\n"
"        uri: storage@127.0.0.1:3301\n"
"        uuid: 8a274925-a26d-47fc-9e1b-af88ce939412\n"
"      uuid: cbf06940-0790-498b-948d-042b62cf3d29\n"
"      master: *1\n"
"  bucket:\n"
"    unreachable: 0\n"
"    available_ro: 0\n"
"    unknown: 0\n"
"    available_rw: 3000\n"
"  status: 0\n"
"  alerts: []\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1588
msgid "Return information about each bucket. Since a bucket map can be huge, only the required range of buckets can be specified."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1591
msgid "the offset in a bucket map of the first bucket to show"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1592
msgid "the maximum number of buckets to show"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1594
msgid "a map of the following type: ``{bucket_id = 'unknown'/replicaset_uuid}``"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1600
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1606
msgid "The ``replicaset.call`` method is similar to ``replicaset.callrw``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1608
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1629
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1648
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1670
msgid "UUID of a replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1609
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1630
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1649
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1671
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1777
msgid "function to execute"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1610
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1631
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1650
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1672
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1778
msgid "array of the function's arguments"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1621
msgid "Call a function on a nearest available master (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with a specified arguments."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1627
msgid "The ``replicaset.callrw`` method is similar to ``replicaset.call``."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1642
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments. It is recommended to call only read-only functions using ``replicaset.callro()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1661
msgid "Call a function on the nearest available replica (distances are defined using ``replica.zone`` and ``cfg.weights`` matrix) with specified arguments, with preference for a replica rather than a master (similar to calling vshard.router.call with prefer_replica = true). It is recommended to call only read-only functions using ``replicaset.callre()``, as the function can be executed not only on a master, but also on replicas."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1683
msgid "Router internal API"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1685
msgid ":ref:`vshard.router.bucket_discovery(bucket_id) <router_api-bucket_discovery>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1691
msgid "Search for the bucket in the whole cluster. If the bucket is not found, it is likely that it does not exist. The bucket might also be moved during rebalancing and currently is in the RECEIVING state."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1701
msgid "Storage public API"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1703
msgid ":ref:`vshard.storage.cfg(cfg, name) <storage_api-cfg>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1704
msgid ":ref:`vshard.storage.info() <storage_api-info>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1705
msgid ":ref:`vshard.storage.call(bucket_id, mode, function_name, {argument_list}) <storage_api-call>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1706
msgid ":ref:`vshard.storage.sync(timeout) <storage_api-sync>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1707
msgid ":ref:`vshard.storage.bucket_pin(bucket_id) <storage_api-bucket_pin>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1708
msgid ":ref:`vshard.storage.bucket_unpin(bucket_id) <storage_api-bucket_unpin>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1709
msgid ":ref:`vshard.storage.bucket_ref(bucket_id, mode) <storage_api-bucket_ref>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1710
msgid ":ref:`vshard.storage.bucket_refro() <storage_api-bucket_refro>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1711
msgid ":ref:`vshard.storage.bucket_refrw() <storage_api-bucket_refrw>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1712
msgid ":ref:`vshard.storage.bucket_unref(bucket_id, mode) <storage_api-bucket_unref>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1713
msgid ":ref:`vshard.storage.bucket_unrefro() <storage_api-bucket_unrefro>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1714
msgid ":ref:`vshard.storage.bucket_unrefrw() <storage_api-bucket_unrefrw>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1715
msgid ":ref:`vshard.storage.find_garbage_bucket(bucket_index, control) <storage_api-find_garbage_bucket>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1716
msgid ":ref:`vshard.storage.rebalancer_disable() <storage_api-rebalancer_disable>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1717
msgid ":ref:`vshard.storage.rebalancer_enable() <storage_api-rebalancer_enable>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1718
msgid ":ref:`vshard.storage.is_locked() <storage_api-is_locked>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1719
msgid ":ref:`vshard.storage.rebalancing_is_in_progress() <storage_api-rebalancing_is_in_progress>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1720
msgid ":ref:`vshard.storage.buckets_info() <storage_api-buckets_info>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1721
msgid ":ref:`vshard.storage.buckets_count() <storage_api-buckets_count>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1722
msgid ":ref:`vshard.storage.sharded_spaces() <storage_api-sharded_spaces>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1728
msgid "Configure the database and start sharding for the specified ``storage`` instance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1731
msgid "a ``storage`` configuration"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1732
msgid "UUID of the instance"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1738
msgid "Return information about the storage instance in the following format:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1740
msgid "tarantool> vshard.storage.info()\n"
"---\n"
"- buckets:\n"
"    2995:\n"
"      status: active\n"
"      id: 2995\n"
"    2997:\n"
"      status: active\n"
"      id: 2997\n"
"    2999:\n"
"      status: active\n"
"      id: 2999\n"
"  replicasets:\n"
"    2dd0a343-624e-4d3a-861d-f45efc571cd3:\n"
"      uuid: 2dd0a343-624e-4d3a-861d-f45efc571cd3\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3301\n"
"        uuid: 2ec29309-17b6-43df-ab07-b528e1243a79\n"
"    c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1:\n"
"      uuid: c7ad642f-2cd8-4a8c-bb4e-4999ac70bba1\n"
"      master:\n"
"        state: active\n"
"        uri: storage:storage@127.0.0.1:3303\n"
"        uuid: 810d85ef-4ce4-4066-9896-3c352fec9e64\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1773
msgid "Call the specified function on the current ``storage`` instance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1776
msgid "a type of the function: 'read' or 'write'"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1782
msgid "The original return value of the executed function, or ``nil`` and error object."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1800
msgid "Pin a bucket to a replica set. A pinned bucket cannot be moved even if it breaks the cluster balance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1805
msgid "``true`` if the bucket is pinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be pinned"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1812
msgid "Return a pinned bucket back into the active state."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1816
msgid "``true`` if the bucket is unpinned successfully; or ``nil`` and ``err`` explaining why the bucket cannot be unpinned"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1823
msgid "Create an RO or RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1826
#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1852
msgid "'read' or 'write'"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1828
msgid "``true`` if the bucket ref is created successfully; or ``nil`` and ``err`` explaining why the ref cannot be created"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1835
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RO mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1842
msgid "An alias for :ref:`vshard.storage.bucket_ref <storage_api-bucket_ref>` in the RW mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1849
msgid "Remove a RO/RW :ref:`ref <vshard-ref>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1854
msgid "``true`` if the bucket ref is removed successfully; or ``nil`` and ``err`` explaining why the ref cannot be removed"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1861
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RO mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1868
msgid "An alias for :ref:`vshard.storage.bucket_unref <storage_api-bucket_unref>` in the RW mode."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1875
msgid "Find a bucket which has data in a space but is not stored in a ``_bucket`` space; or is in a GARBAGE state."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1878
msgid "index of a space with the part of a bucket id"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1879
msgid "a garbage collector controller. If there is an increased buckets generation, then the search should be interrupted."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1882
msgid "an identifier of the bucket in the garbage state, if found; otherwise, nil"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1889
msgid "Return information about each bucket located in storage. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1907
msgid "Return the number of buckets located in storage."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1913
msgid "Immediately wake up a recovery fiber, if it exists."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1919
msgid "Return a flag indicating whether rebalancing is in progress. The result is true if the node is currently applying routes received from a rebalancer node in the special fiber."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1927
msgid "Return a flag indicating whether storage is invisible to the rebalancer."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1933
msgid "Disable rebalancing. A disabled rebalancer sleeps until it is enabled again with vshard.storage.rebalancer_enable()."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1940
msgid "Enable rebalancing."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1946
msgid "Show the spaces that are visible to rebalancer and garbage collector fibers."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1952
msgid "Storage internal API"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1954
msgid ":ref:`vshard.storage.bucket_stat(bucket_id) <storage_api-bucket_stat>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1955
msgid ":ref:`vshard.storage.bucket_recv(bucket_id, from, data) <storage_api-bucket_recv>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1956
msgid ":ref:`vshard.storage.bucket_delete_garbage(bucket_id) <storage_api-bucket_delete_garbage>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1957
msgid ":ref:`vshard.storage.bucket_collect(bucket_id) <storage_api-bucket_collect>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1958
msgid ":ref:`vshard.storage.bucket_force_create(first_bucket_id, count) <storage_api-bucket_force_create>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1959
msgid ":ref:`vshard.storage.bucket_force_drop(bucket_id, to) <storage_api-bucket_force_drop>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1960
msgid ":ref:`vshard.storage.bucket_send(bucket_id, to) <storage_api-bucket_send>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1961
msgid ":ref:`vshard.storage.buckets_discovery() <storage_api-buckets_discovery>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1962
msgid ":ref:`vshard.storage.rebalancer_request_state() <storage_api-rebalancer_request_state>`"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1968
msgid "Receive a bucket identified by bucket id from a remote replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1971
msgid "UUID of source replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1972
msgid "data logically stored in a bucket identified by bucket_id, in the same format as the return value from ``bucket_collect() <storage_api-bucket_collect>``"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1979
msgid "Return information about the bucket id:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1981
msgid "tarantool> vshard.storage.bucket_stat(1)\n"
"---\n"
"- 0\n"
"- status: active\n"
"  id: 1\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:1996
msgid "Force garbage collection for the bucket identified by bucket_id in case the bucket was transferred to a different replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2005
msgid "Collect all the data that is logically stored in the bucket identified by bucket_id:"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2007
msgid "tarantool> vshard.storage.bucket_collect(1)\n"
"---\n"
"- 0\n"
"- - - 514\n"
"    - - [10, 1, 1, 100, 'Account 10']\n"
"      - [11, 1, 1, 100, 'Account 11']\n"
"      - [12, 1, 1, 100, 'Account 12']\n"
"      - [50, 5, 1, 100, 'Account 50']\n"
"      - [51, 5, 1, 100, 'Account 51']\n"
"      - [52, 5, 1, 100, 'Account 52']\n"
"  - - 513\n"
"    - - [1, 1, 'Customer 1']\n"
"      - [5, 1, 'Customer 5']\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2030
msgid "Force creation of the buckets (single or multiple) on the current replica set. Use only for manual emergency recovery or for initial bootstrap."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2033
msgid "an identifier of the first bucket in a range"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2034
msgid "the number of buckets to insert (default = 1)"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2040
msgid "Drop a bucket manually for tests or emergency cases."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2048
msgid "Send a specified bucket from the current replica set to a remote replica set."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2050
msgid "bucket identifier"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2051
msgid "UUID of a remote replica set"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2057
msgid "Check all buckets of the host storage that have the SENT or ACTIVE state, return the number of active buckets."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2060
msgid "the number of buckets in the active state, if found; otherwise, nil"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2066
msgid "Collect an array of active bucket identifiers for discovery."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2072
msgid "Glossary"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2077
msgid "**Vertical scaling**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2079
msgid "Adding more power to a single server: using a more powerful CPU, adding more capacity to RAM, adding more storage space, etc."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2083
msgid "**Horizontal scaling**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2085
msgid "Adding more servers to the pool of resources, then partitioning and distributing a dataset across the servers."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2089
msgid "**Sharding**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2091
msgid "A database architecture that allows partitioning a dataset using a sharding key and distributing a dataset across multiple servers. Sharding is a special case of horizontal scaling."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2096
msgid "**Node**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2098
msgid "A virtual or physical server instance."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2101
msgid "**Cluster**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2103
msgid "A set of nodes that make up a single group."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2106
msgid "**Storage**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2108
msgid "A node storing a subset of a dataset."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2113
msgid "A set of storage nodes storing copies of a dataset. Each storage in a replica set has a role, master or replica."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2117
msgid "**Master**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2119
msgid "A storage in a replica set processing read and write requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2124
msgid "A storage in a replica set processing only read requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2127
msgid "**Read requests**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2129
msgid "Read-only requests, that is, select requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2132
msgid "**Write requests**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2134
msgid "Data-change operations, that is create, replace, update, delete requests."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2137
msgid "**Buckets (virtual buckets)**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2139
msgid "The abstract virtual nodes into which the dataset is partitioned by the sharding key (bucket id)."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2143
msgid "**Bucket id**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2145
msgid "A sharding key defining which bucket belongs to which replica set. A bucket id may be calculated from a :ref:`hash key <router_api-bucket_id>`."
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2149
msgid "**Router**"
msgstr ""

#: ../doc/2.2/reference/reference_rock/vshard/index.rst:2151
msgid "A proxy server responsible for routing requests from an application to nodes in a cluster."
msgstr ""

#: ../doc/2.2/reference/reference_sql/index.rst:39
msgid "SQL reference"
msgstr ""

#: ../doc/2.2/reference/reference_sql/index.rst:41
msgid "This reference covers all the SQL statements and clauses supported by Tarantool."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:37
msgid "SQL statements and clauses"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:43
msgid "ALTER TABLE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:45
#: ../doc/2.2/reference/reference_sql/sql.rst:130
#: ../doc/2.2/reference/reference_sql/sql.rst:212
#: ../doc/2.2/reference/reference_sql/sql.rst:544
#: ../doc/2.2/reference/reference_sql/sql.rst:593
#: ../doc/2.2/reference/reference_sql/sql.rst:648
#: ../doc/2.2/reference/reference_sql/sql.rst:690
#: ../doc/2.2/reference/reference_sql/sql.rst:766
#: ../doc/2.2/reference/reference_sql/sql.rst:805
#: ../doc/2.2/reference/reference_sql/sql.rst:877
#: ../doc/2.2/reference/reference_sql/sql.rst:955
#: ../doc/2.2/reference/reference_sql/sql.rst:1005
#: ../doc/2.2/reference/reference_sql/sql.rst:1049
#: ../doc/2.2/reference/reference_sql/sql.rst:1384
#: ../doc/2.2/reference/reference_sql/sql.rst:1423
#: ../doc/2.2/reference/reference_sql/sql.rst:1469
#: ../doc/2.2/reference/reference_sql/sql.rst:1495
#: ../doc/2.2/reference/reference_sql/sql.rst:1558
#: ../doc/2.2/reference/reference_sql/sql.rst:1613
#: ../doc/2.2/reference/reference_sql/sql.rst:1653
#: ../doc/2.2/reference/reference_sql/sql.rst:1738
#: ../doc/2.2/reference/reference_sql/sql.rst:1805
#: ../doc/2.2/reference/reference_sql/sql.rst:1858
#: ../doc/2.2/reference/reference_sql/sql.rst:1956
#: ../doc/2.2/reference/reference_sql/sql.rst:2007
#: ../doc/2.2/reference/reference_sql/sql.rst:2042
#: ../doc/2.2/reference/reference_sql/sql.rst:2102
#: ../doc/2.2/reference/reference_sql/sql.rst:2247
#: ../doc/2.2/reference/reference_sql/sql.rst:2332
#: ../doc/2.2/reference/reference_sql/sql.rst:2397
#: ../doc/2.2/reference/reference_sql/sql.rst:2466
#: ../doc/2.2/reference/reference_sql/sql.rst:2495
#: ../doc/2.2/reference/reference_sql/sql.rst:2525
#: ../doc/2.2/reference/reference_sql/sql.rst:2554
#: ../doc/2.2/reference/reference_sql/sql.rst:2608
#: ../doc/2.2/reference/reference_sql/sql.rst:2622
#: ../doc/2.2/reference/reference_sql/sql.rst:2655
#: ../doc/2.2/reference/reference_sql/sql.rst:2671
#: ../doc/2.2/reference/reference_sql/sql.rst:2695
#: ../doc/2.2/reference/reference_sql/sql.rst:2713
#: ../doc/2.2/reference/reference_sql/sql.rst:2739
#: ../doc/2.2/reference/reference_sql/sql.rst:2757
#: ../doc/2.2/reference/reference_sql/sql.rst:2779
#: ../doc/2.2/reference/reference_sql/sql.rst:2798
#: ../doc/2.2/reference/reference_sql/sql.rst:2818
#: ../doc/2.2/reference/reference_sql/sql.rst:2834
#: ../doc/2.2/reference/reference_sql/sql.rst:2849
msgid "Syntax:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:47
msgid ":samp:`ALTER TABLE {table-name} RENAME TO {new-table-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:48
msgid ":samp:`ALTER TABLE {table-name} ADD CONSTRAINT {constraint-name} {constraint-definition};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:49
msgid ":samp:`ALTER TABLE {table-name} DROP CONSTRAINT {constraint-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:58
msgid "ALTER is used to change a table's name or to add new constraints or to drop old constraints."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:63
msgid "-- renaming a table:\n"
"ALTER TABLE t1 RENAME TO t2;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:68
msgid "For ``ALTER ... RENAME``, the *old-table* must exist, the *new-table* must not exist."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:71
msgid "-- adding a foreign-key constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT c FOREIGN KEY (s1) REFERENCES t1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:76
msgid "For ``ALTER ... ADD CONSTRAINT``, the table must exist, table must be empty, the constraint name must not already exist for the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:79
msgid "It is not possible to say ``CREATE TABLE table_a ... REFERENCES table_b ...`` if table ``b`` does not exist yet. This is a situation where ``ALTER TABLE`` is handy -- users can ``CREATE TABLE table_a`` without the foreign key, then ``CREATE TABLE table_b``, then ``ALTER TABLE table_a ... REFERENCES table_b ...``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:84
msgid "-- adding a primary-key constraint definition:\n"
"-- This is unusual because primary keys are created automatically\n"
"-- and it is illegal to have two primary keys for the same table.\n"
"-- However, it is possible to drop a primary-key index, and this\n"
"-- is a way to restore the primary key if that happens.\n"
"ALTER TABLE t1 ADD CONSTRAINT primary_key PRIMARY KEY (s1);\n"
"\n"
"-- adding a unique-constraint definition:\n"
"-- Alternatively, you can say CREATE UNIQUE INDEX unique_key ON t1 (s1);\n"
"ALTER TABLE t1 ADD CONSTRAINT unique_key UNIQUE (s1);\n"
"\n"
"-- Adding a check-constraint definition:\n"
"ALTER TABLE t1 ADD CONSTRAINT check_ CHECK (s1 > 0);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:102
msgid "For ``ALTER ... DROP CONSTRAINT``, it is only legal to drop a named constraint, and Tarantool only looks for names of foreign-key constraints. (Tarantool generates the constraint names automatically if the user does not provide them.)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:106
msgid "To remove a unique constraint, use DROP INDEX, which will drop the constraint as well."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:109
msgid "-- dropping a constraint:\n"
"ALTER TABLE t1 DROP CONSTRAINT c;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:115
#: ../doc/2.2/reference/reference_sql/sql.rst:198
#: ../doc/2.2/reference/reference_sql/sql.rst:637
#: ../doc/2.2/reference/reference_sql/sql.rst:1364
#: ../doc/2.2/reference/reference_sql/sql.rst:1724
#: ../doc/2.2/reference/reference_sql/sql.rst:1848
#: ../doc/2.2/reference/reference_sql/sql.rst:1944
#: ../doc/2.2/reference/reference_sql/sql.rst:1994
#: ../doc/2.2/reference/reference_sql/sql.rst:2307
msgid "Limitations:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:117
msgid "It is not possible to add or drop a column."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:118
msgid "It is not possible to modify NOT NULL constraints or column properties DEFAULT and data type. However, it is possible to modify them with Tarantool/NOSQL, for example by calling :ref:`space_object:format() <box_space-format>` with a different ``is_nullable`` value."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:128
#: ../doc/2.2/tutorials/sql_tutorial.rst:117
msgid "CREATE TABLE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:132
msgid ":samp:`CREATE TABLE [IF NOT EXISTS] {table-name} ((column-definition or table-constraint list);`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:141
msgid "Create a new base table, usually called a \"table\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:145
msgid "A table is a *base table* if it is created with CREATE TABLE and contains data in persistent storage."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:148
msgid "A table is a *viewed table*, or just \"view\", if it is created with CREATE VIEW and gets its data from other views or from base tables."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:151
msgid "The *table-name* must be an identifier which is valid according to the rules for identifiers, and must not be the name of an already existing base table or view."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:154
msgid "The *column-definition* or *table-constraint* list is a comma-separated list of column definitions or table constraints."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:157
msgid "A *table-element-list* must be a comma-separated list of table elements; each table element may be either a column definition or a table constraint definition."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:161
#: ../doc/2.2/reference/reference_sql/sql.rst:560
#: ../doc/2.2/reference/reference_sql/sql.rst:614
#: ../doc/2.2/reference/reference_sql/sql.rst:710
#: ../doc/2.2/reference/reference_sql/sql.rst:828
#: ../doc/2.2/reference/reference_sql/sql.rst:900
#: ../doc/2.2/reference/reference_sql/sql.rst:974
#: ../doc/2.2/reference/reference_sql/sql.rst:1076
#: ../doc/2.2/reference/reference_sql/sql.rst:1439
msgid "Rules:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:163
msgid "A primary key is necessary; it can be specified with a table constraint PRIMARY KEY."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:165
msgid "There must be at least one column."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:166
msgid "When IF NOT EXISTS is specified, and there is already a table with the same name, the statement is ignored."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:169
#: ../doc/2.2/reference/reference_sql/sql.rst:568
#: ../doc/2.2/reference/reference_sql/sql.rst:621
#: ../doc/2.2/reference/reference_sql/sql.rst:666
#: ../doc/2.2/reference/reference_sql/sql.rst:717
#: ../doc/2.2/reference/reference_sql/sql.rst:785
#: ../doc/2.2/reference/reference_sql/sql.rst:843
#: ../doc/2.2/reference/reference_sql/sql.rst:909
#: ../doc/2.2/reference/reference_sql/sql.rst:980
#: ../doc/2.2/reference/reference_sql/sql.rst:1093
#: ../doc/2.2/reference/reference_sql/sql.rst:1402
#: ../doc/2.2/reference/reference_sql/sql.rst:1446
msgid "Actions:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:171
msgid "Tarantool evaluates each column definition and *table-constraint*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:173
msgid "Tarantool makes a new definition in the schema."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:174
msgid "Tarantool makes new indexes for PRIMARY KEY or UNIQUE constraints. A unique index name is created automatically."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:176
msgid "Tarantool effectively executes a ``COMMIT`` statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:180
msgid "-- the simplest form, with one column and one constraint:\n"
"CREATE TABLE t1 (s1 INTEGER, PRIMARY KEY (s1));\n"
"\n"
"-- you can see the effect of the statement by querying\n"
"-- Tarantool system spaces:\n"
"SELECT * FROM \"_space\" WHERE \"name\" = 'T1';\n"
"SELECT * FROM \"_index\" JOIN \"_space\" ON \"_index\".\"id\" = \"_space\".\"id\"\n"
"         WHERE \"_space\".\"name\" = 'T1';\n"
"\n"
"-- variation of the simplest form, with delimited identifiers\n"
"-- and an inline comment:\n"
"CREATE TABLE \"T1\" (\"S1\" INT /* synonym of INTEGER */, PRIMARY KEY (\"S1\"));\n"
"\n"
"-- two columns, one named constraint\n"
"CREATE TABLE t1 (s1 INTEGER, s2 STRING, CONSTRAINT c1 PRIMARY KEY (s1, s2));"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:200
msgid "The maximum number of columns is 2000."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:201
msgid "The maximum length of a row depends on the :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` or :ref:`vinyl_max_tuple_size  <cfg_storage-memtx_max_tuple_size>` configuration option."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:210
msgid "Column definition"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:214
msgid ":samp:`column-name data-type [, column-constraint]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:216
msgid "Define a column, which is a table-element used in a CREATE TABLE statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:218
msgid "The ``column-name`` must be an identifier which is valid according to the rules for identifiers."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:221
msgid "Each ``column-name`` must be unique within a table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:227
msgid "Column definition -- data type"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:234
msgid "Every operand has a data type."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:236
msgid "For literals, the data type is usually determined by the format."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:238
msgid "For identifiers, the data type is usually determined by the definition."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:240
msgid "The usual determination may change because of context or because of explicit casting."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:242
msgid "For some SQL data type names there are *aliases*. An alias may be used for data definition. For example VARCHAR(5) and TEXT are aliases of STRING and may appear in `CREATE TABLE table_name (column_name VARCHAR(5) PRIMARY KEY);` but Tarantool, if asked, will report that the data type of `column_name` is STRING."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:248
msgid "For every SQL data type there is a corresponding NoSQL type, for example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:251
msgid "To avoid confusion in this manual, all references to SQL data type names are in upper case and all similar words which refer to NoSQL types or to other kinds of object are in lower case, for example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:255
msgid "STRING is a data type name, but string is a general term;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:256
msgid "NUMBER is a data type name, but number is a general term."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:258
msgid "Although it is common to say that a VARBINARY value is a \"binary string\", this manual will not use that term and will instead say \"byte sequence\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:261
msgid "Here are all the SQL data types, their corresponding NoSQL types, their aliases, and minimum / maximum literal examples."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:266
#: ../doc/2.2/reference/reference_sql/sql.rst:454
msgid "**Data types**"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:274
msgid "SQL type"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:274
msgid "NoSQL type"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:274
msgid "Aliases"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:274
msgid "Minimum"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:274
msgid "Maximum"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:276
msgid "BOOLEAN"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:276
msgid "BOOL"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:276
#: ../doc/2.2/reference/reference_sql/sql.rst:289
msgid "FALSE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:276
msgid "TRUE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:278
msgid "INTEGER"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:278
msgid "INT"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:278
msgid "-9223372036854775808"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:278
#: ../doc/2.2/reference/reference_sql/sql.rst:280
msgid "18446744073709551615"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:280
msgid "UNSIGNED"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:280
msgid "unsigned"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:280
#: ../doc/2.2/reference/reference_sql/sql.rst:282
#: ../doc/2.2/reference/reference_sql/sql.rst:287
#: ../doc/2.2/reference/reference_sql/sql.rst:289
msgid "(none)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:282
msgid "NUMBER"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:282
msgid "-1.79769e308"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:282
msgid "1.79769e308"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:284
msgid "STRING"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:284
msgid "TEXT, VARCHAR(n)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:284
msgid "''"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:284
msgid "'many-characters'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:287
msgid "VARBINARY"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:287
msgid "varbinary"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:287
msgid "X''"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:287
msgid "'X'many-hex-digits'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:289
msgid "SCALAR"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:289
msgid "X'many-hex-digits'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:292
msgid "BOOLEAN values are FALSE, TRUE, and UNKNOWN (which is the same as NULL). FALSE is less than TRUE."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:295
msgid "INTEGER values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between -2^63 and +2^64, or NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:299
msgid "UNSIGNED values are numbers that do not contain decimal points and are not expressed with exponential notation. The range of possible values is between 0 and +2^64, or NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:303
msgid "NUMBER values are numbers that do contain decimal points (for example 0.5) or are expressed with exponential notation (for example 5E-1). The range of possible values is the same as for the IEEE 754 floating-point standard, or NULL. Numbers outside the range of NUMBER literals may be displayed as -inf or inf."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:309
msgid "STRING values are any sequence of zero or more characters encoded with UTF-8, or NULL. The possible character values are the same as for the Unicode standard. Byte sequences which are not valid UTF-8 characters are allowed but not recommended. STRING literal values are enclosed within single quotes, for example 'literal'. If the VARCHAR alias is used for column definition, it must include a maximum length, for example column_1 VARCHAR(40). However, the maximum length is ignored. The data-type may be followed by ``[COLLATE collation-name]``. .. // see section COLLATE clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:318
msgid "VARBINARY values are any sequence of zero or more octets (bytes), or NULL. VARBINARY literal values are expressed as X followed by pairs of hexadecimal digits enclosed within single quotes, for example X'0044'. VARBINARYs NoSQL equivalent is 'varbinary' but not character string -- the MessagePack storage is MP_BIN (MsgPack binary)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:324
msgid "SCALAR can be used for column definitions but the individual column values have one of the preceding types -- BOOLEAN, INTEGER, UNSIGNED, NUMBER, STRING, or VARBINARY. See more about SCALAR in the next section. The data-type may be followed by ``[COLLATE collation-name]``. .. // see section COLLATE clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:330
msgid "Any value of any data type may be NULL. Ordinarily NULL will be cast to the data type of any operand it is being compared to or to the data type of the column it is in. If the data type of NULL cannot be determined from context, it is BOOLEAN."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:337
msgid "Column definition -- the rules for the SCALAR data type"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:339
msgid "SCALAR is a \"complex\" data type, unlike all the other data types which are \"primitive\". Two column values in a SCALAR column can have two different primitive data types."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:342
msgid "Any item defined as SCALAR has an underlying primitive type. For example, here:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:344
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (55),('41');"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:349
msgid "the underlying primitive type of the item in the first row is INTEGER because literal 55 has data type INTEGER, and the underlying primitive type in the second row is STRING (the data type of a literal is always clear from its format)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:354
msgid "An item's primitive type is far more important than its defined type. Incidentally Tarantool might find the primitive type by looking at the way MsgPack stores it, but that is an implementation detail."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:358
msgid "A SCALAR definition may not include a maximum length, as there is no suggested restriction."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:360
msgid "A SCALAR definition may include a COLLATE clause, which affects any items whose primitive data type is STRING. The default collation is \"binary\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:362
msgid "Some assignments are illegal when data types differ, but legal when the target is a SCALAR item. For example ``UPDATE ... SET column1 = 'a'`` is illegal if ``column1`` is defined as INTEGER, but is legal if ``column1`` is defined as SCALAR -- values which happen to be INTEGER will be changed so their data type is STRING."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:367
msgid "There is no literal syntax which implies data type SCALAR."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:368
msgid "TYPEOF(x) is never SCALAR, it is always the underlying data type. This is true even if ``x`` is null (in that case the data type is BOOLEAN). In fact there is no function that is guaranteed to return the defined data type. For example, ``TYPEOF(CAST(1 AS SCALAR));`` returns INTEGER, not SCALAR."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:372
msgid "For any operation that requires implicit casting from an item defined as SCALAR, the syntax is legal but the operation may fail at runtime. At runtime, Tarantool detects the underlying primitive data type and applies the rules for that. For example, if a definition is:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:377
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY, s2 INTEGER);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:381
msgid "and within any row ``s1 = 'a'``, that is, its underlying primitive type is STRING to indicate character strings, then ``UPDATE t SET s2 = s1;`` is illegal. Tarantool usually does not know that in advance."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:384
msgid "For any dyadic operation that requires implicit casting for comparison, the syntax is legal and the operation will not fail at runtime. Take this situation: comparison with a primitive type VARBINARY and a primitive type STRING."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:389
msgid "CREATE TABLE t (s1 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (X'41');\n"
"SELECT * FROM t WHERE s1 > 'a';"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:395
msgid "The comparison is valid, because Tarantool knows the ordering of X'41' and 'a' in Tarantool/NoSQL 'scalar'. This would be true even if ``s1`` was not defined as SCALAR."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:398
msgid "The result data type of min/max operation on a column defined as SCALAR is the data type of the minimum/maximum operand, unless the result value is NULL. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:402
msgid "CREATE TABLE t (s1 INT, s2 SCALAR PRIMARY KEY);\n"
"INSERT INTO t VALUES (1,X'44'),(2,11),(3,1E4),(4,'a');\n"
"SELECT MIN(s2), HEX(MAX(s2)) FROM t;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:408
msgid "The result is: ``- - [11, '44',]``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:410
msgid "That is only possible with Tarantool/NoSQL scalar rules, but ``SELECT SUM(s2)`` would not be legal because addition would in this case require implicit casting from VARBINARY to integer, which is not sensible."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:413
msgid "The result data type of a primitive combination is never SCALAR because we in effect use TYPEOF(item) not the defined data type. (Here we use the word \"combination\" in the way that the standard document uses it for section \"Result of data type combinations\".) Therefore for ``MAX(1E308, 'a', 0, X'00')`` the result is X'00'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:421
msgid "Column definition -- relation to NoSQL"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:423
msgid "All the SQL data types correspond to :ref:`Tarantool/NoSQL types with the same name <box_space-index_field_types>`. For example an SQL STRING is stored in a NoSQL space as type = 'string'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:427
msgid "Therefore specifying an SQL data type X determines that the storage will be in a space with a format column saying that the NoSQL type is 'x'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:430
msgid "The rules for that NoSQL type are applicable to the SQL data type."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:432
msgid "If two items have SQL data types that have the same underlying type, then they are compatible for all assignment or comparison purposes."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:435
msgid "If two items have SQL data types that have different underlying types, then the rules for explicit casts, or implicit (assignment) casts, or implicit (comparison) casts, apply."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:439
msgid "There is one floating-point value which is not handled by SQL: -nan is seen as NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:441
msgid "There are also some Tarantool/NoSQL data types which have no corresponding SQL data types. For example, ``SELECT \"flags\" FROM \"_space\";`` will return a column whose data type is 'map'. Such columns can only be manipulated in SQL by invoking Lua functions."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:448
msgid "Column definition -- column-constraint or default clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:450
msgid "The column-constraint or default clause may be as follows:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:460
msgid "Comment"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:462
msgid "NOT NULL"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:462
msgid "means \"it is illegal to assign a NULL to this column\""
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:465
msgid "PRIMARY KEY"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:465
#: ../doc/2.2/reference/reference_sql/sql.rst:468
#: ../doc/2.2/reference/reference_sql/sql.rst:471
msgid "explained in the later section \"Constraint definition\""
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:468
msgid "UNIQUE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:471
msgid "CHECK (expression)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:474
msgid "DEFAULT expression"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:474
msgid "means \"if INSERT does not assign to this column then assign expression result to this column\" -- if there is no DEFAULT clause then DEFAULT NULL is assumed."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:481
msgid "If column-constraint is PRIMARY KEY, this is a shorthand for a separate table-constraint definition: \"PRIMARY KEY (column-name)\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:484
msgid "If column-constraint is UNIQUE, this is a shorthand for a separate table-constraint definition: \"UNIQUE (column-name)\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:487
msgid "Columns defined with PRIMARY KEY are automatically NOT NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:489
msgid "To enforce some restrictions that Tarantool does not enforce automatically, add CHECK clauses, like these:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:492
msgid "CREATE TABLE t (\"smallint\" INTEGER PRIMARY KEY, CHECK (\"smallint\" <= 32767 AND \"smallint\" >= -32768));\n"
"CREATE TABLE t (\"shorttext\" CHAR(10) PRIMARY KEY, CHECK (length(\"shorttext\") <= 10));"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:497
msgid "but this may cause inserts or updates to be slow."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:501
msgid "Column definition -- examples"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:503
msgid "These are shown within CREATE TABLE statements. Data types may also appear in CAST functions."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:506
msgid "-- the simple form with column-name and data-type\n"
"CREATE TABLE t (column1 INTEGER ...);\n"
"-- with column-name and data-type and column-constraint\n"
"CREATE TABLE t (column1 STRING PRIMARY KEY ...);\n"
"-- with column-name and data-type and collate-clause and two column-constraints\n"
"CREATE TABLE t (column1 SCALAR COLLATE \"unicode\" ...);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:515
msgid "-- with all possible data types and aliases\n"
"CREATE TABLE t\n"
"(column1 BOOLEAN, column2 BOOL,\n"
" column3 INT PRIMARY KEY, column4 INTEGER,\n"
" column4 NUMBER,\n"
" column7 STRING, column8 STRING COLLATE \"unicode\",\n"
" column9 TEXT, columna TEXT COLLATE \"unicode_sv_s1\",\n"
" columnb VARCHAR(0), columnc VARCHAR(100000) COLLATE \"binary\",\n"
" columnd VARBINARY,\n"
" columne SCALAR, columnf SCALAR COLLATE \"unicode_uk_s2\");"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:528
msgid "-- with all possible column constraints and a default clause\n"
"CREATE TABLE t\n"
"(column1 INT PRIMARY KEY,\n"
" column2 INT UNIQUE,\n"
" column3 INT CHECK (column3 > column2),\n"
" column4 INT REFERENCES t,\n"
" column6 INT DEFAULT NULL);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:542
msgid "DROP TABLE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:546
msgid ":samp:`DROP TABLE [IF EXISTS] {table-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:555
msgid "Drop a table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:557
msgid "The *table-name* must identify a table that was created earlier with the :ref:`CREATE TABLE statement <sql_create_table>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:562
msgid "If there is a view that references the table, the drop will fail. Please drop the referencing view with DROP VIEW first."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:564
msgid "If there is a foreign key that references the table, the drop will fail. Please drop the referencing constraint with :ref:`ALTER TABLE ... DROP <sql_alter_table_drop_constraint>` first."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:570
msgid "Tarantool returns an error if the table does not exist."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:571
msgid "The table and all its data are dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:572
msgid "All indexes for the table are dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:573
msgid "All triggers for the table are dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:574
#: ../doc/2.2/reference/reference_sql/sql.rst:626
#: ../doc/2.2/reference/reference_sql/sql.rst:671
#: ../doc/2.2/reference/reference_sql/sql.rst:723
#: ../doc/2.2/reference/reference_sql/sql.rst:790
#: ../doc/2.2/reference/reference_sql/sql.rst:1097
#: ../doc/2.2/reference/reference_sql/sql.rst:1406
msgid "Tarantool effectively executes a COMMIT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:578
msgid "-- the simple case:\n"
"DROP TABLE t31;\n"
"-- with an IF EXISTS clause:\n"
"DROP TABLE IF EXISTS t31;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:585
msgid "See also: :ref:`DROP VIEW <sql_drop_view>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:595
msgid ":samp:`CREATE VIEW [IF NOT EXISTS] {view-name} [(column-list)] AS subquery;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:604
msgid "Create a new viewed table, usually called a \"view\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:606
msgid "The *view-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:608
msgid "The optional *column-list* must be a comma-separated list of names of columns in the view."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:611
msgid "The syntax of the subquery must be the same as the syntax of a SELECT statement, or of a VALUES clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:616
msgid "There must not already be a base table or view with the same name as *view-name*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:618
msgid "If *column-list* is specified, the number of columns in *column-list* must be the same as the number of columns in the *select-list* of the subquery."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:623
#: ../doc/2.2/reference/reference_sql/sql.rst:719
#: ../doc/2.2/reference/reference_sql/sql.rst:1095
msgid "Tarantool will throw an error if a rule is violated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:624
msgid "Tarantool will create a new persistent object with *column-names* equal to the names in the *column-list* or the names in the subquery's *select-list*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:630
msgid "-- the simple case:\n"
"CREATE VIEW v AS SELECT column1, column2 FROM t;\n"
"-- with a column-list:\n"
"CREATE VIEW v (a,b) AS SELECT column1, column2 FROM t;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:639
msgid "It is not possible to insert or update or delete from a view, although sometimes a possible substitution is to create an INSTEAD OF trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:646
msgid "DROP VIEW"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:650
msgid ":samp:`DROP VIEW [IF EXISTS] {view-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:659
msgid "Drop a view."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:661
msgid "The *view-name* must identify a view that was created earlier with the :ref:`CREATE VIEW statement <sql_create_view>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:664
#: ../doc/2.2/reference/reference_sql/sql.rst:783
#: ../doc/2.2/reference/reference_sql/sql.rst:1400
msgid "Rules: none"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:668
msgid "Tarantool returns an error if the view does not exist."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:669
msgid "The view is dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:670
msgid "All triggers for the view are dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:675
msgid "-- the simple case:\n"
"DROP VIEW v31;\n"
"-- with an IF EXISTS clause:\n"
"DROP VIEW IF EXISTS v31;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:682
msgid "See also: :ref:`DROP TABLE <sql_drop_table>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:688
msgid "CREATE INDEX"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:692
msgid ":samp:`CREATE [UNIQUE] INDEX [IF NOT EXISTS] {index-name} ON {table-name} (column-list);`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:701
msgid "Create an index."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:703
msgid "The *index-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:705
msgid "The *table-name* must refer to an existing table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:707
msgid "The *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:712
msgid "There must not already be, for the same table, an index with the same name as *index-name*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:714
msgid "An index name is local to the table the index is defined on."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:715
msgid "The maximum number of indexes per table is 128."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:720
msgid "If the new index is UNIQUE, Tarantool will throw an error if any row exists with columns that have duplicate values."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:722
msgid "Tarantool will create a new index."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:725
msgid "Automatic indexes:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:727
msgid "Indexes may be created automatically for columns mentioned in the PRIMARY KEY or UNIQUE clauses of a CREATE TABLE statement. If an index was created automatically, then the *index-name* is based on four items:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:732
msgid "``pk`` if this is for a PRIMARY KEY clause, ``unique`` if this is for a UNIQUE clause;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:734
msgid "``_unnamed_``;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:735
msgid "the name of the table;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:736
msgid "``_`` and an ordinal number; the first index is 1, the second index is 2, and so on."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:739
msgid "For example, after ``CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT, UNIQUE (s2));`` there are two indexes named ``pk_unnamed_T_1`` and ``unique_unnamed_T_2``. You can confirm this by saying ``SELECT * FROM \"_index\";`` which will list all indexes on all tables. There is no need to say ``CREATE INDEX`` for columns that already have automatic indexes."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:748
msgid "-- the simple case\n"
"CREATE INDEX i ON t (column1);\n"
"-- with IF NOT EXISTS clause\n"
"CREATE INDEX IF NOT EXISTS i ON t (column1);\n"
"-- with UNIQUE specifier and more than one column\n"
"CREATE UNIQUE INDEX i ON t (column1, column2);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:757
msgid "Dropping an automatic index created for a unique constraint will drop the unique constraint as well."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:764
msgid "DROP INDEX"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:768
msgid ":samp:`DROP INDEX [IF EXISTS] index-name ON {table-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:777
msgid "The *index-name* must be the name of an existing index, which was created with CREATE INDEX. Or, the *index-name* must be the name of an index that was created automatically due to a PRIMARY KEY or UNIQUE clause in the CREATE TABLE statement. To see what a table's indexes are, use ``PRAGMA index_list (table-name)``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:787
msgid "Tarantool throws an error if the index does not exist, or is an automatically created index."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:789
msgid "Tarantool will drop the index."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:794
msgid "-- the simplest form:\n"
"DROP INDEX i ON t;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:807
msgid ":samp:`INSERT INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:808
msgid ":samp:`INSERT INTO {table-name} [(column-list)]  select-statement;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:809
msgid ":samp:`INSERT INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:818
msgid "Insert one or more new rows into a table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:820
msgid "The *table-name* must be a name of a table defined earlier with CREATE TABLE."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:822
msgid "The optional *column-list* must be a comma-separated list of names of columns in the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:825
msgid "The *expression-list* must be a comma-separated list of expressions; each expression may contain literals and operators and subqueries and function invocations."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:830
msgid "The values in the *expression-list* are evaluated from left to right."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:831
msgid "The order of the values in the *expression-list* must correspond to the order of the columns in the table, or (if a *column-list* is specified) to the order of the columns in the *column-list*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:834
#: ../doc/2.2/reference/reference_sql/sql.rst:903
msgid "The data type of the value should correspond to the data type of the column, that is, the data type that was specified with CREATE TABLE."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:836
msgid "If a *column-list* is not specified, then the number of expressions must be the same as the number of columns in the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:838
msgid "If a *column-list* is specified, then some columns may be omitted; omitted columns will get default values."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:840
msgid "The parenthesized *expression-list* may be repeated -- ``(expression-list),(expression-list),...`` -- for multiple rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:845
msgid "Tarantool evaluates each expression in *expression-list*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:847
msgid "Tarantool creates zero or more new rows containing values based on the values in the VALUES list or based on the results of the *select-expression* or based on the default values."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:850
msgid "Tarantool executes constraint checks and trigger actions and the actual insertion."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:851
msgid "Tarantool inserts values into the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:857
msgid "-- the simplest form:\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"INSERT INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"INSERT INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"INSERT INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:869
msgid "See also: :ref:`REPLACE statement <sql_replace>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:879
msgid ":samp:`UPDATE {table-name} SET column-name = expression [, column-name = expression ...] [WHERE search-condition];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:890
msgid "Update zero or more existing rows in a table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:892
#: ../doc/2.2/reference/reference_sql/sql.rst:968
msgid "The *table-name* must be a name of a table defined earlier with CREATE TABLE or CREATE VIEW."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:895
msgid "The *column-name* must be an updatable column in the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:897
msgid "The *expression* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:902
msgid "The values in the SET clause are evaluated from left to right."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:905
msgid "If a *search-condition* is not specified, then all rows in the table will be updated; otherwise only those rows which match the *search-condition* will be updated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:911
msgid "Tarantool evaluates each expression in the SET clause, and returns an error if any of the rules is violated. For each row that is found by the WHERE clause, a temporary new row is formed based on the original contents and the modifications caused by the SET clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:915
msgid "Tarantool executes constraint checks and trigger actions and the actual update."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:921
msgid "-- the simplest form:\n"
"UPDATE t SET column1 = 1;\n"
"-- with more than one assignment in the SET clause:\n"
"UPDATE t SET column1 = 1, column2 = 2;\n"
"-- with a WHERE clause:\n"
"UPDATE t SET column1 = 5 WHERE column2 = 6;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:930
msgid "Special cases:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:932
msgid "It is legal to say SET (list of columns) = (list of values). For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:934
msgid "UPDATE t SET (column1, column2, column3) = (1,2,3);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:938
msgid "It is not legal to assign to a column more than once. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:940
msgid "INSERT INTO t (column1) VALUES (0);\n"
"UPDATE t SET column1 = column1 + 1, column1 = column1 + 1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:945
msgid "The result is an error: \"duplicate column name\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:947
msgid "It is not legal to assign to a primary-key column."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:957
msgid ":samp:`DELETE FROM {table-name} [WHERE search-condition];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:966
msgid "Delete zero or more existing rows in a table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:971
msgid "The *search-condition* may contain literals and operators and subqueries and function invocations and column names."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:976
msgid "If a search-condition is not specified, then all rows in the table will be deleted; otherwise only those rows which match the *search-condition* will be deleted."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:982
msgid "Tarantool evaluates each expression in the *search-condition*, and returns an error if any of the rules is violated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:984
msgid "Tarantool finds the set of rows that are to be deleted."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:985
msgid "Tarantool executes constraint checks and trigger actions and the actual deletion."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:986
msgid "Tarantool deletes the set of matching rows from the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:992
msgid "-- the simplest form:\n"
"DELETE FROM t;\n"
"-- with a WHERE clause:\n"
"DELETE FROM t WHERE column2 = 6;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1007
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] VALUES (expression-list) [, (expression-list)];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1008
msgid ":samp:`REPLACE INTO {table-name} [(column-list)] select-statement;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1009
msgid ":samp:`REPLACE INTO {table-name} DEFAULT VALUES;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1018
msgid "Insert one or more new rows into a table, or update existing rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1020
msgid "If a row already exists (as determined by the primary key or any unique key), then the action is delete + insert, and the rules are the same as for a DELETE statement followed by an INSERT statement. Otherwise the action is insert, and the rules are the same as for the INSERT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1028
msgid "-- the simplest form:\n"
"REPLACE INTO table1 VALUES (1, 'A');\n"
"-- with a column list:\n"
"REPLACE INTO table1 (column1, column2) VALUES (2, 'B');\n"
"-- with an arithmetic operator in the first expression:\n"
"REPLACE INTO table1 VALUES (2 + 1, 'C');\n"
"-- put two rows in the table:\n"
"REPLACE INTO table1 VALUES (4, 'D'), (5, 'E');"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1039
msgid "See also: :ref:`INSERT Statement <sql_insert>`, :ref:`UPDATE Statement <sql_update>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1047
msgid "CREATE TRIGGER"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1051
msgid ":samp:`CREATE TRIGGER [IF NOT EXISTS] {trigger-name}` |br| :samp:`BEFORE|AFTER|INSTEAD OF` |br| :samp:`INSERT|UPDATE|DELETE ON {table-name}` |br| :samp:`FOR EACH ROW` |br| :samp:`[WHEN (search-condition)]` |br| :samp:`BEGIN` |br| :samp:`update-statement | insert-statement | delete-statement | select-statement;` |br| :samp:`[update-statement | insert-statement | delete-statement | select-statement; ...]` |br| :samp:`END;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1068
msgid "The *trigger-name* must be valid according to the rules for identifiers."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1070
msgid "If the trigger action time is BEFORE or AFTER, then the *table-name* must refer to an existing base table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1073
msgid "If the trigger action time is INSTEAD OF, then the *table-name* must refer to an existing view."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1078
msgid "There must not already be a trigger with the same name as *trigger-name*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1079
msgid "Triggers on different tables or views share the same namespace."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1080
msgid "The statements between BEGIN and END should not refer to the *table-name* mentioned in the ON clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1082
msgid "The statements between BEGIN and END should not contain an INDEXED BY clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1084
msgid "SQL triggers are not fired upon Tarantool/NoSQL requests. This will change in version 2.2."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1087
msgid "On a replica, effects of trigger execution are applied, and the SQL triggers themselves are not fired upon replication events."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1090
msgid "NoSQL triggers are fired both on replica and master, thus if you have a NoSQL trigger on replica, it is fired when applying effects of an SQL trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1096
msgid "Tarantool will create a new trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1101
msgid "-- the simple case:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with IF NOT EXISTS clause:\n"
"CREATE TRIGGER IF NOT EXISTS delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with FOR EACH ROW and WHEN clauses:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW WHEN a=5\n"
"  BEGIN DELETE FROM warehouses; END;\n"
"-- with multiple statements between BEGIN and END:\n"
"CREATE TRIGGER delete_if_insert BEFORE INSERT ON stores FOR EACH ROW\n"
"  BEGIN DELETE FROM warehouses; INSERT INTO inventories VALUES (1); END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1120
msgid "Trigger extra clauses"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1122
msgid ":samp:`UPDATE OF column-list`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1124
msgid "After BEFORE|AFTER UPDATE it is optional to add ``OF column-list``. If any of the columns in *column-list* is affected at the time the row is processed, then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1128
msgid "CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE  OF column1, column2 ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"UPDATE table1 SET column3 = column3 + 1; -- Trigger will not be activated\n"
"UPDATE table1 SET column2 = column2 + 0; -- Trigger will be activated"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1137
msgid ":samp:`WHEN`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1139
msgid "After *table-name* FOR EACH ROW it is optional to add [``WHEN expression``]. If the expression is true at the time the row is processed, only then the trigger will be activated for that row. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1143
msgid "CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" WHEN (SELECT COUNT(*) FROM table1) > 1\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1149
msgid "This trigger will not be activated unless there is more than one row in ``table1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1152
msgid ":samp:`OLD and NEW`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1154
msgid "The keywords OLD and NEW have special meaning in the context of trigger action:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1156
msgid "OLD.column-name refers to the value of *column-name* before the change."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1157
msgid "NEW.column-name refers to the value of *column-name* after the change."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1161
msgid "CREATE TABLE table1 (column1 VARCHAR(15), column2 INT PRIMARY KEY);\n"
"CREATE TABLE table2 (column1 VARCHAR(15), column2 VARCHAR(15), column3 INT PRIMARY KEY);\n"
"INSERT INTO table1 VALUES ('old value', 1);\n"
"INSERT INTO table2 VALUES ('', '', 1);\n"
"CREATE TRIGGER trigger_on_table1 BEFORE UPDATE ON table1 FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = old.column1, column2 = new.column1; END;\n"
"UPDATE table1 SET column1 = 'new value';\n"
"SELECT * FROM table2;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1172
msgid "At the beginning of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'old value' -- so that is what is seen as ``old.column1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1175
msgid "At the end of the UPDATE for the single row of ``table1``, the value in ``column1`` is 'new value' -- so that is what is seen as ``new.column1``. (OLD and NEW are qualifiers for ``table1``, not ``table2.``)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1179
msgid "Therefore, ``SELECT * FROM table2;`` returns ``['old value', 'new value']``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1181
msgid "``OLD.column-name`` does not exist for an INSERT trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1183
msgid "``NEW.column-name`` does not exist for a DELETE trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1185
msgid "OLD and NEW are read-only; you cannot change their values."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1187
msgid "Deprecated or illegal statements:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1189
msgid "It is legal for the trigger action to include a SELECT statement or a REPLACE statement, but not recommended."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1192
msgid "It is illegal for the trigger action to include a qualified column reference other than ``OLD.column-name`` or ``NEW.column-name``. For example, ``CREATE TRIGGER ... BEGIN UPDATE table1 SET table1.column1=5; END;`` is illegal."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1197
msgid "It is illegal for the trigger action to include statements that include a WITH clause, a DEFAULT VALUES clause, or an INDEXED BY clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1200
msgid "It is usually not a good idea to have a trigger on ``table1`` which causes a change on ``table2``, and at the same time have a trigger on ``table2`` which causes a change on ``table1``. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1204
msgid "CREATE TRIGGER trigger_on_table1\n"
" BEFORE UPDATE ON table1\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table2 SET column1 = column1 + 1; END;\n"
"CREATE TRIGGER trigger_on_table2\n"
" BEFORE UPDATE ON table2\n"
" FOR EACH ROW\n"
" BEGIN UPDATE table1 SET column1 = column1 + 1; END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1215
msgid "Luckily ``UPDATE table1 ...`` will not cause an infinite loop, because Tarantool recognizes when it has already updated so it will stop. However, not every DBMS acts this way."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1223
msgid "Trigger activation"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1225
msgid "These are remarks concerning trigger activation."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1227
msgid "Standard terminology:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1229
msgid "\"trigger action time\" = BEFORE or AFTER or INSTEAD OF"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1230
msgid "\"trigger event\" = INSERT or DELETE or UPDATE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1231
msgid "\"triggered statement\" = BEGIN ... INSERT|DELETE|UPDATE ... END"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1232
msgid "\"triggered when clause\" = WHEN (search condition)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1233
msgid "\"activate\" = execute a triggered statement"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1234
msgid "some vendors use the word \"fire\" instead of \"activate\""
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1236
msgid "If there is more than one trigger for the same trigger event, Tarantool may execute the triggers in any order."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1239
msgid "It is possible for a triggered statement to cause activation of another triggered statement. For example, this is legal:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1242
msgid "CREATE TRIGGER on_t1 BEFORE DELETE ON t1 BEGIN DELETE FROM t2; END;\n"
"CREATE TRIGGER on_t2 BEFORE DELETE ON t2 BEGIN DELETE FROM t3; END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1247
msgid "Activation occurs FOR EACH ROW, not FOR EACH STATEMENT. Therefore, if no rows are candidates for insert or update or delete, then no triggers are activated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1250
msgid "The BEFORE trigger is activated even if the trigger event fails."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1252
msgid "If an UPDATE trigger event does not make a change, the trigger is activated anyway. For example, if row 1 ``column1`` contains 'a', and the trigger event is ``UPDATE ... SET column1 = 'a';``, the trigger is activated."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1256
msgid "The triggered statement may refer to a function: ``RAISE(FAIL, error-message)``. If a triggered statement invokes a ``RAISE(FAIL, error-message)`` function, or if a triggered statement causes an error, then statement execution stops immediately."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1262
msgid "The triggered statement may refer to column values within the rows being changed. in this case:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1265
msgid "The row \"as of before\" the change is called the \"old\" row (which makes sense only for UPDATE and DELETE statements)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1267
msgid "The row \"as of after\" the change is called the \"new\" row (which makes sense only for UPDATE and INSERT statements)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1270
msgid "This example shows how an INSERT can be done to a view by referring to the \"new\" row:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1273
msgid "CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"CREATE VIEW v AS SELECT s1, s2 FROM t;\n"
"CREATE TRIGGER tv INSTEAD OF INSERT ON v\n"
"  FOR EACH ROW\n"
"  BEGIN INSERT INTO t VALUES (new.s1, new.s2); END;\n"
"INSERT INTO v VALUES (1,2);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1282
msgid "Ordinarily saying ``INSERT INTO view_name ...`` is illegal in Tarantool, so this is a workaround."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1285
msgid "It is possible to generalize this so that all data-change statements on views will change the base tables, provided that the view contains all the columns of the base table, and provided that the triggers refer to those columns when necessary, as in this example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1290
msgid "CREATE TABLE base_table (primary_key_column INT PRIMARY KEY, value_column INT);\n"
"CREATE VIEW viewed_table AS SELECT primary_key_column, value_column FROM base_table;\n"
"CREATE TRIGGER viewed_insert INSTEAD OF INSERT ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    INSERT INTO base_table VALUES (new.primary_key_column, new.value_column);\n"
"  END;\n"
"CREATE TRIGGER viewed_update INSTEAD OF UPDATE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    UPDATE base_table\n"
"    SET primary_key_column = new.primary_key_column, value_column = new.value_column\n"
"    WHERE primary_key_column = old.primary_key_column;\n"
"  END;\n"
"CREATE TRIGGER viewed_delete INSTEAD OF DELETE ON viewed_table FOR EACH ROW\n"
"  BEGIN\n"
"    DELETE FROM base_table WHERE primary_key_column = old.primary_key_column;\n"
"  END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1309
msgid "When INSERT or UPDATE or DELETE occurs for table ``X``, Tarantool usually operates in this order (a basic scheme):"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1312
msgid "For each row\n"
"  Perform constraint checks\n"
"  For each BEFORE trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block.\n"
"  Insert or update or delete the row in table X.\n"
"  Perform more constraint checks\n"
"  For each AFTER trigger that refers to table X\n"
"    Check that the trigger's WHEN condition is true.\n"
"    Execute what is in the trigger's BEGIN|END block."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1327
msgid "However, Tarantool does not guarantee execution order when there are multiple constraints, or multiple triggers for the same event (including NoSQL ``on_replace`` triggers or SQL INSTEAD OF triggers that affect a view of table ``X``)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1332
msgid "The maximum number of trigger activations per statement is 32."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1338
msgid "INSTEAD OF triggers"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1340
msgid "A trigger which is created with the clause |br| :samp:`INSTEAD OF {INSERT|UPDATE|DELETE} ON {view-name}` |br| is an INSTEAD OF trigger. For each affected row, the trigger action is performed \"instead of\" the INSERT or UPDATE or DELETE statement that causes trigger activation."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1346
msgid "For example, ordinarily it is illegal to INSERT rows in a view, but it is legal to create a trigger which intercepts attempts to INSERT, and puts rows in the underlying base table:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1350
msgid "CREATE TABLE t1 (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE VIEW v1 AS SELECT column1, column2 FROM t1;\n"
"CREATE TRIGGER t1 INSTEAD OF INSERT ON v1 FOR EACH ROW BEGIN\n"
" INSERT INTO t1 VALUES (NEW.column1, NEW.column2); END;\n"
"INSERT INTO v1 VALUES (1, 1);\n"
"-- ... The result will be: table t1 will contain a new row."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1359
msgid "INSTEAD OF triggers are only legal for views, while BEFORE or AFTER triggers are not legal for views."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1362
msgid "It is legal to create INSTEAD OF triggers with triggered WHEN clauses."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1366
msgid "It is legal to create INSTEAD OF triggers with UPDATE OF *column-list* clauses, but they are not standard SQL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1371
msgid "CREATE TRIGGER et1\n"
"  INSTEAD OF UPDATE OF column2,column1 ON ev1\n"
"  FOR EACH ROW BEGIN\n"
"  INSERT INTO et2 VALUES (NEW.column1, NEW.column2); END;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1382
msgid "DROP TRIGGER"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1386
msgid ":samp:`DROP TRIGGER [IF EXISTS] {trigger-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1395
msgid "Drop a trigger."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1397
msgid "The *trigger-name* must identify a trigger that was created earlier with the CREATE TRIGGER statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1404
msgid "Tarantool returns an error if the trigger does not exist."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1405
msgid "The trigger is dropped."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1410
msgid "-- the simple case:\n"
"DROP TRIGGER tr;\n"
"-- with an IF EXISTS clause:\n"
"DROP TRIGGER IF EXISTS tr;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1421
msgid "TRUNCATE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1425
msgid ":samp:`TRUNCATE TABLE {table-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1434
msgid "Remove all rows in the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1436
msgid "TRUNCATE is considered to be a schema-change rather than a data-change statement, so it does not work within transactions (it cannot be rolled back)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1441
msgid "It is illegal to truncate a table which is referenced by a foreign key."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1442
msgid "It is illegal to truncate a table which is also a system space, such as ``_space``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1444
msgid "The table must be a base table rather than a view."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1448
msgid "All rows in the table are removed. Usually this is faster than ``DELETE FROM table-name;``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1450
msgid "If the table has an autoincrement primary key, its sequence is reset to zero."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1451
msgid "There is no effect for any triggers associated with the table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1452
msgid "There is no effect on the counts for the ``row_count()`` function."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1453
msgid "Only one action is written to the write-ahead log (with ``DELETE FROM table-name;`` there would be one action for each deleted row)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1459
msgid "TRUNCATE TABLE t;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1471
msgid ":samp:`SELECT [ALL|DISTINCT] select-list [from clause] [where clause] [group-by clause] [having clause] [order-by clause];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1485
msgid "Select zero or more rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1487
msgid "The clauses of the SELECT statement are discussed in the following five sections."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1493
msgid "Select-list"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1497
msgid ":samp:`select-list-column [, select-list-column ...] select-list-column:`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1507
msgid "Define what will be in a result set; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1509
msgid "The *select-list* is a comma-delimited list of expressions, or ``*`` (asterisk). An expression can have an alias provided with ``[AS [column-name]]`` clause."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1512
msgid "The ``*`` \"asterisk\" shorthand is valid if and only if the SELECT statement also contains a FROM clause which specifies the table or tables (details about the FROM clause are in the next section). The simple form is ``*`` which means \"all columns\" -- for example, if the select is done for a table which contains three columns ``s1`` ``s2`` ``s3``, then ``SELECT * ...`` is equivalent to ``SELECT s1, s2, s3 ...``. The qualified form is ``table-name.*`` which means \"all columns in the specified table\", which again must be a result of the FROM clause -- for example, if the table is named ``table1``, then ``table1.*`` is equivalent to a list of the columns of ``table1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1524
msgid "The ``[AS [column-name]]`` clause determines the column name. The column name is useful for two reasons:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1527
msgid "in a tabular display, the column names are the headings"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1528
msgid "if the results of the SELECT are used in ``CREATE TABLE new-table-name ... AS SELECT select-list ...``, then the column names in the new table will be the column names in the *select-list*."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1532
msgid "If ``[AS [column-name]]`` is missing, Tarantool makes a name equal to the expression, for example ``SELECT 5*88`` will cause the column name to be ``5*88``, but such names may be ambiguous or illegal in other contexts, so it is better to say, for example, ``SELECT 5 * 88 AS column1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1539
msgid "-- the simple form:\n"
"SELECT 5;\n"
"-- with multiple expressions including operators:\n"
"SELECT 1, 2 * 2, 'Three' || 'Four';\n"
"-- with [[AS] column-name] clause:\n"
"SELECT 5 AS column1;\n"
"-- * which must be eventually followed by a FROM clause:\n"
"SELECT * FROM table1;\n"
"-- as a list:\n"
"SELECT 1 AS a, 2 AS b, table1.* FROM table1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1556
msgid "FROM clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1560
msgid ":samp:`FROM table-reference [, table-reference ...]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1569
msgid "Specify the table or tables for the source of a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1571
msgid "The *table-reference* must be a name of an existing table, or a subquery, or a joined table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1574
msgid "A joined table looks like this:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1576
msgid ":samp:`table-reference-or-joined-table join-operator table-reference-or-joined-table [join-specification]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1578
msgid "A *join-operator* must be any of `the standard types <https://en.wikipedia.org/wiki/Join_(SQL)>`_:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1581
msgid "[NATURAL] LEFT [OUTER] JOIN,"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1582
msgid "[NATURAL] INNER JOIN, or"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1583
msgid "CROSS JOIN"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1585
msgid "A *join-specification* must be any of:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1587
msgid "ON expression, or"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1588
msgid "USING (column-name [, column-name ...])"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1590
msgid "Parentheses are allowed, and ``[[AS] correlation-name]`` is allowed."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1592
msgid "The maximum number of joins in a FROM clause is 64."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1596
msgid "-- the simplest form:\n"
"SELECT * FROM t;\n"
"-- with two tables, making a Cartesian join:\n"
"SELECT * FROM t1, t2;\n"
"-- with one table joined to itself, requiring correlation names:\n"
"SELECT a.*, b.* FROM t1 AS a, t1 AS b;\n"
"-- with a left outer join:\n"
"SELECT * FROM t1 LEFT JOIN t2;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1611
msgid "WHERE clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1615
msgid ":samp:`WHERE condition;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1624
msgid "Specify the condition for filtering rows from a table; this is a clause in a SELECT or UPDATE or DELETE statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1627
msgid "The condition may contain any expression that returns a BOOLEAN (TRUE or FALSE or UNKNOWN) value."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1630
#: ../doc/2.2/reference/reference_sql/sql.rst:1827
msgid "For each row in the table:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1632
#: ../doc/2.2/reference/reference_sql/sql.rst:1829
msgid "if the condition is true, then the row is kept;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1633
#: ../doc/2.2/reference/reference_sql/sql.rst:1830
msgid "if the condition is false or unknown, then the row is ignored."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1635
msgid "In effect, WHERE condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1640
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t WHERE column1 = 5;\n"
"-- with a condition that contains AND and OR and parentheses:\n"
"SELECT 1 FROM t WHERE column1 = 5 AND (x > 1 OR y < 1);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1655
msgid ":samp:`GROUP BY expression [, expression ...]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1664
msgid "Make a grouped table; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1666
msgid "The expressions should be column names in the table, and each column should be specified only once."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1669
msgid "In effect, GROUP BY clause takes a table with rows that may have matching values, combines rows that have matching values into single rows, and returns a table which, because it is the result of GROUP BY, is called a grouped table."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1674
msgid "Thus, if the input is a table:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1676
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'\n"
"1    'b'   'b'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1686
msgid "then ``GROUP BY a, b`` will produce a grouped table:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1688
msgid "a    b      c\n"
"-    -      -\n"
"1    'a'   'b'\n"
"1    'b'   'b'\n"
"2    'a'   'b'\n"
"3    'a'   'b'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1697
msgid "The rows where column ``a`` and column ``b`` have the same value have been merged; column ``c`` has been preserved but its value should not be depended on -- if the rows were not all 'b', Tarantool could pick any value."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1701
msgid "It is useful to envisage a grouped table as having hidden extra columns for the aggregation of the values, for example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1704
msgid "a    b      c    COUNT(a) SUM(a) MIN(c)\n"
"-    -      -    -------- ------ ------\n"
"1    'a'  'b'         2      2    'b'\n"
"1    'b'  'b'         1      1    'b'\n"
"2    'a'  'b'         1      2    'b'\n"
"     'a'  'b'         1      3    'b'"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1713
msgid "These extra columns are what :ref:`aggregate functions <sql_aggregate>` are for."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1717
msgid "-- with a single column:\n"
"SELECT 1 FROM t GROUP BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t GROUP BY column1, column2;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1726
msgid "``SELECT s1,s2 FROM t GROUP BY s1;`` is legal."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1727
msgid "``SELECT s1 AS q FROM t GROUP BY q;`` is legal."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1728
msgid "``SELECT s1 FROM t GROUP by 1;`` is legal."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1736
msgid "Aggregate functions"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1740
#: ../doc/2.2/reference/reference_sql/sql.rst:2610
msgid ":samp:`function-name (one or more expressions)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1742
msgid "Apply a built-in aggregate function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1745
msgid "Aggregate functions are only legal in certain clauses of SELECT for grouped tables. (A table is a grouped table if a GROUP BY clause is present.) Also, if an aggregate function is used in a select-list and GROUP BY clause is omitted, then Tarantool assumes ``SELECT ... GROUP BY [all columns];``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1752
msgid "NULLs are ignored for all aggregate functions except COUNT(*)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1757
msgid "``AVG([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1755
msgid "Return the average value of expression."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1757
msgid "Example: :samp:`AVG({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1762
msgid "``COUNT([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1760
msgid "Return the number of occurrences of expression."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1762
msgid "Example: :samp:`COUNT({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1767
msgid "``COUNT(*)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1765
msgid "Return the number of occurrences of a row."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1767
msgid "Example: :samp:`COUNT(*)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1775
msgid "``GROUP_CONCAT(expression-1 [, expression-2])``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1770
msgid "Return a list of *expression-1* values, separated by commas if *expression-2* is omitted, or separated by the *expression-2* value if *expression-2* is not omitted."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1775
msgid "Example: :samp:`GROUP_CONCAT({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1780
msgid "``MAX([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1778
msgid "Return the maximum value of expression."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1780
msgid "Example: :samp:`MAX({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1785
msgid "``MIN([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1783
msgid "Return the minimum value of expression."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1785
msgid "Example: :samp:`MIN({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1790
msgid "``SUM([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1788
#: ../doc/2.2/reference/reference_sql/sql.rst:1793
msgid "Return the sum of values of expression."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1790
msgid "Example: :samp:`SUM({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1795
msgid "``TOTAL([DISTINCT] expression)``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1795
msgid "Example: :samp:`TOTAL({column1})`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1807
msgid ":samp:`HAVING condition;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1816
msgid "Specify the condition for filtering rows from a grouped table; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1819
msgid "The clause preceding the HAVING clause may be a GROUP BY clause. HAVING operates on the table that the GROUP BY produces, which may contain grouped columns and aggregates."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1823
msgid "If the preceding clause is not a GROUP BY clause, then there is only one group and the HAVING clause may only contain aggregate functions or literals."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1832
msgid "In effect, HAVING condition takes a table with n rows and returns a table with n or fewer rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1837
msgid "-- with a simple condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5;\n"
"-- with a more complicated condition:\n"
"SELECT 1 FROM t GROUP BY column1 HAVING column2 > 5 OR column2 < 5;\n"
"-- with an aggregate:\n"
"SELECT x, SUM(y) FROM t GROUP BY x HAVING SUM(y) > 0;\n"
"-- with no GROUP BY and an aggregate:\n"
"SELECT SUM(y) FROM t GROUP BY x HAVING MIN(y) < MAX(y);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1850
msgid "HAVING without GROUP BY is not supported for multiple tables."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1856
msgid "ORDER BY clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1860
msgid ":samp:`ORDER BY expression [ASC|DESC] [, expression [ASC|DESC] ...]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1869
msgid "Put rows in order; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1871
msgid "An ORDER BY expression has one of three types which are checked in order:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1873
msgid "Expression is a positive integer, representing the ordinal position of the column in the select list. For example, in the statement |br| ``SELECT x, y, z FROM t ORDER BY 2;`` |br| ``ORDER BY 2`` means \"order by the second column in the select list\", which is ``y``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1878
msgid "Expression is a name of a column in the select list, which is determined by an AS clause. For example, in the statement |br| ``SELECT x, y AS x, z FROM t ORDER BY x;`` |br| ``ORDER BY x`` means \"order by the column explicitly named ``x`` in the select list\", which is the second column."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1883
msgid "Expression contains a name of a column in a table of the FROM clause. For example, in the statement |br| ``SELECT x, y FROM t1 JOIN t2 ORDER BY z;`` |br| ``ORDER BY z`` means \"order by a column named ``z`` which is expected to be in table ``t1`` or table ``t2``\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1889
msgid "If both tables contain a column named ``z``, then Tarantool will choose the first column that it finds."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1892
msgid "The expression may also contain operators and function names and literals. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY UPPER(z);`` |br| ``ORDER BY UPPER(z)`` means \"order by the uppercase form of column ``t.z``\", which may be similar to doing ordering in a case-insensitive manner."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1898
msgid "Type 3 is illegal if the SELECT statement contains UNION or EXCEPT or INTERSECT."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1900
msgid "If an ORDER BY clause contains multiple expressions, then expressions on the left are processed first and expressions on the right are processed only if necessary for tie-breaking. For example, in the statement |br| ``SELECT x, y FROM t ORDER BY x, y;`` if there are two rows which both have the same values for column ``x``, then an additional check is made to see which row has a greater value for column ``y``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1909
msgid "In effect, ORDER BY clause takes a table with rows that may be out of order, and returns a table with rows in order."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1912
msgid "Sorting order:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1914
msgid "The default order is ASC (ascending), the optional order is DESC (descending)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1915
msgid "NULLs come first, then numbers (INTEGER or NUMBER), then STRINGs, then VARBINARYs."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1916
msgid "Within STRINGs, ordering is according to collation."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1917
msgid "Collation may be specified within the ORDER BY column-list, or may be default."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1921
msgid "-- with a single column:\n"
"SELECT 1 FROM t ORDER BY column1;\n"
"-- with two columns:\n"
"SELECT 1 FROM t ORDER BY column1, column2;\n"
"-- with a variety of data:\n"
"CREATE TABLE h (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO h VALUES (7,'A'),(4,'A '),(-4,'AZ'),(17,17),(23,NULL);\n"
"INSERT INTO h VALUES (17.5,'Д'),(1e+300,'a'),(0,''),(-1,'');\n"
"SELECT * FROM h ORDER BY s2, s1;\n"
"-- The result of the above SELECT will be:\n"
"- - [23, null]\n"
"  - [17, 17]\n"
"  - [-1, '']\n"
"  - [0, '']\n"
"  - [7, 'A']\n"
"  - [4, 'A ']\n"
"  - [-4, 'AZ']\n"
"  - [1e+300, 'a']\n"
"  - [17.5, 'Д']\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1946
msgid "ORDER BY 1 is legal. This is common but is not standard SQL nowadays."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1954
msgid "LIMIT clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1958
msgid ":samp:`LIMIT limit-expression [OFFSET offset-expression]`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1959
msgid ":samp:`LIMIT offset-expression, limit-expression`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1963
msgid "The above is not a typo: *offset-expression* and *limit-expression* are in reverse order if a comma is used."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1973
msgid "Specify a maximum number of rows and a start row; this is a clause in a SELECT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1976
msgid "Expressions may contain integers and arithmetic operators or functions, for example ``ABS(-3/1)``. However, the result must be an integer value greater than or equal to zero."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1980
msgid "Usually the LIMIT clause follows an ORDER BY clause, because otherwise Tarantool does not guarantee that rows are in order."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1985
msgid "-- simple case:\n"
"SELECT * FROM t LIMIT 3;\n"
"-- both limit and order:\n"
"SELECT * FROM t LIMIT 3 OFFSET 1;\n"
"-- applied to a UNIONed result (LIMIT clause must be the final clause):\n"
"SELECT column1 FROM table1 UNION SELECT column1 FROM table2 ORDER BY 1 LIMIT 1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:1996
msgid "If ORDER BY ... LIMIT is used, then all order-by columns must be ASC or all must be DESC."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2005
#: ../doc/2.2/tutorials/sql_tutorial.rst:665
msgid "VALUES"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2009
msgid ":samp:`VALUES (expression [, expression ...]) [, (expression [, expression ...])`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2018
msgid "Select one or more rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2020
msgid "VALUES has the same effect as SELECT, that is, it returns a result set, but VALUES statements may not have FROM or GROUP or ORDER BY or LIMIT clauses."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2023
msgid "VALUES may be used wherever SELECT may be used, for example in subqueries."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2027
msgid "-- simple case:\n"
"VALUES (1);\n"
"-- equivalent to SELECT 1, 2, 3:\n"
"VALUES (1, 2, 3);\n"
"-- two rows:\n"
"VALUES (1, 2, 3), (4, 5, 6);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2040
msgid "Subquery"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2044
msgid ":ref:`SELECT-statement <sql_select>` syntax"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2045
msgid ":ref:`VALUES-statement <sql_values>` syntax"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2047
msgid "A subquery has the same syntax as a SELECT statement or VALUES statement embedded inside a main statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2052
msgid "The SELECT and VALUES statements are called \"queries\" because they return answers, in the form of result sets."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2055
msgid "Subqueries may be the second part of INSERT statements. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2057
msgid "INSERT INTO t2 SELECT a,b,c FROM t1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2061
msgid "Subqueries may be in the FROM clause of SELECT statements."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2063
msgid "Subqueries may be expressions, or be inside expressions. In this case they must be parenthesized, and usually the number of rows must be 1. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2067
msgid "SELECT 1, (SELECT 5), 3 FROM t WHERE c1 * (SELECT COUNT(*) FROM t2) > 5;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2071
msgid "Subqueries may be expressions on the right side of certain comparison operators, and in this unusual case the number of rows may be greater than 1. The comparison operators are: [NOT] EXISTS and [NOT] IN. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2075
msgid "DELETE FROM t WHERE s1 NOT IN (SELECT s2 FROM t);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2079
msgid "Subqueries may refer to values in the outer query. In this case, the subquery is called a \"correlated subquery\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2082
msgid "Subqueries may refer to rows which are being updated or deleted by the main query. In that case, the subquery finds the matching rows first, before starting to update or delete. For example, after:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2086
msgid "CREATE TABLE t (s1 INT PRIMARY KEY, s2 INT);\n"
"INSERT INTO t VALUES (1,3),(2,1);\n"
"DELETE FROM t WHERE s2 NOT IN (SELECT s1 FROM t);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2092
msgid "only one of the rows is deleted, not both rows."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2098
msgid "WITH clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2100
msgid "**WITH clause (common table expression)**"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2104
msgid ":samp:`WITH {temporary-table-name} AS (subquery)` |br| :samp:`[, {temporary-table-name} AS (subquery)]` |br| :samp:`SELECT statement | INSERT statement | DELETE statement | UPDATE statement | REPLACE statement;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2115
msgid "WITH v AS (SELECT * FROM t) SELECT * FROM v;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2119
msgid "is equivalent to creating a view and selecting from it:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2121
msgid "CREATE VIEW v AS SELECT * FROM t;\n"
"SELECT * FROM v;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2126
msgid "The difference is that a WITH-clause \"view\" is temporary and only useful within the same statement. No CREATE privilege is required."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2129
msgid "The WITH-clause can also be thought of as a subquery that has a name. This is useful when the same subquery is being repeated. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2132
msgid "SELECT * FROM t WHERE a < (SELECT s1 FROM x) AND b < (SELECT s1 FROM x);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2136
msgid "can be replaced with:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2138
msgid "WITH S AS (SELECT s1 FROM x) SELECT * FROM t,S WHERE a < S.s1 AND b < S.s1;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2142
msgid "This \"factoring out\" of a repeated expression is regarded as good practice."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2146
msgid "WITH cte AS (VALUES (7,'') INSERT INTO j SELECT * FROM cte;\n"
"WITH cte AS (SELECT s1 AS x FROM k) SELECT * FROM cte;\n"
"WITH cte AS (SELECT COUNT(*) FROM k WHERE s2 < 'x' GROUP BY s3)\n"
"  UPDATE j SET s2 = 5\n"
"  WHERE s1 = (SELECT s1 FROM cte) OR s3 = (SELECT s1 FROM cte);"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2154
msgid "WITH can only be used at the beginning of a statement, therefore it cannot be used at the beginning of a subquery or after a set operator or inside a CREATE statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2158
msgid "A WITH-clause \"view\" is read-only because Tarantool does not support updatable views."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2165
msgid "WITH RECURSIVE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2167
msgid "**WITH RECURSIVE clause (iterative common table expression)**"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2169
msgid "The real power of WITH lies in the WITH RECURSIVE clause, which is useful when it is combined with UNION or UNION ALL:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2172
msgid ":samp:`WITH RECURSIVE recursive-table-name AS` |br| :samp:`(SELECT ... FROM non-recursive-table-name ...` |br| :samp:`UNION [ALL]` |br| :samp:`SELECT ... FROM recursive-table-name ...)` |br| :samp:`statement-that-uses-recursive-table-name;` |br|"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2185
msgid "In non-SQL this can be read as: starting with a seed value from a non-recursive table, produce a recursive viewed table, UNION that with itself, UNION that with itself, UNION that with itself ... forever, or until a condition in the WHERE clause says \"stop\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2192
msgid "CREATE TABLE ts (s1 INT PRIMARY KEY);\n"
"INSERT INTO ts VALUES (1);\n"
"WITH RECURSIVE w AS (\n"
"  SELECT s1 FROM ts\n"
"  UNION ALL\n"
"  SELECT s1+1 FROM w WHERE s1 < 4)\n"
"SELECT * FROM w;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2202
msgid "First, table ``w`` is seeded from ``t1``, so it has one row: [1]."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2204
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [1] -- adds 1 because the select list says \"s1+1\", and so it has one row: [2]."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2208
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [2] -- adds 1 because the select list says \"s1+1\", and so it has one row: [3]."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2212
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [3] -- adds 1 because the select list says \"s1+1\", and so it has one row: [4]."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2216
msgid "Then, ``UNION ALL (SELECT s1+1 FROM w)`` takes the row from ``w`` -- which contains [4] -- and now the importance of the WHERE clause becomes evident, because \"s1 < 4\" is false for this row, and therefore we have reached the \"stop\" condition."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2221
msgid "So, before the \"stop\", table ``w`` got 4 rows -- [1], [2], [3], [4] -- and the result of the statement looks like:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2224
msgid "tarantool> WITH RECURSIVE w AS (\n"
"         >   SELECT s1 FROM ts\n"
"         >   UNION ALL\n"
"         >   SELECT s1+1 FROM w WHERE s1 < 4)\n"
"         > SELECT * FROM w;\n"
"---\n"
"- - [1]\n"
"  - [2]\n"
"  - [3]\n"
"  - [4]\n"
"..."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2238
msgid "In other words, this ``WITH RECURSIVE ... SELECT`` produces a table of auto-incrementing values."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2245
msgid "UNION, EXCEPT, and INTERSECT clauses"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2249
msgid ":samp:`select-statement UNION [ALL] select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2250
msgid ":samp:`select-statement EXCEPT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2251
msgid ":samp:`select-statement INTERSECT select-statement [ORDER BY clause] [LIMIT clause];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2270
msgid "UNION, EXCEPT, and INTERSECT are collectively called \"set operators\" or \"table operators\". In particular:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2273
msgid "``a UNION b`` means \"take rows which occur in a OR b\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2274
msgid "``a EXCEPT b`` means \"take rows which occur in a AND NOT b\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2275
msgid "``a INTERSECT b`` means \"take rows which occur in a AND b\"."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2277
msgid "Duplicate rows are eliminated unless ALL is specified."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2279
msgid "The *select-statements* may be chained: ``SELECT ... SELECT ... SELECT ...;``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2281
msgid "Each *select-statement* must result in the same number of columns."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2283
msgid "The *select-statements* may be replaced with VALUES statements."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2285
msgid "The maximum number of set operations is 50."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2289
msgid "CREATE TABLE t1 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t2 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t1 VALUES (1,'A'),(2,'B'),(3,NULL);\n"
"INSERT INTO t2 VALUES (1,'A'),(2,'C'),(3,NULL);\n"
"SELECT s2 FROM t1 UNION SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 UNION ALL SELECT s2 FROM t2 ORDER BY s2;\n"
"SELECT s2 FROM t1 EXCEPT SELECT s2 FROM t2;\n"
"SELECT s2 FROM t1 INTERSECT SELECT s2 FROM t2;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2302
msgid "The UNION query returns 4 rows: NULL, 'A', 'B', 'C'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2303
msgid "The UNION ALL query returns 6 rows: NULL, NULL, 'A', 'A', 'B', 'C'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2304
msgid "The EXCEPT query returns 1 row: 'B'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2305
msgid "The INTERSECT query returns 2 rows: NULL, 'A'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2309
msgid "Parentheses are not allowed."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2310
msgid "Evaluation is left to right, INTERSECT does not have precedence."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2314
msgid "CREATE TABLE t01 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t02 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"CREATE TABLE t03 (s1 INT PRIMARY KEY, s2 VARCHAR(1));\n"
"INSERT INTO t01 VALUES (1,'A');\n"
"INSERT INTO t02 VALUES (1,'B');\n"
"INSERT INTO t03 VALUES (1,'A');\n"
"SELECT s2 FROM t01 INTERSECT SELECT s2 FROM t03 UNION SELECT s2 FROM t02;\n"
"SELECT s2 FROM t03 UNION SELECT s2 FROM t02 INTERSECT SELECT s2 FROM t03;\n"
"-- ... results are different."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2330
msgid "INDEXED BY clause"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2334
msgid ":samp:`INDEXED BY {index-name}`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2343
msgid "The INDEXED BY clause may be used in a SELECT, DELETE, or UPDATE statement, immediately after the *table-name*. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2346
msgid "DELETE FROM table7 INDEXED BY index7 WHERE column1 = 'a';"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2350
msgid "In this case the search for 'a' will take place within ``index7``. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2352
msgid "SELECT * FROM table7 NOT INDEXED WHERE column1 = 'a';"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2356
msgid "In this case the search for 'a' will be done via a search of the whole table, what is sometimes called a \"full table scan\", even if there is an index for ``column1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2360
msgid "Ordinarily Tarantool chooses the appropriate index or lookup method depending on a complex set of \"optimizer\" rules; the INDEXED BY clause overrides the optimizer choice."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2366
msgid "Suppose a table has two columns:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2368
msgid "The first column is the primary key and therefore it has an automatic index named ``pk_unnamed_T_1``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2370
msgid "The second column has an index created by the user."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2372
msgid "The user selects with ``INDEXED BY the-index-on-column1``, then selects with ``INDEXED BY the-index-on-column-2``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2375
msgid "CREATE TABLE t (column1 INT PRIMARY KEY, column2 INT);\n"
"CREATE INDEX i ON t (column2);\n"
"INSERT INTO t VALUES (1,2),(2,1);\n"
"SELECT * FROM t INDEXED BY \"pk_unnamed_T_1\";\n"
"SELECT * FROM t INDEXED BY i;\n"
"-- Result for the first select: (1,2),(2,1)\n"
"-- Result for the second select: (2,1),(1,2)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2395
msgid "START TRANSACTION"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2399
msgid ":samp:`START TRANSACTION;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2408
msgid "Start a transaction. After ``START TRANSACTION;``, a transaction is \"active\". If a transaction is already active, then ``START TRANSACTION;`` is illegal."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2411
msgid "Transactions should be active for fairly short periods of time, to avoid concurrency issues. To end a transaction, say ``COMMIT;`` or ``ROLLBACK;``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2414
msgid "Just like in NoSQL, transaction control statements are subject to limitations set by the storage engine involved:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2417
msgid "For memtx storage engine, if a yield happens within an active transaction, the transaction is rolled back."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2419
msgid "For vinyl engine, yields are allowed."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2421
msgid "However,transaction control statements still may not work as you expect when run over a network connection: a transaction is associated with a fiber, not a network connection, and different transaction control statements sent via the same network connection may be executed by different fibers from the fiber pool."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2427
msgid "In order to ensure that all statements are part of the intended transaction, put all of them between ``START TRANSACTION;`` and ``COMMIT;`` or ``ROLLBACK;`` then send as a single batch. For example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2431
msgid "Enclose each separate SQL statement in a :ref:`box.execute() <box-sql_box_execute>` function."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2433
msgid "Pass all the ``box.execute()`` functions to the server in a single message."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2435
msgid "If you are using a console, you can do this by writing everything on a single line."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2438
msgid "If you are using :ref:`net.box <net_box-module>`, you can do this by putting all the function calls in a single string and calling :ref:`eval(string) <net_box-eval>`."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2444
msgid "START TRANSACTION;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2448
msgid "Example of a whole transaction sent to a server on ``localhost:3301`` with ``eval(string)``:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2451
msgid "net_box = require('net.box')\n"
"conn = net_box.new('localhost', 3301)\n"
"s = 'box.execute([[START TRANSACTION; ]]) '\n"
"s = s .. 'box.execute([[INSERT INTO t VALUES (1); ]]) '\n"
"s = s .. 'box.execute([[ROLLBACK; ]]) '\n"
"conn:eval(s)"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2464
msgid "COMMIT"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2468
msgid ":samp:`COMMIT;`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2477
msgid "Commit an active transaction, so all changes are made permanent and the transaction ends."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2480
msgid "COMMIT is illegal unless a transaction is active. If a transaction is not active then SQL statements are committed automatically."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2485
msgid "COMMIT;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2493
msgid "SAVEPOINT"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2497
msgid ":samp:`SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2506
msgid "Set a savepoint, so that ROLLBACK TO *savepoint-name* is possible."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2508
msgid "SAVEPOINT is illegal unless a transaction is active."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2510
msgid "If a savepoint with the same name already exists, it is released before the new savepoint is set."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2515
msgid "SAVEPOINT x;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2523
msgid "RELEASE SAVEPOINT"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2527
msgid ":samp:`RELEASE SAVEPOINT {savepoint-name};`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2536
msgid "Release (destroy) a savepoint created by SAVEPOINT statement."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2538
msgid "RELEASE is illegal unless a transaction is active."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2540
msgid "Savepoints are released automatically when a transaction ends."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2544
msgid "RELEASE SAVEPOINT x;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2552
msgid "ROLLBACK"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2556
msgid ":samp:`ROLLBACK [TO [SAVEPOINT] {savepoint-name}];`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2565
msgid "If ROLLBACK does not specify a *savepoint-name*, rollback an active transaction, so all changes since START TRANSACTION are cancelled, and the transaction ends."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2570
msgid "If ROLLBACK does specify a *savepoint-name*, rollback an active transaction, so all changes since *savepoint-name* are cancelled, and the transaction does not end."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2575
msgid "ROLLBACK is illegal unless a transaction is active."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2579
msgid "-- the simple form:\n"
"ROLLBACK;\n"
"-- the form so changes before a savepoint are not cancelled:\n"
"ROLLBACK TO SAVEPOINT x;"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2586
msgid "-- An example of a Lua function that will do a transaction\n"
"-- containing savepoint and rollback to savepoint.\n"
"function f()\n"
"box.execute([[DROP TABLE IF EXISTS t;]]) -- commits automatically\n"
"box.execute([[CREATE TABLE t (s1 VARCHAR(20) PRIMARY KEY);]]) -- commits automatically\n"
"box.execute([[START TRANSACTION;]]) -- after this succeeds, a transaction is active\n"
"box.execute([[INSERT INTO t VALUES ('Data change #1');]])\n"
"box.execute([[SAVEPOINT \"1\";]])\n"
"box.execute([[INSERT INTO t VALUES ('Data change #2');]])\n"
"box.execute([[ROLLBACK TO SAVEPOINT \"1\";]]) -- rollback Data change #2\n"
"box.execute([[ROLLBACK TO SAVEPOINt \"1\";]]) -- this is legal but does nothing\n"
"box.execute([[COMMIT;]]) -- make Data change #1 permanent, end the transaction\n"
"end"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2606
msgid "Functions"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2612
msgid "Apply a built-in function to one or more expressions and return a scalar value."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2614
msgid "Tarantool supports 32 built-in functions."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2620
msgid "CHAR"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2624
msgid ":samp:`CHAR([numeric-expression [,numeric-expression...])`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2626
msgid "Return the characters whose Unicode code point values are equal to the numeric expressions."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2629
msgid "Short example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2631
msgid "The first 128 Unicode characters are the \"ASCII\" characters, so CHAR(65,66,67) is 'ABC'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2634
msgid "Long example:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2636
msgid "For the current list of Unicode characters, in order by code point, see `www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt <http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt>`_. In that list, there is a line for a Linear B ideogram"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2642
msgid "``100CC;LINEAR B IDEOGRAM B240 WHEELED CHARIOT ...``"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2644
msgid "Therefore, for a string with a chariot in the middle, use the concatenation operator ``||`` and the CHAR function"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2647
msgid "``'start of string ' || CHAR(0X100CC) || ' end of string'``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2657
msgid ":samp:`COALESCE(expression, expression [, expression ...])`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2659
msgid "Return the value of the first non-NULL expression, or, if all expression values are NULL, return NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2663
msgid "``COALESCE(NULL, 17, 32)`` is 17."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2669
msgid "HEX"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2673
msgid ":samp:`HEX(expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2675
msgid "Return the hexadecimal code for each byte in **expression**, which may be either a string or a byte sequence. For ASCII characters, this is straightforward because the encoding is the same as the code point value. For non-ASCII characters, since character strings are usually encoded in UTF-8, each character will require two or more bytes."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2686
msgid "``HEX('A')`` will return ``41``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2687
msgid "``HEX('Д')`` will return ``D094``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2693
msgid "IFNULL"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2697
msgid ":samp:`IFNULL(expression, expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2699
msgid "Return the value of the first non-NULL expression, or, if both expression values are NULL, return NULL. Thus ``IFNULL(expression, expression)`` is the same as ``COALESCE(expression, expression)``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2705
msgid "``IFNULL(NULL, 17)`` is 17"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2711
msgid "LENGTH"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2715
msgid ":samp:`LENGTH(expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2717
msgid "Return the number of characters in the **expression**, or the number of bytes in the **expression**. It depends on the data type: strings with data type STRING are counted in characters, byte sequences with data type VARBINARY are counted in bytes and are not ended by the nul character. There are two aliases for ``LENGTH(expression)`` -- ``CHAR_LENGTH(expression)`` and ``CHARACTER_LENGTH(expression)`` do the same thing."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2728
msgid "``LENGTH('ДД')`` is 2, the string has 2 characters."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2729
msgid "``LENGTH(CAST('ДД' AS VARBINARY))`` is 4, the string has 4 bytes."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2730
msgid "``LENGTH(CHAR(0,65))`` is 2, '\\0' does not mean 'end of string'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2731
msgid "``LENGTH(X'410041')`` is 3, X'...' byte sequences have type VARBINARY."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2741
msgid ":samp:`NULLIF(expression-1, expression-2)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2743
msgid "Return *expression-1* if *expression-1* <> *expression-2*, otherwise return NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2748
msgid "``NULLIF('a','A')`` is 'a'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2749
msgid "``NULLIF(1.00, 1)`` is NULL."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2755
msgid "PRINTF"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2759
msgid ":samp:`PRINTF(string-expression [, expression ...])`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2761
msgid "Return a string formatted according to the rules of the C ``sprintf()`` function, where ``%d%s`` means the next two arguments are a number and a string, etc."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2765
msgid "If an argument is missing or is NULL, it becomes:"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2767
msgid "'0' if the format requires an integer,"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2768
msgid "'0.0' if the format requires a decimal number,"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2769
msgid "'' if the format requires a string."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2771
msgid "Example: ``PRINTF('%da', 5)`` is '5a'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2777
msgid "QUOTE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2781
msgid ":samp:`QUOTE(string-literal)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2783
msgid "Return a string with enclosing quotes if necessary, and with quotes inside the enclosing quotes if necessary. This function is useful for creating strings which are part of SQL statements, because of SQL's rules that string literals are enclosed by single quotes, and single quotes inside such strings are shown as two single quotes in a row."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2790
msgid "Example: ``QUOTE('a')`` is ``'a'``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2796
msgid "SOUNDEX"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2800
msgid ":samp:`SOUNDEX(string-expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2802
msgid "Return a four-character string which represents the sound of ``string-expression``. Often words and names which have different spellings will have the same Soundex representation if they are pronounced similarly, so it is possible to search by what they sound like. The algorithm works with characters in the Latin alphabet and works best with English words."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2810
msgid "Example: ``SOUNDEX('Crater')`` and ``SOUNDEX('Creature')`` both return ``C636``."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2816
msgid "UNICODE"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2820
msgid ":samp:`UNICODE(string-expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2822
msgid "Return the Unicode code point value of the first character of **string-expression**. If *string-expression* is empty, the return is NULL. This is the reverse of CHAR(integer)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2826
msgid "Example: ``UNICODE('Щ')`` is 1065 (hexadecimal 0429)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2832
msgid "UPPER"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2836
msgid ":samp:`UPPER(string-expression)`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2838
msgid "Return the expression, with lower-case characters converted to upper case. This is the reverse of LOWER(string-expression)."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2841
msgid "Example: ``UPPER('-4щl')`` is '-4ЩL'."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2847
msgid "VERSION"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2851
msgid ":samp:`VERSION()`"
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2853
msgid "Return the Tarantool version."
msgstr ""

#: ../doc/2.2/reference/reference_sql/sql.rst:2855
msgid "Example: for a March 2019 build VERSION() is ``2.1.1-374-g27283debc``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:39
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:41
msgid "``tarantoolctl`` is a utility for administering Tarantool :ref:`instances <tarantoolctl-instance_management>`, :ref:`checkpoint files <tarantoolctl-checkpoint_management>` and :ref:`modules <tarantoolctl-module_management>`. It is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:47
msgid "See also ``tarantoolctl`` usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:54
msgid "Command format"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:56
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:60
msgid "``COMMAND`` is one of the following: ``start``, ``stop``, ``status``, ``restart``, ``logrotate``, ``check``, ``enter``, ``eval``, ``connect``, ``cat``, ``play``, ``rocks``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:64
msgid "``NAME`` is the name of an :ref:`instance file <admin-instance_file>` or a :ref:`module <app_server-modules>`."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:67
msgid "``FILE`` is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:69
msgid "``URI`` is the URI of some Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:71
msgid "``OPTIONS`` are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:77
msgid "Commands for managing Tarantool instances"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:83
msgid "``tarantoolctl start NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:80
msgid "Start a Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:82
msgid "Additionally, this command sets the TARANTOOLCTL environment variable to 'true', to mark that the instance was started by ``tarantoolctl``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:86
msgid "``tarantoolctl stop NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:86
msgid "Stop a Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:94
msgid "``tarantoolctl status NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:89
msgid "Show an instance's status (started/stopped). If pid file exists and an alive control socket exists, the return code is ``0``. Otherwise, the return code is not ``0``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:93
msgid "Reports typical problems to stderr (e.g. pid file exists and control socket doesn't)."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:101
msgid "``tarantoolctl restart NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:97
msgid "Stop and start a Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:99
msgid "Additionally, this command sets the TARANTOOL_RESTARTED environment variable to 'true', to mark that the instance was restarted by ``tarantoolctl``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:106
msgid "``tarantoolctl logrotate NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:104
msgid "Rotate logs of a started Tarantool instance. Works only if logging-into-file is enabled in the instance file. Pipe/syslog make no effect."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:109
msgid "``tarantoolctl check NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:109
msgid "Check an instance file for syntax errors."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:117
msgid "``tarantoolctl enter NAME [--language=language]``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:112
msgid "Enter an instance's interactive Lua or SQL console."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:114
msgid "Supported option:"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:116
msgid "``--language=language`` to set :ref:`interactive console <interactive_console>` language. Can be either ``Lua`` or ``SQL``."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:120
msgid "``tarantoolctl eval NAME FILE``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:120
msgid "Evaluate a local Lua file on a running Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:124
msgid "``tarantoolctl connect URI``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:123
msgid "Connect to a Tarantool instance on an admin-console port. Supports both TCP/Unix sockets."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:130
msgid "Commands for managing checkpoint files"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:133
msgid "``tarantoolctl cat FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:133
msgid "Print into stdout the contents of .snap/.xlog files."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:136
msgid "``tarantoolctl play URI FILE.. [--space=space_no ..] [--show-system] [--from=from_lsn] [--to=to_lsn] [--replica=replica_id ..]``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:136
msgid "Play the contents of .snap/.xlog files to another Tarantool instance."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:138
#: ../doc/2.2/reference/tarantoolctl.rst:189
msgid "Supported options:"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:140
msgid "``--space=space_no`` to filter the output by space number. May be passed more than once."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:142
msgid "``--show-system`` to show the contents of system spaces."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:143
msgid "``--from=from_lsn`` to show operations starting from the given lsn."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:144
msgid "``--to=to_lsn`` to show operations ending with the given lsn."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:145
msgid "``--replica=replica_id`` to filter the output by replica id. May be passed more than once."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:152
msgid "Commands for managing Tarantool modules"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:155
msgid "``tarantoolctl rocks install NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:155
msgid "Install a module in the current directory."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:158
msgid "``tarantoolctl rocks remove NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:158
msgid "Remove a module."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:161
msgid "``tarantoolctl rocks show NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:161
msgid "Show information about an installed module."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:164
msgid "``tarantoolctl rocks search NAME``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:164
msgid "Search the repository for modules."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:167
msgid "``tarantoolctl rocks list``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:167
msgid "List all installed modules."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:177
msgid "``tarantoolctl rocks pack {<rockspec> | <name> [<version>]}``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:170
msgid "Create a rock by packing sources or binaries."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:172
#: ../doc/2.2/reference/tarantoolctl.rst:182
msgid "As an argument, you can specify:"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:174
msgid "a ``.rockspec`` file to create a source rock containing the module's sources, or"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:176
msgid "the name of an installed module (and its version if there are more than one) to create a binary rock containing the compiled module."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:187
msgid "``tarantoolctl rocks unpack {<rock_file> | <rockspec> | <name> [version]}``"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:180
msgid "Unpack the contents of a rock into a new directory under the current one."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:184
msgid "source or binary rock files,"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:185
msgid "``.rockspec`` files, or"
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:186
msgid "names of rocks or ``.rockspec`` files in remote repositories (and the rock version if there are more than one)."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:191
msgid "``--server=server_name`` check this server first, then the usual list."
msgstr ""

#: ../doc/2.2/reference/tarantoolctl.rst:192
msgid "``--only-server=server_name`` check this server only, ignore the usual list."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:37
msgid "C tutorial"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:39
msgid "Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-c_stored_procedures>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:46
msgid "C stored procedures"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:48
msgid "Tarantool can call C code with :ref:`modules <app_server-modules>`, or with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial only is about the third option, C stored procedures. In fact the routines are always \"C functions\" but the phrase \"stored procedure\" is commonly used for historical reasons."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:55
msgid "In this tutorial, which can be followed by anyone with a Tarantool development package and a C compiler, there are five tasks:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:58
msgid ":ref:`easy.c <f_c_tutorial-easy>` -- prints \"hello world\";"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:59
msgid ":ref:`harder.c <f_c_tutorial-harder>` -- decodes a passed parameter value;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:60
msgid ":ref:`hardest.c <f_c_tutorial-hardest>` -- uses the C API to do a DBMS insert;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:61
msgid ":ref:`read.c <f_c_tutorial-read>` -- uses the C API to do a DBMS select;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:62
msgid ":ref:`write.c <f_c_tutorial-write>` -- uses the C API to do a DBMS replace."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:64
msgid "After following the instructions, and seeing that the results are what is described here, users should feel confident about writing their own stored procedures."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:68
msgid "**Preparation**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:70
msgid "Check that these items exist on the computer:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:72
msgid "Tarantool 2.1"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:73
msgid "A gcc compiler, any modern version should work"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:74
msgid "``module.h`` and files #included in it"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:75
msgid "``msgpuck.h``"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:76
msgid "``libmsgpuck.a`` (only for some recent msgpuck versions)"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:78
msgid "The ``module.h`` file will exist if Tarantool was installed from source. Otherwise Tarantool's \"developer\" package must be installed. For example on Ubuntu say:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:86
msgid "or on Fedora say:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:88
msgid "$ dnf -y install tarantool-devel"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:92
msgid "The ``msgpuck.h`` file will exist if Tarantool was installed from source. Otherwise the \"msgpuck\" package must be installed from `https://github.com/rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:96
msgid "Both ``module.h`` and ``msgpuck.h`` must be on the include path for the C compiler to see them. For example, if ``module.h`` address is ``/usr/local/include/tarantool/module.h``, and ``msgpuck.h`` address is ``/usr/local/include/msgpuck/msgpuck.h``, and they are not currently on the include path, say:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:102
msgid "$ export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:106
msgid "The ``libmsgpuck.a`` static library is necessary with msgpuck versions produced after February 2017. If and only if you encounter linking problems when using the gcc statements in the examples for this tutorial, you should put ``libmsgpuck.a`` on the path (``libmsgpuck.a`` is produced from both msgpuck and Tarantool source downloads so it should be easy to find). For example, instead of \":code:`gcc -shared -o harder.so -fPIC harder.c`\" for the second example below, you will need to say \":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:115
msgid "Requests will be done using Tarantool as a :ref:`client <admin-using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:119
msgid "box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:127
msgid "In plainer language: create a space named ``capi_test``, and make a connection to self named ``capi_connection``."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:130
msgid "Leave the client running. It will be necessary to enter more requests later."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:134
msgid "**easy.c**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:136
msgid "Start another shell. Change directory (``cd``) so that it is the same as the directory that the client is running on."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:139
msgid "Create a file. Name it ``easy.c``. Put these six lines in it."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:141
msgid "#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}\n"
"int easy2(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world -- easy2\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:156
msgid "Compile the program, producing a library file named ``easy.so``:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:158
msgid "$ gcc -shared -o easy.so -fPIC easy.c"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:162
#: ../doc/2.2/tutorials/c_tutorial.rst:250
#: ../doc/2.2/tutorials/c_tutorial.rst:337
#: ../doc/2.2/tutorials/c_tutorial.rst:441
#: ../doc/2.2/tutorials/c_tutorial.rst:522
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:164
msgid "box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:170
msgid "If these requests appear unfamiliar, re-read the descriptions of :ref:`box.schema.func.create() <box_schema-func_create>`, :ref:`box.schema.user.grant() <box_schema-user_grant>` and :ref:`conn:call() <net_box-call>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:176
msgid "The function that matters is ``capi_connection:call('easy')``."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:178
msgid "Its first job is to find the 'easy' function, which should be easy because by default Tarantool looks on the current directory for a file named ``easy.so``."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:182
msgid "Its second job is to call the 'easy' function. Since the ``easy()`` function in ``easy.c`` begins with ``printf(\"hello world\\n\")``, the words \"hello world\" will appear on the screen."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:186
msgid "Its third job is to check that the call was successful. Since the ``easy()`` function in ``easy.c`` ends with :code:`return 0`, there is no error message to display and the request is over."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:190
#: ../doc/2.2/tutorials/c_tutorial.rst:366
msgid "The result should look like this:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:192
msgid "tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:200
msgid "Now let's call the other function in easy.c -- ``easy2()``. This is almost the same as the ``easy()`` function, but there's a detail: when the file name is not the same as the function name, then we have to specify :samp:`{file-name}.{function-name}`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:206
msgid "box.schema.func.create('easy.easy2', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy.easy2')\n"
"capi_connection:call('easy.easy2')"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:212
msgid "... and this time the result will be \"hello world -- easy2\"."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:214
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:218
msgid "**harder.c**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:220
msgid "Go back to the shell where the ``easy.c`` program was created."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:222
msgid "Create a file. Name it ``harder.c``. Put these 17 lines in it:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:224
msgid "#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:244
msgid "Compile the program, producing a library file named ``harder.so``:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:246
msgid "$ gcc -shared -o harder.so -fPIC harder.c"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:252
msgid "box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:262
msgid "This time the call is passing a Lua table (``passable_table``) to the ``harder()`` function. The ``harder()`` function will see it, it's in the :code:`char *args` parameter."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:266
msgid "At this point the ``harder()`` function will start using functions defined in `msgpuck.h <http://rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are msgpuck functions that handle data formatted according to the MsgPack_ specification. Passes and returns are always done with this format so one must become acquainted with msgpuck to become proficient with the C API."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:274
msgid "For now, though, it's enough to know that ``mp_decode_array()`` returns the number of elements in an array, and ``mp_decode_uint`` returns an unsigned integer, from :code:`args`. And there's a side effect: when the decoding finishes, :code:`args` has changed and is now pointing to the next element."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:280
msgid "Therefore the first displayed line will be \"arg_count = 1\" because there was only one item passed: ``passable_table``. |br| The second displayed line will be \"field_count = 3\" because there are three items in the table. |br| The next three lines will be \"1\" and \"2\" and \"3\" because those are the values in the items in the table."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:287
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:289
msgid "tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:301
msgid "Conclusion: decoding parameter values passed to a C function is not easy at first, but there are routines to do the job, and they're documented, and there aren't very many of them."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:308
msgid "**hardest.c**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:310
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` programs were created."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:313
msgid "Create a file. Name it ``hardest.c``. Put these 13 lines in it:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:315
msgid "#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  char tuple[1024]; /* Must be big enough for mp_encode results */\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:331
msgid "Compile the program, producing a library file named ``hardest.so``:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:333
msgid "$ gcc -shared -o hardest.so -fPIC hardest.c"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:339
msgid "box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:346
msgid "This time the C function is doing three things:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:348
msgid "finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:350
msgid "formatting a tuple using more ``msgpuck.h`` functions;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:351
msgid "inserting a tuple using ``box_insert()``."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:355
msgid "``char tuple[1024];`` is used here as just a quick way of saying \"allocate more than enough bytes\". For serious programs the developer must be careful to allow enough space for all the bytes that the ``mp_encode`` routines will use up."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:360
msgid "Now, still on the client, execute this request:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:362
msgid "box.space.capi_test:select()"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:368
msgid "tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:375
msgid "This proves that the ``hardest()`` function succeeded, but where did :ref:`box_space_id_by_name() <box-box_space_id_by_name>` and :ref:`box_insert() <box-box_insert>` come from? Answer: the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:382
msgid "**read.c**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:384
msgid "Go back to the shell where the ``easy.c`` and the ``harder.c`` and the ``hardest.c`` programs were created."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:387
msgid "Create a file. Name it ``read.c``. Put these 43 lines in it:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:389
msgid "#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:435
msgid "Compile the program, producing a library file named ``read.so``:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:437
msgid "$ gcc -shared -o read.so -fPIC read.c"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:443
msgid "box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:450
msgid "This time the C function is doing four things:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:452
#: ../doc/2.2/tutorials/c_tutorial.rst:533
msgid "once again, finding the numeric identifier of the ``capi_test`` space by calling ``box_space_id_by_name()``;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:454
msgid "formatting a search key = 10000 using more ``msgpuck.h`` functions;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:455
msgid "getting a tuple using ``box_index_get()``;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:456
msgid "going through the tuple's fields with ``box_tuple_get()`` and then decoding each field depending on its type. In this case, since what we are getting is the tuple that we inserted with ``hardest.c``, we know in advance that the type is either MP_UINT or MP_STR; however, it's very common to have a case statement here with one option for each possible type."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:463
msgid "The result of ``capi_connection:call('read')`` should look like this:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:465
msgid "tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:474
msgid "This proves that the ``read()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_index_get() <c_api-box_index-box_index_get>` and :ref:`box_tuple_field() <c_api-tuple-box_tuple_field>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:482
msgid "**write.c**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:484
msgid "Go back to the shell where the programs ``easy.c``, ``harder.c``, ``hardest.c`` and ``read.c`` were created."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:487
msgid "Create a file. Name it ``write.c``. Put these 24 lines in it:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:489
msgid "#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int write(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  static const char *space = \"capi_test\";\n"
"  char tuple_buf[1024]; /* Must be big enough for mp_encode results */\n"
"  uint32_t space_id = box_space_id_by_name(space, strlen(space));\n"
"  if (space_id == BOX_ID_NIL) {\n"
"    return box_error_set(__FILE__, __LINE__, ER_PROC_C,\n"
"    \"Can't find space %s\", \"capi_test\");\n"
"  }\n"
"  char *tuple_end = tuple_buf;\n"
"  tuple_end = mp_encode_array(tuple_end, 2);\n"
"  tuple_end = mp_encode_uint(tuple_end, 1);\n"
"  tuple_end = mp_encode_uint(tuple_end, 22);\n"
"  box_txn_begin();\n"
"  if (box_replace(space_id, tuple_buf, tuple_end, NULL) != 0)\n"
"    return -1;\n"
"  box_txn_commit();\n"
"  fiber_sleep(0.001);\n"
"  struct tuple *tuple = box_tuple_new(box_tuple_format_default(),\n"
"                                      tuple_buf, tuple_end);\n"
"  return box_return_tuple(ctx, tuple);\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:516
msgid "Compile the program, producing a library file named ``write.so``:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:518
msgid "$ gcc -shared -o write.so -fPIC write.c"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:524
msgid "box.schema.func.create('write', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'write')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('write')"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:531
msgid "This time the C function is doing six things:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:535
msgid "making a new tuple;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:536
msgid "starting a transaction;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:537
msgid "replacing a tuple in ``box.space.capi_test``"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:538
msgid "ending a transaction;"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:539
msgid "the final line is a replacement for the loop in ``read.c`` -- instead of getting each field and printing it, use the ``box_return_tuple(...)`` function to return the entire tuple to the caller and let the caller display it."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:544
msgid "The result of ``capi_connection:call('write')`` should look like this:"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:546
msgid "tarantool> capi_connection:call('write')\n"
"---\n"
"- [[1, 22]]\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:553
msgid "This proves that the ``write()`` function succeeded. Once again the important functions that start with `box` -- :ref:`box_txn_begin() <txn-box_txn_begin>`, :ref:`box_txn_commit() <txn-box_txn_commit>` and :ref:`box_return_tuple() <box-box_return_tuple>` -- came from the :ref:`C API <index-c_api_reference>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:560
msgid "Conclusion: the long description of the whole C API is there for a good reason. All of the functions in it can be called from C functions which are called from Lua. So C \"stored procedures\" have full access to the database."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:566
msgid "**Cleaning up**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:568
msgid "Get rid of each of the function tuples with :ref:`box.schema.func.drop <box_schema-func_drop>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:570
msgid "Get rid of the ``capi_test`` space with :ref:`box.schema.capi_test:drop() <box_space-drop>`."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:572
msgid "Remove the ``.c`` and ``.so`` files that were created for this tutorial."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:575
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:577
msgid "Download the source code of Tarantool. Look in a subdirectory :code:`test/box`. Notice that there is a file named :code:`tuple_bench.test.lua` and another file named :code:`tuple_bench.c`. Examine the Lua file and observe that it is calling a function in the C file, using the same techniques that this tutorial has shown."
msgstr ""

#: ../doc/2.2/tutorials/c_tutorial.rst:584
msgid "Conclusion: parts of the standard test suite use C stored procedures, and they must work, because releases don't happen if Tarantool doesn't pass the tests."
msgstr ""

#: ../doc/2.2/tutorials/index.rst:39
msgid "Tutorials"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:39
msgid "`libslave` tutorial"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:41
msgid "``libslave`` is a C++ library for reading data changes done by MysQL and, optionally, writing them to a Tarantool database. It works by acting as a replication slave. The MySQL server writes data-change information to a \"binary log\", and transfers the information to any client that says \"I want to see the information starting with this file and this record, continuously\". So, ``libslave`` is primarily good for making a Tarantool database replica (much faster than using a conventional MySQL slave server), and for keeping track of data changes so they can be searched."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:52
msgid "We will not go into the many details here -- the `API documentation <https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only show an exercise: a minimal program that uses the library."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:58
msgid "Use a test machine. Do not use a production machine."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:60
msgid "STEP 1: Make sure you have:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:62
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:63
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:64
msgid "MySQL client development package. For example, on Ubuntu you can download it with this command:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:67
msgid "$ sudo apt-get install mysql-client-core-5.7"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:71
msgid "STEP 2: Download ``libslave``."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:73
msgid "The recommended source is https://github.com/tarantool/libslave/. Downloads include the source code only."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:76
msgid "$ sudo apt-get install libboost-all-dev\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"$ cd tarantool-libslave\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:87
msgid "If you see an error message mentioning the word \"vector\", edit ``field.h`` and add this line:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:90
msgid "#include <vector>"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:94
msgid "STEP 3: Start the MySQL server. On the command line, add appropriate switches for doing replication. For example:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:97
msgid "$ mysqld --log-bin=mysql-bin --server-id=1"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:101
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:103
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:104
msgid "a \"test\" database with a table named \"test\","
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:105
msgid "a binary log named \"mysql-bin\","
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:106
msgid "a server with server id = 1."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:108
msgid "The values are hard-coded in the program, though of course you can change the program -- it's easy to see their settings."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:111
msgid "STEP 5: Look at the program:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:113
msgid "#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:167
msgid "Everything unnecessary has been stripped so that you can see quickly how it works. At the start of ``main()``, there are some settings used for connecting -- host, port, user, password. Then there is an initialization call with the binary log file name = \"mysql-bin\". Pay particular attention to the ``setCallback`` statement, which passes database name = \"test\", table name = \"test\", and callback function address = callback. The program will be looping and invoking this callback function. See how, earlier in the program, the callback function prints \"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:178
msgid "STEP 5: Put the program in the ``tarantool-libslave`` directory and name it ``example.cpp``."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:181
msgid "Step 6: Compile and build:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:183
msgid "$ g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a -ldl -lpthread"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:189
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:191
msgid "Notice that the name of the static library is ``libslave_a.a``, not ``libslave.a``."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:194
msgid "Step 7: Run:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:196
msgid "$ ./example"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:200
msgid "The result will be nothing -- the program is looping, waiting for the MySQL server to write to the replication binary log."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:203
msgid "Step 8: Start a MySQL client program -- any client program will do. Enter these statements:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:206
msgid "USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:213
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:215
msgid "INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:222
msgid "This is row-based replication, so you see two DELETEs, because there are two rows."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:225
msgid "What the exercise has shown is:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:227
msgid "the library can be built, and"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:228
msgid "programs that use the library can access everything that the MySQL server dumps."
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:231
msgid "For the many details and examples of usage in the field, see:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:0
msgid "Our downloadable ``libslave`` version:"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:0
msgid "https://github.com/tarantool/libslave"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:0
msgid "The version it was forked from (with a different README):"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:0
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:239
msgid "`How to speed up your MySQL with replication to in-memory database <http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-with-replication-to-in-memory-dat.html>`_ article"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:241
msgid "`Replicating data from MySQL to Tarantool <https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""

#: ../doc/2.2/tutorials/libslave.rst:243
msgid "`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-bunin/blog/313594/>`_ article (in Russian)"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:39
msgid "Lua tutorials"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:41
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:43
msgid ":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:44
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:45
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:51
msgid "Insert one million tuples with a Lua stored procedure"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:53
msgid "This is an exercise assignment: “Insert one million tuples. Each tuple should have a constantly-increasing numeric primary-key field and a random alphabetic 10-character string field.”"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:57
msgid "The purpose of the exercise is to show what Lua functions look like inside Tarantool. It will be necessary to employ the Lua math library, the Lua string library, the Tarantool box library, the Tarantool box.tuple library, loops, and concatenations. It should be easy to follow even for a person who has not used either Lua or Tarantool before. The only requirement is a knowledge of how other programming languages work and a memory of the first two chapters of this manual. But for better understanding, follow the comments and the links, which point to the Lua manual or to elsewhere in this Tarantool manual. To further enhance learning, type the statements in with the tarantool client while reading along."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:69
msgid "Configure"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:71
msgid "We are going to use the Tarantool sandbox that was created for our :ref:`\"Getting started\" exercises <getting_started>`. So there is a single space, and a numeric primary key, and a running Tarantool server instance which also serves as a client."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:78
msgid "Delimiter"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:80
msgid "In earlier versions of Tarantool, multi-line functions had to be enclosed within \"delimiters\". They are no longer necessary, and so they will not be used in this tutorial. However, they are still supported. Users who wish to use delimiters, or users of older versions of Tarantool, should check the syntax description for :ref:`declaring a delimiter <console-delimiter>` before proceeding."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:89
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:91
msgid "We will start by making a function that returns a fixed string, “Hello world”."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:93
msgid "function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:99
msgid "The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The function name is string_function. The function has one executable statement, ``return \"hello world\"``. The string \"hello world\" is enclosed in double quotes here, although Lua doesn't care -- one could use single quotes instead. The word \"``end``\" means “this is the end of the Lua function declaration.” To confirm that the function works, we can say"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:106
msgid "string_function()"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:110
msgid "Sending ``function-name()`` means “invoke the Lua function.” The effect is that the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:113
msgid "For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:119
#: ../doc/2.2/tutorials/lua_tutorials.rst:163
#: ../doc/2.2/tutorials/lua_tutorials.rst:215
#: ../doc/2.2/tutorials/lua_tutorials.rst:271
#: ../doc/2.2/tutorials/lua_tutorials.rst:317
#: ../doc/2.2/tutorials/lua_tutorials.rst:377
#: ../doc/2.2/tutorials/lua_tutorials.rst:470
msgid "The screen now looks like this:"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:121
msgid "tarantool> function string_function()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:136
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:138
msgid "Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:141
msgid "function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:149
msgid "We begin by declaring a variable \"``string_value``\". The word \"``local``\" means that string_value appears only in ``main_function``. If we didn't use \"``local``\" then ``string_value`` would be visible everywhere - even by other users using other clients connected to this server instance! Sometimes that's a very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:155
msgid "Then we assign a value to ``string_value``, namely, the result of ``string_function()``. Soon we will invoke ``main_function()`` to check that it got the value."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:159
msgid "For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and Blocks\"`_ ."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:165
msgid "tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:182
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:184
msgid "Now that it's a bit clearer how to make a variable, we can change ``string_function()`` so that, instead of returning a fixed literal \"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:188
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:198
msgid "It is not necessary to destroy the old ``string_function()`` contents, they're simply overwritten. The first assignment invokes a random-number function in Lua's math library; the parameters mean “the number must be an integer between 65 and 90.” The second assignment invokes an integer-to-character function in Lua's string library; the parameter is the code point of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:206
msgid "For more about Lua math-library functions see Lua users \"`Math Library Tutorial`_\". For more about Lua string-library functions see Lua users \"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:212
msgid "Once again the ``string_function()`` can be invoked from main_function() which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:217
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:234
msgid "... Well, actually it won't always look like this because ``math.random()`` produces random numbers. But for the illustration purposes it won't matter what the random string values are."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:240
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:242
msgid "Now that it's clear how to produce one-letter random strings, we can reach our goal of producing a ten-letter string by concatenating ten one-letter strings, in a loop."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:246
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:259
msgid "The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals 10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate\", that is, add the string on the right of the \"..\" sign to the string on the left of the \"..\" sign. Since we start by saying that random_string is \"\" (a blank string), the end result is that random_string has 10 random letters. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:267
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:273
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:295
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:297
msgid "Now that it's clear how to make a 10-letter random string, it's possible to make a tuple that contains a number and a 10-letter random string, by invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:301
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:310
msgid "Once this is done, t will be the value of a new tuple which has two fields. The first field is numeric: 1. The second field is a random string. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:315
msgid "For more about Tarantool tuples see Tarantool manual section :ref:`Submodule box.tuple <box_tuple>`."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:319
msgid "tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:337
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:339
msgid "Now that it's clear how to make a tuple that contains a number and a 10-letter random string, the only trick remaining is putting that tuple into tester. Remember that tester is the first space that was defined in the sandbox, so it's like a database table."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:344
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:353
msgid "The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' because the insertion is going to be to tester. The second parameter is the tuple value. To be perfectly correct we could have said ``box.space.tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" means “insert even if there is already a tuple whose primary-key value is a duplicate”, and that makes it easier to re-run the exercise even if the sandbox database isn't empty. Once this is done, tester will contain a tuple with two fields. The first field will be 1. The second field will be a random 10-letter string. Once again the ``string_function(``) can be invoked from ``main_function()`` which can be invoked with ``main_function()``. But ``main_function()`` won't tell the whole story, because it does not return t, it only puts t into the database. To confirm that something got inserted, we'll use a SELECT request."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:367
msgid "main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:372
msgid "For more about Tarantool insert and replace calls, see Tarantool manual section :ref:`Submodule box.space <box_space>`, :ref:`space_object:insert() <box_space-insert>`, and :ref:`space_object:replace() <box_space-replace>`."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:379
msgid "tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:400
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:402
msgid "Now that it's clear how to insert one tuple into the database, it's no big deal to figure out how to scale up: instead of inserting with a literal value = 1 for the primary key, insert with a variable value = between 1 and 1 million, in a loop. Since we already saw how to loop, that's a simple thing. The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:408
msgid "function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:423
msgid "The standard Lua function `os.clock() <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return the number of CPU seconds since the start. Therefore, by getting start_time = number of seconds just before the inserting, and then getting end_time = number of seconds just after the inserting, we can calculate (end_time - start_time) = elapsed time in seconds. We will display that value by putting it in a request without any assignments, which causes Tarantool to send the value to the client, which prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, will also work.)"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:433
msgid "For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:439
msgid "Since this is the grand finale, we will redo the final versions of all the necessary requests: the request that created ``string_function()``, the request that created ``main_function()``, and the request that invokes ``main_function()``."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:444
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:472
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:511
msgid "What has been shown is that Lua functions are quite expressive (in fact one can do more with Tarantool's Lua stored procedures than one can do with stored procedures in some SQL DBMSs), and that it's straightforward to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:516
msgid "What has also been shown is that inserting a million tuples took 37 seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:524
msgid "Sum a JSON field for all tuples"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:526
msgid "This is an exercise assignment: “Assume that inside every tuple there is a string formatted as JSON. Inside that string there is a JSON numeric field. For each tuple, find the numeric field's value and add it to a 'sum' variable. At end, return the 'sum' variable.” The purpose of the exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:532
msgid "json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:549
msgid "**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be used in the function. Actually it's not necessary to declare all variables at the start, and in a long function it would be better to declare variables just before using them. In fact it's not even necessary to declare variables at all, but an undeclared variable is \"global\". That's not desirable for any of the variables that are declared in line 1, because all of them are for use only within the function."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:556
msgid "**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:561
msgid "**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be repeated as long as there is another index key. A tuple is fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:565
msgid "**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, then the function would abort with an error if it encountered something wrong with the JSON string - a missing colon, for example. By putting the function inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept that sort of error, so if there's a problem just set ``is_valid_json = false`` and we will know what to do about it later."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:572
msgid "**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which means decode a JSON string, and the parameter is t[2] which is a reference to a JSON string. There's a bit of hard coding here, we're assuming that the second field in the tuple is where the JSON string was inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:582
msgid "field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:585
msgid "meaning that the tuple's first field, the primary key field, is a number while the tuple's second field, the JSON string, is a string. Thus the entire statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; if there's an error set ``is_valid_json = false``; if there's no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the decoded string\"."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:591
msgid "**LINE 8.** At last we are ready to get the JSON field value from the Lua table that came from the JSON string. The value in field_name, which is the parameter for the whole function, must be a name of a JSON field. For example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those are just three different ways of saying: for the Quantity field in the Lua table, get the value and put it in variable :code:`field_value`."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:601
msgid "**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON field is not a number, or is missing. In that case, the function would be aborted when there was an attempt to add it to the sum. By first checking ``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:607
msgid "And the function is complete. Time to test it. Starting with an empty database, defined the same way as the sandbox database in our :ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:611
msgid "-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:618
msgid "then add some tuples where the first field is a number and the second field is a string."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:621
msgid "box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:628
msgid "Since this is a test, there are deliberate errors. The \"golf club\" and the \"waffle iron\" do not have numeric Quantity fields, so must be ignored. Therefore the real sum of the Quantity field in the JSON strings should be: 15 + 7 = 22."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:633
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:635
msgid "tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:642
msgid "It works. We'll just leave, as exercises for future improvement, the possibility that the \"hard coding\" assumptions could be removed, that there might have to be an overflow check if some field values are huge, and that the function should contain a :ref:`yield <atomic-threads_fibers_yields>` instruction if the count of tuples is huge."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:651
msgid "Indexed pattern search"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:653
msgid "Here is a generic function which takes a field identifier and a search pattern, and returns all tuples that match. |br| * The field must be the first field of a TREE index. |br| * The function will use `Lua pattern matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows \"magic characters\" in regular expressions. |br| * The initial characters in the pattern, as far as the first magic character, will be used as an index search key. For each tuple that is found via the index, there will be a match of the whole pattern. |br| * To be :ref:`cooperative <atomic-cooperative_multitasking>`, the function should yield after every 10 tuples, unless there is a reason to delay yielding. |br| With this function, we can take advantage of Tarantool's indexes for speed, and take advantage of Lua's pattern matching for flexibility. It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:670
msgid "Read the following Lua code to see how it works. The comments that begin with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:674
msgid "function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:765
msgid "NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name (a string) and field_no (a number). The requirements are: |br| (a) index type must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a search with :ref:`iterator=GE <box_index-iterator-types>` will not return strings in order by string value; |br| (b) field_no must be the first index part; |br| (c) the field must contain strings, because for other data types (such as \"unsigned\") pattern searches are not possible; |br| If these requirements are not met by any index, then print an error message and return nil."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:777
msgid "NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed pattern (a string). The index search key will be the characters in the pattern as far as the first magic character. Lua's magic characters are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is a magic character and therefore the index search key will be \"ABC\". But there is a complication ... If we see \"%\" followed by a punctuation character, that punctuation character is \"escaped\" so remove the \"%\" when making the index search key. For example, if the pattern is \"AB%$E\", the dollar sign is escaped and therefore the index search key will be \"AB$E\". Finally there is a check that the index search key length must be at least three -- this is an arbitrary number, and in fact zero would be okay, but short index search keys will cause long search times."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:794
msgid "NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a result set, just as `box.space...select <box_space-select>` would. We will fill it within an outer loop that contains an inner loop. The outer loop's job is to execute the inner loop, and possibly :ref:`yield <atomic-threads_fibers_yields>`, until the search ends. The inner loop's job is to find tuples via the index, and put them in the result set if they match the pattern."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:803
msgid "NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), see the :ref:`explanation of what index iterators are <box_index-index_pairs>`. Within the inner loop, there will be a local variable named \"tuple\" which contains the latest tuple found via the index search key."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:810
msgid "NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is GE (Greater or Equal), and we must be more specific: if the search index key has N characters, then the leftmost N characters of the result's index field must not be greater than the search index key. For example, if the search index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal that no more matches are possible."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:819
msgid "NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk of code is for cooperative multitasking. The number 10 is arbitrary, and usually a larger number would be okay. The simple rule would be \"after checking 10 tuples, yield, and then resume the search (that is, do the inner loop again) starting after the last value that was found\". However, if the index is non-unique or if there is more than one field in the index, then we might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to decide which \"ABC\" tuple to resume with. Therefore, if the result's index field is the same as the previous result's index field, there is no break."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:832
msgid "NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare the result's index field to the entire pattern. For example, suppose that the caller passed pattern \"ABC.E\" and there is an indexed field containing \"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a tuple containing an indexed field with \"ABCDE\" will be found by the iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return a value which is not nil. Therefore this tuple can be added to the result set."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:842
msgid "NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three conditions which will cause a break from the inner loop: (1) the for loop ends naturally because there are no more index keys which are greater than or equal to the index search key, (2) the index key is too great as described in NOTE #5, (3) it is time for a yield as described in NOTE #6. If condition (1) or condition (2) is true, then there is nothing more to do, the outer loop ends too. If and only if condition (3) is true, the outer loop must yield and then continue. If it does continue, then the inner loop -- the iterator search -- will happen again with a new value for the index search key."
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:855
msgid "EXAMPLE:"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:857
msgid "Start Tarantool, cut and paste the code for function ``indexed_pattern_search()``, and try the following:"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:863
msgid "box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/2.2/tutorials/lua_tutorials.rst:879
msgid "tarantool> indexed_pattern_search(\"t\", 2, \"ABC.E.\")\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:39
msgid "SQL tutorial"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:41
msgid "This tutorial is a demonstration of the SQL feature introduced in Tarantool 2.x series. There are two ways to go through this tutorial:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:44
msgid "read what we say the results are and take our word for it, or"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:45
msgid "copy and paste each section and see everything work with Tarantool 2.1."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:47
msgid "You will encounter all the functionality that you'd encounter in an \"SQL-101\" course."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:54
msgid "Starting up with a first table and SELECTs"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:60
msgid "Requests will be done using Tarantool as a :ref:`client <admin-using_tarantool_as_a_client>`. Start Tarantool and, optionally, enter the Tarantool configuration request, for example:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:65
msgid "tarantool> box.cfg{}"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:69
msgid "Before Tarantool 2.0 you needed to say ``box.cfg{...}`` prior to performing any database operations. Now you can start working with the database outright. Tarantool initiates the database module and applies :ref:`default settings <box_introspection-box_cfg>`."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:77
msgid "\\set"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:79
msgid "A feature of the client console program is that you can switch languages and specify the end-of-statement delimiter."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:82
msgid "Here we say: default language is SQL and statements end with semicolons."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:84
msgid "tarantool> \\set language sql\n"
"tarantool> \\set delimiter ;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:91
msgid "CREATE, INSERT, UPDATE, SELECT"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:93
msgid "Start with simple SQL statements just to be sure they're there."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:95
msgid "CREATE TABLE table1 (column1 INTEGER PRIMARY KEY, column2 VARCHAR(100));\n"
"INSERT INTO table1 VALUES (1, 'A');\n"
"UPDATE table1 SET column2 = 'B';\n"
"SELECT * FROM table1 WHERE column1 = 1;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:102
msgid "The result of the ``SELECT`` statement will look like this:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:104
msgid "tarantool> SELECT * FROM table1 WHERE column1 = 1;\n"
"---\n"
"- - [1, 'B']\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:111
msgid "Reality check: actually the result will include include initial fields called \"metadata\", the names and data types of each column. For all SELECT examples we show only the result rows without showing the metadata."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:119
msgid "Here is ``CREATE TABLE`` with more details:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:121
msgid "There are multiple columns, with different data types."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:122
msgid "There is a ``PRIMARY KEY`` (unique and not-null) for two of the columns."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:124
msgid "CREATE TABLE table2 (column1 INTEGER,\n"
"                     column2 VARCHAR(100),\n"
"                     column3 SCALAR,\n"
"                     column4 FLOAT,\n"
"                     PRIMARY KEY (column1, column2));"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:132
#: ../doc/2.2/tutorials/sql_tutorial.rst:287
msgid "The result will be: \"``rowcount: 1``\" (no error)."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:138
msgid "Try to put 5 rows in the table:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:140
msgid "The INTEGER and FLOAT columns get numbers."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:141
msgid "The VARCHAR and SCALAR columns get strings (the SCALAR strings are expressed as hexadecimals)."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:144
msgid "INSERT INTO table2 VALUES (1, 'AB', X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (1, 'CD', X'2020', 1E4);\n"
"INSERT INTO table2 VALUES (1, 'AB', X'A5', -5.5);\n"
"INSERT INTO table2 VALUES (2, 'AB', X'2020', 12.34567);\n"
"INSERT INTO table2 VALUES (-1000, '', X'', 0.0);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:154
msgid "The third ``INSERT`` will fail because of a primary-key violation (``1, 'AB'`` is a duplication)."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:156
msgid "The other four ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:160
msgid "SELECT with ORDER BY clause"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:162
msgid "Retrieve the 4 rows in the table, in descending order by ``column2``, then (where the ``column2`` values are the same) in ascending order by column4."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:166
msgid "\"*\" is short for \"all columns\"."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:168
msgid "SELECT * FROM table2 ORDER BY column2 DESC, column4 ASC;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:174
msgid "- - [1, 'CD', '  ', 10000]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [2, 'AB', '  ', 12.34567]\n"
"  - [-1000, '', '', 0]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:183
msgid "SELECT with WHERE clauses"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:185
msgid "Retrieve some of what you inserted:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:187
msgid "The first statement uses the ``LIKE`` comparison operator which is asking for \"first character must be 'A', the next characters can be anything.\""
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:190
msgid "The second statement uses logical operators and parentheses, so the ANDed expressions must be true, or the ORed expression must be true. Notice the columns don't have to be indexed."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:194
msgid "SELECT column1, column2, column1 * column4 FROM table2 WHERE column2\n"
"LIKE 'A%';\n"
"SELECT column1, column2, column3, column4 FROM table2\n"
"    WHERE (column1 < 2 AND column4 < 10)\n"
"    OR column3 = X'2020';"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:202
msgid "The results will be:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:204
msgid "- - [1, 'AB', 5.5]\n"
"  - [2, 'AB', 24.69134]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:211
msgid "- - [-1000, '', '', 0]\n"
"  - [1, 'AB', 'AB', 5.5]\n"
"  - [1, 'CD', '  ', 10000]\n"
"  - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:220
msgid "SELECT with GROUP BY and aggregating"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:222
msgid "Retrieve with grouping."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:224
msgid "The rows which have the same values for ``column2`` are grouped and are aggregated -- summed, counted, averaged -- for ``column4``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:228
msgid "SELECT column2, SUM(column4), COUNT(column4), AVG(column4)\n"
"FROM table2\n"
"GROUP BY column2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:236
msgid "- - ['', 0, 1, 0]\n"
"  - ['AB', 17.84567, 2, 8.922835]\n"
"  - ['CD', 10000, 1, 10000]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:246
msgid "Complications and complex SELECTs"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:250
msgid "NULLs"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:252
msgid "Insert more rows, containing NULL values."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:254
msgid "NULL is not the same as Lua nil; it commonly is used in SQL for unknown or not-applicable."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:257
msgid "INSERT INTO table2 VALUES (1, NULL, X'4142', 5.5);\n"
"INSERT INTO table2 VALUES (0, '!!@', NULL, NULL);\n"
"INSERT INTO table2 VALUES (0, '!!!', X'00', NULL);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:265
msgid "The first ``INSERT`` will fail because NULL is not permitted for a column that was defined with a ``PRIMARY KEY`` clause."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:268
msgid "The other ``INSERT`` statements will succeed."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:272
msgid "Indexes"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:274
msgid "Make a new index on column4."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:276
msgid "There already is an index for the primary key. Indexes are useful for making queries faster. In this case, the index also acts as a constraint, because it prevents two rows from having the same values in ``column4``. However, it is not an error that ``column4`` has multiple occurrences of NULLs."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:283
msgid "CREATE UNIQUE INDEX i ON table2 (column4);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:291
msgid "Create a subset table"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:293
msgid "Make a table which will have some of the columns of ``table2``, and some of the rows of ``table2``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:296
msgid "You can do this by combining ``INSERT`` with ``SELECT``. Then select everything in the resultant subset table."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:299
msgid "CREATE TABLE table3 (column1 INTEGER, column2 VARCHAR(100), PRIMARY KEY\n"
"(column2));\n"
"INSERT INTO table3 SELECT column1, column2 FROM table2 WHERE column1 <> 2;\n"
"SELECT * FROM table3;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:308
msgid "- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:318
msgid "SELECT with a subquery"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:320
msgid "A subquery is a query within a query."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:322
msgid "Here we find all the rows in ``table2`` whose ``(column1, column2)`` values are not in ``table3``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:325
msgid "SELECT * FROM table2 WHERE (column1, column2) NOT IN (SELECT column1,\n"
"column2 FROM table3);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:330
msgid "The result is, unsurprisingly, the single row which we deliberately excluded when we inserted the rows in the ``INSERT ... SELECT`` statement:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:334
msgid "- - [2, 'AB', '  ', 12.34567]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:340
msgid "SELECT with a join"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:342
msgid "A join is a combination of two tables. There is more than one way to do them in Tarantool: \"Cartesian joins\", \"left outer joins\", etc."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:346
msgid "Here we're just showing the most typical case, where column values from one table match column values from another table."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:350
msgid "SELECT * FROM table2, table3\n"
"    WHERE table2.column1 = table3.column1 AND table2.column2 = table3.column2\n"
"    ORDER BY table2.column4;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:358
msgid "- - [0, '!!!', \"\\0\", null, 0, '!!!']\n"
"  - [0, '!!@', null, null, 0, '!!@']\n"
"  - [-1000, '', '', 0, -1000, '']\n"
"  - [1, 'AB', 'AB', 5.5, 1, 'AB']\n"
"  - [1, 'CD', ' ', 10000, 1, 'CD']"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:370
msgid "Constraints affecting updates"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:374
msgid "CREATE TABLE, with a CHECK clause"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:376
msgid "First we make a table which includes a \"constraint\" that there must not be any rows containing 13 in ``column2``. Then we try to insert such a row."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:380
msgid "CREATE TABLE table4 (column1 INTEGER PRIMARY KEY, column2 INTEGER, CHECK\n"
"(column2 <> 13));\n"
"INSERT INTO table4 VALUES (12, 13);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:386
msgid "Result: the insert fails, as it should, with the message \"``error: 'CHECK constraint failed: TABLE4'``\"."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:391
msgid "CREATE TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:393
msgid "First we make a table which includes a \"constraint\" that there must not be any rows containing values that do not appear in ``table2``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:397
msgid "When we made ``table2``, we specified that its \"primary key\" columns were ``(column1, column2)``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:400
msgid "CREATE TABLE table5 (column1 INTEGER, column2 VARCHAR(100),\n"
"    PRIMARY KEY (column1),\n"
"    FOREIGN KEY (column1, column2) REFERENCES table2 (column1, column2));\n"
"INSERT INTO table5 VALUES (2,'AB');\n"
"INSERT INTO table5 VALUES (3,'AB');"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:408
#: ../doc/2.2/tutorials/sql_tutorial.rst:511
msgid "Result:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:410
msgid "The first ``INSERT`` statement succeeds because ``table3`` contains a row with ``[2, 'AB', ' ', 12.34567]``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:412
msgid "The second INSERT statement, correctly, fails with the message \"``error: FOREIGN KEY constraint failed``\"."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:419
msgid "Due to earlier INSERT statements, these values are in ``table2 column4``: ``{0, NULL, NULL, 5.5, 10000, 12.34567}``. We will add 5 to every one of them except the one with 0. (Adding 5 to NULL will result in NULL, as SQL arithmetic requires.) Then we'll use ``SELECT`` to see what happened to ``column4``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:425
msgid "UPDATE table2 SET column4 = column4 + 5 WHERE column4 <> 0;\n"
"SELECT column4 FROM table2 ORDER BY column4;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:430
msgid "The result is: ``{NULL, NULL, 0, 10.5, 17.34567, 10005}``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:436
msgid "Due to earlier ``INSERT`` statements, there are now 6 rows in ``table2``:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:438
msgid "- - [-1000, '', '', 0]\n"
"  - [0, '!!!', \"\\0\", null]\n"
"  - [0, '!!@', null, null]\n"
"  - [1, 'AB', 'AB', 10.5]\n"
"  - [1, 'CD', '  ', 10005]\n"
"  - [2, 'AB', '  ', 17.34567]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:447
msgid "We will try to delete the last and first of these rows."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:449
msgid "DELETE FROM table2 WHERE column1 = 2;\n"
"DELETE FROM table2 WHERE column1 = -1000;\n"
"SELECT COUNT(column1) FROM table2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:457
msgid "The first ``DELETE`` statement causes an error message because (remember?) there's a foreign-key constraint."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:459
msgid "The second ``DELETE`` statement succeeds."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:460
msgid "The ``SELECT`` statement shows that there are now only 5 rows remaining."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:464
msgid "ALTER TABLE, with a FOREIGN KEY clause"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:466
msgid "Now we want to make another \"constraint\", that there must not be any rows in ``table1`` containing values that do not appear in ``table5``. We couldn't do this when we created ``table1`` because at that time ``table5`` did not exist. But we can add constraints to existing tables with the ALTER TABLE statement."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:474
msgid "ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);\n"
"DELETE FROM table1;\n"
"ALTER TABLE table1 ADD CONSTRAINT c\n"
"    FOREIGN KEY (column1) REFERENCES table5 (column1);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:482
msgid "Result: the ``ALTER TABLE`` statement fails the first time because there is a row in ``table1``, and ADD CONSTRAINT requires that the table be empty. But after we delete that row, the ``ALTER TABLE`` statement succeeds the second time. Thus we have set up a chain of references, from ``table1`` to ``table5`` and from ``table5`` to ``table2``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:493
msgid "The idea of a trigger is: if a change (``INSERT`` or ``UPDATE`` or ``DELETE``) happens, then a further action -- perhaps another ``INSERT`` or ``UPDATE`` or ``DELETE`` -- will happen."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:497
msgid "There are many variants, the one we'll illustrate here is: just after doing an update in ``table3``, do an update in ``table2``. We will specify this as ``FOR EACH ROW``, so (since there are 5 rows in ``table3``) the trigger will be activated 5 times."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:503
msgid "SELECT column4 FROM table2 WHERE column1 = 2;\n"
"CREATE TRIGGER tr AFTER UPDATE ON table3 FOR EACH ROW\n"
"BEGIN UPDATE table2 SET column4 = column4 + 1 WHERE column1 = 2; END;\n"
"UPDATE table3 SET column2 = column2;\n"
"SELECT column4 FROM table2 WHERE column1 = 2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:513
msgid "The first ``SELECT`` shows that the original value of ``column4`` in ``table2`` where ``column1 = 2`` was: 17.34567."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:515
msgid "The second ``SELECT`` returns:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:517
msgid "- - [22.34567]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:525
msgid "Operators and functions"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:529
msgid "String operations"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:531
msgid "You can manipulate string data (usually defined with CHAR or VARCHAR data types) in many ways."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:534
#: ../doc/2.2/tutorials/sql_tutorial.rst:561
msgid "We'll illustrate here:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:536
msgid "the ``||`` operator for concatenation and"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:537
msgid "the ``SUBSTR`` function for extraction."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:539
msgid "SELECT column2, column2 || column2, SUBSTR(column2, 2, 1) FROM table2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:545
msgid "- - ['!!!', '!!!!!!', '!']\n"
"  - ['!!@', '!!@!!@', '!']\n"
"  - ['AB', 'ABAB', 'B']\n"
"  - ['CD', 'CDCD', 'D']\n"
"  - ['AB', 'ABAB', 'B']"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:556
msgid "Number operations"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:558
msgid "You can also manipulate number data (usually defined with INTEGER or FLOAT data types) in many ways."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:563
msgid "the ``<<`` operator for shift left and"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:564
msgid "the ``%`` operator for modulo."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:566
msgid "SELECT column1, column1 << 1, column1 << 2, column1 % 2 FROM table2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:572
msgid "- - [0, 0, 0, 0]\n"
"  - [0, 0, 0, 0]\n"
"  - [1, 2, 4, 1]\n"
"  - [1, 2, 4, 1]\n"
"  - [2, 4, 8, 0]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:582
msgid "Ranges and limits"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:584
msgid "Tarantool can handle:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:586
msgid "integers anywhere in the 4-byte integer range,"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:587
msgid "approximate-numerics anywhere in the 8-byte IEEE floating point range,"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:588
msgid "any Unicode characters, with UTF-8 encoding and a choice of collations."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:590
msgid "Here we will insert some such values in a new table, and see what happens when we select them, with arithmetic on a number column and ordering by a string column."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:594
msgid "CREATE TABLE t6 (column1 INTEGER, column2 VARCHAR(10), column4 FLOAT,\n"
"PRIMARY KEY (column1));\n"
"INSERT INTO t6 VALUES (-1234567890, 'АБВГД', 123456.123456);\n"
"INSERT INTO t6 VALUES (+1234567890, 'GD', 1e30);\n"
"INSERT INTO t6 VALUES (10, 'FADEW?', 0.000001);\n"
"INSERT INTO t6 VALUES (5, 'ABCDEFG', NULL);\n"
"SELECT column1 + 1, column2, column4 * 2 FROM t6 ORDER BY column2;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:604
#: ../doc/2.2/tutorials/sql_tutorial.rst:630
#: ../doc/2.2/tutorials/sql_tutorial.rst:815
msgid "The result is:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:606
msgid "- - [6, 'ABCDEFG', null]\n"
"  - [11, 'FADEW?', 2e-06]\n"
"  - [1234567891, 'GD', 2e+30]\n"
"  - [-1234567889, 'АБВГД', 246912.246912]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:615
msgid "Views"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:617
msgid "A view, or \"viewed table\", is virtual, that is, its rows aren't physically in the database, their values are calculated from other tables."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:621
msgid "Here we'll create a view ``v3`` based on ``table3``, then we select from it."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:624
msgid "CREATE VIEW v3 AS SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE\n"
"column4 >= 0;\n"
"SELECT * FROM v3;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:632
#: ../doc/2.2/tutorials/sql_tutorial.rst:657
msgid "- - ['АБ', 123456.123456]\n"
"  - ['FA', 1e-06]\n"
"  - ['GD', 1e+30]"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:640
msgid "Common table expressions"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:642
msgid "By putting ``WITH`` + ``SELECT`` in front of a ``SELECT``, we can make a sort of temporary view that lasts for the duration of the statement."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:646
msgid "Here we'll select from the sort of temporary view."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:648
msgid "WITH cte AS (\n"
"             SELECT SUBSTR(column2,1,2), column4 FROM t6 WHERE column4\n"
"             >= 0)\n"
"SELECT * FROM cte;"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:655
msgid "Result: the same as the result we got with ``CREATE VIEW`` earlier:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:667
msgid "Tarantool can handle statements like ``SELECT 55;`` (select without ``FROM``) like some other popular DBMSs. But it also handles the more standard statement ``VALUES (expression [, expression ...]);``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:672
msgid "Here we'll use both styles."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:674
msgid "SELECT 55 * 55, 'The rain in Spain';\n"
"VALUES (55 * 55, 'The rain in Spain');"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:679
msgid "The result of either statement will be:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:681
msgid "- - [3025, 'The rain in Spain']"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:687
msgid "Metadata"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:689
msgid "What database objects have we created? We can find out about:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:691
msgid "tables with ``SELECT * FROM \"_space\";``"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:692
msgid "indexes with ``SELECT * FROM \"_index\";``"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:693
msgid "triggers with ``SELECT * FROM \"_trigger\";`` (These names will be familiar to old Tarantool users because we're actually selecting from NoSQL \"system spaces\".)"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:697
msgid "Here we will select from ``_space``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:699
msgid "SELECT \"id\", \"name\", \"owner\", \"engine\" FROM \"_space\" WHERE \"name\"='TABLE3';"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:703
msgid "The result is (we know we will get a row because we created ``table3`` earlier):"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:705
msgid "- - [517, 'table3', 1, 'memtx']"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:713
msgid "Calling from a host language to make a big table"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:717
msgid "box.execute()"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:719
msgid "Now we will change the settings so that the console accepts statements written in Lua instead of statements written in SQL. (More ways to switch languages will exist in Tarantool clients in our next version.)"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:724
msgid "This doesn't mean we have left the SQL world though, because we can invoke SQL statements using a Lua function: ``box.execute(string)``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:728
msgid "Here we'll switch languages, and ask to select again what's in ``table3``. These statements must be entered separately."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:732
msgid "tarantool> \\set language lua\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:737
msgid "Showing both the statements and the results:"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:739
msgid "tarantool> \\set language lua\n"
"---\n"
"...\n"
"tarantool> box.execute([[SELECT * FROM table3;]]);\n"
"---\n"
"- - [-1000, '']\n"
"  - [0, '!!!']\n"
"  - [0, '!!@']\n"
"  - [1, 'AB']\n"
"  - [1, 'CD']\n"
"..."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:755
msgid "Create a million-row table"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:757
msgid "We've illustrated a lot of SQL, but does it scale? To answer that, let's make a bigger table."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:760
msgid "For this we are going to use Lua. We will not explain the Lua, because that's in the Lua section of the Tarantool manual. Just copy-and-paste these instructions and wait for about a minute."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:765
msgid "box.execute(\"CREATE TABLE tester (s1 INT PRIMARY KEY, s2 VARCHAR(10))\");\n"
"\n"
"function string_function()\n"
"   local random_number\n"
"   local random_string\n"
"   random_string = \"\"\n"
"   for x = 1,10,1 do\n"
"     random_number = math.random(65, 90)\n"
"     random_string = random_string .. string.char(random_number)\n"
"   end\n"
"   return random_string\n"
"end;\n"
"\n"
"function main_function()\n"
"   local string_value, t, sql_statement\n"
"   for i = 1,1000000,1 do\n"
"     string_value = string_function()\n"
"     sql_statement = \"INSERT INTO tester VALUES (\" .. i .. \",'\" .. string_value .. \"')\"\n"
"     box.execute(sql_statement)\n"
"   end\n"
"end;\n"
"start_time = os.clock();\n"
"main_function();\n"
"end_time = os.clock();\n"
"'insert done in ' .. end_time - start_time .. ' seconds';"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:793
msgid "The result is: you now have a table with a million rows, with a message saying \"``insert done in 88.570578 seconds``\"."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:798
msgid "Select from a million-row table"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:800
msgid "Now that we have something a bit larger to play with, let's see how long it takes to SELECT."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:803
msgid "The first query we'll do will automatically go via an index, because ``s1`` is the primary key."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:806
msgid "The second query we'll do will not go via an index, because for ``s2`` we didn't say ``CREATE INDEX xxxx ON tester (s2);``."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:810
msgid "box.execute([[SELECT * FROM tester WHERE s1 = 73446;]]);\n"
"box.execute([[SELECT * FROM tester WHERE s2 LIKE 'QFML%';]]);"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:817
msgid "the first statement will finish instantaneously,"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:818
msgid "the second statement will be noticeably slower but still a fraction of a second."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:823
msgid "Cleanup and exit"
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:825
msgid "We're done. We've shown that Tarantool 2.1 has a very reasonable subset of SQL, and it works."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:828
msgid "The rest of these commands will simply destroy all the database objects that were created so that you can do the demonstration again. These statements must be entered separately."
msgstr ""

#: ../doc/2.2/tutorials/sql_tutorial.rst:833
msgid "tarantool> \\set language sql\n"
"tarantool> DROP TABLE tester;\n"
"tarantool> DROP TABLE table1;\n"
"tarantool> DROP VIEW v3;\n"
"tarantool> DROP TRIGGER tr;\n"
"tarantool> DROP TABLE table5;\n"
"tarantool> DROP TABLE table4;\n"
"tarantool> DROP TABLE table3;\n"
"tarantool> DROP TABLE table2;\n"
"tarantool> DROP TABLE t6;\n"
"tarantool> \\set language lua\n"
"tarantool> os.exit();"
msgstr ""

#: ../doc/2.2/whats_new.rst:39
msgid "Release Notes"
msgstr ""

#: ../doc/2.2/whats_new.rst:41
msgid "The Release Notes are summaries of significant changes introduced in Tarantool :ref:`2.2.1 <whats_new_221>`, :ref:`2.1.2 <whats_new_212>`, :ref:`2.1.1 <whats_new_211>`, :ref:`2.0.4 <whats_new_204>`, :ref:`1.10.3 <whats_new_1103>`, :ref:`1.10.2 <whats_new_1102>`, :ref:`1.9.0 <whats_new_190>`, :ref:`1.8.1 <whats_new_181>`, :ref:`1.7.6 <whats_new_176>`, :ref:`1.7.5 <whats_new_175>`, :ref:`1.7.4 <whats_new_174>`, :ref:`1.7.3 <whats_new_173>`, :ref:`1.7.2 <whats_new_172>`, :ref:`1.7.1 <whats_new_171>`, :ref:`1.6.9 <whats_new_169>`, :ref:`1.6.8 <whats_new_168>`, and :ref:`1.6.6 <whats_new_166>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:60
msgid "For smaller feature changes and bug fixes, see closed `milestones <https://github.com/tarantool/tarantool/milestones?state=closed>`_ at GitHub."
msgstr ""

#: ../doc/2.2/whats_new.rst:68
msgid "Version 2.x"
msgstr ""

#: ../doc/2.2/whats_new.rst:70
msgid "Tarantool 2.x is backward compatible with Tarantool 1.10.x in binary data layout, client-server protocol and replication protocol. You can :ref:`upgrade <admin-upgrades>` using the ``box.schema.upgrade()`` procedure."
msgstr ""

#: ../doc/2.2/whats_new.rst:77
msgid "**Release 2.2.1**"
msgstr ""

#: ../doc/2.2/whats_new.rst:79
msgid "Release type: beta. Release date: 2019-08-02."
msgstr ""

#: ../doc/2.2/whats_new.rst:81
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/2.2.1."
msgstr ""

#: ../doc/2.2/whats_new.rst:83
msgid "This is a :ref:`beta <release-policy>` version of the 2.2 series. The label \"beta\" means we have no critical issues and all planned features are there."
msgstr ""

#: ../doc/2.2/whats_new.rst:86
msgid "The goal of this release is to introduce new indexing features, extend SQL feature set, and improve integration with the core."
msgstr ""

#: ../doc/2.2/whats_new.rst:89
#: ../doc/2.2/whats_new.rst:369
#: ../doc/2.2/whats_new.rst:526
#: ../doc/2.2/whats_new.rst:709
#: ../doc/2.2/whats_new.rst:804
#: ../doc/2.2/whats_new.rst:920
#: ../doc/2.2/whats_new.rst:1032
#: ../doc/2.2/whats_new.rst:1114
#: ../doc/2.2/whats_new.rst:1308
#: ../doc/2.2/whats_new.rst:1464
#: ../doc/2.2/whats_new.rst:1524
#: ../doc/2.2/whats_new.rst:1643
#: ../doc/2.2/whats_new.rst:1703
#: ../doc/2.2/whats_new.rst:1765
#: ../doc/2.2/whats_new.rst:1863
#: ../doc/2.2/whats_new.rst:1903
msgid "Functionality added or changed:"
msgstr ""

#: ../doc/2.2/whats_new.rst:91
msgid "(SQL) ALTER now allows to add a constraint:"
msgstr ""

#: ../doc/2.2/whats_new.rst:93
msgid "CREATE TABLE t2 (id INT PRIMARY KEY);\n"
"ALTER TABLE t2 ADD CONSTRAINT ck CHECK(id  > 0);"
msgstr ""

#: ../doc/2.2/whats_new.rst:98
msgid "(SQL) CHECK constraints are validated during DML operations performed from the Lua land:"
msgstr ""

#: ../doc/2.2/whats_new.rst:101
msgid "s = box.schema.space.create('withdata')\n"
"pk = s:create_index('pk')\n"
"s:format({{'idx', 'number'}})\n"
"s:create_check_constraint('le10', '\"idx\" < 10')"
msgstr ""

#: ../doc/2.2/whats_new.rst:108
msgid "tarantool> s:insert({11})\n"
"---\n"
"- error: 'Check constraint failed ''le10'': \"idx\" < 10'\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:115
msgid "(SQL) New :ref:`SQL types <sql_column_def_data_type>` introduced: VARBINARY, UNSIGNED, and `BOOLEAN`."
msgstr ""

#: ../doc/2.2/whats_new.rst:118
msgid "(SQL) CREATE TABLE statement (and all other data definition statements) are now truly transactional."
msgstr ""

#: ../doc/2.2/whats_new.rst:121
msgid "(SQL) SQL now uses Tarantool diagnostics API to set errors, so error reporting now provides an error code in addition to error message."
msgstr ""

#: ../doc/2.2/whats_new.rst:124
msgid "(SQL) Multiple improvements to the type system to make it more consistent."
msgstr ""

#: ../doc/2.2/whats_new.rst:126
msgid "(SQL) Added aliases for LENGTH() from ANSI SQL: CHAR_LENGTH() and CHARACTER_LENGTH()."
msgstr ""

#: ../doc/2.2/whats_new.rst:129
msgid "(SQL) It is possible to use HAVING without GROUP BY."
msgstr ""

#: ../doc/2.2/whats_new.rst:131
msgid "(Server) New fixed point type (DECIMAL) introduced to Tarantool:"
msgstr ""

#: ../doc/2.2/whats_new.rst:133
msgid "decimal = require('decimal')\n"
"tarantool> a = decimal.new('123.456789')\n"
"---\n"
"...\n"
"tarantool> decimal.precision(a)\n"
"---\n"
"- 9\n"
"...\n"
"tarantool> decimal.scale(a)\n"
"---\n"
"- 6\n"
"...\n"
"tarantool> decimal.round(a, 4)\n"
"---\n"
"- '123.4568'\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:152
msgid "(Server) Multikey index support:"
msgstr ""

#: ../doc/2.2/whats_new.rst:154
msgid "-- Multikey indexes (for memtx tree & vinyl);\n"
"-- cannot be primary; may be non-unique\n"
"s = box.schema.space.create('clients', {engine = 'vinyl'})\n"
"pk = s:create_index('pk')\n"
"phone_type = s:create_index('phone_type', {\n"
"    unique = false,\n"
"    parts = {{'[3][*].type', 'str'}}})\n"
"\n"
"s:insert({1, 'James',\n"
"         {{type = 'home', number = '999'},\n"
"          {type = 'work', number = '777'}\n"
"         }})\n"
"s:insert({2, 'Bob',\n"
"          {{type = 'work', number = '888'}}})\n"
"s:insert({3, 'Alice', {{type = 'home', number = '333'}}})"
msgstr ""

#: ../doc/2.2/whats_new.rst:172
msgid "tarantool> phone_type:select('work')\n"
"---\n"
"- - [1, 'James', [{'type': 'home', 'number': '999'},\n"
"                  {'type': 'work', 'number': '777'}]]\n"
"  - [2, 'Bob', [{'type': 'work', 'number': '888'}]]\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:181
msgid "(Server) Now it is possible to make functions persistent:"
msgstr ""

#: ../doc/2.2/whats_new.rst:183
msgid "box.schema.func.create('summarize',\n"
"                      {body = [[function(a,b) return a+b end]],\n"
"                      is_deterministic = true})"
msgstr ""

#: ../doc/2.2/whats_new.rst:189
msgid "tarantool> box.func.summarize\n"
"- aggregate: none\n"
"  returns: any\n"
"  exports:\n"
"    lua: true\n"
"    sql: false\n"
"  id: 66\n"
"  is_sandboxed: false\n"
"  setuid: false\n"
"  is_multikey: false\n"
"  is_deterministic: true\n"
"  body: function(a,b) return a+b end\n"
"  name: summarize\n"
"  language: LUA\n"
"\n"
"tarantool> box.func.summarize:call({1, 2})\n"
"---\n"
"- 3\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:211
msgid "(Server) Functional indexes implemented:"
msgstr ""

#: ../doc/2.2/whats_new.rst:213
msgid "-- Functional multikey indexes: define is_multikey = true\n"
"-- in function definition and return a table of keys from function\n"
"lua_code = [[function(tuple)\n"
"                local address = string.split(tuple[2])\n"
"                local ret = {}\n"
"                for _, v in pairs(address) do table.insert(ret, {utf8.upper(v)}) end\n"
"                return ret\n"
"             end]]\n"
"box.schema.func.create('addr_extractor', {body = lua_code,\n"
"                                          is_deterministic = true,\n"
"                                          is_sandboxed = true,\n"
"                                          opts = {is_multikey = true}})\n"
"s = box.schema.space.create('withdata')\n"
"pk = s:create_index('name', {parts = {1, 'string'}})\n"
"idx = s:create_index('addr', {unique = false, func = box.func.addr_extractor.id, parts = {{1, 'string', collation = 'unicode_ci'}}})\n"
"\n"
"s:insert({\"James\", \"SIS Building Lambeth London UK\"})\n"
"s:insert({\"Sherlock\", \"221B Baker St Marylebone London NW1 6XE UK\"})"
msgstr ""

#: ../doc/2.2/whats_new.rst:234
msgid "tarantool>  idx:select('Sis')\n"
"---\n"
"- - ['James', 'SIS Building Lambeth London UK']\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:241
msgid "Partial core dumps, which are now on by default. It is now possible to avoid dumping tuples at all during core dump."
msgstr ""

#: ../doc/2.2/whats_new.rst:244
msgid "Data definition statements, such as create or alter index, which do not yield, can now be used in a transaction. This in practice includes all statements except creating an index on a non-empty space, or changing a format on a non-empty space."
msgstr ""

#: ../doc/2.2/whats_new.rst:249
msgid "It is now possible to set a sequence not only for the first part of the index:"
msgstr ""

#: ../doc/2.2/whats_new.rst:251
msgid "s.index.pk:alter{sequence = {field = 2}}"
msgstr ""

#: ../doc/2.2/whats_new.rst:255
msgid "Allow to call ``box.session.exists()`` and ``box.session.fd()`` without any arguments."
msgstr ""

#: ../doc/2.2/whats_new.rst:258
msgid "New function introduced to get an index key from a tuple:"
msgstr ""

#: ../doc/2.2/whats_new.rst:260
msgid "s = box.schema.space.create('withdata')\n"
"pk = s:create_index('pk')\n"
"sk = s:create_index('sk', {parts = {\n"
"      {2, 'number', path = 'a'},\n"
"      {2, 'number', path = 'b'}}})\n"
"s:insert{1, {a = 1, b = 1}}\n"
"s:insert{2, {a = 1, b = 2}}\n"
"s:insert{3, {a = 3, b = 3}}\n"
"sk:select(2)\n"
"\n"
"key_def_lib = require('key_def')\n"
"key_def = key_def_lib.new(pk.parts)\n"
"for _, tuple in sk:pairs({1}) do\n"
"    local key = key_def:extract_key(tuple)\n"
"    pk:delete(key)\n"
"end\n"
"s:select()"
msgstr ""

#: ../doc/2.2/whats_new.rst:280
msgid "(Engines) New protocol (called :ref:`SWIM <swim-module>`) implemented to keep a table of cluster members."
msgstr ""

#: ../doc/2.2/whats_new.rst:283
msgid "(Engines) Removed yields from Vinyl DDL on commit triggers."
msgstr ""

#: ../doc/2.2/whats_new.rst:285
msgid "(Engines) Improved performance of SELECT-s on memtx spaces. The drawback is that now every memtx-tree tuple consumes extra 8 bytes for a search hint."
msgstr ""

#: ../doc/2.2/whats_new.rst:289
msgid "(Engines) Indexes of memtx spaces are now built in background fibers. This means that we do not block the event loop during index build anymore."
msgstr ""

#: ../doc/2.2/whats_new.rst:292
msgid "Replication applier now can apply transactions which were concurrent on the master concurrently on replica. This dramatically improves replication peak performance, from ~50K writes per second to 200K writes per second and higher on a single instance."
msgstr ""

#: ../doc/2.2/whats_new.rst:297
msgid "Transaction boundaries introduced to replication protocol. This means that Tarantool replication is now transaction-safe, and also reduces load on replica write ahead log in case the master uses a lot of multi-statement transactions."
msgstr ""

#: ../doc/2.2/whats_new.rst:302
msgid "Tuple access by field name for ``net.box``:"
msgstr ""

#: ../doc/2.2/whats_new.rst:304
msgid "box.cfg{listen = 3302}\n"
"box.schema.user.grant('guest','read, write, execute', 'space')\n"
"box.schema.user.grant('guest', 'create', 'space')\n"
"box.schema.create_space(\"named\", {format = {{name = \"id\"}}})\n"
"box.space.named:create_index('id', {parts = {{1, 'unsigned'}}})\n"
"box.space.named:insert({1})\n"
"\n"
"require('net.box').connect('localhost', 3302).space.named:get(1).id"
msgstr ""

#: ../doc/2.2/whats_new.rst:315
msgid "Cluster id check is now the slave’s responsibility."
msgstr ""

#: ../doc/2.2/whats_new.rst:317
msgid "It is now possible to set the output format to Lua instead of YAML in the :ref:`interactive console <interactive_console>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:320
msgid "Multiple new collations added. New collations follow this naming pattern:"
msgstr ""

#: ../doc/2.2/whats_new.rst:323
msgid "unicode_<locale>_<strength>"
msgstr ""

#: ../doc/2.2/whats_new.rst:327
msgid "Three strengths are used:"
msgstr ""

#: ../doc/2.2/whats_new.rst:329
msgid "Primary - \"s1”"
msgstr ""

#: ../doc/2.2/whats_new.rst:330
msgid "Secondary - \"s2\""
msgstr ""

#: ../doc/2.2/whats_new.rst:331
msgid "Tertiary - \"s3\""
msgstr ""

#: ../doc/2.2/whats_new.rst:333
msgid "The following list contains so-called \"stable\" collations - the ones whose sort order doesn't depend on the ICU version:"
msgstr ""

#: ../doc/2.2/whats_new.rst:336
msgid "unicode_am_s3\n"
"unicode_fi_s3\n"
"unicode_de__phonebook_s3\n"
"unicode_haw_s3\n"
"unicode_he_s3\n"
"unicode_hi_s3\n"
"unicode_is_s3\n"
"unicode_ja_s3\n"
"unicode_ko_s3\n"
"unicode_lt_s3\n"
"unicode_pl_s3\n"
"unicode_si_s3\n"
"unicode_es_s3"
msgstr ""

#: ../doc/2.2/whats_new.rst:352
msgid "New function ``utime()`` introduced to the ``fio`` module."
msgstr ""

#: ../doc/2.2/whats_new.rst:354
msgid ":ref:`Merger <merger-module>` for tuples streams added."
msgstr ""

#: ../doc/2.2/whats_new.rst:358
msgid "**Release 2.1.2**"
msgstr ""

#: ../doc/2.2/whats_new.rst:360
msgid "Release type: stable. Release date: 2019-04-05."
msgstr ""

#: ../doc/2.2/whats_new.rst:362
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/2.1.2."
msgstr ""

#: ../doc/2.2/whats_new.rst:364
msgid "This is the first :ref:`stable <release-policy>` release in the 2.x series."
msgstr ""

#: ../doc/2.2/whats_new.rst:366
msgid "The goal of this release is to significantly extend SQL support and increase stability."
msgstr ""

#: ../doc/2.2/whats_new.rst:371
msgid "(SQL) ``box.sql.execute()`` replaced with :ref:`box.execute() <box-sql_box_execute>`. It now works just like ``netbox.execute()``: returns result set metadata, row count, etc. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:376
msgid "box.execute(\"CREATE TABLE person(id INTEGER PRIMARY KEY, birth_year INT)\")\n"
"---\n"
"- row_count: 1\n"
"...\n"
"box.execute(\"SELECT birth_year FROM person\")\n"
"---\n"
"- metadata:\n"
"  - name: birth_year\n"
"    type: INTEGER\n"
"  rows:\n"
"  - [1983]\n"
"  - [1984]\n"
"..."
msgstr ""

#: ../doc/2.2/whats_new.rst:392
msgid "(SQL) Type system was :ref:`significantly refactored <sql>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:394
msgid "(SQL) There are cases in SQL when it is possible to do Tarantool’s update operation for UPDATE statement, instead of doing delete + insert. However, there are cases where SQL semantics is too complex. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:398
msgid "CREATE TABLE file (id INT PRIMARY KEY, checksum INT);\n"
"INSERT INTO stock VALUES (1, 3),(2, 4),(3,5);\n"
"CREATE UNIQUE INDEX i ON file (checksum);\n"
"SELECT * FROM file;\n"
"-- [1, 3], [2, 4], [3, 5]\n"
"UPDATE OR REPLACE file SET checksum = checksum + 1;\n"
"SELECT * FROM stock;\n"
"-- [1, 4], [3, 6]"
msgstr ""

#: ../doc/2.2/whats_new.rst:409
msgid "I.e. [1, 3] tuple is updated as [1, 4] and have replaced tuple [2, 4]. This logic is implemented by preventive tuple deletion from all corresponding indexes in SQL."
msgstr ""

#: ../doc/2.2/whats_new.rst:413
msgid "(SQL) Now SQL’s integer type is stored as integer in space’s format. It was stored as scalar before, which made comarisons slow."
msgstr ""

#: ../doc/2.2/whats_new.rst:416
msgid "(SQL) It is now possible to define a constraint :ref:`within column definition <sql_create_table>`. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:419
msgid "CREATE TABLE person (id INT PRIMARY KEY, age INT, CHECK (age > 10));"
msgstr ""

#: ../doc/2.2/whats_new.rst:423
msgid "(SQL) Syntax for the pragma ``pragma index_info`` is now unified with ``table_info``. E.g. to get information on index ``age_index`` of table ``person`` you can write:"
msgstr ""

#: ../doc/2.2/whats_new.rst:427
msgid "pragma index_info(person.age_index);"
msgstr ""

#: ../doc/2.2/whats_new.rst:431
msgid "(Server) It is now possible to index a field specified using JSON. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:433
msgid "person = box.schema.create_space(\"person\")\n"
"name_idx = person:create_index('name', {parts = {{'[2]fname', 'str'}, {'[2]sname', 'str'}}})\n"
"person:insert({1, {fname='James', sname='Bond'}, {town='London', country='GB', organization='MI6'}})"
msgstr ""

#: ../doc/2.2/whats_new.rst:439
msgid "(Server) In case of out of space event, Tarantool is now allowed to delete backup WAL files not needed for recovery from the last checkpoint."
msgstr ""

#: ../doc/2.2/whats_new.rst:442
msgid "(Server) Add support for :ref:`tarantoolctl rocks pack / unpack <tarantoolctl-module_management>` subcommands. The subcommands are used to create / deploy binary rock distributions."
msgstr ""

#: ../doc/2.2/whats_new.rst:445
msgid "(Server) ``string.rstrip`` and ``string.lstrip`` should accept symbols to strip. Add optional 'chars' parameter for specifying the unwanted characters. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:448
msgid "local chars = \"#\\0\"\n"
"str = \"##Hello world!#\"\n"
"print(string.strip(str, chars)) -- \"Hello world!\""
msgstr ""

#: ../doc/2.2/whats_new.rst:454
msgid "(Server) :ref:`on_shutdown <box_ctl-on_shutdown>` trigger added. It may be set in a way similar to ``space:on_replace`` triggers:"
msgstr ""

#: ../doc/2.2/whats_new.rst:457
msgid "box.ctl.on_shutdown(new_trigger, old_trigger)"
msgstr ""

#: ../doc/2.2/whats_new.rst:461
msgid "(Server) :ref:`on_schema_init <box_ctl-on_schema_init>` trigger added. It may be set before the first call to ``box.cfg()`` and is fired during ``box.cfg()`` before user data recovery start. To set the trigger, say:"
msgstr ""

#: ../doc/2.2/whats_new.rst:465
msgid "box.ctl.on_schema_init(new_trig, old_trig)"
msgstr ""

#: ../doc/2.2/whats_new.rst:469
msgid "(Server) A new option for the snapshot daemon, :ref:`box.cfg.checkpoint_wal_threshold <cfg_checkpoint_daemon-checkpoint_wal_threshold>`, allows to limit the maximum disk size of maintained WALs. Once the configured threshold is exceeded, the WAL thread notifies the checkpoint daemon that it's time to make a new checkpoint and delete old WAL files."
msgstr ""

#: ../doc/2.2/whats_new.rst:475
msgid "(Server) New types of :ref:`privileges <authentication-owners_privileges>` -- to create, alter and drop space -- were introduced. In order to create, drop or alter space or index, you should have a corresponding privilege. E.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:480
msgid "box.schema.user.create(\"optimizer\", { password  = 'secret' })\n"
"box.schema.user.grant(\"optimizer\", \"alter\", \"space\")\n"
"person = box.schema.space.create(\"person\")\n"
"box.session.su(\"optimizer\")\n"
"i = s:create_index(\"primary\") -- success\n"
"s:insert{1} -- fail\n"
"s:select{} -- fail\n"
"s:drop() -- fail"
msgstr ""

#: ../doc/2.2/whats_new.rst:491
msgid "Notice the incompatible change: Tarantool 1.10 requires read/write/execute privileges on an object to allow create, drop or alter. These privileges are no longer sufficient in 2.1. To remedy the problem, Tarantool 2.1 automatically grants create/drop/alter privileges on an object if a user has read/write/execute privileges on it during schema upgrade. But old scripts may stop working if read/write/execute is granted **after** schema upgrade."
msgstr ""

#: ../doc/2.2/whats_new.rst:499
msgid "Additionally, create/drop/alter privileges are already supported in 1.10, which also supports the old semantics of read/write/execute. You are encouraged to grant new privileges in 1.10 before upgrade and modify your scripts."
msgstr ""

#: ../doc/2.2/whats_new.rst:506
msgid "**Release 2.1.1**"
msgstr ""

#: ../doc/2.2/whats_new.rst:508
msgid "Release type: beta. Release date: 2018-11-14."
msgstr ""

#: ../doc/2.2/whats_new.rst:510
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/2.1.1."
msgstr ""

#: ../doc/2.2/whats_new.rst:512
msgid "This release resolves all major bugs since 2.0.4 alpha and extends Tarantool's SQL feature set."
msgstr ""

#: ../doc/2.2/whats_new.rst:517
msgid "**Release 2.0.4**"
msgstr ""

#: ../doc/2.2/whats_new.rst:519
msgid "Release type: alpha. Release date: 2018-02-15."
msgstr ""

#: ../doc/2.2/whats_new.rst:521
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/2.0.4."
msgstr ""

#: ../doc/2.2/whats_new.rst:523
msgid "This is a successor of the 1.8.x releases. It improves the overall stability of the SQL engine and has some new features."
msgstr ""

#: ../doc/2.2/whats_new.rst:528
msgid "Added support for SQL collations by incorporating libICU character set and collation library."
msgstr ""

#: ../doc/2.2/whats_new.rst:530
msgid "IPROTO interface was extended to support SQL queries."
msgstr ""

#: ../doc/2.2/whats_new.rst:531
msgid "``net.box`` subsystem was extended to support SQL queries."
msgstr ""

#: ../doc/2.2/whats_new.rst:532
msgid "Enabled ``ANALYZE`` statement to produce correct results, necessary for efficient query plans."
msgstr ""

#: ../doc/2.2/whats_new.rst:534
msgid "Enabled savepoints functionality. ``SAVEPOINT`` statement works w/o issues."
msgstr ""

#: ../doc/2.2/whats_new.rst:535
msgid "Enabled ``ALTER TABLE ... RENAME`` statement."
msgstr ""

#: ../doc/2.2/whats_new.rst:536
msgid "Improved rules for identifier names: now fully consistent with Lua frontend."
msgstr ""

#: ../doc/2.2/whats_new.rst:537
msgid "Enabled support for triggers; trigger bodies now persist in Tarantool snapshots and survive server restart."
msgstr ""

#: ../doc/2.2/whats_new.rst:539
msgid "Significant performance improvements."
msgstr ""

#: ../doc/2.2/whats_new.rst:545
msgid "Version 1.10"
msgstr ""

#: ../doc/2.2/whats_new.rst:549
msgid "**Release 1.10.3**"
msgstr ""

#: ../doc/2.2/whats_new.rst:551
msgid "Release type: stable (lts). Release date: 2019-04-01.  Tag: 1-10-3."
msgstr ""

#: ../doc/2.2/whats_new.rst:553
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.10.3."
msgstr ""

#: ../doc/2.2/whats_new.rst:557
msgid "1.10.3 is the next :ref:`stable (lts) <release-policy>` release in the 1.10 series. The label 'stable' means we have had systems running in production without known crashes, bad results or other showstopper bugs for quite a while now."
msgstr ""

#: ../doc/2.2/whats_new.rst:561
msgid "This release resolves 69 issues since 1.10.2. There may be bugs in less common areas, please feel free to file an issue at GitHub. Compatibility"
msgstr ""

#: ../doc/2.2/whats_new.rst:565
msgid "Tarantool 1.10.x is backward compatible with Tarantool 1.9.x in binary data layout, client-server protocol and replication protocol. Please :ref:`upgrade <admin-upgrades>` using the ``box.schema.upgrade()`` procedure to unlock all the new features of the 1.10.x series when migrating from 1.9 version."
msgstr ""

#: ../doc/2.2/whats_new.rst:568
msgid "Functionality added or changed"
msgstr ""

#: ../doc/2.2/whats_new.rst:570
msgid "(Engines) Randomize vinyl index compaction Issue `3944 <https://github.com/tarantool/tarantool/issues/3944>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:572
msgid "(Engines) Throttle tx thread if compaction doesn't keep up with dumps Issue `3721 <https://github.com/tarantool/tarantool/issues/3721>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:574
msgid "(Engines) Do not apply run_count_per_level to the last level Issue `3657 <https://github.com/tarantool/tarantool/issues/3657>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:576
msgid "(Server) Report the number of active iproto connections Issue `3905 <https://github.com/tarantool/tarantool/issues/3905>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:578
msgid "(Replication) Never keep a dead replica around if running out of disk space Issue `3397 <https://github.com/tarantool/tarantool/issues/3397>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:580
msgid "(Replication) Report join progress to the replica log Issue `3165 <https://github.com/tarantool/tarantool/issues/3165>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:582
msgid "(Lua) Expose snapshot status in box.info.gc() Issue `3935 <https://github.com/tarantool/tarantool/issues/3935>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:584
msgid "(Lua) Show names of Lua functions in backtraces in fiber.info() Issue `3538 <https://github.com/tarantool/tarantool/issues/3538>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:586
msgid "(Lua) Check if transaction opened Issue `3518 <https://github.com/tarantool/tarantool/issues/3518>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:589
msgid "Bugs fixed"
msgstr ""

#: ../doc/2.2/whats_new.rst:591
msgid "(Engines) Tarantool crashes if DML races with DDL Issue `3420 <https://github.com/tarantool/tarantool/issues/3420>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:593
msgid "(Engines) Recovery error if DDL is aborted Issue `4066 <https://github.com/tarantool/tarantool/issues/4066>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:595
msgid "(Engines) Tarantool could commit in the read-only mode Issue `4016 <https://github.com/tarantool/tarantool/issues/4016>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:597
msgid "(Engines) Vinyl iterator crashes if used throughout DDL Issue `4000 <https://github.com/tarantool/tarantool/issues/4000>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:599
msgid "(Engines) Vinyl doesn't exit until dump/compaction is complete Issue `3949 <https://github.com/tarantool/tarantool/issues/3949>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:601
msgid "(Engines) After re-creating secondary index no data is visible Issue `3903 <https://github.com/tarantool/tarantool/issues/3903>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:603
msgid "(Engines) box.info.memory().tx underflow Issue `3897 <https://github.com/tarantool/tarantool/issues/3897>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:605
msgid "(Engines) Vinyl stalls on intensive random insertion Issue `3603 <https://github.com/tarantool/tarantool/issues/3603>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:607
msgid "(Server) Newer version of libcurl explodes fiber stack Issue `3569 <https://github.com/tarantool/tarantool/issues/3569>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:609
msgid "(Server) SIGHUP crashes tarantool Issue `4063 <https://github.com/tarantool/tarantool/issues/4063>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:611
msgid "(Server) checkpoint_daemon.lua:49: bad argument #2 to 'format' Issue `4030 <https://github.com/tarantool/tarantool/issues/4030>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:613
msgid "(Server) fiber:name() show only part of name Issue `4011 <https://github.com/tarantool/tarantool/issues/4011>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:615
msgid "(Server) Second hot standby switch may fail Issue `3967 <https://github.com/tarantool/tarantool/issues/3967>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:617
msgid "(Server) Updating box.cfg.readahead doesn't affect existing connections Issue `3958 <https://github.com/tarantool/tarantool/issues/3958>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:619
msgid "(Server) fiber.join() blocks in 'suspended' if fiber has cancelled Issue `3948 <https://github.com/tarantool/tarantool/issues/3948>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:621
msgid "(Server) Tarantool can be crashed by sending gibberish to a binary socket Issue `3900 <https://github.com/tarantool/tarantool/issues/3900>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:623
msgid "(Server) Stored procedure to produce push-messages never breaks on client disconnect Issue `3859 <https://github.com/tarantool/tarantool/issues/3559>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:625
msgid "(Server) Tarantool crashed in lj_vm_return Issue `3840 <https://github.com/tarantool/tarantool/issues/3840>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:627
msgid "(Server) Fiber executing box.cfg() may process messages from iproto Issue `3779 <https://github.com/tarantool/tarantool/issues/3779>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:629
msgid "(Server) Possible regression on nosqlbench Issue `3747 <https://github.com/tarantool/tarantool/issues/3747>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:631
msgid "(Server) Assertion after improper index creation Issue `3744 <https://github.com/tarantool/tarantool/issues/3744>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:633
msgid "(Server) Tarantool crashes on vshard startup (lj_gc_step) Issue `3725 <https://github.com/tarantool/tarantool/issues/3725>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:635
msgid "(Server) Do not restart replication on box.cfg if the configuration didn't change Issue `3711 <https://github.com/tarantool/tarantool/issues/3711>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:637
msgid "(Replication) Applier times out too fast when reading large tuples Issue `4042 <https://github.com/tarantool/tarantool/issues/4042>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:639
msgid "(Replication) Vinyl replica join fails Issue `3968 <https://github.com/tarantool/tarantool/issues/3968>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:641
msgid "(Replication) Error during replication Issue `3910 <https://github.com/tarantool/tarantool/issues/3910>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:643
msgid "(Replication) Downstream status doesn't show up in replication.info unless the channel is broken Issue `3904 <https://github.com/tarantool/tarantool/issues/3904>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:645
msgid "(Replication) replication fails: tx checksum mismatch Issue `3993 <https://github.com/tarantool/tarantool/issues/3883>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:647
msgid "(Replication) Rebootstrap crashes if master has replica's rows Issue `3740 <https://github.com/tarantool/tarantool/issues/3740>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:649
msgid "(Replication) After restart tuples revert back to their old state which was before replica sync Issue `3722 <https://github.com/tarantool/tarantool/issues/3722>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:651
msgid "(Replication) Add vclock for safer hot standby switch Issue `3002 <https://github.com/tarantool/tarantool/issues/3002>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:653
msgid "(Replication) Master row is skipped forever in case of wal write failure Issue `2283 <https://github.com/tarantool/tarantool/issues/2283>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:655
msgid "(Lua) space:frommap():tomap() conversion fail Issue `4045 <https://github.com/tarantool/tarantool/issues/4045>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:657
msgid "(Lua) Non-informative message when trying to read a negative count of bytes from socket Issue `3979 <https://github.com/tarantool/tarantool/issues/3979>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:659
msgid "(Lua) space:frommap raise \"tuple field does not match...\" even for nullable field Issue `3883 <https://github.com/tarantool/tarantool/issues/3883>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:661
msgid "(Lua) Tarantool crashes on net.box.call after some uptime with vshard internal fiber Issue `3751 <https://github.com/tarantool/tarantool/issues/3751>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:663
msgid "(Lua) Heap use after free in lbox_error Issue `1955 <https://github.com/tarantool/tarantool/issues/1955>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:665
msgid "(Misc) http.client doesn't honour 'connection: keep-alive' Issue `3955 <https://github.com/tarantool/tarantool/issues/3955>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:667
msgid "(Misc) net.box wait_connected is broken Issue `3856 <https://github.com/tarantool/tarantool/issues/3856>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:669
msgid "(Misc) Mac build fails on Mojave Issue `3797 <https://github.com/tarantool/tarantool/issues/3797>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:671
msgid "(Misc) FreeBSD build error: no SSL support Issue `3750 <https://github.com/tarantool/tarantool/issues/3750>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:673
msgid "(Misc) 'http.client' sets invalid (?) reason Issue `3681 <https://github.com/tarantool/tarantool/issues/3681>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:675
msgid "(Misc) Http client silently modifies headers when value is not a \"string\" or a \"number\" Issue `3679 <https://github.com/tarantool/tarantool/issues/3679>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:677
msgid "(Misc) yaml.encode uses multiline format for 'false' and 'true' Issue `3662 <https://github.com/tarantool/tarantool/issues/3662>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:679
msgid "(Misc) yaml.encode encodes 'null' incorrectly Issue `3583 <https://github.com/tarantool/tarantool/issues/3583>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:681
msgid "(Misc) Error object message is empty Issue `3604 <https://github.com/tarantool/tarantool/issues/3604>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:683
msgid "(Misc) Log can be flooded by warning messages Issue `2218 <https://github.com/tarantool/tarantool/issues/2218>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:686
msgid "Deprecations: the console=true option for :ref:`net.box.new <net_box-new>` is deprecated."
msgstr ""

#: ../doc/2.2/whats_new.rst:690
msgid "**Release 1.10.2**"
msgstr ""

#: ../doc/2.2/whats_new.rst:692
msgid "Release type: stable (lts). Release date: 2018-10-13.  Tag: 1-10-2."
msgstr ""

#: ../doc/2.2/whats_new.rst:694
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.10.2."
msgstr ""

#: ../doc/2.2/whats_new.rst:696
msgid "This is the first :ref:`stable (lts) <release-policy>` release in the 1.10 series. Also, Tarantool 1.10.2 is a major release that deprecates Tarantool 1.9.2. It resolves 95 issues since 1.9.2."
msgstr ""

#: ../doc/2.2/whats_new.rst:701
msgid "Tarantool 1.10.x is backward compatible with Tarantool 1.9.x in binary data layout, client-server protocol and replication protocol. You can :ref:`upgrade <admin-upgrades>` using the ``box.schema.upgrade()`` procedure."
msgstr ""

#: ../doc/2.2/whats_new.rst:706
msgid "The goal of this release is to significantly increase ``vinyl`` stability and introduce automatic rebootstrap of a Tarantool replica set."
msgstr ""

#: ../doc/2.2/whats_new.rst:711
msgid "(Engines) support ALTER for non-empty vinyl spaces. Issue `1653 <https://github.com/tarantool/tarantool/issues/1653>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:713
msgid "(Engines) tuples stored in the vinyl cache are not shared among the indexes of the same space. Issue `3478 <https://github.com/tarantool/tarantool/issues/3478>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:716
msgid "(Engines) keep a stack of UPSERTS in ``vy_read_iterator``. Issue `1833 <https://github.com/tarantool/tarantool/issues/1833>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:718
msgid "(Engines) ``box.ctl.reset_stat()``, a function to reset vinyl statistics. Issue `3198 <https://github.com/tarantool/tarantool/issues/3198>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:721
msgid "(Server) :ref:`configurable syslog destination <cfg_logging-log>`. Issue `3487 <https://github.com/tarantool/tarantool/issues/3487>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:723
msgid "(Server) allow different nullability in indexes and format. Issue `3430 <https://github.com/tarantool/tarantool/issues/3430>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:725
msgid "(Server) allow to :ref:`back up any checkpoint <admin-backups-backup_start>`, not just the last one. Issue `3410 <https://github.com/tarantool/tarantool/issues/3410>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:729
msgid "(Server) a way to detect that a Tarantool process was started / restarted by ``tarantoolctl`` (:ref:`TARANTOOLCTL and TARANTOOL_RESTARTED <tarantoolctl-instance_management>` env vars). Issues `3384 <https://github.com/tarantool/tarantool/issues/3384>`_, `3215 <https://github.com/tarantool/tarantool/issues/3215>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:735
msgid "(Server) :ref:`net_msg_max <cfg_networking-net_msg_max>` configuration parameter to restrict the number of allocated fibers. Issue `3320 <https://github.com/tarantool/tarantool/issues/3320>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:739
msgid "(Replication) display the connection status if the downstream gets disconnected from the upstream (:ref:`box.info.replication.downstream.status <box_info_replication>` ``= disconnected``). Issue `3365 <https://github.com/tarantool/tarantool/issues/3365>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:745
msgid "(Replication) :ref:`replica-local spaces <replication-local>` Issue `3443 <https://github.com/tarantool/tarantool/issues/3443>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:747
msgid "(Replication) :ref:`replication_skip_conflict <cfg_replication-replication_skip_conflict>`, a new option in ``box.cfg{}`` to skip conflicting rows in replication. Issue `3270 <https://github.com/tarantool/tarantool/issues/3270>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:751
msgid "(Replication) remove old snapshots which are not needed by replicas. Issue `3444 <https://github.com/tarantool/tarantool/issues/3444>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:754
msgid "(Replication) log records which tried to commit twice. Issue `3105 <https://github.com/tarantool/tarantool/issues/3105>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:758
msgid "(Lua) new function :ref:`fiber.join() <fiber_object-join>`. Issue `1397 <https://github.com/tarantool/tarantool/issues/1397>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:760
msgid "(Lua) new option ``names_only`` to :ref:`tuple:tomap() <box_tuple-tomap>`. Issue `3280 <https://github.com/tarantool/tarantool/issues/3280>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:762
msgid "(Lua) support custom rock servers (``server`` and ``only-server`` options for :ref:`tarantoolctl rocks <tarantoolctl-module_management>` command). Issue `2640 <https://github.com/tarantool/tarantool/issues/2640>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:767
msgid "(Lua) expose ``on_commit``/``on_rollback`` triggers to Lua; Issue `857 <https://github.com/tarantool/tarantool/issues/857>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:769
msgid "(Lua) new function :ref:`box.is_in_txn() <box-is_in_txn>` to check if a transaction is open; Issue `3518 <https://github.com/tarantool/tarantool/issues/3518>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:772
msgid "(Lua) tuple field access via a json path (by :ref:`number <box_tuple-field_number>`, :ref:`name <box_tuple-field_name>`, and :ref:`path <box_tuple-field_path>`); Issue `1285 <https://github.com/tarantool/tarantool/issues/1285>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:777
msgid "(Lua) new function :ref:`space:frommap() <box_space-frommap>`; Issue `3282 <https://github.com/tarantool/tarantool/issues/3282>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:779
msgid "(Lua) new module :ref:`utf8 <utf8-module>` that implements libicu's bindings for use in Lua; Issues `3290 <https://github.com/tarantool/tarantool/issues/3290>`_, `3385 <https://github.com/tarantool/tarantool/issues/3385>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:788
msgid "Version 1.9"
msgstr ""

#: ../doc/2.2/whats_new.rst:792
msgid "**Release 1.9.0**"
msgstr ""

#: ../doc/2.2/whats_new.rst:794
msgid "Release type: stable. Release date: 2018-02-26.  Tag: 1.9.0-4-g195d446."
msgstr ""

#: ../doc/2.2/whats_new.rst:796
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.9.0."
msgstr ""

#: ../doc/2.2/whats_new.rst:798
msgid "This is the successor of the 1.7.6 stable release. The goal of this release is increased maturity of vinyl and master-master replication, and it contributes a number of features to this cause. Please follow the download instructions at https://tarantool.io/en/download/download.html to download and install a package for your operating system."
msgstr ""

#: ../doc/2.2/whats_new.rst:806
msgid "(Security) it is now possible to :ref:`block/unblock <authentication-owners_privileges>` users. Issue `2898 <https://github.com/tarantool/tarantool/issues/2898>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:809
msgid "(Security) new function :ref:`box.session.euid() <box_session-euid>` to return effective user. Effective user can be different from authenticated user in case of ``setuid`` functions or ``box.session.su``. Issue `2994 <https://github.com/tarantool/tarantool/issues/2994>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:813
msgid "(Security) new :ref:`super <box_space-user>` role, with superuser access. Grant 'super' to guest to disable access control. Issue `3022 <https://github.com/tarantool/tarantool/issues/3022>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:816
msgid "(Security) :ref:`on_auth <box_session-on_auth>` trigger is now fired in case of both successful and failed authentication. Issue `3039 <https://github.com/tarantool/tarantool/issues/3039>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:819
msgid "(Replication/recovery) new replication configuration algorithm: if replication doesn't connect to replication_quorum peers in :ref:`replication_connect_timeout <cfg_replication-replication_connect_timeout>` seconds, the server start continues but the server enters the new :ref:`orphan <replication-orphan_status>` status, which is basically read-only, until the replicas connect to each other. Issues `3151 <https://github.com/tarantool/tarantool/issues/3151>`_ and `2958 <https://github.com/tarantool/tarantool/issues/2958>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:825
msgid "(Replication/recovery) after replication connect at startup, the server does not start processing write requests before :ref:`syncing up <replication-orphan_status>` syncing up with all connected peers."
msgstr ""

#: ../doc/2.2/whats_new.rst:828
msgid "(Replication/recovery) it is now possible to explicitly set :ref:`instance_uuid <cfg_replication-instance_uuid>` and :ref:`replica set uuid <cfg_replication-replicaset_uuid>` as configuration parameters. Issue `2967 <https://github.com/tarantool/tarantool/issues/2967>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:832
msgid "(Replication/recovery) :ref:`box.once() <box-once>` no longer fails on a read-only replica but waits. Issue `2537 <https://github.com/tarantool/tarantool/issues/2537>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:835
msgid "(Replication/recovery) :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>` can now skip a corrupted xlog file. Issue `3076 <https://github.com/tarantool/tarantool/issues/3076>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:837
msgid "(Replication/recovery) improved replication monitoring: :ref:`box.info.replication <box_info_replication>` shows peer ip:port and correct replication lag even for idle peers. Issues `2753 <https://github.com/tarantool/tarantool/issues/2753>`_ and `2689 <https://github.com/tarantool/tarantool/issues/2689>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:841
msgid "(Application server) new :ref:`before <box_space-before_replace>` triggers which can be used for conflict resolution in master-master replication. Issue `2993 <https://github.com/tarantool/tarantool/issues/2993>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:844
msgid "(Application server) :ref:`http client <http-module>` now correctly parses cookies and supports http+unix:// paths. Issues `3040 <https://github.com/tarantool/tarantool/issues/3040>`_ and `2801 <https://github.com/tarantool/tarantool/issues/2801>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:848
msgid "(Application server) ``fio`` rock now supports ``file_exists()``, ``rename()`` works across filesystems, and ``read()`` without arguments reads the whole file. Issues `2924 <https://github.com/tarantool/tarantool/issues/2924>`_, `2751 <https://github.com/tarantool/tarantool/issues/2751>`_ and `2925 <https://github.com/tarantool/tarantool/issues/2925>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:854
msgid "(Application server) ``fio`` rock errors now follow Tarantool function call conventions and always return an error message in addition to the error flag."
msgstr ""

#: ../doc/2.2/whats_new.rst:856
msgid "(Application server) ``digest`` rock now supports pbkdf2 password hashing algorithm, useful in PCI/DSS compliant applications. Issue `2874 <https://github.com/tarantool/tarantool/issues/2874>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:859
msgid "(Application server) :ref:`box.info.memory() <box_info_memory>` provides a high-level overview of server memory usage, including networking, Lua, transaction and index memory. Issue `934 <https://github.com/tarantool/tarantool/issues/934>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:862
msgid "(Database) it is now possible to :ref:`add missing tuple fields <box_space-is_nullable>` to an index, which is very useful when adding an index along with the evolution of the database schema. Issue `2988 <https://github.com/tarantool/tarantool/issues/2988>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:866
msgid "(Database) lots of improvements in field type support when creating or :ref:`altering <box_index-alter>` spaces and indexes. Issues `2893 <https://github.com/tarantool/tarantool/issues/2893>`_, `3011 <https://github.com/tarantool/tarantool/issues/3011>`_ and `3008 <https://github.com/tarantool/tarantool/issues/3008>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:871
msgid "(Database) it is now possible to turn on :ref:`is_nullable <box_space-is_nullable>` property on a field even if the space is not empty, the change is instantaneous. Issue `2973 <https://github.com/tarantool/tarantool/issues/2973>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:874
msgid "(Database) :ref:`logging <log-module>` has been improved in many respects: individual messages (issues `1972 <https://github.com/tarantool/tarantool/issues/1972>`_, `2743 <https://github.com/tarantool/tarantool/issues/2743>`_, `2900 <https://github.com/tarantool/tarantool/issues/2900>`_), more logging in cases when it was useful (issues `3096 <https://github.com/tarantool/tarantool/issues/3096>`_, `2871 <https://github.com/tarantool/tarantool/issues/2871>`_)."
msgstr ""

#: ../doc/2.2/whats_new.rst:881
msgid "(Vinyl storage engine) it is now possible to make a :ref:`unique <box_index-unique>` vinyl index non-unique without index rebuild. Issue `2449 <https://github.com/tarantool/tarantool/issues/2449>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:884
msgid "(Vinyl storage engine) improved UPDATE, REPLACE and recovery performance in presence of secondary keys. Issues `2289 <https://github.com/tarantool/tarantool/issues/2289>`_, `2875 <https://github.com/tarantool/tarantool/issues/2875>`_ and `3154 <https://github.com/tarantool/tarantool/issues/3154>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:889
msgid "(Vinyl storage engine) :ref:`space:len() <box_space-len>` and :ref:`space:bsize() <box_space-bsize>` now work for vinyl (although they are still not exact). Issue `3056 <https://github.com/tarantool/tarantool/issues/3056>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:893
msgid "(Vinyl storage engine) recovery speed has improved in presence of secondary keys. Issue `2099 <https://github.com/tarantool/tarantool/issues/2099>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:896
msgid "(Builds) Alpine Linux support. Issue `3067 <https://github.com/tarantool/tarantool/issues/3067>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:903
msgid "Version 1.8"
msgstr ""

#: ../doc/2.2/whats_new.rst:907
msgid "**Release 1.8.1**"
msgstr ""

#: ../doc/2.2/whats_new.rst:909
msgid "Release type: alpha. Release date: 2017-05-17.  Tag: 1.8.1."
msgstr ""

#: ../doc/2.2/whats_new.rst:911
msgid "Announcement: https://groups.google.com/forum/#!msg/tarantool-ru/XYaoqJpc544/mSvKrYwNAgAJ."
msgstr ""

#: ../doc/2.2/whats_new.rst:913
msgid "This is an alpha release which delivers support for a substantial subset of the ISO/IEC 9075:2011 SQL standard, including joins, subqueries and views. SQL is a major feature of the 1.8 release series, in which we plan to add support for ODBC and JDBC connectors, SQL triggers, prepared statements, security and roles, and generally ensure SQL is a first class query language in Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:922
msgid "A new function ``box.sql.execute()`` (later changed to ``box.execute`` in Tarantool 2.1) was added to query Tarantool databases using SQL statements, e.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:926
msgid "tarantool> box.sql.execute([[SELECT * FROM _schema]]);"
msgstr ""

#: ../doc/2.2/whats_new.rst:930
msgid "SQL and Lua are fully interoperable."
msgstr ""

#: ../doc/2.2/whats_new.rst:931
msgid "New meta-commands introduced to Tarantool's console."
msgstr ""

#: ../doc/2.2/whats_new.rst:933
msgid "You can now set input language to either SQL or Lua, e.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:935
msgid "tarantool> \\set language sql\n"
"tarantool> SELECT * FROM _schema;\n"
"tarantool> \\set language lua\n"
"tarantool> print(\"Hello, world!\")"
msgstr ""

#: ../doc/2.2/whats_new.rst:942
msgid "Most SQL statements are supported:"
msgstr ""

#: ../doc/2.2/whats_new.rst:944
msgid "CREATE/DROP TABLE/INDEX/VIEW"
msgstr ""

#: ../doc/2.2/whats_new.rst:946
msgid "tarantool> CREATE TABLE table1 (column1 INTEGER PRIMARY KEY, column2 VARCHAR(100));"
msgstr ""

#: ../doc/2.2/whats_new.rst:950
msgid "INSERT/UPDATE/DELETE statements e.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:952
msgid "tarantool> INSERT INTO table1 VALUES (1, 'A');\n"
"...\n"
"tarantool> UPDATE table1 SET column2 = 'B';"
msgstr ""

#: ../doc/2.2/whats_new.rst:958
msgid "SELECT statements, including complex complicated variants which include multiple JOINs, nested SELECTs etc. e.g.:"
msgstr ""

#: ../doc/2.2/whats_new.rst:961
msgid "tarantool> SELECT sum(column1) FROM table1 WHERE column2 LIKE '_B' GROUP BY column2;"
msgstr ""

#: ../doc/2.2/whats_new.rst:965
msgid "WITH statements e.g."
msgstr ""

#: ../doc/2.2/whats_new.rst:967
msgid "tarantool> WITH cte AS ( SELECT SUBSTR(column2,1,2), column1 FROM table1 WHERE column1 >= 0) SELECT * FROM cte;"
msgstr ""

#: ../doc/2.2/whats_new.rst:971
msgid "SQL schema is persistent, so it is able to survive ``snapshot()``/``restore()`` sequence."
msgstr ""

#: ../doc/2.2/whats_new.rst:972
msgid "SQL features are described in a :ref:`tutorial <sql_tutorial>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:978
msgid "Version 1.7"
msgstr ""

#: ../doc/2.2/whats_new.rst:982
msgid "**Release 1.7.6**"
msgstr ""

#: ../doc/2.2/whats_new.rst:984
msgid "Release type: stable. Release date: 2017-11-07.  Tag: 1.7.6-0-g7b2945d6c."
msgstr ""

#: ../doc/2.2/whats_new.rst:986
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool/hzc7O2YDZUc."
msgstr ""

#: ../doc/2.2/whats_new.rst:988
msgid "This is the next stable release in the 1.7 series. It resolves more than 75 issues since 1.7.5."
msgstr ""

#: ../doc/2.2/whats_new.rst:991
msgid "What's new in Tarantool 1.7.6?"
msgstr ""

#: ../doc/2.2/whats_new.rst:993
msgid "In addition to :ref:`rollback <box-rollback>` of a transaction, there is now rollback to a defined point within a transaction -- :ref:`savepoint <box-savepoint>` support."
msgstr ""

#: ../doc/2.2/whats_new.rst:995
msgid "There is a new object type: :ref:`sequences <index-box_sequence>`. The older option, :ref:`auto-increment <box_space-auto_increment>`, will be deprecated."
msgstr ""

#: ../doc/2.2/whats_new.rst:997
msgid "String indexes can have :ref:`collations <index-collation>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:999
msgid "New options are available for:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1001
msgid ":ref:`net_box <net_box-module>` (timeouts),"
msgstr ""

#: ../doc/2.2/whats_new.rst:1002
msgid ":ref:`string <string-module>` functions,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1003
msgid "space :ref:`formats <box_space-format>` (user-defined field names and types),"
msgstr ""

#: ../doc/2.2/whats_new.rst:1004
msgid ":ref:`base64 <digest-base64_encode>` (``urlsafe`` option), and"
msgstr ""

#: ../doc/2.2/whats_new.rst:1005
msgid "index :ref:`creation <box_space-create_index>` (collation, :ref:`is-nullable <box_space-is_nullable>`, field names)."
msgstr ""

#: ../doc/2.2/whats_new.rst:1008
#: ../doc/2.2/whats_new.rst:1454
#: ../doc/2.2/whats_new.rst:1514
#: ../doc/2.2/whats_new.rst:1696
#: ../doc/2.2/whats_new.rst:1739
#: ../doc/2.2/whats_new.rst:1851
#: ../doc/2.2/whats_new.rst:1893
msgid "Incompatible changes:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1010
msgid "Layout of ``box.space._index`` has been extended to support :ref:`is_nullable <box_space-is_nullable>` and :ref:`collation <index-collation>` features. All new indexes created on columns with ``is_nullable`` or ``collation`` properties will have the new definition format. Please update your client libraries if you plan to use these new features. Issue `2802 <https://github.com/tarantool/tarantool/issues/2802>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1017
msgid ":ref:`fiber_name() <fiber_object-name_get>` now raises an exception instead of truncating long fiber names. We found that some Lua modules such as :ref:`expirationd <expirationd-module>` use ``fiber.name()`` as a key to identify background tasks. If a name is truncated, this fact was silently missed. The new behavior allows to detect bugs caused by ``fiber.name()`` truncation. Please use ``fiber.name(name, { truncate = true })`` to emulate the old behavior. Issue `2622 <https://github.com/tarantool/tarantool/issues/2622>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1024
msgid ":ref:`space:format() <box_space-format>` is now validated on DML operations. Previously ``space:format()`` was only used by client libraries, but starting from Tarantoool 1.7.6, field types in ``space:format()`` are validated on the server side on every DML operation, and field names can be used in indexes and Lua code. If you used ``space:format()`` in a non-standard way, please update layout and type names according to the official documentation for space formats."
msgstr ""

#: ../doc/2.2/whats_new.rst:1034
msgid "Hybrid schema-less + schemaful data model. Earlier Tarantool versions allowed to store arbitrary MessagePack documents in spaces. Starting from Tarantool 1.7.6, you can use :ref:`space:format() <box_space-format>` to define schema restrictions and constraints for tuples in spaces. Defined field types are automatically validated on every DML operation, and defined field names can be used instead of field numbers in Lua code. A new function :ref:`tuple:tomap() <box_tuple-tomap>` was added to convert a tuple into a key-value Lua dictionary."
msgstr ""

#: ../doc/2.2/whats_new.rst:1041
msgid "Collation and Unicode support. By default, when Tarantool compares strings, it takes into consideration only the numeric value of each byte in the string. To allow the ordering that you see in phone books and dictionaries, Tarantool 1.7.6 introduces support for collations based on the `Default Unicode Collation Element Table (DUCET) <http://unicode.org/reports/tr10/#Default_Unicode_Collation_Element_Table>`_ and the rules described in `Unicode® Technical Standard #10 Unicode Collation Algorithm (UTS #10 UCA) <http://unicode.org/reports/tr10>`_ See :ref:`collations <index-collation>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:1049
msgid "NULL values in unique and non-unique indexes. By default, all fields in Tarantool are  \"NOT NULL\". Starting from Tarantool 1.7.6, you can use ``is_nullable`` option in :ref:`space:format() <box_space-format>` or :ref:`inside an index part definition <box_space-is_nullable>` to allow storing NULL in indexes. Tarantool partially implements `three-valued logic <https://en.wikipedia.org/wiki/Three-valued_logic>`_ from the SQL standard and allows storing multiple NULL values in unique indexes. Issue `1557 <https://github.com/tarantool/tarantool/issues/1557>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1059
msgid "Sequences and a new implementation of :ref:`auto_increment() <box_space-auto_increment>`. Tarantool 1.7.6 introduces new :ref:`sequence number generators <index-box_sequence>` (like CREATE SEQUENCE in SQL). This feature is used to implement new persistent auto increment in spaces. Issue `389 <https://github.com/tarantool/tarantool/issues/389>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1064
msgid "Vinyl: introduced gap locks in Vinyl transaction manager. The new locking mechanism in Vinyl TX manager reduces the number of conflicts in transactions. Issue `2671 <https://github.com/tarantool/tarantool/issues/2671>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1067
msgid "net.box: :ref:`on_connect <box_session-on_connect>` and :ref:`on_disconnect <box_session-on_disconnect>` triggers. Issue `2858 <https://github.com/tarantool/tarantool/issues/2858>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1070
msgid "Structured logging in :ref:`JSON format <cfg_logging-log_format>`. Issue `2795 <https://github.com/tarantool/tarantool/issues/2795>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1072
msgid "(Lua) Lua: :ref:`string.strip() <string-strip>` Issue `2785 <https://github.com/tarantool/tarantool/issues/2785>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1074
msgid "(Lua) added :ref:`base64_urlsafe_encode() <digest-base64_encode>` to ``digest`` module. Issue `2777 <https://github.com/tarantool/tarantool/issues/2777>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1076
msgid "Log conflicted keys in master-master replication. Issue `2779 <https://github.com/tarantool/tarantool/issues/2779>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1078
msgid "Allow to disable backtrace in :ref:`fiber.info() <fiber-info>`. Issue `2878 <https://github.com/tarantool/tarantool/issues/2878>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1080
msgid "Implemented ``tarantoolctl rocks make *.spec``. Issue `2846 <https://github.com/tarantool/tarantool/issues/2846>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1082
msgid "Extended the default loader to look for ``.rocks`` in the parent dir hierarchy. Issue `2676 <https://github.com/tarantool/tarantool/issues/2676>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1084
msgid "``SOL_TCP`` options support in :ref:`socket:setsockopt() <socket-setsockopt>`. Issue `598 <https://github.com/tarantool/tarantool/issues/598>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1086
msgid "Partial emulation of LuaSocket on top of Tarantool Socket. Issue `2727 <https://github.com/tarantool/tarantool/issues/2727>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1089
msgid "Developer tools:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1091
msgid "Integration with IntelliJ IDEA with debugging support. Now you can use IntelliJ IDEA as an IDE to develop and debug Lua applications for Tarantool. See :ref:`Using IDE <app_server-using_ide>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:1094
msgid "Integration with `MobDebug <https://github.com/pkulchenko/MobDebug>`_ remote Lua debugger. Issue `2728 <https://github.com/tarantool/tarantool/issues/2728>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1096
msgid "Configured ``/usr/bin/tarantool`` as an alternative Lua interpreter on Debian/Ubuntu. Issue `2730 <https://github.com/tarantool/tarantool/issues/2730>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1099
#: ../doc/2.2/whats_new.rst:1200
#: ../doc/2.2/whats_new.rst:1876
#: ../doc/2.2/whats_new.rst:1956
msgid "New rocks:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1101
msgid "`smtp.client <https://github.com/tarantool/smtp>`_ - support SMTP via ``libcurl``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1105
msgid "**Release 1.7.5**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1107
msgid "Release type: stable. Release date: 2017-08-22.  Tag: 1.7.5."
msgstr ""

#: ../doc/2.2/whats_new.rst:1109
msgid "Announcement: https://github.com/tarantool/doc/issues/289."
msgstr ""

#: ../doc/2.2/whats_new.rst:1111
msgid "This is a stable release in the 1.7 series. This release resolves more than 160 issues since 1.7.4."
msgstr ""

#: ../doc/2.2/whats_new.rst:1116
msgid "(Vinyl) a new :ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>` mode to recover broken disk files. Use ``box.cfg{force_recovery=true}`` to recover corrupted data files after hardware issues or power outages. Issue `2253 <https://github.com/tarantool/tarantool/issues/2253>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1121
msgid "(Vinyl) index options can be changed on the fly without rebuild. Now :ref:`page_size <cfg_storage-vinyl_page_size>`, :ref:`run_size_ratio <cfg_storage-vinyl_run_size_ratio>`, :ref:`run_count_per_level <cfg_storage-vinyl_run_count_per_level>` and :ref:`bloom_fpr <cfg_storage-vinyl_bloom_fpr>` index options can be dynamically changed via :ref:`index:alter() <box_index-alter>`. The changes take effect in newly created data files only. Issue `2109 <https://github.com/tarantool/tarantool/issues/2109>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1129
msgid "(Vinyl) improve :ref:`box.info.vinyl() <box_introspection-box_info>` and ``index:info()`` output. Issue `1662 <https://github.com/tarantool/tarantool/issues/1662>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1131
msgid "(Vinyl) introduce :ref:`box.cfg.vinyl_timeout <cfg_basic-vinyl_timeout>` option to control quota throttling. Issue `2014 <https://github.com/tarantool/tarantool/issues/2014>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1133
msgid "Memtx: stable :ref:`index:pairs() <box_index-index_pairs>` iterators for the TREE index. TREE iterators are automatically restored to a proper position after index's modifications. Issue `1796 <https://github.com/tarantool/tarantool/issues/1796>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1136
msgid "(Memtx) :ref:`predictable order <box_index-index_pairs>` for non-unique TREE indexes. Non-unique TREE indexes preserve the sort order for duplicate entries. Issue `2476 <https://github.com/tarantool/tarantool/issues/2476>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1139
msgid "(Memtx+Vinyl) dynamic configuration of :ref:`max tuple size <cfg_storage-memtx_max_tuple_size>`. Now ``box.cfg.memtx_max_tuple_size`` and ``box.cfg.vinyl_max_tuple_size`` configuration options can be changed on the fly without need to restart the server. Issue `2667 <https://github.com/tarantool/tarantool/issues/2667>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1143
msgid "(Memtx+Vinyl) new implementation. Space :ref:`truncation <box_space-truncate>` doesn't cause re-creation of all indexes any more. Issue `618 <https://github.com/tarantool/tarantool/issues/618>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1146
msgid "Extended the :ref:`maximal length <limitations_length>` of all identifiers from 32 to 65k characters. Space, user and function names are not limited by 32 characters anymore. Issue `944 <https://github.com/tarantool/tarantool/issues/944>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1149
msgid ":ref:`Heartbeat <cfg_replication-replication_timeout>` messages for replication. Replication client now sends the selective acknowledgments for processed records and automatically re-establish stalled connections. This feature also changes :ref:`box.info.replication[replica_id].vclock <box_info_replication>`. to display committed vclock of remote replica. Issue `2484 <https://github.com/tarantool/tarantool/issues/2484>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1155
msgid "Keep track of remote replicas during WAL maintenance. Replication master now automatically preserves xlogs needed for remote replicas. Issue `748 <https://github.com/tarantool/tarantool/issues/748>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1158
msgid "Enabled :ref:`box.tuple.new() <box_tuple-new>` to work without ``box.cfg()``. Issue `2047 <https://github.com/tarantool/tarantool/issues/2047>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1160
msgid ":ref:`box.atomic(fun, ...) <box-atomic>` wrapper to execute function in a transaction. Issue `818 <https://github.com/tarantool/tarantool/issues/818>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1162
msgid ":ref:`box.session.type() <box_session-type>` helper to determine session type. Issue `2642 <https://github.com/tarantool/tarantool/issues/2642>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1164
msgid "Hot code :ref:`reload <box_schema-func_reload>` for stored C stored procedures. Use ``box.schema.func.reload('modulename.function')`` to reload dynamic shared libraries on the fly. Issue `910 <https://github.com/tarantool/tarantool/issues/910>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1168
msgid ":ref:`string.hex() <string-hex>` and ``str:hex()`` Lua API. Issue `2522 <https://github.com/tarantool/tarantool/issues/2522>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1170
msgid "Package manager based on LuaRocks. Use ``tarantoolctl rocks install MODULENAME`` to install MODULENAME Lua module from https://rocks.tarantool.org/. Issue `2067 <https://github.com/tarantool/tarantool/issues/2067>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1174
msgid "Lua 5.1 command line options. Tarantool binary now supports '-i', '-e', '-m' and '-l' command line options. Issue `1265 <https://github.com/tarantool/tarantool/issues/1265>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1177
msgid "Experimental GC64 mode for LuaJIT. GC64 mode allow to operate the full address space on 64-bit hosts. Enable via ``-DLUAJIT_ENABLE_GC64=ON compile-time`` configuration option. Issue `2643 <https://github.com/tarantool/tarantool/issues/2643>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1181
msgid "Syslog logger now support non-blocking mode. :ref:`box.cfg{log_nonblock=true} <cfg_logging-log_nonblock>` now also works for syslog logger. Issue `2466 <https://github.com/tarantool/tarantool/issues/2466>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1184
msgid "Added a VERBOSE :ref:`log level <cfg_logging-log_level>` beyond INFO. Issue `2467 <https://github.com/tarantool/tarantool/issues/2467>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1186
msgid "Tarantool now automatically makes snapshots every hour. Please set :ref:`box.cfg{checkpoint_interval=0  <cfg_checkpoint_daemon-checkpoint_interval>` to restore pre-1.7.5 behaviour. Issue `2496 <https://github.com/tarantool/tarantool/issues/2496>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1189
msgid "Increase precision for percentage ratios provoded by :ref:`box.slab.info() <box_slab_info>`. Issue `2082 <https://github.com/tarantool/tarantool/issues/2082>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1191
msgid "Stack traces now contain symbols names on all supported platforms. Previous versions of Tarantool didn't display meaningful function names in :ref:`fiber.info() <fiber-info>` on non-x86 platforms. Issue `2103 <https://github.com/tarantool/tarantool/issues/2103>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1195
msgid "Allowed to create fiber with custom stack size from C API. Issue `2438 <https://github.com/tarantool/tarantool/issues/2438>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1197
msgid "Added ``ipc_cond`` to public C API. Issue `1451 <https://github.com/tarantool/tarantool/issues/1451>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1202
msgid ":ref:`http.client <http-module>` (built-in) - libcurl-based HTTP client with SSL/TLS support. Issue `2083 <https://github.com/tarantool/tarantool/issues/x2083>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1204
msgid ":ref:`iconv <iconv-converter>` (built-in) - bindings for iconv. Issue `2587 <https://github.com/tarantool/tarantool/issues/2587>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1206
msgid "`authman <https://github.com/mailru/tarantool-authman>`_ - API for user registration and login in your site using email and social networks."
msgstr ""

#: ../doc/2.2/whats_new.rst:1208
msgid "`document <https://github.com/tarantool/document>`_ - store nested documents in Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:1209
msgid "`synchronized <https://github.com/tarantool/synchronized>`_ - critical sections for Lua."
msgstr ""

#: ../doc/2.2/whats_new.rst:1213
msgid "**Release 1.7.4**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1215
msgid "Release type: release candidate. Release date: 2017-05-12. Release tag: Tag: 1.7.4."
msgstr ""

#: ../doc/2.2/whats_new.rst:1217
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.4 or https://groups.google.com/forum/#!topic/tarantool/3x88ATX9YbY"
msgstr ""

#: ../doc/2.2/whats_new.rst:1220
msgid "This is a release candidate in the 1.7 series. Vinyl Engine, the flagship feature of 1.7.x, is now feature complete."
msgstr ""

#: ../doc/2.2/whats_new.rst:1223
msgid "Incompatible changes"
msgstr ""

#: ../doc/2.2/whats_new.rst:1225
msgid "``box.cfg()`` options were changed to add Vinyl support:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1227
msgid "``snap_dir`` renamed to ``memtx_dir``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1228
msgid "``slab_alloc_arena`` (gigabytes) renamed to ``memtx_memory`` (bytes), default value changed from 1Gb to 256MB"
msgstr ""

#: ../doc/2.2/whats_new.rst:1230
msgid "``slab_alloc_minimal`` renamed to ``memtx_min_tuple_size``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1231
msgid "``slab_alloc_maximal`` renamed to ``memtx_max_tuple_size``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1232
msgid "``slab_alloc_factor`` is deprecated, not relevant in 1.7.x"
msgstr ""

#: ../doc/2.2/whats_new.rst:1233
msgid "``snapshot_count`` renamed to ``checkpoint_count``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1234
msgid "``snapshot_period`` renamed to ``checkpoint_interval``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1235
msgid "``logger`` renamed to ``log``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1236
msgid "``logger_nonblock`` renamed to ``log_nonblock``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1237
msgid "``logger_level`` renamed to ``log_level``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1238
msgid "``replication_source`` renamed to ``replication``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1239
msgid "``panic_on_snap_error = true`` and ``panic_on_wal_error = true`` superseded by ``force_recovery = false``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1242
msgid "Until Tarantool 1.8, you can use deprecated parameters for both initial and runtime configuration, but such usage will print a warning in the server log. Issues `1927 <https://github.com/tarantool/tarantool/issues/1927>`_ and `2042 <https://github.com/tarantool/tarantool/issues/2042>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1248
msgid "Hot standy mode is now off by default. Tarantool automatically detects another running instance in the same ``wal_dir`` and refuses to start. Use ``box.cfg {hot_standby = true}`` to enable the hot standby mode. Issue `775 <https://github.com/tarantool/tarantool/issues/775>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1252
msgid "UPSERT via a secondary key was banned to avoid unclear semantics. Issue `2226 <https://github.com/tarantool/tarantool/issues/2226>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1254
msgid "``box.info`` and ``box.info.replication`` format was changed to display information about upstream and downstream connections (Issue `723 <https://github.com/tarantool/tarantool/issues/723>`_):"
msgstr ""

#: ../doc/2.2/whats_new.rst:1258
msgid "Added ``box.info.replication[instance_id].downstream.vclock`` to display the last sent row to remote replica."
msgstr ""

#: ../doc/2.2/whats_new.rst:1260
msgid "Added ``box.info.replication[instance_id].id``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1261
msgid "Added ``box.info.replication[instance_id].lsn``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1262
msgid "Moved ``box.info.replication[instance_id].{vclock,status,error}`` to ``box.info.replication[instance_id].upstream.{vclock,status,error}``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1264
msgid "All registered replicas from ``box.space._cluster`` are included to ``box.info.replication`` output."
msgstr ""

#: ../doc/2.2/whats_new.rst:1266
msgid "``box.info.server.id`` renamed ``box.info.id``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1267
msgid "``box.info.server.lsn`` renamed ``box.info.lsn``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1268
msgid "``box.info.server.uuid`` renamed ``box.info.uuid``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1269
msgid "``box.info.cluster.signature`` renamed to ``box.info.signature``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1270
msgid "``box.info.id`` and ``box.info.lsn`` now return `nil` instead of `-1` during initial cluster bootstrap."
msgstr ""

#: ../doc/2.2/whats_new.rst:1273
msgid "``net.box``: added per-request options to all requests:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1275
msgid "``conn.call(func_name, arg1, arg2,...)`` changed to ``conn.call(func_name, {arg1, arg2, ...}, opts)``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1277
msgid "``conn.eval(func_name, arg1, arg2,...)`` changed to ``conn.eval(func_name, {arg1, arg2, ...}, opts)``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1280
msgid "All requests now support ``timeout = <seconds>``, ``buffer = <ibuf>`` options."
msgstr ""

#: ../doc/2.2/whats_new.rst:1281
msgid "Added ``connect_timeout`` option to ``netbox.connect()``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1282
msgid "``netbox:timeout()`` and ``conn:timeout()`` are now deprecated. Use ``netbox.connect(host, port, { call_16 = true })`` for 1.6.x-compatible behavior. Issue `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1286
msgid "systemd configuration changed to support ``Type=Notify`` / ``sd_notify()``. Now ``systemctl start tarantool@INSTANCE`` will wait until Tarantool has started and recovered from xlogs. The recovery status is reported to ``systemctl status tarantool@INSTANCE``. Issue `1923 <https://github.com/tarantool/tarantool/issues/1923>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1291
msgid "``log`` module now doesn't prefix all messages with the full path to tarantool binary when used without ``box.cfg()``. Issue `1876 <https://github.com/tarantool/tarantool/issues/1876>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1294
msgid "``require('log').logger_pid()`` was renamed to ``require('log').pid()``. Issue `2917 <https://github.com/tarantool/tarantool/issues/2917>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1296
msgid "Removed Lua 5.0 compatible defines and functions (Issue `2396 <https://github.com/tarantool/tarantool/issues/2396>`_):"
msgstr ""

#: ../doc/2.2/whats_new.rst:1299
msgid "``luaL_reg`` removed in favor of ``luaL_Reg``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1300
msgid "``luaL_getn(L, i)`` removed in favor of ``lua_objlen(L, i)``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1301
msgid "``luaL_setn(L, i, j)`` removed (was no-op)"
msgstr ""

#: ../doc/2.2/whats_new.rst:1302
msgid "``lua_ref(L, lock)`` removed in favor of ``luaL_ref(L, lock)``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1303
msgid "``lua_getref(L,ref)`` removed in favor of ``lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1304
msgid "``lua_unref(L, ref)`` removed in favor of ``luaL_unref(L, ref)``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1305
msgid "``math.mod()`` removed in favor of ``math.fmod()``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1306
msgid "``string.gfind()`` removed in favor of ``string.gmatch()``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1310
msgid "(Vinyl) multi-level compaction. The compaction scheduler now groups runs of the same range into levels to reduce the write amplification during compaction. This design allows Vinyl to support 1:100+ ram:disk use-cases. Issue `1821 <https://github.com/tarantool/tarantool/issues/1821>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1315
msgid "(Vinyl) bloom filters for sorted runs. Bloom filter is a probabilistic data structure which can be used to test whether a requested key is present in a run file without reading the actual file from the disk. Bloom filter may have false-positive matches but false-negative matches are impossible. This feature reduces the number of seeks needed for random lookups and speeds up REPLACE/DELETE with enabled secondary keys. Issue `1919 <https://github.com/tarantool/tarantool/issues/1919>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1323
msgid "(Vinyl) key-level cache for point lookups and range queries. Vinyl storage engine caches selected keys and key ranges instead of entire disk pages like in traditional databases. This approach is more efficient because the cache is not polluted with raw disk data. Issue `1692 <https://github.com/tarantool/tarantool/issues/1692>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1328
msgid "(Vinyl) implemented the common memory level for in-memory indexes. Now all in-memory indexes of a space store pointers to the same tuples instead of cached secondary key index data. This feature significantly reduces the memory footprint in case of secondary keys. Issue `1908 <https://github.com/tarantool/tarantool/issues/1908>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1333
msgid "(Vinyl) new implementation of initial state transfer of JOIN command in replication protocol. New replication protocol fixes problems with consistency and secondary keys. We implemented a special kind of low-cost database-wide read-view to avoid dirty reads in JOIN procedure. This trick wasn't not possible in traditional B-Tree based databases. Issue `2001 <https://github.com/tarantool/tarantool/issues/2001>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1339
msgid "(Vinyl) index-wide mems/runs. Removed ranges from in-memory and and the stop layer of LSM tree on disk. Issue `2209 <https://github.com/tarantool/tarantool/issues/2209>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1342
msgid "(Vinyl) coalesce small ranges. Before dumping or compacting a range, consider coalescing it with its neighbors. Issue `1735 <https://github.com/tarantool/tarantool/issues/1735>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1346
msgid "(Vinyl) implemented transnational journal for metadata. Now information about all Vinyl files is logged in a special ``.vylog`` file. Issue `1967 <https://github.com/tarantool/tarantool/issues/1967>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1349
msgid "(Vinyl) implemented consistent secondary keys. Issue `2410 <https://github.com/tarantool/tarantool/issues/2410>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1351
msgid "(Memtx+Vinyl) implemented low-level Lua API to create consistent backups. of Memtx + Vinyl data. The new feature provides ``box.backup.start()/stop()`` functions to create backups of all spaces. :ref:`box.backup.start() <admin-backups-backup_start>` pauses the Tarantool garbage collector and returns the list of files to copy. These files then can be copied be any third-party tool, like cp, ln, tar, rsync, etc. ``box.backup.stop()`` lets the garbage collector continue. Created backups can be restored instantly by copying into a new directory and starting a new Tarantool instance. No special preparation, conversion or unpacking is needed. Issue `1916 <https://github.com/tarantool/tarantool/issues/1916>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1362
msgid "(Vinyl) added statistics for background workers to ``box.info.vinyl()``. Issue `2005 <https://github.com/tarantool/tarantool/issues/2005>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1364
msgid "(Memtx+Vinyl) reduced the memory footprint for indexes which keys are sequential and start from the first field. This optimization was necessary for secondary keys in Vinyl, but we optimized Memtx as well. Issue `2046 <https://github.com/tarantool/tarantool/issues/2046>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1368
msgid "LuaJIT was rebased on the latest 2.1.0b3 with out patches (Issue `2396 <https://github.com/tarantool/tarantool/issues/2396>`_):"
msgstr ""

#: ../doc/2.2/whats_new.rst:1371
msgid "Added JIT compiler backend for ARM64"
msgstr ""

#: ../doc/2.2/whats_new.rst:1372
msgid "Added JIT compiler backend and interpreter for MIPS64"
msgstr ""

#: ../doc/2.2/whats_new.rst:1373
msgid "Added some more Lua 5.2 and Lua 5.3 extensions"
msgstr ""

#: ../doc/2.2/whats_new.rst:1374
msgid "Fixed several bugs"
msgstr ""

#: ../doc/2.2/whats_new.rst:1375
msgid "Removed Lua 5.0 legacy (see incompatible changes above)."
msgstr ""

#: ../doc/2.2/whats_new.rst:1377
msgid "Enabled a new smart string hashing algorithm in LuaJIT to avoid significant slowdown when a lot of collisions are generated. Contributed by Yury Sokolov (@funny-falcon) and Nick Zavaritsky (@mejedi). See https://github.com/tarantool/luajit/pull/2."
msgstr ""

#: ../doc/2.2/whats_new.rst:1381
msgid "``box.snapshot()`` now updates mtime of a snapshot file if there were no changes to the database since the last snapshot. Issue `2045 <https://github.com/tarantool/tarantl/issues/2045>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1384
msgid "Implemented ``space:bsize()`` to return the memory size utilized by all tuples of the space. Contributed by Roman Tokarev (@rtokarev). Issue `2043 <https://github.com/tarantool/tarantool/issues/2043>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1388
msgid "Exported new Lua/C functions to public API:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1390
msgid "``luaT_pushtuple``, ``luaT_istuple`` (issue `1878 <https://github.com/tarantool/tarantool/issues/1878>`_)"
msgstr ""

#: ../doc/2.2/whats_new.rst:1392
msgid "``luaT_error``, ``luaT_call``, ``luaT_cpcall`` (issue `2291 <https://github.com/tarantool/tarantool/issues/2291>`_)"
msgstr ""

#: ../doc/2.2/whats_new.rst:1394
msgid "``luaT_state`` (issue `2416 <https://github.com/tarantool/tarantool/issues/2416>`_)"
msgstr ""

#: ../doc/2.2/whats_new.rst:1397
msgid "Exported new Box/C functions to public API: ``box_key_def``, ``box_tuple_format``, ``tuple_compare()``, ``tuple_compare_with_key()``. Issue `2225 <https://github.com/tarantool/tarantool/issues/2225>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1400
msgid "xlogs now can be rotated based on size (``wal_max_size``) as well as the number of written rows (``rows_per_wal``). Issue `173 <https://github.com/tarantool/tarantool/issues/173>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1403
msgid "Added ``string.split()``, ``string.startswith()``, ``string.endswith()``, ``string.ljust()``, ``string.rjust()``, ``string.center()`` API. Issues `2211 <https://github.com/tarantool/tarantool/issues/2211>`_, `2214 <https://github.com/tarantool/tarantool/issues/2214>`_, `2415 <https://github.com/tarantool/tarantool/issues/2415>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1408
msgid "Added ``table.copy()`` and ``table.deepcopy()`` functions. Issue `2212 <https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1410
msgid "Added ``pwd`` module to work with UNIX users and groups. Issue `2213 <https://github.com/tarantool/tarantool/issues/2213>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1412
msgid "Removed noisy \"client unix/: connected\" messages from logs. Use ``box.session.on_connect()``/``on_disconnect()`` triggers instead. Issue `1938 <https://github.com/tarantool/t`arantool/issues/1938>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1416
msgid "``box.session.on_connect()``/``on_disconnect()``/``on_auth()`` triggers now also fired for admin console connections."
msgstr ""

#: ../doc/2.2/whats_new.rst:1419
msgid "tarantoolctl: ``eval``, ``enter``, ``connect`` commands now support UNIX pipes. Issue `672 <https://github.com/tarantool/tarantool/issues/672>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1421
msgid "tarantoolctl: improved error messages and added a new man page. Issue `1488 <https://github.com/tarantool/tarantool/issues/1488>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1423
msgid "tarantoolctl: added filter by ``replica_id`` to ``cat`` and ``play`` commands. Issue `2301 <https://github.com/tarantool/tarantool/issues/2301>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1425
msgid "tarantoolctl: ``start``, ``stop`` and ``restart`` commands now redirect to ``systemctl start/stop/restart`` when systemd is enabled. Issue `2254 <https://github.com/tarantool/tarantool/issues/2254>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1428
msgid "net.box: added ``buffer = <buffer>`` per-request option to store raw MessagePack responses into a C buffer. Issue `2195 <https://github.com/tarantool/tarantool/issues/2195>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1431
msgid "net.box: added ``connect_timeout`` option. Issue `2054 <https://github.com/tarantool/tarantool/issues/2054>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1433
msgid "net.box: added ``on_schema_reload()`` hook. Issue `2021 <https://github.com/tarantool/tarantool/issues/2021>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1435
msgid "net.box: exposed ``conn.schema_version`` and ``space.connection`` to API. Issue `2412 <https://github.com/tarantool/tarantool/issues/2412>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1437
msgid "log: ``debug()``/``info()``/``warn()``/``error()`` now doesn't fail on formatting errors. Issue `889 <https://github.com/tarantool/tarantool/issues/889>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1440
msgid "crypto: added HMAC support. Contributed by Andrey Kulikov (@amdei). Issue `725 <https://github.com/tarantool/tarantool/issues/725>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1446
msgid "**Release 1.7.3**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1448
msgid "Release type: beta. Release date: 2016-12-24. Release tag: Tag: 1.7.3-0-gf0c92aa."
msgstr ""

#: ../doc/2.2/whats_new.rst:1450
msgid "Announcement: https://github.com/tarantool/tarantool/releases/tag/1.7.3"
msgstr ""

#: ../doc/2.2/whats_new.rst:1452
msgid "This is the second beta release in the 1.7 series."
msgstr ""

#: ../doc/2.2/whats_new.rst:1456
msgid "Broken ``coredump()`` Lua function was removed. Use ``gdb -batch -ex \"generate-core-file\" -p $PID`` instead. Issue `1886 <https://github.com/tarantool/tarantool/issues/1886>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1459
msgid "Vinyl disk layout was changed since 1.7.2 to add ZStandard compression and improve the performance of secondary keys. Use the replication mechanism to upgrade from 1.7.2 beta. Issue `1656 <https://github.com/tarantool/tarantool/issues/1656>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1466
msgid "Substantial progress on stabilizing the Vinyl storage engine:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1468
msgid "Fix most known crashes and bugs with bad results."
msgstr ""

#: ../doc/2.2/whats_new.rst:1469
msgid "Switch to use XLOG/SNAP format for all data files."
msgstr ""

#: ../doc/2.2/whats_new.rst:1470
msgid "Enable ZStandard compression for all data files."
msgstr ""

#: ../doc/2.2/whats_new.rst:1471
msgid "Squash UPSERT operations on the fly and merge hot keys using a background fiber."
msgstr ""

#: ../doc/2.2/whats_new.rst:1473
msgid "Significantly improve the performance of index:pairs() and index:count()."
msgstr ""

#: ../doc/2.2/whats_new.rst:1474
msgid "Remove unnecessary conflicts from transactions."
msgstr ""

#: ../doc/2.2/whats_new.rst:1475
msgid "In-memory level was mostly replaced by memtx data structures."
msgstr ""

#: ../doc/2.2/whats_new.rst:1476
msgid "Specialized allocators are used in most places."
msgstr ""

#: ../doc/2.2/whats_new.rst:1478
msgid "We're still actively working on Vinyl and plan to add multi-level compaction and improve the performance of secondary keys in 1.7.4. This implies a data format change."
msgstr ""

#: ../doc/2.2/whats_new.rst:1481
msgid "Support for DML requests for space:on_replace() triggers. Issue `587 <https://github.com/tarantool/tarantool/issues/587>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1483
msgid "UPSERT can be used with the empty list of operations. Issue `1854 <https://github.com/tarantool/tarantool/issues/1854>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1485
msgid "Lua functions to manipulate environment variables. Issue `1718 <https://github.com/tarantool/tarantool/issues/1718>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1487
msgid "Lua library to read Tarantool snapshots and xlogs. Issue `1782 <https://github.com/tarantool/tarantool/issues/1782>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1489
msgid "New ``play`` and ``cat`` commands in ``tarantoolctl``. Issue `1861 <https://github.com/tarantool/tarantool/issues/1861>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1491
msgid "Improve support for the large number of active network clients. Issue#5#1892."
msgstr ""

#: ../doc/2.2/whats_new.rst:1493
msgid "Support for ``space:pairs(key, iterator-type)`` syntax. Issue `1875 <https://github.com/tarantool/tarantool/issues/1875>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1495
msgid "Automatic cluster bootstrap now also works without authorization. Issue `1589 <https://github.com/tarantool/tarantool/issues/1589>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1497
msgid "Replication retries to connect to master indefinitely. Issue `1511 <https://github.com/tarantool/tarantool/issues/1511>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1499
msgid "Temporary spaces now work with ``box.cfg { read_only = true }``. Issue `1378 <https://github.com/tarantool/tarantool/issues/1378>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1501
msgid "The maximum length of space names increased to 64 bytes (was 32). Issue `2008 <https://github.com/tarantool/tarantool/issues/2008>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1506
msgid "**Release 1.7.2**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1508
msgid "Release type: beta. Release date: 2016-09-29. Release tag: Tag: `1.7.2-1-g92ed6c4`."
msgstr ""

#: ../doc/2.2/whats_new.rst:1510
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool-ru/qUYUesEhRQg"
msgstr ""

#: ../doc/2.2/whats_new.rst:1512
msgid "This is a release in the 1.7 series."
msgstr ""

#: ../doc/2.2/whats_new.rst:1516
msgid "A new binary protocol command for CALL, which no more restricts a function to returning an array of tuples and allows returning an arbitrary MsgPack/JSON result, including scalars, nil and void (nothing). The old CALL is left intact for backward compatibility. It will be removed in the next major release. All programming language drivers will be gradually changed to use the new CALL. Issue `1296 <https://github.com/tarantool/tarantool/issues/1296>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1526
msgid "Vinyl storage engine finally reached the beta stage. This release fixes more than 90 bugs in Vinyl, in particular, removing unpredictable latency spikes, all known crashes and bad/lost result bugs."
msgstr ""

#: ../doc/2.2/whats_new.rst:1530
msgid "new cooperative multitasking based architecture to eliminate latency spikes,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1531
msgid "support for non-sequential multi-part keys,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1532
msgid "support for secondary keys,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1533
msgid "support for ``auto_increment()``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1534
msgid "number, integer, scalar field types in indexes,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1535
msgid "INSERT, REPLACE and UPDATE return new tuple, like in memtx."
msgstr ""

#: ../doc/2.2/whats_new.rst:1537
msgid "We're still actively working on Vinyl and plan to add ``zstd`` compression and a new memory allocator for Vinyl in-memory index in 1.7.3. This implies a data format change which we plan to implement before 1.7 becomes generally available."
msgstr ""

#: ../doc/2.2/whats_new.rst:1541
msgid "Tab-based autocompletion in the interactive console, ``require('console').connect()``, ``tarantoolctl enter`` and ``tarantoolctl connect`` commands. Issues `86 <https://github.com/tarantool/tarantool/issues/86>`_ and `1790 <https://github.com/tarantool/tarantool/issues/1790>`_. Use the TAB key to auto complete the names of Lua variables, functions and meta-methods."
msgstr ""

#: ../doc/2.2/whats_new.rst:1548
msgid "A new implementation of ``net.box`` improving performance and solving problems when the Lua garbage collector handles dead connections. Issues `799 <https://github.com/tarantool/tarantool/issues/799>`_, `800 <https://github.com/tarantool/tarantool/issues/800>`_, `1138 <https://github.com/tarantool/tarantool/issues/1138>`_ and `1750 <https://github.com/tarantool/tarantool/issues/1750>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1554
msgid "memtx snapshots and xlog files are now compressed on the fly using the fast `ZStandard <https://github.com/facebook/zstd>`_ compression algorithm. Compression options are configured automatically to get an optimal trade-off between CPU utilization and disk throughput."
msgstr ""

#: ../doc/2.2/whats_new.rst:1558
msgid "``fiber.cond()`` - a new synchronization mechanism for cooperative multitasking. Issue `1731 <https://github.com/tarantool/tarantool/issues/1731>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1560
msgid "Tarantool can now be installed using universal Snappy packages (http://snapcraft.io/) with ``snap install tarantool --channel=beta``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1563
#: ../doc/2.2/whats_new.rst:1725
#: ../doc/2.2/whats_new.rst:1826
msgid "New rocks and packages:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1565
#: ../doc/2.2/whats_new.rst:1727
msgid "`curl <https://github.com/tarantool/tarantool-curl>`_ - non-blocking bindings for libcurl"
msgstr ""

#: ../doc/2.2/whats_new.rst:1566
#: ../doc/2.2/whats_new.rst:1728
msgid "`prometheus <https://github.com/tarantool/prometheus>`_ - Prometheus metric collector for Tarantool"
msgstr ""

#: ../doc/2.2/whats_new.rst:1567
msgid "`gis <https://github.com/tarantool/gis>`_ - a full-featured geospatial extension for Tarantool"
msgstr ""

#: ../doc/2.2/whats_new.rst:1568
msgid "`mqtt <https://github.com/tarantool/mqtt>`_ - an MQTT protocol client for Tarantool"
msgstr ""

#: ../doc/2.2/whats_new.rst:1569
#: ../doc/2.2/whats_new.rst:1731
msgid "`luaossl <https://github.com/tarantool/luaossl>`_ - the most comprehensive OpenSSL module in the Lua universe"
msgstr ""

#: ../doc/2.2/whats_new.rst:1571
msgid "Deprecated, removed features and minor incompatibilities:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1573
msgid "``num`` and ``str`` fields type names are deprecated, use ``unsigned`` and ``string`` instead. Issue `1534 <https://github.com/tarantool/tarantool/issues/1534>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1576
msgid "``space:inc()`` and ``space:dec()`` were removed (deprecated in 1.6.x) Issue `1289 <https://github.com/tarantool/tarantool/issues/1289>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1578
msgid "``fiber:cancel()`` is now asynchronous and doesn't wait for the fiber to end. Issue `1732 <https://github.com/tarantool/tarantool/issues/1732>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1580
msgid "Implicit error-prone ``tostring()`` was removed from ``digest`` API. Issue `1591 <https://github.com/tarantool/tarantool/issues/1591>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1582
#: ../doc/2.2/whats_new.rst:1698
msgid "Support for SHA-0 (``digest.sha()``) was removed due to OpenSSL upgrade."
msgstr ""

#: ../doc/2.2/whats_new.rst:1583
msgid "``net.box`` now uses one-based indexes for ``space.name.index[x].parts``. Issue `1729 <https://github.com/tarantool/tarantool/issues/1729>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1585
msgid "Tarantool binary now dynamically links with ``libssl.so`` during compile time instead of loading it at the run time."
msgstr ""

#: ../doc/2.2/whats_new.rst:1587
msgid "Debian and Ubuntu packages switched to use native ``systemd`` configuration alongside with old-fashioned ``sysvinit`` scripts."
msgstr ""

#: ../doc/2.2/whats_new.rst:1590
msgid "``systemd`` provides its own facilities for multi-instance management. To upgrade, perform the following steps:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1593
msgid "Install new 1.7.2 packages."
msgstr ""

#: ../doc/2.2/whats_new.rst:1594
msgid "Ensure that ``INSTANCENAME.lua`` file is present in ``/etc/tarantool/instace.enabled``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1595
#: ../doc/2.2/whats_new.rst:1747
msgid "Stop INSTANCENAME using ``tarantoolctl stop INSTANCENAME``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1596
#: ../doc/2.2/whats_new.rst:1748
msgid "Start INSTANCENAME using ``systemctl start tarantool@INSTANCENAME``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1597
#: ../doc/2.2/whats_new.rst:1749
msgid "Enable INSTANCENAME during system boot using ``systemctl enable trantool@INTANCENAME``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1598
msgid "Say ``systemctl disable tarantool; update-rc.d tarantool remove`` to disable sysvinit-compatible wrappers."
msgstr ""

#: ../doc/2.2/whats_new.rst:1601
msgid "Refer to issue `1291 <https://github.com/tarantool/tarantool/issues/1291>`_ comment and :ref:`the administration chapter <admin>` for additional information."
msgstr ""

#: ../doc/2.2/whats_new.rst:1604
msgid "Debian and Ubuntu packages start a ready-to-use ``example.lua`` instance on a clean installation of the package. The default instance grants universe permissions for ``guest`` user and listens on \"locahost:3313\"."
msgstr ""

#: ../doc/2.2/whats_new.rst:1608
#: ../doc/2.2/whats_new.rst:1701
msgid "Fedora 22 packages were deprecated (EOL)."
msgstr ""

#: ../doc/2.2/whats_new.rst:1612
msgid "**Release 1.7.1**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1614
msgid "Release type: alpha. Release date: 2016-07-11."
msgstr ""

#: ../doc/2.2/whats_new.rst:1616
msgid "Announcement: https://groups.google.com/forum/#!topic/tarantool/KGYj3VKJKb8"
msgstr ""

#: ../doc/2.2/whats_new.rst:1618
msgid "This is the first alpha in the 1.7 series. The main feature of this release is a new storage engine, called \"vinyl\". Vinyl is a write optimized storage engine, allowing the amount of data stored exceed the amount of available RAM 10-100x times. Vinyl is a continuation of the Sophia engine from 1.6, and effectively a fork and a distant relative of Dmitry Simonenko's Sophia. Sophia is superseded and replaced by Vinyl. Internally it is organized as a log structured merge tree. However, it takes a serious effort to improve on the traditional deficiencies of log structured storage, such as poor read performance and unpredictable write latency. A single index is range partitioned among many LSM data structures, each having its own in-memory buffers of adjustable size. Range partitioning allows merges of LSM levels to be more granular, as well as to prioritize hot ranges over cold ones in access to resources, such as RAM and I/O. The merge scheduler is designed to minimize write latency while ensuring read performance stays within acceptable limits. Vinyl today only supports a primary key index. The index can consist of up to 256 parts, like in MemTX, up from 8 in Sophia. Partial key reads are supported. Support of non-sequential multi part keys, as well as secondary keys is on the short term todo. Our intent is to remove all limitations currently present in Vinyl, making it a first class citizen in Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:1645
msgid "The disk-based storage engine, which was called ``sophia`` or ``phia`` in earlier versions, is superseded by the ``vinyl`` storage engine."
msgstr ""

#: ../doc/2.2/whats_new.rst:1647
msgid "There are new types for indexed fields."
msgstr ""

#: ../doc/2.2/whats_new.rst:1648
msgid "The LuaJIT version is updated."
msgstr ""

#: ../doc/2.2/whats_new.rst:1649
msgid "Automatic replica set bootstrap (for easier configuration of a new replica set) is supported."
msgstr ""

#: ../doc/2.2/whats_new.rst:1651
msgid "The ``space_object:inc()`` function is removed."
msgstr ""

#: ../doc/2.2/whats_new.rst:1652
msgid "The ``space_object:dec()`` function is removed."
msgstr ""

#: ../doc/2.2/whats_new.rst:1653
msgid "The ``space_object:bsize()`` function is added."
msgstr ""

#: ../doc/2.2/whats_new.rst:1654
msgid "The ``box.coredump()`` function is removed, for an alternative see :ref:`Core dumps <admin-core_dumps>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:1656
msgid "The ``hot_standby`` configuration option is added."
msgstr ""

#: ../doc/2.2/whats_new.rst:1657
msgid "Configuration parameters revised or renamed:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1659
msgid "``slab_alloc_arena`` (in gigabytes) to ``memtx_memory`` (in bytes),"
msgstr ""

#: ../doc/2.2/whats_new.rst:1660
msgid "``slab_alloc_minimal`` to ``memtx_min_tuple_size``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1661
msgid "``slab_alloc_maximal`` to ``memtx_max_tuple_size``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1662
msgid "``replication_source`` to ``replication``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1663
msgid "``snap_dir`` to ``memtx_dir``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1664
msgid "``logger`` to ``log``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1665
msgid "``logger_nonblock`` to ``log_nonblock``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1666
msgid "``snapshot_count`` to ``checkpoint_count``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1667
msgid "``snapshot_period`` to ``checkpoint_interval``,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1668
msgid "``panic_on_wal_error`` and ``panic_on_snap_error`` united under ``force_recovery``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1669
msgid "Until Tarantool 1.8, you can use :ref:`deprecated parameters <cfg_deprecated>` for both initial and runtime configuration, but Tarantool will display a warning. Also, you can specify both deprecated and up-to-date parameters, provided that their values are harmonized. If not, Tarantool will display an error."
msgstr ""

#: ../doc/2.2/whats_new.rst:1673
msgid "Automatic replication cluster bootstrap; it's now much easier to configure a new replication cluster."
msgstr ""

#: ../doc/2.2/whats_new.rst:1675
msgid "New indexable data types: INTEGER and SCALAR."
msgstr ""

#: ../doc/2.2/whats_new.rst:1676
msgid "Code refactoring and performance improvements."
msgstr ""

#: ../doc/2.2/whats_new.rst:1677
msgid "Updated LuaJIT to 2.1-beta116."
msgstr ""

#: ../doc/2.2/whats_new.rst:1683
msgid "Version 1.6"
msgstr ""

#: ../doc/2.2/whats_new.rst:1687
msgid "**Release 1.6.9**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1689
msgid "Release type: maintenance. Release date: 2016-09-27. Release tag: 1.6.9-4-gcc9ddd7."
msgstr ""

#: ../doc/2.2/whats_new.rst:1691
msgid "Since February 15, 2017, due to Tarantool issue#2040 `Remove sophia engine from 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_ there no longer is a storage engine named `sophia`. It will be superseded in version 1.7 by the `vinyl` storage engine."
msgstr ""

#: ../doc/2.2/whats_new.rst:1699
msgid "Tarantool binary now dynamically links with libssl.so during compile time instead of loading it at the run time."
msgstr ""

#: ../doc/2.2/whats_new.rst:1705
msgid "Tab-based autocompletion in the interactive console. Issue `86 <https://github.com/tarantool/tarantool/issues/86>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1707
msgid "LUA_PATH and LUA_CPATH environment variables taken into account, like in PUC-RIO Lua. Issue `1428 <https://github.com/tarantool/tarantool/issues/1428>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1709
msgid "Search for ``.dylib`` as well as for ``.so`` libraries in OS X. Issue `810 <https://github.com/tarantool/tarantool/issues/810>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1711
msgid "A new ``box.cfg { read_only = true }`` option to emulate master-slave behavior. Issue `246 <https://github.com/tarantool/tarantool/issues/246>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1713
msgid "``if_not_exists = true`` option added to box.schema.user.grant. Issue `1683 <https://github.com/tarantool/tarantool/issues/1683>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1715
msgid "``clock_realtime()``/``monotonic()`` functions added to the public C API. Issue `1455 <https://github.com/tarantool/tarantool/issues/1455>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1717
msgid "``space:count(key, opts)`` introduced as an alias for ``space.index.primary:count(key, opts)``. Issue `1391 <https://github.com/tarantool/tarantool/issues/13918>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1720
msgid "Upgrade script for 1.6.4 -> 1.6.8 -> 1.6.9. Issue `1281 <https://github.com/tarantool/tarantool/issues/1281>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1722
msgid "Support for OpenSSL 1.1. Issue `1722 <https://github.com/tarantool/tarantool/issues/1722>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1729
msgid "`gis <https://github.com/tarantool/gis>`_ - full-featured geospatial extension for Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:1730
msgid "`mqtt <https://github.com/tarantool/mqtt>`_ - MQTT protocol client for Tarantool"
msgstr ""

#: ../doc/2.2/whats_new.rst:1735
msgid "**Release 1.6.8**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1737
msgid "Release type: maintenance. Release date: 2016-02-25. Release tag: 1.6.8-525-ga571ac0."
msgstr ""

#: ../doc/2.2/whats_new.rst:1741
msgid "RPM packages for CentOS 7 / RHEL 7 and Fedora 22+ now use native systemd configuration without legacy sysvinit shell scripts. Systemd provides its own facilities for multi-instance management. To upgrade, perform the following steps:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1746
msgid "Ensure that ``INSTANCENAME.lua`` file is present in ``/etc/tarantool/instace.available``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1751
msgid "``/etc/tarantool/instance.enabled`` directory is now deprecated for systemd-enabled platforms."
msgstr ""

#: ../doc/2.2/whats_new.rst:1753
msgid "See :ref:`the administration chapter <admin>` for additional information."
msgstr ""

#: ../doc/2.2/whats_new.rst:1755
msgid "Sophia was upgraded to v2.1 to fix upsert, memory corruption and other bugs. Sophia v2.1 doesn't support old v1.1 data format. Please use Tarantool replication to upgrade. Issue `1222 <https://github.com/tarantool/tarantool/issues/1222>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1759
msgid "Ubuntu Vivid, Fedora 20, Fedora 21 were deprecated due to EOL."
msgstr ""

#: ../doc/2.2/whats_new.rst:1760
msgid "i686 packages were deprecated. Please use our RPM and DEB specs to build these on your own infrastructure."
msgstr ""

#: ../doc/2.2/whats_new.rst:1762
msgid "Please update your ``yum.repos.d`` and/or apt ``sources.list.d`` according to instructions at http://tarantool.org/download.html"
msgstr ""

#: ../doc/2.2/whats_new.rst:1767
msgid "Tarantool 1.6.8 fully supports ARMv7 and ARMv8 (aarch64) processors. Now it is possible to use Tarantool on a wide range of consumer devices, starting from popular Raspberry PI 2 to coin-size embedded boards and no-name mini-micro-nano-PCs. Issue `1153 <https://github.com/tarantool/tarantool/issues/1153>`_. (Also qemu works well, but we don't have real hardware to check.)"
msgstr ""

#: ../doc/2.2/whats_new.rst:1773
msgid "Tuple comparator functions were optimized, providing up to 30% performance boost when an index key consists of 2, 3 or more parts. Issue `969 <https://github.com/tarantool/tarantool/issues/969>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1776
msgid "Tuple allocator changes give another 15% performance improvement. Issue `1298 <https://github.com/tarantool/tarantool/issues/1298>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1778
msgid "Replication relay performance was improved by reducing the amount of data directory re-scans. Issue `11150 <https://github.com/tarantool/tarantool/issues/1150>`_"
msgstr ""

#: ../doc/2.2/whats_new.rst:1781
msgid "A random delay was introduced into snapshot daemon, reducing the chance that multiple instances take a snapshot at the same time. Issue `732 <https://github.com/tarantool/tarantool/issues/732>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1784
msgid "Sophia storage engine was upgraded to v2.1:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1786
msgid "serializable Snapshot Isolation (SSI),"
msgstr ""

#: ../doc/2.2/whats_new.rst:1787
msgid "RAM storage mode,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1788
msgid "anti-cache storage mode,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1789
msgid "persistent caching storage mode,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1790
msgid "implemented AMQ Filter,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1791
msgid "LRU mode,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1792
msgid "separate compression for hot and cold data,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1793
msgid "snapshot implementation for Faster Recovery,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1794
msgid "upsert reorganizations and fixes,"
msgstr ""

#: ../doc/2.2/whats_new.rst:1795
msgid "new performance metrics."
msgstr ""

#: ../doc/2.2/whats_new.rst:1797
msgid "Please note \"Incompatible changes\" above."
msgstr ""

#: ../doc/2.2/whats_new.rst:1799
msgid "Allow to remove servers with non-zero LSN from ``_cluster`` space. Issue `1219 <https://github.com/tarantool/tarantool/issues/1219>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1801
msgid "``net.box`` now automatically reloads space and index definitions. Issue `1183 <https://github.com/tarantool/tarantool/issues/1183>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1803
msgid "The maximal number of indexes in space was increased to 128. Issue `1311 <https://github.com/tarantool/tarantool/issues/1311>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1805
msgid "New native ``systemd`` configuration with support of instance management and daemon supervision (CentOS 7 and Fedora 22+ only). Please note \"Incompatible changes\" above. Issue `1264 <https://github.com/tarantool/tarantool/issues/1264>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1809
msgid "Tarantool package was accepted to the official Fedora repositories (https://apps.fedoraproject.org/packages/tarantool)."
msgstr ""

#: ../doc/2.2/whats_new.rst:1811
msgid "Tarantool brew formula (OS X) was accepted to the official Homebrew repository (http://brewformulas.org/tarantool)."
msgstr ""

#: ../doc/2.2/whats_new.rst:1813
msgid "Clang compiler support was added on FreeBSD. Issue `786 <https://github.com/tarantool/tarantool/issues/786>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1815
msgid "Support for musl libc, used by Alpine Linux and Docker images, was added. Issue `1249 <https://github.com/tarantool/tarantool/issues/1249>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1817
msgid "Added support for GCC 6.0."
msgstr ""

#: ../doc/2.2/whats_new.rst:1818
msgid "Ubuntu Wily, Xenial and Fedora 22, 23 and 24 are now supported distributions for which we build official packages."
msgstr ""

#: ../doc/2.2/whats_new.rst:1820
msgid "box.info.cluster.uuid can be used to retrieve cluster UUID. Issue `1117 <https://github.com/tarantool/tarantool/issues/1117>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1822
msgid "Numerous improvements in the documentation, added documentation for ``syslog``, ``clock``, ``fiber.storage`` packages, updated the built-in tutorial."
msgstr ""

#: ../doc/2.2/whats_new.rst:1828
msgid "Tarantool switched to a new Docker-based cloud build infrastructure The new buildbot significantly decreases commit-to-package time. The official repositories at http://tarantool.org now contain the latest version of the server, rocks and connectors. See http://github.com/tarantool/build"
msgstr ""

#: ../doc/2.2/whats_new.rst:1833
msgid "The repositories at http://tarantool.org/download.html were moved to http://packagecloud.io cloud hosting (backed by Amazon AWS). Thanks to packagecloud.io for their support of open source!"
msgstr ""

#: ../doc/2.2/whats_new.rst:1836
msgid "``memcached`` - memcached text and binary protocol implementation for Tarantool. Turns Tarantool into a persistent memcached with master-master replication. See https://github.com/tarantool/memcached"
msgstr ""

#: ../doc/2.2/whats_new.rst:1839
msgid "``migrate`` - a Tarantool rock for migration from Tarantool 1.5 to 1.6. See https://github.com/bigbes/migrate"
msgstr ""

#: ../doc/2.2/whats_new.rst:1841
msgid "``cqueues`` - a Lua asynchronous networking, threading, and notification framework (contributed by @daurnimator). PR `1204 <https://github.com/tarantool/tarantool/pull/1204>`_."
msgstr ""

#: ../doc/2.2/whats_new.rst:1847
msgid "**Release 1.6.7**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1849
msgid "Release type: maintenance. Release date: 2015-11-17."
msgstr ""

#: ../doc/2.2/whats_new.rst:1853
msgid "The syntax of ``upsert`` command has been changed and an extra ``key`` argument was removed from it. The primary key for look up is now always taken from the tuple, which is the second argument of upsert. ``upsert()`` was added fairly late at a release cycle and the design had an obvious bug which we had to fix. Sorry for this."
msgstr ""

#: ../doc/2.2/whats_new.rst:1859
msgid "``fiber.channel.broadcast()`` was removed since it wasn't used by anyone and didn't work properly."
msgstr ""

#: ../doc/2.2/whats_new.rst:1861
msgid "tarantoolctl ``reload`` command renamed to ``eval``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1865
msgid "``logger`` option now accepts a syntax for syslog output. Use uri-style syntax for file, pipe or syslog log destination."
msgstr ""

#: ../doc/2.2/whats_new.rst:1867
msgid "``replication_source`` now accepts an array of URIs, so each replica can have up to 30 peers."
msgstr ""

#: ../doc/2.2/whats_new.rst:1869
msgid "RTREE index now accept two types of ``distance`` functions: ``euclid`` and ``manhattan``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1871
msgid "``fio.abspath()`` - a new function in ``fio`` rock to convert a relative path to absolute."
msgstr ""

#: ../doc/2.2/whats_new.rst:1873
msgid "The process title now can be set with an on-board ``title`` rock."
msgstr ""

#: ../doc/2.2/whats_new.rst:1874
msgid "This release uses LuaJIT 2.1."
msgstr ""

#: ../doc/2.2/whats_new.rst:1878
msgid "``memcached`` - makes Tarantool understand Memcached binary protocol. Text protocol support is in progress and will be added to the rock itself, without changes to the server core."
msgstr ""

#: ../doc/2.2/whats_new.rst:1884
msgid "**Release 1.6.6**"
msgstr ""

#: ../doc/2.2/whats_new.rst:1886
msgid "Release type: maintenance. Release date: 2015-08-28."
msgstr ""

#: ../doc/2.2/whats_new.rst:1889
msgid "Tarantool 1.6 is no longer getting major new features, although it will be maintained. The developers are concentrating on Tarantool version 1.9."
msgstr ""

#: ../doc/2.2/whats_new.rst:1895
msgid "A new schema of ``_index`` system space which accommodates multi-dimensional RTREE indexes. Tarantool 1.6.6 works fine with an old snapshot and system spaces, but you will not be able to start Tarantool 1.6.5 with a data directory created by Tarantool 1.6.6, neither will you be able to query Tarantool 1.6.6 schema with 1.6.5 net.box."
msgstr ""

#: ../doc/2.2/whats_new.rst:1901
msgid "``box.info.snapshot_pid`` is renamed to ``box.info.snapshot_in_progress``"
msgstr ""

#: ../doc/2.2/whats_new.rst:1905
msgid "Threaded architecture for network. Network I/O has finally been moved to a separate thread, increasing single instance performance by up to 50%."
msgstr ""

#: ../doc/2.2/whats_new.rst:1908
msgid "Threaded architecture for checkpointing. Tarantool no longer forks to create a snapshot, but uses a separate thread, accessing data via a consistent read view. This eliminates all known latency spikes caused by snapshotting."
msgstr ""

#: ../doc/2.2/whats_new.rst:1913
msgid "Stored procedures in C/C++. Stored procedures in C/C++ provide speed (3-4 times, compared to a Lua version in our measurements), as well as unlimited extensibility power. Since C/C++ procedures run in the same memory space as the database, they are also an easy tool to corrupt database memory. See :ref:`The C API description <index-c_api_reference>`."
msgstr ""

#: ../doc/2.2/whats_new.rst:1920
msgid "Multidimensional RTREE index. RTREE index type now support a large (up to 32) number of dimensions. RTREE data structure has been optimized to actually use `R\\*-TREE <https://en.wikipedia.org/wiki/R*_tree>`_. We're working on further improvements of the index, in particular, configurable distance function. See https://github.com/tarantool/tarantool/wiki/R-tree-index-quick-start-and-usage"
msgstr ""

#: ../doc/2.2/whats_new.rst:1927
msgid "Sophia 2.1.1, with support of compression and multipart primary keys. See https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"
msgstr ""

#: ../doc/2.2/whats_new.rst:1930
msgid "New ``upsert`` command available in the binary protocol and in stored functions. The key advantage of upsert is that it's much faster with write-optimized storage (sophia storage engine), but some caveats exists as well. See Issue `905 <https://github.com/tarantool/tarantool/issues/905>`_ for details. Even though upsert performance advantage is most prominent with sophia engine, it works with all storage engines."
msgstr ""

#: ../doc/2.2/whats_new.rst:1937
msgid "Better memory diagnostics information for fibers, tuple and index arena Try a new command ``box.slab.stats()``, for detailed information about tuple/index slabs, ``fiber.info()`` now displays information about memory used by the fiber."
msgstr ""

#: ../doc/2.2/whats_new.rst:1941
msgid "Update and delete now work using a secondary index, if the index is unique."
msgstr ""

#: ../doc/2.2/whats_new.rst:1943
msgid "Authentication triggers. Set ``box.session.on_auth`` triggers to catch authentication events. Trigger API is improved to display all defined triggers, easily remove old triggers."
msgstr ""

#: ../doc/2.2/whats_new.rst:1946
msgid "Manifold performance improvements of ``net.box`` built-in package."
msgstr ""

#: ../doc/2.2/whats_new.rst:1947
msgid "Performance optimizations of BITSET index."
msgstr ""

#: ../doc/2.2/whats_new.rst:1948
msgid "``panic_on_wal_error`` is a dynamic configuration option now."
msgstr ""

#: ../doc/2.2/whats_new.rst:1949
msgid "iproto ``sync`` field is available in Lua as ``session.sync()``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1950
msgid "``box.once()`` - a new method to invoke code once in an instance and replica set lifetime. Use ``once()`` to set up spaces and uses, as well as do schema upgrade in production."
msgstr ""

#: ../doc/2.2/whats_new.rst:1954
msgid "``box.error.last()`` to return the last error in a session."
msgstr ""

#: ../doc/2.2/whats_new.rst:1958
msgid "``jit.*``, ``jit.dump``, ``jit.util``, ``jit.vmdef`` modules of LuaJIT 2.0 are now available as built-ins. See http://luajit.org/ext_jit.html"
msgstr ""

#: ../doc/2.2/whats_new.rst:1961
msgid "``strict`` built-in package, banning use of undeclared variables in Lua. Strict mode is on when Tarantool is compiled with debug. Turn on/off with ``require('strict').on()``/``require('strict').off()``."
msgstr ""

#: ../doc/2.2/whats_new.rst:1964
msgid "``pg`` and ``mysql`` rocks, available at http://rocks.tarantool.org - working with MySQL and PostgreSQL from Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:1966
msgid "``gperftools`` rock, availble at http://rocks.tarantool.org - getting perfromance data using Google's gperf from Tarantool."
msgstr ""

#: ../doc/2.2/whats_new.rst:1968
msgid "``csv`` built-in rock, to parse and load CSV (comma-separated values) data."
msgstr ""

#: ../doc/2.2/whats_new.rst:1971
msgid "New supported platforms:"
msgstr ""

#: ../doc/2.2/whats_new.rst:1973
msgid "Fedora 22, Ubuntu Vivid"
msgstr ""

