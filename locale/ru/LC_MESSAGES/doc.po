# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2019-03-18 11:56+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../doc/1.6/book/admin/backups.rst:39
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/1.6/book/admin/backups.rst:41
msgid ""
"Tarantool storage architecture is append-only: files are only appended "
"to, and are never overwritten. Old files are removed by garbage "
"collection after a checkpoint. You can configure the amount of past "
"checkpoints preserved by garbage collection by configuring Tarantool "
":ref:`snapshot daemon <book_cfg_snapshot_daemon>`. Backups can be taken "
"at any time, with minimal overhead on database performance."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:52
#, fuzzy
msgid "Hot backup (memtx)"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**\"Горячее\" резервирование**"

#: ../doc/1.6/book/admin/backups.rst:54
msgid "This is a special case when there are only in-memory tables."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:56
#, fuzzy
msgid ""
"The last snapshot file is a backup of the entire database; and the WAL "
"files that are made after the last snapshot are incremental backups. "
"Therefore taking a backup is a matter of copying the snapshot and WAL "
"files."
msgstr ""
"Суть процедуры: последний созданный Tarantool'ом файл-снимок является "
"резервной копией всей базы; а WAL-файлы, созданные следом, являются "
"инкрементными копиями. Поэтому вся процедура резервирования сводится к "
"копированию последнего файла-снимка и последующих WAL-файлов."

#: ../doc/1.6/book/admin/backups.rst:60
#, fuzzy
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and "
".xlog files on the :ref:`snap_dir <cfg_basic-snap_dir>` and :ref:`wal_dir"
" <cfg_basic-wal_dir>` directories."
msgstr ""
"С помощью :program:`tar` создайте сжатую (насколько это можно) копию "
"последнего :file:`.snap`-файла и последующих :file:`.xlog`-файлов из "
"директорий :ref:`snap_dir <cfg_basic-snap_dir>` и :ref:`wal_dir "
"<cfg_basic-wal_dir>`."

#: ../doc/1.6/book/admin/backups.rst:64
#, fuzzy
msgid "If there is a security policy, encrypt the .tar file."
msgstr ""
"Если того требуют правила безопасности, зашифруйте получившийся "
":file:`tar`-файл."

#: ../doc/1.6/book/admin/backups.rst:66
#, fuzzy
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте :file:`tar`-файл в надежное место."

#: ../doc/1.6/book/admin/backups.rst:68
#, fuzzy
msgid ""
"Later, restoring the database is a matter of taking the .tar file and "
"putting its contents back in the snap_dir and wal_dir directories."
msgstr ""
"... В дальнейшем вы сможете восстановить базу данных, просто взяв этот "
":file:`tar`-файл и разархивировав его содержимое в директории "
"``snap_dir`` и ``wal_dir``."

#: ../doc/1.6/book/admin/backups.rst:75
msgid "Hot backup (general idea)"
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:77
msgid "To take a backup, in general terms:"
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:79
msgid ""
"Issue ``box.backup.begin()`` on the administrative console. This will "
"suspend garbage collection till the next ``box.backup.end()`` and will "
"return a list of files to backup."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:83
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, at a state consistent with the last checkpoint."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:87
msgid "Resume garbage collection with ``box.backup.end()``."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:93
#, fuzzy
msgid "Continuous remote backup (memtx)"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Постоянное удаленное резервирование**"

#: ../doc/1.6/book/admin/backups.rst:95
msgid ""
"The :ref:`replication <index-box_replication>` feature is useful for "
"backup as well as for load balancing."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:98
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica "
"is up to date, and doing a cold backup on it. Since all the other "
"replicas continue to operate, this is not a cold backup from the end "
"user’s point of view. This could be done on a regular basis, with a "
"``cron`` job or with a Tarantool fiber."
msgstr ""

#: ../doc/1.6/book/admin/backups.rst:107
#, fuzzy
msgid "Continuous backup (memtx)"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Постоянное удаленное резервирование**"

#: ../doc/1.6/book/admin/backups.rst:109
#, fuzzy
msgid ""
"The logged changes done since the last cold backup must be secured, while"
" the system is running."
msgstr ""
"Суть процедуры: по ходу работы системы нужно сохранять записи об "
"изменениях, сделанных со времени последнего \"холодного\" резервирования."

#: ../doc/1.6/book/admin/backups.rst:112
#, fuzzy
msgid ""
"For this purpose, you need a file copy utility that will do the copying "
"remotely and continuously, copying only the parts of a write ahead log "
"file that are changing. One such utility is `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""
"Для этого вам понадобится специальная утилита для копирования частей "
"файлов (например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), "
"которая позволит удаленно и на постоянной основе копировать только "
"изменившиеся части файлов-снимков и WAL-файлов, а не все эти файлы "
"целиком."

#: ../doc/1.6/book/admin/backups.rst:117
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should "
"be frequent production of new snapshot files or new WAL files as changes "
"occur, so that only the new files need to be copied."
msgstr ""
"Вы можете взять и обычную утилиту (для копирования файлов целиком), но "
"тогда вам придется создавать файлы-снимки и WAL-файлы на каждое "
"изменение, чтобы нужно было копировать только новые файлы."

#: ../doc/1.6/book/admin/bug_reports.rst:39
msgid "Bug reports"
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:41
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the "
"time to tell us about it."
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:44
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage "
"you to include the following information:"
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:47
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs "
"from the expected behavior according to our manual. Please provide "
"specific unique information. For example, instead of \"I can’t get "
"certain information\", say \"box.space.x:delete() didn’t report what was "
"deleted\"."
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:52
msgid ""
"Your operating system name and version, the Tarantool name and version, "
"and any unusual details about your machine and its configuration."
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:55
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a "
"Tarantool :ref:`log file <admin-logs>`."
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:58
msgid ""
"If this is a feature request or if it affects a special category of "
"users, be sure to mention that."
msgstr ""

#: ../doc/1.6/book/admin/bug_reports.rst:61
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:39
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/1.6/book/admin/daemon_supervision.rst:45
#, fuzzy
msgid "Server signals"
msgstr "Обработка сигналов от сервера"

#: ../doc/1.6/book/admin/daemon_supervision.rst:47
#, fuzzy
msgid "Tarantool processes these signals during the main thread event loop:"
msgstr "Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:55
msgid "Signal"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:55
#: ../doc/1.6/book/box/box_schema.rst:69 ../doc/1.6/book/box/box_space.rst:243
#: ../doc/1.6/book/box/data_model.rst:597
msgid "Effect"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:57
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/1.6/book/admin/daemon_supervision.rst:57
#, fuzzy
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""
"может привести к ротации лога, см. :ref:`пример в разделе \"Запись в "
"журнал\" <cfg_logging-logging_example>`."

#: ../doc/1.6/book/admin/daemon_supervision.rst:61
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/1.6/book/admin/daemon_supervision.rst:61
#, fuzzy
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""
"может привести к сохранению снимка, см. описание функции "
":ref:`box.snapshot <admin-snapshot>`."

#: ../doc/1.6/book/admin/daemon_supervision.rst:64
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/1.6/book/admin/daemon_supervision.rst:64
#, fuzzy
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""
"может привести к корректному завершению работы (с предварительным "
"сохранением всех данных)."

#: ../doc/1.6/book/admin/daemon_supervision.rst:67
#, fuzzy
msgid "SIGINT (also known as keyboard interrupt)"
msgstr ""
"(или \"прерывание с клавиатуры\") может привести к корректному завершению"
" работы (с предварительным сохранением всех данных)."

#: ../doc/1.6/book/admin/daemon_supervision.rst:67
#, fuzzy
msgid "May cause graceful shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../doc/1.6/book/admin/daemon_supervision.rst:71
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/1.6/book/admin/daemon_supervision.rst:71
#, fuzzy
msgid "Causes an immediate shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../doc/1.6/book/admin/daemon_supervision.rst:74
msgid ""
"Other signals will result in behavior defined by the operating system. "
"Signals other than SIGKILL may be ignored, especially if Tarantool is "
"executing a long-running procedure which prevents return to the main "
"thread event loop."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:82
#, fuzzy
msgid "Automatic instance restart"
msgstr "Запуск экземпляров"

#: ../doc/1.6/book/admin/daemon_supervision.rst:84
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to "
"destroy an instance:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:88
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:99
#, fuzzy
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что :program:`systemd` перезапустила его:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:101
#, fuzzy
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../doc/1.6/book/admin/daemon_supervision.rst:106
#, fuzzy
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:108
#, fuzzy
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."
msgstr ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@example.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@example.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@example.service: Service hold-off time over, scheduling "
"restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found example.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."

#: ../doc/1.6/book/admin/daemon_supervision.rst:125
msgid "Core dumps"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:127
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool "
"crashes."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:130
#, fuzzy
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves "
"core dumps and stack traces in case of a crash. Here is a general \"how "
"to\" for how to enable core dumps on a Unix system:"
msgstr ""
"При аварийном завершении Tarantool-сервера, :program:`coredumpctl` "
"автоматически сохраняет дампы памяти (core dumps) и трассировку стека "
"(stack traces). Вот как работает этот механизм:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:134
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say "
"``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a "
"core dump may not be produced."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:138
msgid ""
"Set a directory for writing core dumps to, and make sure that the "
"directory is writable. On Linux, the directory path is set in a kernel "
"parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:142
msgid ""
"Make sure that core dumps include stack trace information. If you use a "
"binary Tarantool distribution, this is automatic. If you build Tarantool "
"from source, you will not get detailed information if you pass "
"``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:147
msgid ""
"To simulate a crash, you can execute an illegal command against a "
"Tarantool instance:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:150
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:157
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer "
"to it as $PID), you can abort a Tarantool instance by running ``gdb`` "
"debugger:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:160
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:164
msgid "or manually sending a SIGABRT signal:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:166
msgid "$ kill -SIGABRT $PID"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:172
msgid "To find out the process id of the instance ($PID), you can:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:174
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-"
"box_info>`,"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:176
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:178
#, fuzzy
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.6/book/admin/daemon_supervision.rst:180
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the "
"Tarantool daemon, say:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:183
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/1.6/book/admin/daemon_supervision.rst:190
msgid "To save a core dump into a file, say:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:192
#, fuzzy
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr ""
"Теперь введем :samp:`coredumpctl -o filename.core info <pid>`, чтобы "
"сохранить дамп памяти в отдельный файл."

#: ../doc/1.6/book/admin/daemon_supervision.rst:200
msgid "Stack traces"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:202
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack"
" trace\" or \"backtrace\"."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:206
msgid "To save a stack trace into a file, say:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:208
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:212
#: ../doc/1.6/book/admin/instance_config.rst:145
#: ../doc/1.6/reference/tarantoolctl.rst:48
msgid "where:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:214
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:215
msgid "\"core\" is the path to the core file, and"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:216
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the "
"stack trace."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:220
msgid ""
"Occasionally, you may find that the trace file contains output without "
"debug symbols – the lines will contain ”??” instead of names. If this "
"happens, check the instructions on these Tarantool wiki pages: `How to "
"debug core dump of stripped tarantool "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
"stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-"
"different-OS>`_."
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:227
#, fuzzy
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию, введем "
":samp:`coredumpctl info <pid>`:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:229
#, fuzzy
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../doc/1.6/book/admin/daemon_supervision.rst:268
msgid "Debugger"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:270
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:272
msgid "$ coredumpctl gdb <pid>"
msgstr ""

#: ../doc/1.6/book/admin/daemon_supervision.rst:276
#, fuzzy
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to "
"improve ``gdb`` experience, for example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы "
"сделать отладку средствами :program:`gdb` более эффективной. Например:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:279
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/1.6/book/admin/daemon_supervision.rst:283
#, fuzzy
msgid ""
"``gdb`` also provides information about the debuginfo packages you need "
"to install:"
msgstr ""
"С помощью :program:`gdb` вы можете узнать, какие еще ``debuginfo``-пакеты"
" нужно установить:"

#: ../doc/1.6/book/admin/daemon_supervision.rst:286
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/1.6/book/admin/daemon_supervision.rst:297
#, fuzzy
msgid ""
"Symbolic names are present in stack traces even if you don’t have "
"``tarantool-debuginfo`` package installed."
msgstr ""
"В трассировке стека используются символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../doc/1.6/book/admin/disaster_recovery.rst:39
msgid "Disaster recovery"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:41
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a replication"
" cluster that includes a master and a replica, or two masters."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:44
msgid ""
"The basic recommendation is to configure all Tarantool instances in a "
"cluster to create :ref:`checkpoint files <index-box_persistence>` at a "
"regular basis."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:47
msgid "Here follow action plans for typical crash scenarios."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:53
#, fuzzy
msgid "Master-replica"
msgstr "Репликация по схеме master-master"

#: ../doc/1.6/book/admin/disaster_recovery.rst:55
msgid "Configuration: One master and one replica."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:57
msgid "Problem: The master has crashed."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:59
#: ../doc/1.6/book/admin/disaster_recovery.rst:126
#, fuzzy
msgid "Your actions:"
msgstr "Операции"

#: ../doc/1.6/book/admin/disaster_recovery.rst:61
msgid ""
"Ensure the master is stopped for good. For example, log in to the master "
"machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:64
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` parameter to *false* and let the load be handled "
"by the replica (effective master)."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:68
msgid ""
"Set up a replacement for the crashed master on a spare host, with "
":ref:`replication_source <cfg_replication-replication_source>` parameter "
"set to replica (effective master), so it begins to catch up with the new "
"master’s state. The new instance should have :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` parameter set to *true*."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:74
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file "
"<index-box_persistence>`, which it may have not transferred to the "
"replica before crash. If you were able to salvage the master .xlog file, "
"you may be able to recover these. In order to do it:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:79
msgid ""
"Find out the position of the crashed master, as reflected on the new "
"master."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:81
msgid "Find out instance UUID from the crashed master xlog:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:83
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:88
msgid "On the new master, use the UUID to find the position:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:90
msgid ""
"tarantool>box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-"
"8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:97
msgid ""
"Play the records from the crashed .xlog to the new master, starting from "
"the new master position:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:100
msgid ""
"Issue this request locally at the new master's machine to find out "
"instance ID of the new master:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:103
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:110
msgid "Play the records to the new master:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:112
msgid ""
"$ tarantoolctl <new_master_uri> <xlog_file> play --from-lsn 23425 "
"--replica 1"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:120
#, fuzzy
msgid "Master-master"
msgstr "Репликация по схеме master-master"

#: ../doc/1.6/book/admin/disaster_recovery.rst:122
#, fuzzy
msgid "Configuration: Two masters."
msgstr "Параметры конфигурации"

#: ../doc/1.6/book/admin/disaster_recovery.rst:124
msgid "Problem: Master#1 has crashed."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:128
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:130
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-"
"disaster_recovery-master_replica>` recovery scenario to create a new "
"master and salvage lost data."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:138
msgid "Data loss"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:140
msgid "Configuration: Master-master or master-replica."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:142
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated"
" to the other node (master or replica)."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:145
msgid ""
"The following steps are applicable only to data in memtx storage engine. "
"Your actions:"
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:148
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"checkpointing with ``box.backup.begin()``. Disabling the checkpointing is"
" necessary to prevent automatic garbage collection of older checkpoints."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:152
msgid ""
"Get the latest valid .snap file and use ``tarantoolctl cat`` command to "
"calculate at which lsn the data loss occurred."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:155
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command "
"to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""

#: ../doc/1.6/book/admin/disaster_recovery.rst:158
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""

#: ../doc/1.6/book/admin/index.rst:39
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/1.6/book/admin/index.rst:41
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""

#: ../doc/1.6/book/admin/index.rst:43
msgid ""
"Here we show how to administer Tarantool instances using any of the "
"following utilities:"
msgstr ""

#: ../doc/1.6/book/admin/index.rst:46
msgid "``systemd`` native utilities, or"
msgstr ""

#: ../doc/1.6/book/admin/index.rst:47
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as "
"part of Tarantool distribution."
msgstr ""

#: ../doc/1.6/book/admin/index.rst:52
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""

#: ../doc/1.6/book/admin/index.rst:53
#, fuzzy
msgid "Console examples here are for Fedora."
msgstr "(здесь и далее мы приводим примеры консольного вывода для Fedora)."

#: ../doc/1.6/book/admin/index.rst:55
msgid "This chapter includes the following sections:"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:39
msgid "Instance configuration"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:41
msgid "For each Tarantool instance, you need two files:"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:43
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with "
"instance-specific logic. Put this file into the ``/usr/share/tarantool/``"
" directory."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:47
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as"
" a :ref:`Lua module <app_server-modules>` that bootstraps the database "
"and exports ``start()`` function for API calls):"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:51
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:63
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, "
"into the ``/etc/tarantool/instances.enabled`` directory."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:67
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we "
"load ``my_app.lua`` module and make a call to ``start()`` function from "
"that module):"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:87
#, fuzzy
msgid "Instance file"
msgstr "``instance_dir``"

#: ../doc/1.6/book/admin/instance_config.rst:89
msgid ""
"After this short introduction, you may wonder what an instance file is, "
"what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is"
" an application server, so why not start the application stored in "
"``/usr/share/tarantool`` directly?"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:94
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP"
" socket. This daemon needs to be started automatically when the operating"
" system starts, and managed with the operating system standard tools for "
"service management -- such as ``systemd`` or ``init.d``. To serve this "
"very purpose, we created **instance files**."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:101
msgid ""
"You can have more than one instance file. For example, a single "
"application in ``/usr/share/tarantool`` can run in multiple instances, "
"each of them having its own instance file. Or you can have multiple "
"applications in ``/usr/share/tarantool`` -- again, each of them having "
"its own instance file."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:106
msgid ""
"An instance file is typically created by a system administrator. An "
"application file is often provided by a developer, in a Lua rock or an "
"rpm/deb package."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:109
msgid ""
"An instance file is designed to not differ in any way from a Lua "
"application. It must, however, configure the database, i.e. contain a "
"call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, "
"because it’s the only way to turn a Tarantool script into a background "
"process, and ``tarantoolctl`` is a tool to manage background processes. "
"Other than that, an instance file may contain arbitrary Lua code, and, in"
" theory, even include the entire application business logic in it. We, "
"however, do not recommend this, since it clutters the instance file and "
"leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:123
#, fuzzy
msgid "`tarantoolctl` configuration file"
msgstr "``tarantoolctl connect``."

#: ../doc/1.6/book/admin/instance_config.rst:125
msgid ""
"While instance files contain instance configuration, ``tarantoolctl`` "
"configuration file contains the configuration that ``tarantoolctl`` uses "
"to override instance configuration. In other words, it contains system-"
"wide configuration defaults."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:130
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (installed to"
" ``/etc/default/tarantool`` as part of Tarantool distribution):"
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:134
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    snap_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/1.6/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will"
" add “/instance_name” to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл. Скрипт "
":program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени "
"директории."

#: ../doc/1.6/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/1.6/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся :file:`*.xlog`-файлы. Скрипт "
":program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени "
"директории."

#: ../doc/1.6/book/admin/instance_config.rst
msgid "``snap_dir``"
msgstr "``snap_dir``"

#: ../doc/1.6/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""
"Директория, где хранятся :file:`*.snap`-файлы. Скрипт "
":program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени "
"директории."

#: ../doc/1.6/book/admin/instance_config.rst
#, fuzzy
msgid "``log``"
msgstr "``logger``"

#: ../doc/1.6/book/admin/instance_config.rst
#, fuzzy
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add "
"\"/instance_name.log\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от "
"Tarantool-приложений. Скрипт :program:`tarantoolctl` добавляет \":samp"
":`/{instance-name}`\" к имени директории."

#: ../doc/1.6/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/1.6/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system "
"user name rather than the Tarantool-client user name. Tarantool will "
"change its effective user to this user after becoming a daemon."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/1.6/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put "
"instance files in this directory, or create symbolic links."
msgstr ""

#: ../doc/1.6/book/admin/instance_config.rst:172
msgid ""
"As a full-featured example, you can take `example.lua "
"<https://github.com/tarantool/tarantool/blob/1.6/extra/dist/example.lua>`_"
" script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:39
msgid "Logs"
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:41
msgid ""
"Tarantool logs important events to a file, e.g. "
"``/var/log/tarantool/my_app.log``. To build the log file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends “.log” extension."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:45
#, fuzzy
msgid "Let’s write something to the log file:"
msgstr "Давайте запишем что-нибудь в файл журнала:"

#: ../doc/1.6/book/admin/logs.rst:47
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:55
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/1.6/book/admin/logs.rst:57
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.6.9-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/105/snapshot_daemon I> started\n"
"2017-04-04 15:54:04.988 [29255] main/105/snapshot_daemon I> scheduled the"
" next snapshot at Tue Apr  4 17:43:16 2017\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'snapshot_period' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:75
msgid ""
"When logging to a file, the system administrator must ensure logs are "
"rotated timely and do not take up all the available disk space. With "
"``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` "
"program, which you must have installed."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:80
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This "
"is what this file is usually like:"
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:84
#, fuzzy, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"

#: ../doc/1.6/book/admin/logs.rst:99
msgid ""
"If you use a different log rotation program, you can invoke "
"``tarantoolctl logrotate`` command to request instances to reopen their "
"log files after they were moved by the program of your choice."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:105
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program "
"specified in the configuration file (see :ref:`logger <cfg_logging-"
"logger>` parameter)."
msgstr ""

#: ../doc/1.6/book/admin/logs.rst:108
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` "
"defaults. ``tarantoolctl`` automatically detects if an instance is using "
"``syslog`` or an external program for logging, and does not override the "
"log destination in this case. In such configurations, log rotation is "
"usually handled by the external program used for logging. So, "
"``tarantoolctl logrotate`` command works only if logging-into-file is "
"enabled in the instance file."
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:39
#, fuzzy
msgid "Notes for operating systems"
msgstr "Заметки для пользователей systemd"

#: ../doc/1.6/book/admin/os_notes.rst:45
msgid "Mac OS"
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:47
msgid ""
"On Mac OS, you can administer Tarantool instances only with "
"``tarantoolctl``. No native system tools are supported."
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:54
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/1.6/book/admin/os_notes.rst:56
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD,"
" use paths other than those suggested in :ref:`Instance configuration "
"<admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory,"
" use ``/usr/local/etc/tarantool/`` and create the following "
"subdirectories:"
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:62
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:63
msgid "``instances.available`` for all available instance files, and"
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:64
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:66
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr ""

#: ../doc/1.6/book/admin/os_notes.rst:68
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""

#: ../doc/1.6/book/admin/security.rst:39
msgid "Security"
msgstr ""

#: ../doc/1.6/book/admin/security.rst:41
msgid "Tarantool allows for two types of connections:"
msgstr ""

#: ../doc/1.6/book/admin/security.rst:43
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` "
"module, you can set up a port which can be used to open an administrative"
" console to the server. This is for administrators to connect to a "
"running instance and make requests. ``tarantoolctl`` invokes "
"``console.listen()`` to create a control socket for each started "
"instance."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:49
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box``"
" module, you can set up a binary port for connections which read and "
"write to the database or invoke stored procedures."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:53
#, fuzzy
msgid "When you connect to an admin console:"
msgstr "При установке соединение через порт для администрирования:"

#: ../doc/1.6/book/admin/security.rst:55
msgid "The client-server protocol is plain text."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:56
#, fuzzy
msgid "No password is necessary."
msgstr "Пароль не требуется"

#: ../doc/1.6/book/admin/security.rst:57
#, fuzzy
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает привилегии администратора."

#: ../doc/1.6/book/admin/security.rst:58
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:60
#, fuzzy
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If"
" it is a TCP port, it should only be opened for a specific IP. Ideally, "
"it should not be a TCP port at all, it should be a Unix domain socket, so"
" that access to the server machine is required. Thus a typical port setup"
" for admin console is:"
msgstr ""
"Поэтому порты для администрирования следует настраивать очень осторожно. "
"Если это TCP-порт, то он должен быть открыть только для определенного "
"IP-адреса. В идеале мы рекомендуем вовсе не использовать TCP-порты. "
"Вместо них лучше настроить доменный Unix-сокет, который требует настройки"
" прав доступа к серверной машине. Тогда типичная настройка порта для "
"администрирования будет выглядеть следующим образом:"

#: ../doc/1.6/book/admin/security.rst:65
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/1.6/book/admin/security.rst:69
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/1.6/book/admin/security.rst:71
#, fuzzy
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "admin:any_string@/var/lib/tarantool/socket_name.sock"

#: ../doc/1.6/book/admin/security.rst:75
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and "
"the connector has the privilege to read on ``/var/lib/tarantool``. "
"Alternatively, to connect to an admin console of an instance started with"
" ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-"
"executing_code_on_an_instance>`."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:80
#, fuzzy
msgid ""
"To find out whether a TCP port is a port for admin console, use "
"``telnet``. For example:"
msgstr ""
"Выяснить, является ли некий TCP-порт портом для администрирования, можно "
"с помощью :program:`telnet`. Например:"

#: ../doc/1.6/book/admin/security.rst:83
#, fuzzy
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.6.9 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"

#: ../doc/1.6/book/admin/security.rst:92
#, fuzzy
msgid ""
"In this example, the response does not include the word \"binary\" and "
"does include the words \"Lua console\". Therefore it is clear that this "
"is a successful connection to a port for admin console, and you can now "
"enter admin requests on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова "
"\"Lua console\". Это значит, что мы установили соединение на порту для "
"администрирования и можем вводить администраторские запросы на этом "
"терминале."

#: ../doc/1.6/book/admin/security.rst:97
#, fuzzy
msgid "When you connect to a binary port:"
msgstr "При установке соединение через порт для администрирования:"

#: ../doc/1.6/book/admin/security.rst:99
msgid ""
"The client-server protocol is :ref:`binary <box_protocol-"
"iproto_protocol>`."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:100
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:101
msgid "To change the user, it’s necessary to authenticate."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:103
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects "
"the type of connection during handshake and uses :ref:`EVAL "
"<box_protocol-eval>` binary protocol command when it’s necessary to "
"execute Lua commands over a binary connection. To execute EVAL, the "
"authenticated user must have global \"EXECUTE\" privilege."
msgstr ""

#: ../doc/1.6/book/admin/security.rst:109
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating "
"a Tarantool user with global \"EXECUTE\" privilege and non-empty password"
" can be used to provide a system administrator **remote** access to an "
"instance."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:39
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/1.6/book/admin/server_introspection.rst:45
#, fuzzy
msgid "Using Tarantool as a client"
msgstr "Использование tarantool в качестве клиента"

#: ../doc/1.6/book/admin/server_introspection.rst:47
msgid "Tarantool enters the interactive mode if:"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:49
msgid ""
"you start Tarantool without an :ref:`instance file <admin-"
"instance_file>`, or"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:52
#, fuzzy
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-"
"module>`, либо"

#: ../doc/1.6/book/admin/server_introspection.rst:54
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter "
"requests. When used this way, Tarantool can be a client for a remote "
"server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:58
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" "
"and \"connect\" commands."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:65
#, fuzzy
msgid "Executing code on an instance"
msgstr "Настройка конкретного экземпляра Tarantool-сервера:"

#: ../doc/1.6/book/admin/server_introspection.rst:67
#, fuzzy
msgid ""
"You can attach to an instance's admin console and execute some Lua code "
"using ``tarantoolctl``:"
msgstr ""
"Вы можете подсоединиться к запущенному экземпляру Tarantool-сервера и "
"выполнить некий Lua-скрипт с помощью утилиты :program:`tarantoolctl`:"

#: ../doc/1.6/book/admin/server_introspection.rst:70
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:86
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance "
"without attaching to its admin console. For example:"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:89
msgid ""
"# executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"$ # - OR -\n"
"# executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:101
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or "
"the :ref:`net.box <net_box-module>` module from a Tarantool server. Also,"
" you can write your client programs with any of the :ref:`connectors "
"<index-box_connectors>`. However, most of the examples in this manual "
"illustrate usage with either ``tarantoolctl connect`` or :ref:`using the "
"Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:112
msgid "Health checks"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:114
msgid "To check the instance status, say:"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:116
#, fuzzy
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"$ # - OR -\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"

#: ../doc/1.6/book/admin/server_introspection.rst:132
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:134
#, fuzzy
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"
msgstr ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found example.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"

#: ../doc/1.6/book/admin/server_introspection.rst:144
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:146
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify "
"all configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:149
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total"
" use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:152
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect "
"Tarantool server variables, primarily those related to replication)"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:155
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect "
"Tarantool request and network statistics)"
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:158
msgid ""
"You can also try `tarantool/prometheus "
"<https://github.com/tarantool/prometheus>`_, a Lua module that makes it "
"easy to collect metrics (e.g. memory usage or number of requests) from "
"Tarantool applications and databases and expose them via the Prometheus "
"protocol."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:163
#: ../doc/1.6/book/box/authentication.rst:253
#: ../doc/1.6/book/box/box_schema.rst:115
#: ../doc/1.6/book/box/box_session.rst:111
#: ../doc/1.6/book/box/box_session.rst:140
#: ../doc/1.6/book/box/box_session.rst:184
#: ../doc/1.6/book/box/box_session.rst:288 ../doc/1.6/book/box/triggers.rst:106
#, fuzzy
msgid "**Example**"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Примеры:**"

#: ../doc/1.6/book/admin/server_introspection.rst:165
msgid ""
"A very popular administrator request is :ref:`box.slab.info() "
"<box_slab_info>`, which displays detailed memory usage statistics for a "
"Tarantool instance."
msgstr ""

#: ../doc/1.6/book/admin/server_introspection.rst:168
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:39
#, fuzzy
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка конкретного экземпляра:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:41
msgid ""
"While a Lua application is executed by Tarantool, an instance file is "
"executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:44
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:46
#, fuzzy
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"

#: ../doc/1.6/book/admin/start_stop_instance.rst:50
msgid ""
"Read and parse the command line arguments. The last argument, in our "
"case, contains an instance name."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:53
msgid ""
"Read and parse its own configuration file. This file contains "
"``tarantoolctl`` defaults, like the path to the directory where instances"
" should be searched for."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:57
msgid ""
"The default ``tarantoolctl`` configuration file is installed in "
"``/etc/default/tarantool``. This file is used when ``tarantoolctl`` is "
"invoked by root. When invoked by a local user, ``tarantoolctl`` first "
"looks for its defaults file in the current directory "
"(``$PWD/.tarantoolctl``), and then in the current user’s home directory "
"(``$HOME/.config/tarantool/tarantool``). If not found, ``tarantoolctl`` "
"falls back to :ref:`built-in defaults <admin-tarantoolctl_config_file>`."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:65
msgid ""
"Look up the instance file in the instance directory, e.g. "
"``/etc/tarantool/instances.enabled``. To build the instance file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends \".lua\" extension to the instance file."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:70
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-"
"process its parameters and ensure that instance paths are pointing to the"
" paths defined in the ``tarantoolctl`` configuration file. For example, "
"if the configuration file specifies that instance work directory must be "
"in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` "
"ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in "
"``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of"
" what the path is set to in the instance file itself."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:79
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with "
"Lua console attached to it. This file is used later by ``tarantoolctl`` "
"to query the instance state, send commands to the instance and so on."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:83
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:85
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance"
" name is ``my_app``):"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:88
#, fuzzy
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool example.lua <running>"

#: ../doc/1.6/book/admin/start_stop_instance.rst:94
#, fuzzy
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl "
"start my_app``."
msgstr ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"

#: ../doc/1.6/book/admin/start_stop_instance.rst:97
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app``"
" instance, say:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:100
#, fuzzy
msgid "$ tarantoolctl check my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.6/book/admin/start_stop_instance.rst:104
#, fuzzy
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""
"Для автоматической загрузки экземпляра ``${MYAPP}`` во время запуска всей"
" системы используйте команду :samp:`systemctl enable tarantool@${MYAPP}`."

#: ../doc/1.6/book/admin/start_stop_instance.rst:106
#, fuzzy
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.6/book/admin/start_stop_instance.rst:110
msgid "To stop a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:112
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:118
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:120
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:130
#, fuzzy
msgid "Running Tarantool locally"
msgstr "Использование tarantool в качестве клиента"

#: ../doc/1.6/book/admin/start_stop_instance.rst:132
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test"
" purposes. Let's configure a local instance, then start and monitor it "
"with ``tarantoolctl``."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:136
msgid "First, we create a sandbox directory on the user's path:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:138
#, fuzzy
msgid "$ mkdir ~/tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../doc/1.6/book/admin/start_stop_instance.rst:142
msgid ""
"... and set default ``tarantoolctl`` configuration in "
"``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:145
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:157
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:159
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have "
"permissions to switch current user when invoked by a local user. The "
"instance will be running under 'admin'."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:163
#, fuzzy
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let "
"the file contents be:"
msgstr ""
"Создадим файл :file:`/tarantool_test/my_app.lua` для приложения "
"``my_app``:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:166
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../doc/1.6/book/admin/start_stop_instance.rst:182
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` "
"first:"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:184
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.6.9-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:201
#, fuzzy
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "С помощью :program:`tarantoolctl` запустим наше приложение..."

#: ../doc/1.6/book/admin/start_stop_instance.rst:203
#, fuzzy
msgid "$ tarantoolctl start my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.6/book/admin/start_stop_instance.rst:207
#, fuzzy
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""
"... и получим сообщения о том, что экземпляр нашего приложения запущен. "
"Затем скажем:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:209
#, fuzzy
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l /tarantool_test/my_app"

#: ../doc/1.6/book/admin/start_stop_instance.rst:213
#, fuzzy
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr "... и увидим :file:`.snap`-файл и :file:`.xlog`-файл. Затем скажем:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:215
#, fuzzy
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ sudo less /tarantool_test/log/my_app.log"

#: ../doc/1.6/book/admin/start_stop_instance.rst:219
#, fuzzy
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages,"
" if any. Then:"
msgstr ""
"... и увидим содержимое файла журнала для приложения ``my_app``, в т.ч. "
"сообщения об ошибках, если они были. Затем скажем:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:222
#, fuzzy
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ cd /tarantool_test\n"
"$ # допустим, что 'tarantool' запускает Tarantool-сервер\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.6/book/admin/start_stop_instance.rst:230
#, fuzzy
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr "... и увидим те несколько кортежей, которые создало приложение ``my_app``."

#: ../doc/1.6/book/admin/start_stop_instance.rst:232
#, fuzzy
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus "
"we say:"
msgstr ""
"Всё. Теперь остановим приложение ``my_app``. Единственный корректный "
"способ — это использовать :program:`tarantoolctl`:"

#: ../doc/1.6/book/admin/start_stop_instance.rst:234
#, fuzzy
msgid "$ tarantoolctl stop my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.6/book/admin/start_stop_instance.rst:238
msgid "Finally, we make a cleanup."
msgstr ""

#: ../doc/1.6/book/admin/start_stop_instance.rst:240
#, fuzzy
msgid "$ rm -R tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../doc/1.6/book/admin/upgrades.rst:39
#, fuzzy
msgid "Upgrades"
msgstr "Обновление сервера и базы данных"

#: ../doc/1.6/book/admin/upgrades.rst:45
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:47
msgid ""
"If you created a database with an older Tarantool version and have now "
"installed a newer version, make the request ``box.schema.upgrade()``. "
"This updates Tarantool system spaces to match the currently installed "
"version of Tarantool."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:51
#, fuzzy
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` "
"with a database created in early 2015. only a small part of the output is"
" shown."
msgstr ""
"Например, вот что происходит, если выполнить запрос "
":samp:`box.schema.upgrade()` для базы, созданной в начале 2015 года (для "
"примера показана лишь малая часть выводимых сообщений):"

#: ../doc/1.6/book/admin/upgrades.rst:54
#, fuzzy
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"num\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.6.9\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../doc/1.6/book/admin/upgrades.rst:69
#, fuzzy
msgid "Upgrading a Tarantool instance"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.6/book/admin/upgrades.rst:71
msgid ""
"Tarantool is backward compatible between two adjacent versions. For "
"example, you should have no or little trouble when upgrading from "
"Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 1.8. Meanwhile Tarantool "
"1.8 may have incompatible changes when migrating from Tarantool 1.6. to "
"1.8 directly."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:76
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in "
"production from 1.6.x to 1.7.x (or to 1.9.x, which is actually the "
"renamed 1.7 series). Notice that this will **always imply a downtime**. "
"To upgrade **without downtime**, you need several Tarantool servers "
"running in a replication cluster (see :ref:`below <admin-"
"upgrades_replication_cluster>`)."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:83
msgid ""
"Tarantool 1.7 has an incompatible .snap and .xlog file format: 1.6 files "
"are supported during upgrade, but you won’t be able to return to 1.6 "
"after running under 1.7 for a while. It also renames a few configuration "
"parameters, but old parameters are supported. The full list of breaking "
"changes is available in `release notes for Tarantool 1.7 / 1.9 "
"<https://github.com/tarantool/tarantool/releases>`_."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:89
msgid ""
"To upgrade from Tarantool 1.6 to 1.7 (or to 1.9.x, which is actually the "
"renamed 1.7 series):"
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:92
msgid ""
"Check with application developers whether application files need to be "
"updated due to incompatible changes (see `1.7 / 1.9 release notes "
"<https://github.com/tarantool/tarantool/releases>`_). If yes, back up the"
" old application files."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:97
msgid "Stop the Tarantool server."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:99
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in "
":ref:`Backups <admin-backups>`) and the package from which the current "
"(old) version was installed (for rollback purposes)."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:103
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:106
msgid ""
"Update the Tarantool database. Make the request ``box.schema.upgrade()``."
" This will create new system spaces, update data type names (e.g. num -> "
"unsigned, str -> string) and options in Tarantool system spaces."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:110
#, fuzzy
msgid "Update application files, if needed."
msgstr ""
"Произвести ротацию журналов указанного приложения (создать новые, удалить"
" старые)"

#: ../doc/1.6/book/admin/upgrades.rst:112
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or "
"``systemctl``."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:118
#, fuzzy
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в условиях эксплуатации"

#: ../doc/1.6/book/admin/upgrades.rst:120
msgid ""
"Tarantool 1.7 (as well as Tarantool 1.9) can work as a replica for "
"Tarantool 1.6 and vice versa. Replicas perform capability negotiation on "
"handshake, and new 1.7 replication features are not used with 1.6 "
"replicas. This allows upgrading clustered configurations."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:125
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and "
"works for any cluster configuration: master-master or master-replica."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:128
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master "
"cluster). See details in :ref:`Upgrading a Tarantool instance <admin-"
"upgrades_instance>`."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:132
msgid "Verify installation on the replicas:"
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:134
#, fuzzy
msgid "Start Tarantool."
msgstr "Утилита tarantoolctl"

#: ../doc/1.6/book/admin/upgrades.rst:136
msgid "Attach to the master and start working as before."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:138
msgid ""
"The master runs the old Tarantool version, which is always compatible "
"with the next major version."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:141
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:143
msgid "Verify master installation:"
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:145
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:147
msgid "Switch to master mode."
msgstr ""

#: ../doc/1.6/book/admin/upgrades.rst:149
msgid ""
"Upgrade the database on any master node in the cluster. Make the request "
"``box.schema.upgrade()``. This updates Tarantool system spaces to match "
"the currently installed version of Tarantool. Changes are propagated to "
"other nodes via the regular replication mechanism."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:39
msgid "Contributing a module"
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:41
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for "
"local usage <app_server-modules>`. Now let's discuss how to create a more"
" advanced Tarantool module and then get it published on `Tarantool rocks "
"page <http://tarantool.org/rocks.html>`_ and included in `official "
"Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:48
msgid ""
"To help our contributors, we have created `modulekit "
"<http://github.com/tarantool/modulekit>`_, a set of templates for "
"creating Tarantool modules in Lua and C."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:54
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` "
"package first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:57
#, fuzzy
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.6/book/app_server/contributing_module.rst:65
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:67
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:75
msgid "Contributing a module in C"
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:77
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than"
" in Lua. For example, to work with specific hardware or low-level system "
"interfaces."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:80
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""

#: ../doc/1.6/book/app_server/contributing_module.rst:86
msgid ""
"You can also create modules with C++, provided that the code does not "
"throw exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в "
"их коде не будут выбрасываться исключения."

#: ../doc/1.6/book/app_server/cookbook.rst:39
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../doc/1.6/book/app_server/cookbook.rst:41
msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:43
msgid ""
"You can execute any of these programs by copying the code into a ``.lua``"
" file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp"
":`./{program-name}.lua` on the terminal."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:47
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:49
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:53
msgid ""
"This runs  Tarantool Lua application server, which should be on the "
"execution path."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:56
msgid "Use freely."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:62
msgid "hello_world.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:64
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:66
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:76
msgid "console_start.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:78
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating "
"spaces) if this is the first time the server has been run. Then use "
":ref:`console.start() <console-start>` to start interactive mode."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:82
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'num'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:103
msgid "fio_read.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:105
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:107
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:125
msgid "fio_write.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:127
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:129
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:147
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:149
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:152
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:167
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:169
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C function: gettimeofday(). This delivers time with millisecond "
"precision, unlike the time function in Tarantool's :ref:`clock module "
"<clock-module>`."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:173
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:197
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:199
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C library function. (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:202
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:247
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:249
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access "
"a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:253
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:283
msgid "print_arrays.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:285
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator "
"function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is"
" recommended for map-like tables or mixed tables.) The display will look "
"like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2"
" v2\"."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:293
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:307
msgid "count_array.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:309
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua "
"table. This operation has O(log(N)) complexity."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:312
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:323
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:325
msgid ""
"Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple"
" \"#\" operator to deliver improper results. The \"print(#t)\" "
"instruction will print \"4\"; the \"print(counter)\" instruction will "
"print \"3\"; the \"print(max)\" instruction will print \"10\". Other "
"table functions, such as table.sort(), will also misbehave when \"nils\" "
"are present."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:333
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:353
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:355
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil =="
" missing value behavior. Although :code:`json.NULL == nil` is "
":code:`true`, all the print instructions in this program will print the "
"correct value: 10."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:360
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:383
msgid "count_map.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:385
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:387
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:400
msgid "swap.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:402
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third "
"variable."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:404
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:417
msgid "class.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:419
msgid ""
"Create a class, create a metatable for the class, create an instance of "
"the class. Another illustration is at `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:423
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:457
msgid "garbage.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:459
msgid ""
"Force Lua `garbage collection "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the "
"`collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-"
"collectgarbage>`_."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:462
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:472
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:474
msgid ""
"Start one fiber for producer and one fiber for consumer. Use "
":ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and "
"synchronize. One can tweak the channel size (:code:`ch_size` in the "
"program code) to control the number of simultaneous tasks waiting for "
"processing."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:479
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:533
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:535
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a "
"remote host via TCP. Display the connection details and the result of a "
"GET request."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:539
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:557
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:559
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple "
"TCP server, by creating a function that handles requests and echos them, "
"and passing the function to :ref:`socket.tcp_server() <socket-"
"tcp_server>`. This program has been used to test with 100,000 clients, "
"with each client getting a separate fiber."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:567
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:590
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:592
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-"
"blocking DNS resolution, getting both the AF_INET6 and AF_INET "
"information for 'google.com'. This technique is not always necessary for "
"tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` "
"performs `socket.getaddrinfo` under the hood, before trying to connect to"
" the first available address."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:600
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:620
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:622
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can "
"be implemented with sockets and fibers."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:627
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:676
msgid ""
"A function for a client that connects to this server could look something"
" like this ..."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:679
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:700
msgid "http_get.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:702
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to get data via "
"HTTP."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:705
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:723
msgid "http_send.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:725
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to send data via "
"HTTP."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:728
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:745
msgid "http_server.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:747
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool"
" into a web server."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:750
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:767
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:769
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks "
"(like PHP). Therefore there is no need to learn new languages in order to"
" write templates."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:775
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:788
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it"
" would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/1.6/book/app_server/cookbook.rst:791
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:39
#, fuzzy
msgid "Creating an application"
msgstr "Остановить приложение"

#: ../doc/1.6/book/app_server/creating_app.rst:41
msgid ""
"Further we walk you through key programming practices that will give you "
"a good start in writing Lua applications for Tarantool. For an adventure,"
" this is a story of implementing... a real microservice based on "
"Tarantool! We implement a backend for a simplified version of `Pokémon Go"
" <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented"
" reality game released in mid-2016. In this game, players use a mobile "
"device's GPS capability to locate, capture, battle and train virtual "
"monsters called \"pokémon\", who appear on the screen as if they were in "
"the same real-world location as the player."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:51
msgid ""
"To stay within the walk-through format, let's narrow the original "
"gameplay as follows. We have a map with pokémon spawn locations. Next, we"
" have multiple players who can send catch-a-pokémon requests to the "
"server (which runs our Tarantool microservice). The server replies "
"whether the pokémon is caught or not, increases the player's pokémon "
"counter if yes, and triggers the respawn-a-pokémon method that spawns a "
"new pokémon at the same location in a while."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:59
msgid ""
"We leave client-side applications outside the scope of this story. Yet we"
" promise a mini-demo in the end to simulate real users and give us some "
"fun. :-)"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:65
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:71
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:73
msgid ""
"To make our game logic available to other developers and Lua "
"applications, let's put it into a Lua module."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:76
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which "
"enhances Tarantool functionality. So, we can install our logic as a "
"module in Tarantool and use it from any Tarantool application or module. "
"Like applications, modules in Tarantool can be written in Lua (rocks), C "
"or C++."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:81
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:83
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:84
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:86
msgid ""
"Technically, a module is a file with source code that exports its "
"functions in an API. For example, here is a Lua module named "
"``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:90
#, fuzzy
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../doc/1.6/book/app_server/creating_app.rst:98
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as "
"a file, then load this module with the ``require()`` directive and call "
"the exported function."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:102
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from"
" ``mymodule.lua`` module:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:105
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:115
msgid ""
"A thing to remember here is that the ``require()`` directive takes load "
"paths to Lua modules from the ``package.path`` variable. This is a "
"semicolon-separated string, where a question mark is used to interpolate "
"the module name. By default, this variable contains system-wide Lua paths"
" and the working directory. But if we put our modules inside a specific "
"folder (e.g. ``scripts/``), we need to add this folder to "
"``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:122
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:126
msgid ""
"For our microservice, a simple and convenient solution would be to put "
"all methods in a Lua module (say ``pokemon.lua``) and to write a Lua "
"application (say ``game.lua``) that initializes the gaming environment "
"and starts the game loop."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:134
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:136
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn "
"locations; in this version of the game, let a location be a rectangle "
"identified with two points, upper-left and lower-right;"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:139
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's "
"location point;"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:141
msgid ""
"**pokémon**, which has the same fields as the player, plus a status "
"(active/inactive, that is present on the map or not) and a catch "
"probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:145
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver "
"our backend application as a microservice, the good practice would be to "
"send/receive our data in the universal JSON format, thus using Tarantool "
"as a document storage."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:153
msgid "Avro schemas"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:155
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which "
"reduces data footprint and ensures all stored documents are valid. We "
"will use Tarantool module `avro-schema <https://github.com/tarantool"
"/avro-schema>`_ which checks the schema of a JSON document and converts "
"it to a Tarantool tuple. The tuple will contain only field values, and "
"thus take a lot less space than the original document. In avro-schema "
"terms, converting JSON documents to tuples is \"flattening\", and "
"restoring the original documents is \"unflattening\". The usage is quite "
"straightforward:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:164
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema "
"<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
"entity's fields with their names and :ref:`Lua types <index-box_data-"
"types>`."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:168
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects "
"in memory for all schema entities, and ``compile()`` that generates "
"flatten/unflatten methods for each entity."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:171
msgid ""
"Further on, we just call flatten/unflatten methods for a respective "
"entity on receiving/sending the entity's data."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:174
msgid ""
"Here's what our schema definitions for the player and pokémon entities "
"look like:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:176
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:221
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:223
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:246
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for "
"it, because we have only one map in the game, it has very few fields, and"
" -- which is most important -- we use the map only inside our logic, "
"never exposing it to external users."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:254
msgid ""
"Next, we need methods to implement the game logic. To simulate object-"
"oriented programming in our Lua code, let's store all Lua functions and "
"shared variables in a single local variable (let's name it as ``game``). "
"This will allow us to address functions or variables from within our "
"module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:260
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:279
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object"
" fields, and local functions as object methods."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:284
#, fuzzy
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** "
"variables with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода "
"используются *локальные* переменные. Будьте аккуратны, если в своих "
"модулях вы будете использовать *глобальные* переменные, поскольку "
"пользователи ваших модулей могут не знать об этих переменных."

#: ../doc/1.6/book/app_server/creating_app.rst:287
msgid ""
"To enable/disable the use of undeclared global variables in your Lua "
"code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:290
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:292
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the "
"coordinates of both the player and pokémon, this method will apply a "
"probability factor, so not every pokémon within the player's reach will "
"be caught);"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:296
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds "
"(we assume that a frightened pokémon runs away, so we remove a pokémon "
"from the map on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:299
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 "
"caught pokémon A\");"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:301
msgid ""
"``start()`` to initialize the game (it will create database spaces, "
"create and compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:304
msgid ""
"Besides, it would be convenient to have methods for working with "
"Tarantool storage. For example:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:307
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:308
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:310
msgid ""
"We'll need these two methods primarily when initializing our game, but we"
" can also call them later, for example to test our code."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:317
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:319
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to "
"populate Tarantool spaces with pokémon data. Why not keep all game data "
"in memory? Why use a database? The answer is: :ref:`persistence <index-"
"box_persistence>`. Without a database, we risk losing data on power "
"outage, for example. But if we store our data in an in-memory database, "
"Tarantool takes care to persist it on disk whenever it's changed. This "
"gives us one more benefit: quick startup in case of failure. Tarantool "
"has a :ref:`smart algorithm <internals-recovery_process>` that quickly "
"loads all data from disk into memory on startup, so the warm-up takes "
"little time."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:329
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
"module:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:331
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named "
"``pokemon`` for storing information about pokémons (we don't create a "
"similar space for players, because we intend to only send/receive player "
"information via API calls, so we needn't store it);"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:335
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'num'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:337
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:340
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon "
"ID is the first field in a Tarantool tuple since it’s the first member of"
" the respective Avro type. So does the pokémon status. The actual JSON "
"document may have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:345
#, fuzzy
msgid "The implementation of ``start()`` method looks like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../doc/1.6/book/app_server/creating_app.rst:347
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'num'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:385
msgid "GIS"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:387
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming "
"logic."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:389
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID "
"number, and we need to answer whether the player has actually caught the "
"pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:393
msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have"
" the active status):"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:398
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:422
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:424
msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:427
msgid ""
"To keep things simple, we don't load any specific map, assuming that we "
"deal with a world map. And we do not validate incoming coordinates, "
"assuming again that all received locations are within the planet Earth."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:431
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:433
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic "
"System standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically,"
" it comprises a standard coordinate system for the Earth and represents "
"the Earth as an ellipsoid."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:437
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on"
" WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:442
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, "
"where each system has a unique number. In our code, we assign these "
"listing numbers to respective variables:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:446
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:451
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch "
"it. Let's set the distance to 100 meters."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:455
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:459
msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the "
"pokémon (here we generate some random value and let the pokémon escape if"
" the random value happens to be less than 100 minus pokémon's chance "
"value):"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:466
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:495
#, fuzzy
msgid "Index iterators"
msgstr "Операции с индексами"

#: ../doc/1.6/book/app_server/creating_app.rst:497
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do "
"this for all pokémons on the map every 60 seconds using ``respawn()`` "
"method. We iterate through pokémons by status using Tarantool index "
"iterator function :ref:`index:pairs <box_index-index_pairs>` and reset "
"the statuses of all \"caught\" pokémons back to \"active\" using "
"``box.space.pokemons:update()``."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:503
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:516
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:518
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:521
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:523
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'num'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:563
msgid "Fibers"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:565
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But"
" we need to execute ``respawn()`` every 60 seconds. Creating a "
":ref:`fiber <fiber-module>` is the Tarantool way of making application "
"logic work in the background at all times."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:571
msgid ""
"A **fiber** is a lightweight **thread**. The key difference is that "
"threads use preemptive multitasking, while fibers use cooperative "
"multitasking. This gives fibers the following two advantages over "
"threads:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:575
msgid ""
"Better controllability. Threads often depend on the kernel's thread "
"scheduler to preempt a busy thread and resume another thread, so "
"preemption may occur unpredictably. Fibers yield themselves to run "
"another fiber while executing, so yields are controlled by application "
"logic."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:579
msgid ""
"Higher performance. Threads require more resources to preempt as they "
"need to address the system kernel. Fibers are lighter and faster as they "
"don't need to address the kernel to yield."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:583
msgid ""
"Yet fibers have some limitations as compared with threads, the main "
"limitation being no multi-core mode. All fibers in an application belong "
"to a single thread, so they all use the same CPU core as the parent "
"thread. Meanwhile, this limitation is not really serious for Tarantool "
"applications, because a typical bottleneck for Tarantool is the HDD, not "
"the CPU."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:589
msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use"
" of fibers is recommended."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:596
msgid ""
"Well, performance or controllability are of little importance in our "
"case. We'll launch ``respawn()`` in a fiber to make it work in the "
"background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:600
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:618
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:620
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:640
#: ../doc/1.6/reference/configuration/index.rst:260
msgid "Logging"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:642
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` "
"from Tarantool :ref:`log <log-module>` module. We also need this function"
" in ``notify()`` to add a record to the log file on every successful "
"catch:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:646
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:653
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see "
"the log output in console when we launch our application in script mode."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:659
msgid ""
"Great! We've discussed all programming practices used in our Lua module "
"(see `pokemon.lua "
"<https://github.com/tarantool/pokemon/blob/1.6/src/pokemon.lua>`_)."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:662
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua "
"application (see `game.lua "
"<https://github.com/tarantool/pokemon/blob/1.6/game.lua>`_) to initialize"
" Tarantool's database module, initialize our game, call the game loop and"
" simulate a couple of player requests."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:667
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and "
"``game.lua`` application in the current directory, install all external "
"modules, and launch the Tarantool instance running our ``game.lua`` "
"application (this example is for Ubuntu):"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:672
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:680
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes "
"the demo logic from ``game.lua``: adds a pokémon named Pikachu (its "
"chance to be caught is very high, 99.1), displays the current map (it "
"contains one active pokémon, Pikachu) and processes catch requests from "
"two players. Player1 is located just near the lonely Pikachu pokémon and "
"Player2 is located far away from it. As expected, the catch results in "
"this output are \"true\" for Player1 and \"false\" for Player2. Finally, "
"Tarantool displays the current map which is empty, because Pikachu is "
"caught and temporarily inactive:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:689
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.6.9-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:714
msgid "nginx"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:716
msgid ""
"In the real life, this microservice would work over HTTP. Let's add "
"`nginx <https://nginx.org/en/>`_ web server to our environment and make a"
" similar demo. But how do we make Tarantool methods callable via REST "
"API? We use nginx with `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ module and create "
"one more Lua script (`app.lua "
"<https://github.com/tarantool/pokemon/blob/1.6/src/app.lua>`_) that "
"exports three of our game methods -- ``add_pokemon()``, ``map()`` and "
"``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:725
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:754
msgid ""
"An easy way to configure and launch nginx would be to create a Docker "
"container based on a `Docker image <https://hub.docker.com/r/tarantool"
"/tarantool-nginx/>`_ with nginx and the upstream module already installed"
" (see `http/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.6/http/Dockerfile>`_). We "
"take a standard `nginx.conf "
"<https://github.com/tarantool/pokemon/blob/1.6/http/nginx.conf>`_, where "
"we define an upstream with our Tarantool backend running (this is another"
" Docker container, see details below):"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:763
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:770
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the "
"upstream module's `README "
"<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:774
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:800
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second "
"Docker container based on the `official Tarantool 1.6 image "
"<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.6/src/Dockerfile>`_) and set"
" the container's default command to ``tarantool app.lua``. This is the "
"backend."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:809
msgid "Non-blocking IO"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:811
msgid ""
"To test the REST API, we create a new script (`client.lua "
"<https://github.com/tarantool/pokemon/blob/1.6/client/client.lua>`_), "
"which is similar to our ``game.lua`` application, but makes HTTP POST and"
" GET requests rather than calling Lua functions:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:816
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:891
msgid ""
"When you run this script, you’ll notice that both players have equal "
"chances to make the first attempt at catching the pokémon. In a classical"
" Lua script, a networked call blocks the script until it’s finished, so "
"the first catch attempt can only be done by the player who entered the "
"game first. In Tarantool, both players play concurrently, since all "
"modules are integrated with Tarantool :ref:`cooperative multitasking "
"<atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:899
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block."
" The fiber running ``catch()`` function on behalf of Player1 issues a "
"non-blocking call to the operating system and yields control to the next "
"fiber, which happens to be the fiber of Player2. Player2’s fiber does the"
" same. When the network response is received, Player1's fiber is "
"activated by Tarantool cooperative scheduler, and resumes its work. All "
"Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are "
"integrated with Tarantool cooperative scheduler. For module developers, "
"Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:908
msgid ""
"For our HTTP test, we create a third container based on the `official "
"Tarantool 1.6 image <https://github.com/tarantool/docker>`_ (see "
"`client/Dockerfile "
"<https://github.com/tarantool/pokemon/blob/1.6/client/Dockerfile>`_) and "
"set the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:916
msgid ""
"To run this test locally, download our `pokemon "
"<https://github.com/tarantool/pokemon>`_ project from GitHub (branch 1.6)"
" and say:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:919
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:924
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` "
"(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You"
" can see log messages from all these containers in the console, pclient "
"saying that it made an HTTP request to create a pokémon, made two catch "
"requests, requested the map (empty since the pokémon is caught and "
"temporarily inactive) and exited:"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:930
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:943
msgid ""
"Congratulations! Here's the end point of our walk-through. As further "
"reading, see more about :ref:`installing <app_server-installing_module>` "
"and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/1.6/book/app_server/creating_app.rst:947
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and "
":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua "
"cookbook recipes <cookbook>`."
msgstr ""

#: ../doc/1.6/book/app_server/index.rst:39
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/1.6/book/app_server/index.rst:41
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a "
"Lua application server."
msgstr ""

#: ../doc/1.6/book/app_server/index.rst:44 ../doc/1.6/book/box/index.rst:44
#: ../doc/1.6/book/getting_started/index.rst:44
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:39
#, fuzzy
msgid "Installing a module"
msgstr "Установка существующего модуля"

#: ../doc/1.6/book/app_server/installing_module.rst:41
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:44
msgid "Tarantool modules repository, and"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:45
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:51
msgid "Installing a module from a repository"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:53
#, fuzzy
msgid ""
"See `README in tarantool/rocks repository "
"<https://github.com/tarantool/rocks#managing-modules-with-"
"tarantool-168>`_ for detailed instructions."
msgstr ""
"Далее на странице `репозитория \"tarantool/rocks\" на GitHub "
"<https://github.com/tarantool/rocks>`_ вы можете посмотреть примеры "
"модулей и инструкции по добавлению собственных модулей в общий "
"репозиторий."

#: ../doc/1.6/book/app_server/installing_module.rst:61
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:63
msgid "Follow these steps:"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:65
msgid ""
"Install Tarantool as recommended on the `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:68
msgid ""
"Install the module you need. Look up the module's name on `Tarantool "
"rocks page <http://tarantool.org/rocks.html>`_ and put the prefix "
"\"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:72
msgid ""
"# for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"# for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:80
msgid ""
"For example, to install the module `shard "
"<http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:83
#, fuzzy
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.6/book/app_server/installing_module.rst:87
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/1.6/book/app_server/installing_module.rst:89
#, fuzzy
msgid "load any module with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../doc/1.6/book/app_server/installing_module.rst:91
msgid "tarantool> local-name = require('module-name')"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:95
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or "
"``package.cpath`` (C):"
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:98
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/1.6/book/app_server/installing_module.rst:118
#, fuzzy
msgid ""
"Question-marks stand for the module name that was specified earlier when "
"saying ``require('module-name')``."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при "
"вызове :extsamp:`require('{*{имя_модуля}*}')`."

#: ../doc/1.6/book/app_server/launching_app.rst:39
#, fuzzy
msgid "Launching an application"
msgstr "Остановить приложение"

#: ../doc/1.6/book/app_server/launching_app.rst:41
msgid ""
"Using Tarantool as an application server, you can write your own "
"applications. Tarantool’s native language for writing applications is "
"`Lua <http://www.lua.org/about.html>`_, so a typical application would be"
" a file that contains your Lua script. But you can also write "
"applications in C or C++."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:49
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool "
"tutorial before proceeding with this chapter. To launch the tutorial, say"
" ``tutorial()`` in Tarantool console:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:53
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:68
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a"
" simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:71
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:76
msgid "We save it in a file (let it be ``myapp.lua`` in the current directory)."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:78
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:84
msgid "Launching in Docker"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:86
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-"
"using_docker>`, the following command will start Tarantool without any "
"application:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:89
msgid ""
"# create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:94
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:96
msgid ""
"# create a temporary container and\n"
"# launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:105
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:107
msgid "our application file (``\\`pwd\\`/myapp.lua``) and"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:108
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:110
msgid ""
"By convention, the directory for Tarantool application code inside a "
"container is ``/opt/tarantool``, and the directory for data is "
"``/var/lib/tarantool``."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:117
msgid "Launching a binary program"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:119
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-"
"using_binary>` or from a :ref:`source build <building_from_source>`, we "
"can launch our application:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:123
msgid "in the script mode,"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:124
#, fuzzy
msgid "as a server application, or"
msgstr "Репликация по схеме master-master"

#: ../doc/1.6/book/app_server/launching_app.rst:125
msgid "as a daemon service."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:127
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:135
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:137
msgid ""
"Now let’s turn this script into a **server application**. We use "
":ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua "
"module to:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:141
msgid ""
"launch the database (a database has a persistent on-disk state, which "
"needs to be restored after we start an application) and"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:143
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:145
msgid ""
"We also add some simple database logic, using :ref:`space.create() "
"<box_schema-space_create>` and :ref:`create_index() <box_space-"
"create_index>` to create a space with a primary index. We use the "
"function :ref:`box.once() <box-once>` to make sure that our logic will be"
" executed only once when the database is initialized for the first time, "
"so we don't try to create an existing space or index on each invocation "
"of the script:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:166
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:185
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:195
msgid ""
"But the Tarantool instance will stop if we close the current terminal "
"window. To detach Tarantool and our application from the terminal window,"
" we can launch it in the **daemon mode**. To do so, we add some "
"parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:199
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:201
msgid ""
":ref:`logger <cfg_logging-logger>` = ``'dir-name'`` that tells the "
"Tarantool daemon where to store its log file (other log settings are "
"available in Tarantool :ref:`log <log-module>` module), and"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:204
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the "
"Tarantool daemon where to store its pid file."
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:207
#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:25
#: ../doc/1.6/reference/reference_lua/box_error.rst:72
#: ../doc/1.6/reference/reference_rock/dbms.rst:116
#: ../doc/1.6/reference/reference_rock/dbms.rst:469
msgid "For example:"
msgstr "Например:"

#: ../doc/1.6/book/app_server/launching_app.rst:209
msgid ""
"box.cfg {\n"
"   listen = 3301,\n"
"   background = true,\n"
"   logger = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:218
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:226
msgid ""
"Tarantool executes our script, gets detached from the current shell "
"session (you won't see it with ``ps | grep \"tarantool\"``) and continues"
" working in the background as a daemon attached to the global session "
"(with SID = 0):"
msgstr ""

#: ../doc/1.6/book/app_server/launching_app.rst:236
msgid ""
"Now that we have discussed how to create and launch a Lua application for"
" Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:39
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/1.6/book/box/atomic.rst:41
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. "
"That is why Tarantool has a guarantee of execution atomicity. That "
"requires emphasis."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:49
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:51
#, fuzzy
msgid ""
"How does Tarantool process a basic operation? As an example, let's take "
"this query:"
msgstr ""
"Как Tarantool выполняет основные операции? Давайте рассмотрим это на "
"следующем примере:"

#: ../doc/1.6/book/box/atomic.rst:53
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.6/book/box/atomic.rst:57
#, fuzzy
msgid "This is equivalent to an SQL statement like:"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../doc/1.6/book/box/atomic.rst:59
#, fuzzy
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[[1]\" = 3"

#: ../doc/1.6/book/box/atomic.rst:63
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:65
msgid ""
"If we issue the query on a remote client, then the **network thread** on "
"the server side receives the query, parses the statement and changes it "
"to a server executable message which has already been checked, and which "
"the server instance can understand without parsing everything again."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:70
msgid ""
"The network thread ships this message to the instance's **\"transaction "
"processor\" thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing "
"and preparation."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:75
#, fuzzy
msgid ""
"The instance's transaction processor thread uses the primary-key index on"
" field[1] to find the location of the tuple. It determines that the tuple"
" can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""
"Поток, выполняющий обработку транзакций на стороне сервера, использует "
"первичный индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он"
" проверяет, что данный кортеж можно обновить (мы хотим лишь изменить "
"значение не индексированного поля, и вряд ли что-то пойдет не так в таком"
" простом случае)."

#: ../doc/1.6/book/box/atomic.rst:80
msgid ""
"The transaction processor thread sends a message to the **write-ahead "
"logging (WAL) thread** to commit the transaction. When done, the WAL "
"thread replies with a COMMIT or ROLLBACK result, which is returned to the"
" client."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:85
#, fuzzy
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while "
"thread #2 writes row #y. With Tarantool, no such thing ever happens. Only"
" the transaction processor thread can access the database, and there is "
"only one transaction processor thread for each Tarantool instance."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В Tarantool'е есть только один поток обработки транзакций. Многие люди "
"уже привыкли к мысли, что потоков для обработки данных может быть много "
"(например, поток #1 читает данные из строки #x, в то время как поток #2 "
"записывает данные в столбец #y). В случае с Tarantool'ом такого не "
"происходит. доступ к базе есть только у потока обработки транзакций, и на"
" каждый экземпляр Tarantool'а есть только один такой поток."

#: ../doc/1.6/book/box/atomic.rst:92
#, fuzzy
msgid ""
"Like any other Tarantool thread, the transaction processor thread can "
"handle many **fibers**. A fiber is a set of computer instructions that "
"may contain \"**yield**\" signals. The transaction processor thread will "
"execute all computer instructions until a yield, then switch to execute "
"the instructions of a different fiber. Thus (say) the thread reads row #x"
" for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Поток обработки транзакций может управлять множеством *файберов*. Файбер "
"— это набор инструкций, среди которых могут быть и сигналы \"передать "
"управление\". Поток обработки транзакций выполняет инструкции, пока не "
"увидит такой сигнал, и тогда он переключается на выполнение инструкций из"
" другого файбера. Например, таким образом поток обработки транзакций "
"сначала выполняет чтение данных из строки #x для файбера #1, а затем "
"выполняет запись в строку #y для файбер #2."

#: ../doc/1.6/book/box/atomic.rst:99
msgid ""
"Yields must happen, otherwise the transaction processor thread would "
"stick permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:102
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change "
"operation or network-access causes an implicit yield, and every statement"
" that goes through the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:106
msgid ""
"explicit yields: in a Lua function, you can (and should) add “yield” "
"statements to prevent hogging. This is called **cooperative "
"multitasking**."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:113
#, fuzzy
msgid "Cooperative multitasking"
msgstr "Среда взаимной многозадачности"

#: ../doc/1.6/book/box/atomic.rst:115
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running "
"fiber will deliberately yield when it encounters a “yield point”: a "
"transaction commit, an operating system call, or an explicit ``yield()`` "
"request. Any system call which can block will be performed "
"asynchronously, and any running fiber which must wait for a system call "
"will be preempted, so that another ready-to-run fiber takes its place and"
" becomes the new running fiber."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:123
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource,"
" no race conditions, and no memory consistency issues."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:127
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or"
" SELECT, fiber scheduling is fair: it takes only a little time to process"
" the request, schedule a disk write, and yield to a fiber serving the "
"next client."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:131
msgid ""
"However, a function might perform complex computations or might be "
"written in such a way that yields do not occur for a long time. This can "
"lead to unfair scheduling, when a single client throttles the rest of the"
" system, or to apparent stalls in request processing. Avoiding this "
"situation is the responsibility of the function’s author."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:141
#, fuzzy
msgid "Transactions"
msgstr "Контроль транзакций"

#: ../doc/1.6/book/box/atomic.rst:143
msgid ""
"In the absence of transactions, any function that contains yield points "
"may see changes in the database state caused by fibers that preempt. "
"Multi-statement transactions exist to provide isolation: each transaction"
" sees a consistent database state and commits all its changes atomically."
" At commit time, a yield happens and all transaction changes are written "
"to the write ahead log in a single batch."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:150
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the"
" first transaction to commit wins. If a concurrent active transaction has"
" read a value modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:154
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:160
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:166
#, fuzzy
msgid "Implicit yields"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Правила неявной передачи управления"

#: ../doc/1.6/book/box/atomic.rst:168
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid "
"blocking."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:172
msgid "Database operations usually do not yield, but it depends on the engine:"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:174
msgid "In memtx, reads or writes do not require I/O and do not yield."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:176
msgid ""
"In future storage engines, not all data is in memory, and SELECT often "
"incurs a disc I/O, and therefore yields, while a write may stall waiting "
"for memory to free up, thus also causing a yield."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:180
msgid ""
"In the \"autocommit\" mode, all data change operations are followed by an"
" automatic commit, which yields. So does an explicit commit of a multi-"
"statement transaction, :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:184
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` and :ref:`socket "
"<socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:188
#: ../doc/1.6/book/box/authentication.rst:186
#: ../doc/1.6/book/box/box_session.rst:215
#, fuzzy
msgid "**Example #1**"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Примеры:**"

#: ../doc/1.6/book/box/atomic.rst:190
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write "
"to WAL and so does not yield."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:194
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit"
" if the engine is memtx."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:197
#: ../doc/1.6/book/box/authentication.rst:194
#: ../doc/1.6/book/box/box_session.rst:224
#, fuzzy
msgid "**Example #2**"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Примеры:**"

#: ../doc/1.6/book/box/atomic.rst:199
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw "
"from tuple#1, deposit in tuple#2, and end the transaction, making its "
"effects permanent."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:204
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:220
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then"
" implicit yielding at commit time does not take place, because there are "
"no writes to the WAL."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:224
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not "
"itself an implicit yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:232
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:236
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program "
"being executed on the server instance, but causes yielding if it is done "
"as a series of transmissions from a client, including a client which "
"operates via telnet, via one of the connectors, or via the MySQL and "
"PostgreSQL rocks, or via the interactive mode when :ref:`using Tarantool "
"as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.6/book/box/atomic.rst:243
msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:39
msgid "Access control"
msgstr "Ограничение доступа"

#: ../doc/1.6/book/box/authentication.rst:41
msgid ""
"Understanding security details is primarily an issue for administrators. "
"Meanwhile, ordinary users should at least skim this section to get an "
"idea of how Tarantool makes it possible for administrators to prevent "
"unauthorized access to the database and to certain functions."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:46
msgid "In a nutshell:"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:48
msgid ""
"There is a method to guarantee with password checks that users really are"
" who they say they are (“authentication”)."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:51
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames "
"and password-hashes are stored."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:54
msgid ""
"There are functions for saying that certain users are allowed to do "
"certain things (“privileges”)."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:57
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges "
"are stored. Whenever a user tries to do an operation, there is a check "
"whether the user has the privilege to do the operation (“access "
"control”)."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:61
msgid "Further on, we explain all of this in more detail."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:67
msgid "Users"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:69
msgid ""
"There is a **current user** for any program working with Tarantool, local"
" or remote. If a remote connection is using a :ref:`binary port <admin-"
"security>`, the current user, by default, is '**guest**'. If the "
"connection is using an :ref:`admin-console port <admin-security>`, the "
"current user is '**admin**'. When executing a :ref:`Lua initialization "
"script <index-init_label>`, the current user is also ‘admin’."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:78
msgid ""
"The current user name can be found with :ref:`box.session.user() "
"<box_session-user>`."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:80
msgid "The current user can be changed:"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:82
msgid ""
"For a binary port connection -- with AUTH protocol command, supported by "
"most clients;"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:85
msgid ""
"For an admin-console connection and in a Lua initialization script -- "
"with :ref:`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:88
msgid ""
"For a stored function invoked with CALL command over a binary port -- "
"with :ref:`SETUID <box_schema-func_create>` property enabled for the "
"function, which makes Tarantool temporarily replace the current user with"
" the function’s creator, with all creator's privileges, during function "
"execution."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:97
msgid "Passwords"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:99
msgid ""
"Each user may have a **password**. The password is any alphanumeric "
"string."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:101
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` "
"system space with a `cryptographic hash function "
"<https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if"
" the password is ‘x’, the stored hash-password is a long string like "
"‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool "
"instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the "
"client must mix with the hashed-password before sending to the instance. "
"Thus the original value ‘x’ is never stored anywhere except in the user’s"
" head, and the hashed value is never passed down a network wire except "
"when mixed with a random salt."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:115
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose "
"of writing a new client application), read the `scramble.h "
"<https://github.com/tarantool/tarantool/blob/1.6/src/scramble.h>`_ header"
" file."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:120
msgid ""
"This system prevents malicious onlookers from finding passwords by "
"snooping in the log files or snooping on the wire. It is the same system "
"that `MySQL introduced several years ago "
"<http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which "
"has proved adequate for medium-security installations. Nevertheless, "
"administrators should warn users that no system is foolproof against "
"determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long "
"unobvious passwords, but it is ultimately up to the users to choose or "
"change their own passwords."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:130
msgid ""
"There are two functions for managing passwords in Tarantool: "
":ref:`box.schema.user.password() <box_schema-user_password>` for changing"
" a user's password and :ref:`box.schema.user.passwd() <box_schema-"
"user_passwd>` for getting a hash-password."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:139
msgid "Owners and privileges"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:141
msgid ""
"In Tarantool, all objects are organized into a hierarchy of ownership. "
"Ordinarily the **owner** of every object is its creator. The creator of "
"the initial database state (we call it ‘universe’) --  including the "
"database itself, the system spaces, the users -- is ‘admin’."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:146
msgid ""
"An object's owner can share some rights on the object by **granting "
"privileges** to other users. The following privileges are implemented:"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:149
msgid "Read an object,"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:150
msgid "Write, i.e. modify contents of an object,"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:151
msgid ""
"Execute, i.e. use an object (if the privilege makes sense for the object;"
" for example, spaces can not be \"executed\", but functions can)."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:156
msgid ""
"Currently, \"drop\" and \"grant\" privileges can not be granted to other "
"users. This possibility will be added in future versions of Tarantool."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:159
msgid ""
"This is how the privilege system works under the hood. To be able to "
"create objects, a user needs to have write access to Tarantool's system "
"spaces. The 'admin' user, who is at the top of the hierarchy and who is "
"the ultimate source of privileges, shares write access to a system space "
"(e.g. :ref:`_space <box_space-space>`) with some users. Now the users can"
" insert data into the system space (e.g. creating new spaces) and "
"themselves become creators/definers of new objects. For the objects they "
"created, the users can in turn share privileges with other users."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:168
msgid ""
"This is why only an object's owner can drop the object, but not other "
"ordinary users. Meanwhile, 'admin' can drop any object or delete any "
"other user, because 'admin' is the creator and ultimate owner of them "
"all."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:172
msgid ""
"The syntax of all :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() "
"<box_schema-user_revoke>` commands in Tarantool follows this basic idea."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:176
msgid "Their first argument is \"who gets\" or \"who is revoked\" a grant."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:178
msgid ""
"Their second argument is the type of privilege granted, or a list of "
"privileges."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:180
msgid "Their third argument is the object type on which the privilege is granted."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:182
msgid ""
"Their fourth and optional argument is the object name (‘universe' has no "
"name, because there is only one ‘universe’, but you need to specify names"
" for functions/users/spaces/etc)."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:188
msgid ""
"Here we disable all privileges and run Tarantool in the ‘no-privilege’ "
"mode."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:190
#, fuzzy
msgid "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"

#: ../doc/1.6/book/box/authentication.rst:196
msgid ""
"Here we create a Lua function that will be executed under the user id of "
"its creator, even if called by another user."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:199
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function "
"('read_and_modify') and the no-password user becomes this function's "
"creator. Finally, we grant another user ('public_user') access to execute"
" Lua functions created by the no-password user."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:204
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.space.u:create_index('pk')\n"
"box.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create('internal')\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"box.schema.user.grant('internal', 'read,write', 'space', '_func')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil then\n"
"        u:put{key, box.session.uid()}\n"
"        i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:238
msgid "Roles"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:240
msgid ""
"A **role** is a container for privileges which can be granted to regular "
"users. Instead of granting or revoking individual privileges, you can put"
" all the privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:244
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, "
"but the third field in the tuple -- the type field -- is ‘role’ rather "
"than ‘user’."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:247
msgid ""
"An important feature in role management is that roles can be **nested**. "
"For example, role R1 can be granted a privilege \"role R2\", so users "
"with the role R1 will subsequently get all privileges from both roles R1 "
"and R2. In other words, a user gets all the privileges that are granted "
"to a user’s roles, directly or indirectly."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:255
msgid ""
"-- This example will work for a user with many privileges, such as "
"'admin'\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)"
"\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,"
"\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:278
msgid ""
"For details about Tarantool functions related to role management, see "
"reference on :ref:`box.schema <box_schema>` submodule."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:285
msgid "Sessions and security"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:287
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:289
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:290
msgid ""
"the :ref:`current user <authentication-users>` associated with the "
"connection,"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:291
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:292
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:294
msgid ""
"In Tarantool, a single session can execute multiple concurrent "
"transactions. Each transaction is identified by a unique integer id, "
"which can be queried at start of the transaction using "
":ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/1.6/book/box/authentication.rst:300
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""

#: ../doc/1.6/book/box/box_cfg.rst:39
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/1.6/book/box/box_cfg.rst:43
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server"
" configuration parameters (see \"Configuration reference\" for :ref:`a "
"complete description of all configuration parameters <box_cfg_params>`). "
"Use ``box.cfg`` without braces to get read-only access to those "
"parameters."
msgstr ""

#: ../doc/1.6/book/box/box_cfg.rst:48 ../doc/1.6/book/box/box_index.rst:67
#: ../doc/1.6/book/box/box_index.rst:466 ../doc/1.6/book/box/box_index.rst:602
#: ../doc/1.6/book/box/box_index.rst:630 ../doc/1.6/book/box/box_index.rst:658
#: ../doc/1.6/book/box/box_index.rst:685 ../doc/1.6/book/box/box_index.rst:709
#: ../doc/1.6/book/box/box_index.rst:775 ../doc/1.6/book/box/box_index.rst:798
#: ../doc/1.6/book/box/box_index.rst:818 ../doc/1.6/book/box/box_info.rst:83
#: ../doc/1.6/book/box/box_schema.rst:208
#: ../doc/1.6/book/box/box_schema.rst:238
#: ../doc/1.6/book/box/box_schema.rst:270
#: ../doc/1.6/book/box/box_schema.rst:307
#: ../doc/1.6/book/box/box_schema.rst:329
#: ../doc/1.6/book/box/box_schema.rst:351
#: ../doc/1.6/book/box/box_schema.rst:374
#: ../doc/1.6/book/box/box_schema.rst:393
#: ../doc/1.6/book/box/box_schema.rst:408
#: ../doc/1.6/book/box/box_schema.rst:435
#: ../doc/1.6/book/box/box_schema.rst:464
#: ../doc/1.6/book/box/box_schema.rst:481
#: ../doc/1.6/book/box/box_schema.rst:518
#: ../doc/1.6/book/box/box_schema.rst:539
#: ../doc/1.6/book/box/box_schema.rst:554 ../doc/1.6/book/box/box_slab.rst:61
#: ../doc/1.6/book/box/box_slab.rst:115 ../doc/1.6/book/box/box_slab.rst:154
#: ../doc/1.6/book/box/box_space.rst:181 ../doc/1.6/book/box/box_space.rst:206
#: ../doc/1.6/book/box/box_space.rst:336 ../doc/1.6/book/box/box_space.rst:378
#: ../doc/1.6/book/box/box_space.rst:411 ../doc/1.6/book/box/box_space.rst:442
#: ../doc/1.6/book/box/box_space.rst:467 ../doc/1.6/book/box/box_space.rst:505
#: ../doc/1.6/book/box/box_space.rst:523 ../doc/1.6/book/box/box_space.rst:622
#: ../doc/1.6/book/box/box_space.rst:665 ../doc/1.6/book/box/box_space.rst:701
#: ../doc/1.6/book/box/box_space.rst:719 ../doc/1.6/book/box/box_space.rst:756
#: ../doc/1.6/book/box/box_space.rst:828 ../doc/1.6/book/box/box_space.rst:905
#: ../doc/1.6/book/box/box_space.rst:1010
#: ../doc/1.6/book/box/box_space.rst:1046
#: ../doc/1.6/book/box/box_space.rst:1065
#: ../doc/1.6/book/box/box_space.rst:1082
#: ../doc/1.6/book/box/box_space.rst:1132
#: ../doc/1.6/book/box/box_space.rst:1248
#: ../doc/1.6/book/box/box_space.rst:1467 ../doc/1.6/book/box/box_tuple.rst:68
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:245
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:283
#: ../doc/1.6/dev_guide/reference_capi/coio.rst:74
#: ../doc/1.6/dev_guide/reference_capi/say.rst:83
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:164
#: ../doc/1.6/reference/reference_lua/box_error.rst:82
#: ../doc/1.6/reference/reference_lua/box_error.rst:120
#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:78
#: ../doc/1.6/reference/reference_lua/clock.rst:60
#: ../doc/1.6/reference/reference_lua/clock.rst:83
#: ../doc/1.6/reference/reference_lua/clock.rst:102
#: ../doc/1.6/reference/reference_lua/clock.rst:121
#: ../doc/1.6/reference/reference_lua/clock.rst:141
#: ../doc/1.6/reference/reference_lua/console.rst:79
#: ../doc/1.6/reference/reference_lua/console.rst:110
#: ../doc/1.6/reference/reference_lua/console.rst:135
#: ../doc/1.6/reference/reference_lua/console.rst:174
#: ../doc/1.6/reference/reference_lua/crypto.rst:73
#: ../doc/1.6/reference/reference_lua/crypto.rst:101
#: ../doc/1.6/reference/reference_lua/csv.rst:83
#: ../doc/1.6/reference/reference_lua/csv.rst:165
#: ../doc/1.6/reference/reference_lua/csv.rst:210
#: ../doc/1.6/reference/reference_lua/errno.rst:75
#: ../doc/1.6/reference/reference_lua/fiber.rst:99
#: ../doc/1.6/reference/reference_lua/fiber.rst:123
#: ../doc/1.6/reference/reference_lua/fiber.rst:143
#: ../doc/1.6/reference/reference_lua/fiber.rst:163
#: ../doc/1.6/reference/reference_lua/fiber.rst:177
#: ../doc/1.6/reference/reference_lua/fiber.rst:194
#: ../doc/1.6/reference/reference_lua/fiber.rst:213
#: ../doc/1.6/reference/reference_lua/fiber.rst:240
#: ../doc/1.6/reference/reference_lua/fiber.rst:257
#: ../doc/1.6/reference/reference_lua/fiber.rst:277
#: ../doc/1.6/reference/reference_lua/fiber.rst:298
#: ../doc/1.6/reference/reference_lua/fiber.rst:323
#: ../doc/1.6/reference/reference_lua/fiber.rst:343
#: ../doc/1.6/reference/reference_lua/fiber.rst:368
#: ../doc/1.6/reference/reference_lua/fiber.rst:388
#: ../doc/1.6/reference/reference_lua/fiber.rst:433
#: ../doc/1.6/reference/reference_lua/fiber.rst:452
#: ../doc/1.6/reference/reference_lua/fio.rst:70
#: ../doc/1.6/reference/reference_lua/fio.rst:90
#: ../doc/1.6/reference/reference_lua/fio.rst:108
#: ../doc/1.6/reference/reference_lua/fio.rst:132
#: ../doc/1.6/reference/reference_lua/fio.rst:165
#: ../doc/1.6/reference/reference_lua/fio.rst:203
#: ../doc/1.6/reference/reference_lua/fio.rst:224
#: ../doc/1.6/reference/reference_lua/fio.rst:239
#: ../doc/1.6/reference/reference_lua/fio.rst:252
#: ../doc/1.6/reference/reference_lua/fio.rst:276
#: ../doc/1.6/reference/reference_lua/fio.rst:299
#: ../doc/1.6/reference/reference_lua/fio.rst:318
#: ../doc/1.6/reference/reference_lua/fio.rst:341
#: ../doc/1.6/reference/reference_lua/fio.rst:357
#: ../doc/1.6/reference/reference_lua/fio.rst:392
#: ../doc/1.6/reference/reference_lua/fio.rst:414
#: ../doc/1.6/reference/reference_lua/fio.rst:437
#: ../doc/1.6/reference/reference_lua/fio.rst:467
#: ../doc/1.6/reference/reference_lua/fio.rst:485
#: ../doc/1.6/reference/reference_lua/fio.rst:508
#: ../doc/1.6/reference/reference_lua/fio.rst:526
#: ../doc/1.6/reference/reference_lua/fio.rst:558
#: ../doc/1.6/reference/reference_lua/fio.rst:578
#: ../doc/1.6/reference/reference_lua/json.rst:57
#: ../doc/1.6/reference/reference_lua/json.rst:95
#: ../doc/1.6/reference/reference_lua/json.rst:122
#: ../doc/1.6/reference/reference_lua/net_box.rst:86
#: ../doc/1.6/reference/reference_lua/net_box.rst:102
#: ../doc/1.6/reference/reference_lua/net_box.rst:116
#: ../doc/1.6/reference/reference_lua/net_box.rst:129
#: ../doc/1.6/reference/reference_lua/net_box.rst:145
#: ../doc/1.6/reference/reference_lua/net_box.rst:203
#: ../doc/1.6/reference/reference_lua/net_box.rst:219
#: ../doc/1.6/reference/reference_lua/net_box.rst:230
#: ../doc/1.6/reference/reference_lua/osmodule.rst:62
#: ../doc/1.6/reference/reference_lua/osmodule.rst:85
#: ../doc/1.6/reference/reference_lua/osmodule.rst:104
#: ../doc/1.6/reference/reference_lua/osmodule.rst:121
#: ../doc/1.6/reference/reference_lua/osmodule.rst:139
#: ../doc/1.6/reference/reference_lua/osmodule.rst:154
#: ../doc/1.6/reference/reference_lua/osmodule.rst:167
#: ../doc/1.6/reference/reference_lua/osmodule.rst:182
#: ../doc/1.6/reference/reference_lua/osmodule.rst:197
#: ../doc/1.6/reference/reference_lua/osmodule.rst:213
#: ../doc/1.6/reference/reference_lua/osmodule.rst:228
#: ../doc/1.6/reference/reference_lua/other.rst:51
#: ../doc/1.6/reference/reference_lua/other.rst:89
#: ../doc/1.6/reference/reference_lua/pickle.rst:98
#: ../doc/1.6/reference/reference_lua/pickle.rst:143
#: ../doc/1.6/reference/reference_lua/socket.rst:147
#: ../doc/1.6/reference/reference_lua/socket.rst:165
#: ../doc/1.6/reference/reference_lua/socket.rst:182
#: ../doc/1.6/reference/reference_lua/socket.rst:254
#: ../doc/1.6/reference/reference_lua/socket.rst:410
#: ../doc/1.6/reference/reference_lua/strict.rst:52
#: ../doc/1.6/reference/reference_lua/tap.rst:104
#: ../doc/1.6/reference/reference_lua/tap.rst:146
#: ../doc/1.6/reference/reference_lua/tarantool.rst:52
#: ../doc/1.6/reference/reference_lua/uri.rst:60
#: ../doc/1.6/reference/reference_rock/dbms.rst:222
#: ../doc/1.6/reference/reference_rock/dbms.rst:246
#: ../doc/1.6/reference/reference_rock/dbms.rst:270
#: ../doc/1.6/reference/reference_rock/dbms.rst:565
#: ../doc/1.6/reference/reference_rock/dbms.rst:589
#: ../doc/1.6/reference/reference_rock/dbms.rst:612
msgid "**Example:**"
msgstr ""

#: ../doc/1.6/book/box/box_cfg.rst:50
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:39
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/1.6/book/box/box_index.rst:41
msgid ""
"The ``box.index`` submodule provides read-only access for index "
"definitions and index keys. Indexes are contained in :samp:`box.space"
".{space-name}.index` array within each space object. They provide an API "
"for ordered iteration over tuples. This API is a direct binding to "
"corresponding methods of index objects of type ``box.index`` in the "
"storage engine."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:53
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst ../doc/1.6/book/box/box_info.rst
#: ../doc/1.6/book/box/box_schema.rst ../doc/1.6/book/box/box_session.rst
#: ../doc/1.6/book/box/box_slab.rst ../doc/1.6/book/box/box_space.rst
#: ../doc/1.6/book/box/box_tuple.rst
#: ../doc/1.6/dev_guide/documentation_guidelines.rst
#: ../doc/1.6/reference/reference_lua/clock.rst
#: ../doc/1.6/reference/reference_lua/csv.rst
#: ../doc/1.6/reference/reference_lua/errno.rst
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.6/reference/reference_lua/fio.rst
#: ../doc/1.6/reference/reference_lua/json.rst
#: ../doc/1.6/reference/reference_lua/msgpack.rst
#: ../doc/1.6/reference/reference_lua/net_box.rst
#: ../doc/1.6/reference/reference_lua/pickle.rst
#: ../doc/1.6/reference/reference_lua/socket.rst
#: ../doc/1.6/reference/reference_lua/tap.rst
#: ../doc/1.6/reference/reference_lua/uri.rst
#: ../doc/1.6/reference/reference_lua/uuid.rst
#: ../doc/1.6/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:55 ../doc/1.6/book/box/box_schema.rst:71
#: ../doc/1.6/book/box/box_schema.rst:87 ../doc/1.6/book/box/box_space.rst:251
#: ../doc/1.6/book/box/box_space.rst:253 ../doc/1.6/book/box/data_model.rst:189
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:83
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:109
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:125
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:133
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:141
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:147
#: ../doc/1.6/reference/reference_lua/fio.rst:201
#: ../doc/1.6/reference/reference_lua/fio.rst:297
#: ../doc/1.6/reference/reference_lua/fio.rst:339
#: ../doc/1.6/reference/reference_lua/fio.rst:355
#: ../doc/1.6/reference/reference_lua/fio.rst:412
#: ../doc/1.6/reference/reference_lua/fio.rst:483
#: ../doc/1.6/reference/reference_lua/net_box.rst:100
#: ../doc/1.6/reference/reference_lua/net_box.rst:114
#: ../doc/1.6/reference/reference_lua/net_box.rst:127
#: ../doc/1.6/reference/reference_lua/socket.rst:252
#: ../doc/1.6/reference/reference_lua/socket.rst:431
#: ../doc/1.6/reference/reference_lua/socket.rst:442
#: ../doc/1.6/reference/reference_lua/tap.rst:83
#: ../doc/1.6/reference/reference_lua/tap.rst:102
#: ../doc/1.6/reference/reference_lua/tap.rst:134
#: ../doc/1.6/reference/reference_lua/tap.rst:165
#: ../doc/1.6/reference/reference_lua/tap.rst:176
#: ../doc/1.6/reference/reference_lua/tap.rst:193
#: ../doc/1.6/reference/reference_lua/tap.rst:201
msgid "boolean"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:59
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:63
msgid "An array describing index key fields."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:65 ../doc/1.6/book/box/box_info.rst:81
#: ../doc/1.6/book/box/box_schema.rst:101 ../doc/1.6/book/box/box_slab.rst:59
#: ../doc/1.6/book/box/box_slab.rst:113 ../doc/1.6/book/box/box_slab.rst:152
#: ../doc/1.6/book/box/box_space.rst:1080
#: ../doc/1.6/reference/reference_lua/csv.rst:81
#: ../doc/1.6/reference/reference_lua/fiber.rst:211
#: ../doc/1.6/reference/reference_lua/fio.rst:150
#: ../doc/1.6/reference/reference_lua/fio.rst:220
#: ../doc/1.6/reference/reference_lua/fio.rst:524
#: ../doc/1.6/reference/reference_lua/json.rst:93
#: ../doc/1.6/reference/reference_lua/pickle.rst:141
#: ../doc/1.6/reference/reference_lua/socket.rst:180
#: ../doc/1.6/reference/reference_lua/socket.rst:554
#: ../doc/1.6/reference/reference_lua/socket.rst:566
#: ../doc/1.6/reference/reference_lua/yaml.rst:60
msgid "table"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:69
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: NUM\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:87
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:90
msgid ""
"The :samp:`{key}` parameter specifies what must match within the index. "
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example,"
" a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other "
"index types, however, do not support ordering."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:97
msgid ""
"To understand consistency of tuples returned by an iterator, it's "
"essential to know the principles of the Tarantool transaction processing "
"subsystem. An iterator in Tarantool does not own a consistent read view. "
"Instead, each procedure is granted exclusive access to all tuples and "
"spaces until there is a \"context switch\": which may happen due to "
":ref:`the implicit yield rules <atomic-implicit-yields>`, or by an "
"explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution "
"flow returns to the yielded procedure, the data set could have changed "
"significantly. Iteration, resumed after a yield point, does not preserve "
"the read view, but continues with the new content of the database. The "
"tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be "
"used together."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst ../doc/1.6/book/box/box_schema.rst
#: ../doc/1.6/book/box/box_session.rst ../doc/1.6/book/box/box_space.rst
#: ../doc/1.6/book/box/box_tuple.rst
#: ../doc/1.6/dev_guide/documentation_guidelines.rst
#: ../doc/1.6/dev_guide/reference_capi/box.rst
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst
#: ../doc/1.6/dev_guide/reference_capi/coio.rst
#: ../doc/1.6/dev_guide/reference_capi/error.rst
#: ../doc/1.6/dev_guide/reference_capi/fiber.rst
#: ../doc/1.6/dev_guide/reference_capi/latch.rst
#: ../doc/1.6/dev_guide/reference_capi/say.rst
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst
#: ../doc/1.6/dev_guide/reference_capi/utils.rst
#: ../doc/1.6/reference/reference_lua/box_error.rst
#: ../doc/1.6/reference/reference_lua/box_once.rst
#: ../doc/1.6/reference/reference_lua/clock.rst
#: ../doc/1.6/reference/reference_lua/console.rst
#: ../doc/1.6/reference/reference_lua/csv.rst
#: ../doc/1.6/reference/reference_lua/errno.rst
#: ../doc/1.6/reference/reference_lua/fiber.rst
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.6/reference/reference_lua/fio.rst
#: ../doc/1.6/reference/reference_lua/json.rst
#: ../doc/1.6/reference/reference_lua/log.rst
#: ../doc/1.6/reference/reference_lua/msgpack.rst
#: ../doc/1.6/reference/reference_lua/net_box.rst
#: ../doc/1.6/reference/reference_lua/osmodule.rst
#: ../doc/1.6/reference/reference_lua/other.rst
#: ../doc/1.6/reference/reference_lua/pickle.rst
#: ../doc/1.6/reference/reference_lua/socket.rst
#: ../doc/1.6/reference/reference_lua/tap.rst
#: ../doc/1.6/reference/reference_lua/uri.rst
#: ../doc/1.6/reference/reference_lua/uuid.rst
#: ../doc/1.6/reference/reference_lua/yaml.rst
msgid "Parameters"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:111 ../doc/1.6/book/box/box_index.rst:455
#: ../doc/1.6/book/box/box_index.rst:590 ../doc/1.6/book/box/box_index.rst:617
#: ../doc/1.6/book/box/box_index.rst:645 ../doc/1.6/book/box/box_index.rst:676
#: ../doc/1.6/book/box/box_index.rst:701 ../doc/1.6/book/box/box_index.rst:730
#: ../doc/1.6/book/box/box_index.rst:751 ../doc/1.6/book/box/box_index.rst:764
#: ../doc/1.6/book/box/box_index.rst:790 ../doc/1.6/book/box/box_index.rst:810
#: ../doc/1.6/book/box/box_index.rst:832
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:113 ../doc/1.6/book/box/box_space.rst:604
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:115
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst ../doc/1.6/book/box/box_info.rst
#: ../doc/1.6/book/box/box_schema.rst ../doc/1.6/book/box/box_session.rst
#: ../doc/1.6/book/box/box_slab.rst ../doc/1.6/book/box/box_space.rst
#: ../doc/1.6/book/box/box_tuple.rst
#: ../doc/1.6/dev_guide/documentation_guidelines.rst
#: ../doc/1.6/reference/reference_lua/clock.rst
#: ../doc/1.6/reference/reference_lua/console.rst
#: ../doc/1.6/reference/reference_lua/csv.rst
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.6/reference/reference_lua/fio.rst
#: ../doc/1.6/reference/reference_lua/json.rst
#: ../doc/1.6/reference/reference_lua/log.rst
#: ../doc/1.6/reference/reference_lua/msgpack.rst
#: ../doc/1.6/reference/reference_lua/net_box.rst
#: ../doc/1.6/reference/reference_lua/other.rst
#: ../doc/1.6/reference/reference_lua/pickle.rst
#: ../doc/1.6/reference/reference_lua/socket.rst
#: ../doc/1.6/reference/reference_lua/tap.rst
#: ../doc/1.6/reference/reference_lua/uuid.rst
#: ../doc/1.6/reference/reference_lua/yaml.rst
msgid "return"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:119 ../doc/1.6/book/box/box_space.rst:609
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:123
msgid ""
"**Possible errors:** No such space; wrong type; Selected iteration type "
"is not supported for the index type; or key is not supported for the "
"iteration type."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:127
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:130
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example "
"``{1234, 'abcd'}``). Each part of a key will be compared to each part of "
"an index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:135
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:144 ../doc/1.6/book/box/box_index.rst:243
#: ../doc/1.6/book/box/box_index.rst:277 ../doc/1.6/book/box/box_index.rst:313
#: ../doc/1.6/book/box/box_schema.rst:69 ../doc/1.6/book/box/box_space.rst:243
#: ../doc/1.6/book/box/box_space.rst:1381
msgid "Type"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:144 ../doc/1.6/book/box/box_index.rst:243
#: ../doc/1.6/book/box/box_index.rst:277 ../doc/1.6/book/box/box_index.rst:313
msgid "Arguments"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:144 ../doc/1.6/book/box/box_index.rst:243
#: ../doc/1.6/book/box/box_index.rst:277 ../doc/1.6/book/box/box_index.rst:313
#: ../doc/1.6/book/box/box_space.rst:1381
msgid "Description"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:146 ../doc/1.6/book/box/box_index.rst:250
#: ../doc/1.6/book/box/box_index.rst:283 ../doc/1.6/book/box/box_index.rst:318
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:146 ../doc/1.6/book/box/box_index.rst:152
#: ../doc/1.6/book/box/box_index.rst:157 ../doc/1.6/book/box/box_index.rst:164
#: ../doc/1.6/book/box/box_index.rst:171 ../doc/1.6/book/box/box_index.rst:175
#: ../doc/1.6/book/box/box_index.rst:181 ../doc/1.6/book/box/box_index.rst:250
#: ../doc/1.6/book/box/box_index.rst:256 ../doc/1.6/book/box/box_index.rst:318
#: ../doc/1.6/book/box/box_index.rst:326 ../doc/1.6/book/box/box_index.rst:331
#: ../doc/1.6/book/box/box_index.rst:336 ../doc/1.6/book/box/box_index.rst:341
#: ../doc/1.6/book/box/box_index.rst:351
msgid "search value"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:146
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. Tuples are returned in ascending order by "
"index key. This is the default."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:152
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:152
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:157 ../doc/1.6/book/box/box_index.rst:256
#: ../doc/1.6/book/box/box_index.rst:326
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:157
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater"
" than a search value, it matches. Tuples are returned in ascending order "
"by index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:164 ../doc/1.6/book/box/box_index.rst:331
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:164
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index "
"key is greater than or equal to a search value, it matches. Tuples are "
"returned in ascending order by index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:171 ../doc/1.6/book/box/box_index.rst:279
#: ../doc/1.6/book/box/box_index.rst:315
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:171
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:175 ../doc/1.6/book/box/box_index.rst:336
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:175
msgid ""
"The comparison operator is '<' (less than). If an index key is less than "
"a search value, it matches. Tuples are returned in descending order by "
"index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:181 ../doc/1.6/book/box/box_index.rst:341
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:181
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key "
"is less than or equal to a search value, it matches. Tuples are returned "
"in descending order by index key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:190
msgid ""
"Informally, we can state that searches with TREE indexes are generally "
"what users will find is intuitive, provided that there are no nils and no"
" missing parts. Formally, the logic is as follows. A search key has zero "
"or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or"
" more parts, for example {1}, {1,2,3},{1,2,3}. An search key may contain "
"nil (but not msgpack.NULL, which is the wrong type). An index key may not"
" contain nil or msgpack.NULL, although a later version of Tarantool will "
"have different rules --  the behavior of searches with nil is subject to "
"change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is "
"said to \"match\" an index key if the following statements, which are "
"pseudocode for the comparison operation, return TRUE."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:236
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:245
msgid "box.index.ALL"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:245 ../doc/1.6/book/box/box_index.rst:279
#: ../doc/1.6/book/box/box_index.rst:315
msgid "none"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:245
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:250
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. The number of returned tuples will be 0 or 1. "
"This is the default."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:256
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key "
"is greater than a hash of a search value, it matches. Tuples are returned"
" in ascending order by hash of index key, which will appear to be random."
" Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} "
"in each search, and using the last returned value from the previous "
"result as the start search value for the next search."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:270
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:279
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:283 ../doc/1.6/book/box/box_index.rst:288
#: ../doc/1.6/book/box/box_index.rst:293 ../doc/1.6/book/box/box_index.rst:298
msgid "bitset value"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:283
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are "
"returned in their order within the space. This is the default."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:288
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:288
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:293
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:293
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:298
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:298
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:306
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:315
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:318
msgid ""
"If all points of the rectangle-or-box defined by the search value are the"
" same as the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space. \"Rectangle-or-box\""
" means \"rectangle-or-box as explained in section about :ref:`RTREE "
"<box_index-rtree>`\". This is the default."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:326
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:331
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key,"
" it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:336
msgid ""
"If all points of the rectangle-or-box defined by the index key are within"
" the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:341
msgid ""
"If all points of the rectangle-or-box defined by the index key are "
"within, or at the side of, the rectangle-or-box defined by the search "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:346
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:346
msgid "search values"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:346
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:351
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:351
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key "
"are within, or at the side of, defined by the index key, it matches. "
"Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:357
msgid "**First Example of index pairs():**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:359
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:361
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'STR', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:407
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:409
msgid ""
"This Lua code finds all the tuples whose primary key values begin with "
"'XY'. The assumptions include that there is a one-part primary-key TREE "
"index on the first field, which must be a string. The iterator loop "
"ensures that the search will return tuples where the first value is "
"greater than or equal to 'XY'. The conditional statement within the loop "
"ensures that the looping will stop when the first two letters are not "
"'XY'."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:417
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:425
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:427
msgid ""
"This Lua code finds all the tuples whose primary key values are greater "
"than or equal to 1000, and less than or equal to 1999 (this type of "
"request is sometimes called a \"range search\" or a \"between search\"). "
"The assumptions include that there is a one-part primary-key TREE index "
"on the first field, which must be a number. The iterator loop ensures "
"that the search will return tuples where the first value is greater than "
"or equal to 1000. The conditional statement within the loop ensures that "
"the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:437
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:449
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:457 ../doc/1.6/book/box/box_index.rst:592
#: ../doc/1.6/book/box/box_index.rst:619 ../doc/1.6/book/box/box_index.rst:647
#: ../doc/1.6/book/box/box_index.rst:703 ../doc/1.6/book/box/box_index.rst:732
#: ../doc/1.6/book/box/box_index.rst:753
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:458
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:459
msgid "type of iterator"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:460
#, fuzzy
msgid "maximum number of tuples"
msgstr "Количество обращений к кортежам"

#: ../doc/1.6/book/box/box_index.rst:461
msgid "start tuple number"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:463
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:464 ../doc/1.6/book/box/box_space.rst:750
msgid "array of tuples"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:468
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'NUM' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'str'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:494
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:496
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:505
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:512
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:517
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is "
"omitted, then every key in the index is considered to be a match, "
"regardless of iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the tester space"
" via the first (primary-key) index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:527
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be"
" replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` returns an "
"error."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:535
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:537
msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:541
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'STR'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'NUM'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:588
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:594
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:595 ../doc/1.6/book/box/box_index.rst:624
#: ../doc/1.6/book/box/box_index.rst:652 ../doc/1.6/book/box/box_index.rst:681
#: ../doc/1.6/book/box/box_index.rst:741 ../doc/1.6/book/box/box_index.rst:756
#: ../doc/1.6/book/box/box_space.rst:174 ../doc/1.6/book/box/box_space.rst:374
#: ../doc/1.6/book/box/box_space.rst:429 ../doc/1.6/book/box/box_space.rst:500
#: ../doc/1.6/book/box/box_space.rst:692 ../doc/1.6/book/box/box_space.rst:886
#: ../doc/1.6/book/box/box_tuple.rst:62 ../doc/1.6/book/box/box_tuple.rst:206
#: ../doc/1.6/book/box/box_tuple.rst:207 ../doc/1.6/book/box/box_tuple.rst:326
msgid "tuple"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:597
msgid ""
"**Possible errors:** No such index; wrong type; more than one tuple "
"matches."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:599
msgid ""
"**Complexity factors:** Index size, Index type. See also "
":ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:604
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:615
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:621
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is "
"supplied, returns the first key which is greater than or equal to ``key-"
"value``."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:626 ../doc/1.6/book/box/box_index.rst:654
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:628 ../doc/1.6/book/box/box_index.rst:656
#: ../doc/1.6/book/box/box_index.rst:683 ../doc/1.6/book/box/box_space.rst:615
#: ../doc/1.6/book/box/box_space.rst:754
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:632
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:643
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:649
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is "
"supplied, returns the last key which is less than or equal to ``key-"
"value``."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:660
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:671
msgid ""
"Find a random value in the specified index. This method is useful when "
"it's important to get insight into data distribution in an index without "
"having to iterate over the entire data set."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:678
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:680
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:687
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:698
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:704 ../doc/1.6/book/box/box_space.rst:202
msgid "comparison method"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:706
msgid "the number of matching index keys."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:707 ../doc/1.6/book/box/box_index.rst:836
#: ../doc/1.6/book/box/box_schema.rst:77 ../doc/1.6/book/box/box_schema.rst:81
#: ../doc/1.6/book/box/box_session.rst:52
#: ../doc/1.6/book/box/box_session.rst:57
#: ../doc/1.6/book/box/box_session.rst:83 ../doc/1.6/book/box/box_space.rst:249
#: ../doc/1.6/book/box/box_space.rst:259 ../doc/1.6/book/box/box_space.rst:332
#: ../doc/1.6/book/box/box_space.rst:463 ../doc/1.6/book/box/box_tuple.rst:94
#: ../doc/1.6/book/box/box_tuple.rst:119 ../doc/1.6/book/box/box_tuple.rst:168
#: ../doc/1.6/book/box/data_model.rst:193
#: ../doc/1.6/reference/reference_lua/fiber.rst:275
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:116
#: ../doc/1.6/reference/reference_lua/fio.rst:130
#: ../doc/1.6/reference/reference_lua/fio.rst:504
#: ../doc/1.6/reference/reference_lua/socket.rst:271
#: ../doc/1.6/reference/reference_lua/socket.rst:394
msgid "number"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:711
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:724 ../doc/1.6/book/box/box_space.rst:844
#: ../doc/1.6/book/box/box_tuple.rst:307
msgid "Update a tuple."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:726
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is "
"searched in this index instead of primary key. This index ought to be "
"unique."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:733 ../doc/1.6/book/box/box_space.rst:878
#: ../doc/1.6/book/box/box_space.rst:995
msgid "operation type represented in string"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:734 ../doc/1.6/book/box/box_space.rst:879
#: ../doc/1.6/book/box/box_space.rst:996 ../doc/1.6/book/box/box_tuple.rst:319
msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:738 ../doc/1.6/book/box/box_space.rst:883
#: ../doc/1.6/book/box/box_space.rst:1000 ../doc/1.6/book/box/box_tuple.rst:323
msgid "what value will be applied"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:740 ../doc/1.6/book/box/box_space.rst:885
msgid "the updated tuple."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:745
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:747
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is "
"searched in this index instead of in the primary-key index. This index "
"ought to be unique."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:755
msgid "the deleted tuple."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:762
msgid "Alter an index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:766
#, fuzzy
msgid ""
"options list, same as the options list for :ref:`create_index <box_space-"
"create_index>`"
msgstr ""
"Подробнее о других типах индексов см. в описании функции "
":ref:`create_index <box_space-create_index>`."

#: ../doc/1.6/book/box/box_index.rst:769 ../doc/1.6/book/box/box_index.rst:814
#: ../doc/1.6/book/box/box_schema.rst:166
#: ../doc/1.6/book/box/box_schema.rst:372
#: ../doc/1.6/book/box/box_schema.rst:516 ../doc/1.6/book/box/box_space.rst:404
#: ../doc/1.6/book/box/box_space.rst:661 ../doc/1.6/book/box/box_space.rst:717
#: ../doc/1.6/book/box/box_space.rst:819 ../doc/1.6/book/box/data_model.rst:187
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:279
#: ../doc/1.6/reference/reference_lua/console.rst:74
#: ../doc/1.6/reference/reference_lua/fiber.rst:321
#: ../doc/1.6/reference/reference_lua/fiber.rst:364
#: ../doc/1.6/reference/reference_lua/log.rst:67
#: ../doc/1.6/reference/reference_lua/msgpack.rst:181
#: ../doc/1.6/reference/reference_lua/tap.rst:71
#: ../doc/1.6/reference/reference_lua/tap.rst:90
#: ../doc/1.6/reference/reference_lua/tap.rst:144
msgid "nil"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:771
msgid ""
"**Possible errors:** Index does not exist, or the first index cannot be "
"changed to {unique = false}, or the alter function is only applicable for"
" the memtx storage engine."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:777
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:787
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples"
" are deleted."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:793
msgid "nil."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:795
msgid ""
"**Possible errors:** Index does not exist, or a primary-key index cannot "
"be dropped while a secondary-key index exists."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:800
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:808
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:274
msgid "Rename an index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:812
msgid "new name for index"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:816
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:820
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:285
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:826 ../doc/1.6/book/box/box_space.rst:817
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:830
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:835 ../doc/1.6/book/box/box_tuple.rst:118
msgid "number of bytes"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:840
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:842
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. The example function will:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:846
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:847
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:850
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:849
msgid "field[1] = 1000"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:850
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:851
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:852
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:853
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:854
msgid "Return the formatted value."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:856
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, "
":ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function "
"uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:865
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:890 ../doc/1.6/book/box/box_tuple.rst:375
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:892
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:909
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:911
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators"
" and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named "
"\"t\", whose primary key was defined with "
"``create_index('primary',{parts={1,'str'}})``."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:918
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:932
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they"
" only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples. In this example the "
"tuples are merely printed, a page at a time. But it should be simple to "
"change the functionality, for example by yielding after each retrieval, "
"or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:939
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:952
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:954
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial "
"searches if the index type is RTREE. There are operations for searching "
"*rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* "
"(geometric objects with more than 4 corners and more than 4 sides, "
"sometimes called hyperrectangles). This manual uses the term *rectangle-"
"or-box* for the whole class of objects that includes both rectangles and "
"boxes. Only rectangles will be illustrated."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:962
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and "
"Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a"
" picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:968
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           "
"<-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   "
"<-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   "
"<-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               "
"<-Rectangle#4"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:982
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate "
"of top left, Y-axis coordinate of top left, X-axis coordinate of bottom "
"right, Y-axis coordinate of bottom right} -- or more succinctly: "
"{x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on "
"the X axis and position 2 on the Y axis, and ends at position 3 on the X "
"axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. "
"Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are "
"{4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. "
"Rectangle#4 is actually a \"point\" since it has zero width and zero "
"height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:992
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:995
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:997
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'NUM'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.6/book/box/box_index.rst:1010
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key "
"index. (RTREE indexes cannot be unique and therefore cannot be primary-"
"key indexes.) The second field must be an \"array\", which means its "
"values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let "
"us populate the table by inserting two tuples, containing the coordinates"
" of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1016
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1021
msgid ""
"And now, following the description of `RTREE iterator types`_, we can "
"search the rectangles with these requests:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1026
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1042
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 "
"returns 1 tuple because the rectangle {4,7,5,9}, which was "
"\"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was "
"Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator "
"always returns all tuples, and the first returned tuple will be "
"{3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest "
"neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1050
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1053
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1064
msgid ""
"The additional option here is ``dimension=3``. The default dimension is "
"2, which is why it didn't need to be specified for the examples of "
"rectangle. The maximum dimension is 20. Now for insertions and selections"
" there will usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1069
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1074
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1077
msgid ""
"tarantool> s = box.schema.space.create('RM')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('SM', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1088
msgid ""
"The additional option here is ``distance='manhattan'``. The default "
"distance calculator is 'euclid', which is the straightforward as-the-"
"crow-flies method. The optional distance calculator is 'manhattan', which"
" can be a more appropriate method if one is following the lines of a grid"
" rather than traveling in a straight line."
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1094
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/1.6/book/box/box_index.rst:1100
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:39
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:43
msgid ""
"The ``box.info`` submodule provides access to information about server "
"instance variables."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:45
msgid "**server.lsn** Log Sequence Number for the latest entry in the WAL."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:46
msgid ""
"**server.ro**  True if the instance is in \"read_only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:48
msgid ""
"**server.uuid** The unique identifier of this instance, as stored in the "
"database. This value is also in the :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:51
msgid "**server.id** The number of this instance within a replica set."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:52
msgid ""
"**version** Tarantool version. This value is also shown by "
":ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:54
msgid ""
"**status** Usually this is 'running', but it can be 'loading', 'orphan', "
"or 'hot_standby'."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:55
msgid "**vclock** Same as replication.vclock."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:56
msgid ""
"**pid** Process ID. This value is also shown by the :ref:`tarantool "
"<tarantool-build>` module. This value is also shown by the Linux \"ps "
"-A\" command."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:59
msgid ""
"**cluster.uuid** UUID of the cluster. Every replica in a replica set will"
" have the same cluster.uuid value. This value is also in the "
":ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:61
msgid ""
"**replication.lag** Number of seconds that the replica is behind the "
"master."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:62
msgid ""
"**replication.status** Usually this is 'follow', but it can be 'off', "
"'stopped', 'connecting', 'auth', or 'disconnected'."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:64
msgid "**replication.idle** Number of seconds that the instance has been idle."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:65
msgid ""
"**replication.vclock** See the :ref:`discussion of \"vector clock\" "
"<internals-vector>` in the Internals section."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:66
msgid ""
"**replication.uuid** The unique identifier of a master to which this "
"instance is connected."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:67
msgid ""
"**replication.uptime** Number of seconds since the instance started. This"
" value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:70
msgid ""
"The replication fields are blank unless the instance is a :ref:`replica "
"<index-box_replication>`. The replication fields are in an array if the "
"instance is a replica for more than one master."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:75
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate "
"over keys with the Lua ``pairs()`` function. For this purpose, "
"``box.info()`` builds and returns a Lua table with all keys and values "
"provided in the submodule."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:80
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/1.6/book/box/box_info.rst:85
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 0\n"
"    ro: false\n"
"    uuid: 25684d65-636e-44cd-ab5d-4bb38d9b4411\n"
"    id: 1\n"
"  version: 1.6.9-28-g75ec202\n"
"  status: running\n"
"  vclock: {}\n"
"  pid: 8228\n"
"  cluster:\n"
"    uuid: e17aac30-e85a-40be-ad4a-9bf4c1f9ed43\n"
"    signature: 0\n"
"  replication: {}\n"
"  uptime: 15\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.6.9-28-g75ec202\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:39
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/1.6/book/box/box_schema.rst:43
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, and function tuples."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:50
msgid "Create a space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:52
msgid ""
"name of space, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:54
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:56
msgid "space object"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:57
#: ../doc/1.6/dev_guide/documentation_guidelines.rst:243
#: ../doc/1.6/reference/reference_lua/fiber.rst:97
#: ../doc/1.6/reference/reference_lua/fiber.rst:121
#: ../doc/1.6/reference/reference_lua/fiber.rst:141
#: ../doc/1.6/reference/reference_lua/fio.rst:388
#: ../doc/1.6/reference/reference_lua/net_box.rst:84
#: ../doc/1.6/reference/reference_lua/socket.rst:145
#: ../doc/1.6/reference/reference_lua/socket.rst:163
#: ../doc/1.6/reference/reference_lua/socket.rst:353
#: ../doc/1.6/reference/reference_lua/socket.rst:379
#: ../doc/1.6/reference/reference_lua/tap.rst:57
msgid "userdata"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:61
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:69 ../doc/1.6/book/box/box_space.rst:59
#: ../doc/1.6/book/box/box_space.rst:243 ../doc/1.6/book/box/box_space.rst:1381
msgid "Name"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:69 ../doc/1.6/book/box/box_space.rst:243
msgid "Default"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:71
msgid "temporary"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:71
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-"
"ahead log <internals-wal>` and there is no :ref:`replication <index-"
"box_replication>`."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:71 ../doc/1.6/book/box/box_schema.rst:87
#: ../doc/1.6/reference/reference_lua/msgpack.rst:171
msgid "false"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:77 ../doc/1.6/book/box/box_space.rst:249
msgid "id"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:77
msgid ""
"unique identifier: users can refer to spaces with the id instead of the "
"name"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:77
msgid "last space's id, +1"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:81
msgid "field_count"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:81
msgid ""
"fixed count of fields: for example if field_count=5, it is illegal to "
"insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:81
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:87 ../doc/1.6/book/box/box_space.rst:253
msgid "if_not_exists"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:87
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:93
msgid "engine"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:93
#, fuzzy
msgid "storage engine: 'memtx'"
msgstr "Дисковый движок vinyl"

#: ../doc/1.6/book/box/box_schema.rst:93 ../doc/1.6/book/box/box_schema.rst:96
#: ../doc/1.6/book/box/box_schema.rst:305
#: ../doc/1.6/book/box/box_session.rst:72
#: ../doc/1.6/book/box/box_session.rst:91
#: ../doc/1.6/book/box/data_model.rst:191
#: ../doc/1.6/reference/reference_lua/errno.rst:73
#: ../doc/1.6/reference/reference_lua/fiber.rst:192
#: ../doc/1.6/reference/reference_lua/fiber.rst:296
#: ../doc/1.6/reference/reference_lua/fiber.rst:341
#: ../doc/1.6/reference/reference_lua/fio.rst:68
#: ../doc/1.6/reference/reference_lua/fio.rst:88
#: ../doc/1.6/reference/reference_lua/fio.rst:106
#: ../doc/1.6/reference/reference_lua/json.rst:55
#: ../doc/1.6/reference/reference_lua/msgpack.rst:52
#: ../doc/1.6/reference/reference_lua/pickle.rst:94
#: ../doc/1.6/reference/reference_lua/socket.rst:291
#: ../doc/1.6/reference/reference_lua/socket.rst:322
#: ../doc/1.6/reference/reference_lua/socket.rst:338
#: ../doc/1.6/reference/reference_lua/yaml.rst:52
msgid "string"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:93
msgid "'memtx'"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:96 ../doc/1.6/book/box/box_space.rst:1383
#: ../doc/1.6/book/box/box_space.rst:1386
msgid "user"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:96
msgid ""
"name of the user who is considered to be the space's :ref:`owner "
"<authentication-owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:96
msgid "current user's name"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:101
msgid "format"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:101
msgid ""
"field names and types: For an illustration with the ``format`` option, "
"see the :ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:101
msgid "(blank)"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:108
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` "
"for object references targeting space objects, for example "
":samp:`box.schema.space.drop({space-id})` will drop a space. However, the"
" common approach is to use functions attached to the space objects, for "
"example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:117
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:135
msgid ""
"After a space is created, usually the next step is to :ref:`create an "
"index <box_space-create_index>` for it, and then it is available for "
"insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:143
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:148
#: ../doc/1.6/book/box/box_schema.rst:498
msgid "The possible options are:"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:150
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already exists,"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:153
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform "
"Resource Identifier) it is usually illegal to include a user-name without"
" a password."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:160
#: ../doc/1.6/book/box/box_space.rst:1465
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:162
msgid ""
"name of user, which should not be a number and should not contain special"
" characters"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:164
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:168
#: ../doc/1.6/book/box/box_schema.rst:189
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/1.6/book/box/box_schema.rst:170
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:180
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:185
#: ../doc/1.6/book/box/box_schema.rst:205
#: ../doc/1.6/book/box/box_schema.rst:223
#: ../doc/1.6/book/box/box_schema.rst:256
msgid "the name of the user"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:186
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:191
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:200
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not "
"exist. For explanation of how Tarantool maintains user data, see section "
":ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:206
#: ../doc/1.6/book/box/box_schema.rst:406
#: ../doc/1.6/book/box/box_schema.rst:552
#: ../doc/1.6/reference/reference_lua/uuid.rst:140
msgid "bool"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:210
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:220
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or "
"to another role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:224
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:225
msgid "'space' or 'function'."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:226
msgid "name of object to grant permissions to"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:227
msgid "name of role to grant to user."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:229
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple "
"with that object-name must exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:232
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'. In this case, object name"
" is omitted."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:235
#: ../doc/1.6/book/box/box_schema.rst:267
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:240
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:253
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user "
"or from another role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:257
#: ../doc/1.6/book/box/box_schema.rst:423
#: ../doc/1.6/book/box/box_schema.rst:451
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:258
#: ../doc/1.6/book/box/box_schema.rst:424
#: ../doc/1.6/book/box/box_schema.rst:452
msgid "'space' or 'function'"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:259
#: ../doc/1.6/book/box/box_schema.rst:425
#: ../doc/1.6/book/box/box_schema.rst:453
msgid "the name of a function or space"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:261
msgid ""
"The user must exist, and the object must exist, but it is not an error if"
" the user does not have the privilege."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:264
#: ../doc/1.6/book/box/box_schema.rst:429
#: ../doc/1.6/book/box/box_schema.rst:458
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:272
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:283
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool "
"maintains passwords, see section :ref:`Passwords <authentication-"
"passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:289
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not "
"usable from a remote connection. Such users can be useful if they have "
"defined some procedures with the :ref:`SETUID <box_schema-func_create>` "
"option, on which privileges are granted to externally-connectable users. "
"This way, external users cannot create/drop objects, they can only invoke"
" procedures."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:296
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established "
"connection over a :ref:`binary port <admin-security>`, and Tarantool does"
" not require a password to establish a binary connection. It is, however,"
" possible to change the current user to ‘guest’ by providing the AUTH "
"packet with no password at all or an empty password. This feature is "
"useful for connection pools, which want to reuse a connection for a "
"different user without re-establishing it."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:304
msgid "password to be hashed"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:309
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:317
msgid ""
"Associate a password with the user who is currently logged in, or with "
"another user."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:320
msgid ""
"Users who wish to change their own passwords should use "
"``box.schema.user.passwd(password)`` syntax."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:323
msgid ""
"Administrators who wish to change passwords of other users should use "
"``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:326
msgid "user-name"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:327
msgid "password"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:331
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:340
msgid ""
"Return a description of a user's privileges. For explanation of how "
"Tarantool maintains user data, see section :ref:`Users <authentication-"
"users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:345
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:353
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:362
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:366
msgid ""
"name of role, which should not be a number and should not contain special"
" characters"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:368
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already exists"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:376
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:385
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:389
#: ../doc/1.6/book/box/box_schema.rst:405
#: ../doc/1.6/book/box/box_schema.rst:422
#: ../doc/1.6/book/box/box_schema.rst:450
msgid "the name of the role"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:390
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:395
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:403
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not "
"exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:410
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:420
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:427
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:432
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` -- to grant a role to a role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:437
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:448
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:455
msgid ""
"The role must exist, and the object must exist, but it is not an error if"
" the role does not have the privilege."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:461
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name``."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:466
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:477
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:479
msgid "the name of the role."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:483
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:491
msgid ""
"Create a function tuple. This does not create the function itself -- that"
" is done with Lua -- but if it is necessary to grant privileges for a "
"function, box.schema.func.create must be done first. For explanation of "
"how Tarantool maintains function data, see reference on :ref:`_func "
"<box_space-func>` space."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:500
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the ``_func`` tuple already "
"exists."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:503
msgid ""
"``setuid`` = ``true|false`` (default = false) - with ``true`` to make "
"Tarantool treat the function’s caller as the function’s creator, with "
"full privileges. Remember that SETUID works only over :ref:`binary ports "
"<admin-security>`. SETUID doesn't work if you invoke a function via an "
"admin console or inside a Lua script."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:510
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:512
msgid ""
"name of function, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:514
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:520
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:531
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains "
"function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:535
#: ../doc/1.6/book/box/box_schema.rst:551
msgid "the name of the function"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:536
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:541
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:549
msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_schema.rst:556
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:39
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/1.6/book/box/box_session.rst:41
msgid ""
"The ``box.session`` submodule allows querying the session state, writing "
"to a session-specific temporary Lua table, or setting up triggers which "
"will fire when a session starts or ends. A *session* is an object "
"associated with each client connection."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:50
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"meaning there is no session."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:56
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:61
msgid ""
"This function works only if there is a peer, that is, if a connection has"
" been made to a separate Tarantool instance."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:64
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to "
"a separate instance, the return is null. The command is executed on the "
"server instance, so the \"local name\" is the server instance's host and "
"port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:74
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:80
msgid ""
"the value of the :code:`sync` integer constant used in the `binary "
"protocol "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/iproto_constants.h>`_."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:89
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:97
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:100
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current"
" user <authentication-users>` temporarily while executing the function --"
" this is analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:105
msgid "name of a target user"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:106
msgid ""
"name of a function, or definition of a function. Additional parameters "
"may be passed to ``box.session.su``, they will be interpreted as "
"parameters of function-to-execute."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:113
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:135
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool "
"queue manager <https://github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:142
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:171
msgid ""
"Define a trigger for execution when a new session is created due to an "
"event such as :ref:`console.connect <console-connect>`. The trigger "
"function will be the first thing executed after a new session is created."
" If the trigger execution fails and raises an error, the error is sent to"
" the client and the connection is closed."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:176
#: ../doc/1.6/book/box/box_session.rst:207
#: ../doc/1.6/book/box/box_session.rst:280
#: ../doc/1.6/book/box/box_space.rst:540
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:177
#: ../doc/1.6/book/box/box_session.rst:208
#: ../doc/1.6/book/box/box_session.rst:281
#: ../doc/1.6/book/box/box_space.rst:542
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:178
#: ../doc/1.6/book/box/box_session.rst:209
#: ../doc/1.6/book/box/box_session.rst:282
#: ../doc/1.6/book/box/box_space.rst:545
msgid "nil or function pointer"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:180
#: ../doc/1.6/book/box/box_session.rst:211
#: ../doc/1.6/book/box/box_session.rst:284
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:182
#: ../doc/1.6/book/box/box_session.rst:213
#: ../doc/1.6/book/box/box_session.rst:286
#, fuzzy
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""
"См. подробности о работе потока записи в WAL в разделе  :ref:`Детали "
"реализации <b_internals>`."

#: ../doc/1.6/book/box/box_session.rst:186
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:195
msgid ""
"If a trigger always results in an error, it may become impossible to "
"connect to a server to reset it."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:202
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the "
"client still exists and can access session properties, such as "
"box.session.id."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:217
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:226
msgid ""
"After the following series of requests, a Tarantool instance will write a"
" message using the :ref:`log <log-module>` module whenever any user "
"connects or disconnects."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:229
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:246
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:248
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:259
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:261
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:263
msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:268
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate "
":ref:`authentication packet <box_protocol-authentication>`. For this "
"case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:272
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to "
"\"guest\", the user name before the authentication is done. To get the "
"user name **after** the authentication is done, use the special syntax: "
":code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:278
msgid ""
"If the trigger fails by raising an error, the error is sent to the client"
" and the connection is closed."
msgstr ""

#: ../doc/1.6/book/box/box_session.rst:290
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:39
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:43
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store tuples. This can "
"be used to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:51
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:55
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:56
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:57
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:63
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:80
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:82
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are "
"high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high "
"(90-95%)."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:85
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. "
"the memory is used efficiently)."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:89
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily "
"fragmentized. Most probably, there is no immediate out-of-memory risk in "
"this case, but generally this is an issue to consider. For example, "
"probable risks are that the entire memory quota is used for tuples, and "
"there is are no slabs left for a piece of an index. Or that all slabs are"
" allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:99
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:101
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator "
"can use for both tuples and indexes (as configured in "
":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` parameter, e.g. "
"the default is 1 gigabyte = 2^30 bytes = 1,073,741,824 bytes);"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:105
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:106
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the"
" slab allocator;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:108
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together"
" (including allocated, but currently free slabs);"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:110
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and "
"indexes together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:117
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:138
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. "
"The report is broken down into groups by *data item size* as well as by "
"*slab size* (64-byte, 136-byte, etc). The report includes the memory "
"allocated for storing both tuples and indexes."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:145
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:146
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and "
"indexes);"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:147
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:148
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:149
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:150
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:156
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:158
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:170
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) "
"stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so "
"``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of "
"which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:175
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:177
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/1.6/book/box/box_slab.rst:208
msgid ""
"The total ``mem_used`` for all groups in this report equals "
"``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:40
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/1.6/book/box/box_space.rst:42
msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:48
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all "
"``box.space`` members."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:51
msgid "**The functions and members of box.space**"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:59
msgid "Use"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:61
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:61
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:64
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:64 ../doc/1.6/book/box/box_space.rst:88
msgid "Get count of tuples"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:67
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:67
msgid "Create an index"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:70
msgid ":ref:`space_object:dec() <box_space-dec>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:70
msgid "Decrement a tuple's counter"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:73
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:73
msgid "Delete a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:76
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:76
msgid "Destroy a space"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:79
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:79
msgid "Select a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:82
msgid ":ref:`space_object:inc() <box_space-inc>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:82
msgid "Increment a tuple's counter"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:85
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:85
msgid "Insert a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:88
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:91
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:91
msgid "Create a replace trigger"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:94
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:94
msgid "Prepare for iterating"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:97
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:97 ../doc/1.6/book/box/box_space.rst:103
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:100
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:100
msgid "Rename a space"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:103
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:106
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:106
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:109
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:109
msgid "Select one or more tuples"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:112
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:112
msgid "Delete all tuples"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:115
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:115 ../doc/1.6/book/box/box_space.rst:118
msgid "Update a tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:118
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:121
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:121
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:124
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:124
msgid "Required number of fields"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:127
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:127
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:130
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:130
msgid "Container of space's indexes"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:133
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:133
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:136
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:136
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:139
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:139
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:142
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:142
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:145
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:145
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:148
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:148
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:151
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:151
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:163
msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have a ``num`` primary key index of type "
"``TREE``. The primary-key field will be incremented before the insert."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:168 ../doc/1.6/book/box/box_space.rst:198
#: ../doc/1.6/book/box/box_space.rst:224 ../doc/1.6/book/box/box_space.rst:368
#: ../doc/1.6/book/box/box_space.rst:401 ../doc/1.6/book/box/box_space.rst:423
#: ../doc/1.6/book/box/box_space.rst:495 ../doc/1.6/book/box/box_space.rst:518
#: ../doc/1.6/book/box/box_space.rst:602 ../doc/1.6/book/box/box_space.rst:657
#: ../doc/1.6/book/box/box_space.rst:687 ../doc/1.6/book/box/box_space.rst:740
#: ../doc/1.6/book/box/box_space.rst:814 ../doc/1.6/book/box/box_space.rst:874
#: ../doc/1.6/book/box/box_space.rst:991
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:170
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:173 ../doc/1.6/book/box/box_space.rst:691
msgid "the inserted tuple."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:176 ../doc/1.6/book/box/box_space.rst:408
#: ../doc/1.6/book/box/box_space.rst:433 ../doc/1.6/book/box/box_space.rst:698
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:179
msgid ""
"**Possible errors:** index has wrong type or primary-key indexed field is"
" not a number."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:183
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:200 ../doc/1.6/book/box/box_space.rst:370
#: ../doc/1.6/book/box/box_space.rst:876
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:204
msgid "Number of tuples."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:208
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:219
msgid ""
"Create an index. It is mandatory to create an index for a space before "
"trying to insert tuples into it, or select tuples from it. The first "
"created index, which will be used as the primary-key index, must be "
"unique."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:226
msgid ""
"name of index, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:230
msgid "index object"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:231
msgid "index_object"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:235
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:245
msgid "type"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:245
msgid "type of index"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:245
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:245
msgid "'TREE'"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:249
msgid "unique identifier"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:249
msgid "last index's id, +1"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:251
msgid "unique"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:251
msgid "index is unique"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:251
msgid "``true``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:253
msgid "no error if duplicate name"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:253
msgid "``false``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:256
msgid "parts"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:256
msgid "field-numbers  + types"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:256
msgid "{field_no, 'NUM' or 'STR' or 'ARRAY')"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:256
msgid "``{1, 'NUM'}``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:259
msgid "dimension"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:259 ../doc/1.6/book/box/box_space.rst:261
msgid "affects RTREE only"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:259 ../doc/1.6/book/box/box_space.rst:1389
msgid "2"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:261
msgid "distance"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:261
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:261
msgid "'euclid'"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:265
msgid ""
"**Possible errors:** too many parts. Index '...' already exists. Primary "
"key must be unique."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:267
#, fuzzy
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'NUM', "
"2, 'STR'}})\n"
"---\n"
"..."
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.6/book/box/box_space.rst:278
#, fuzzy
msgid "Details about index field types:"
msgstr "Тип поля для индексирования"

#: ../doc/1.6/book/box/box_space.rst:280
msgid ""
"The three index field types (NUM | STR | ARRAY) differ depending on what "
"values are allowed, and what index types are allowed."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:284
msgid ""
"**NUM**: unsigned integers between 0 and 18446744073709551615, about 18 "
"quintillion. The name will be changed to 'unsigned' in Tarantool version "
"1.7. Legal in memtx TREE or HASH indexes."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:287
msgid ""
"**STR**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. The name will be changed to 'string' "
"in Tarantool version 1.7. Legal in memtx TREE or HASH or BITSET indexes."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:291
#, fuzzy
msgid ""
"**ARRAY**: array of integers between -9223372036854775808 and "
"9223372036854775807. Legal in memtx RTREE indexes."
msgstr ""
"``integer`` (знаковое целое число в диапазоне от "
"-9,223,372,036,854,775,808 до 9,223,372,036,854,775,807)"

#: ../doc/1.6/book/box/box_space.rst:296
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:305
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.6/book/box/box_space.rst:305
msgid "What can be in it"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:305
msgid "Where is it legal"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:305 ../doc/1.6/book/box/data_model.rst:279
#: ../doc/1.6/reference/reference_lua/socket.rst:590
msgid "Examples"
msgstr "Примеры:"

#: ../doc/1.6/book/box/box_space.rst:307
msgid "**NUM**"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:307
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:307
msgid "memtx TREE or HASH indexes, |br|"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:307
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/1.6/book/box/box_space.rst:310
#, fuzzy
msgid "**STR**"
msgstr "**scalar**"

#: ../doc/1.6/book/box/box_space.rst:310
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:310
msgid "memtx TREE or HASH indexes |br|"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:310
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:313
#, fuzzy
msgid "**ARRAY**"
msgstr "**scalar**"

#: ../doc/1.6/book/box/box_space.rst:313
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:313
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:313
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:322
msgid ""
"Decrements a counter in a tuple whose primary key matches the ``field-"
"value(s)``. The field following the primary-key fields will be the "
"counter. If there is no tuple matching the ``field-value(s)``, a new one "
"is not inserted. If the counter value drops to zero, the tuple is "
"deleted."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:328 ../doc/1.6/book/box/box_space.rst:459
msgid ""
"Parameters: :samp:`{space_object}` = an object reference; :codeitalic"
":`field-value(s)` (type = Lua table or scalar) = values which must match "
"the primary key."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:331 ../doc/1.6/book/box/box_space.rst:462
msgid "the new counter value"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:334
msgid "**Complexity factors:** Index size, Index type, WAL settings."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:338
msgid ""
"tarantool> s = box.schema.space.create('space19')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   unique = true,\n"
"         >   parts = {1, 'NUM', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> box.space.space19:insert{1, 'a', 1000}\n"
"---\n"
"- [1, 'a', 1000]\n"
"...\n"
"tarantool> box.space.space19:dec{1, 'a'}\n"
"---\n"
"- 999\n"
"...\n"
"tarantool> box.space.space19:dec{1, 'a'}\n"
"---\n"
"- 998\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:366
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:373
msgid "the deleted tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:376
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:380
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected num'\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:399
msgid "Drop a space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:406
msgid "**Possible errors:** If ``space_object`` does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:413
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:421
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:425 ../doc/1.6/book/box/box_space.rst:742
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:428
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:431
msgid "**Possible errors:** If space_object does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:436
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:444
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:452
msgid ""
"Increments a counter in a tuple whose primary key matches the field-"
"value(s). The field following the primary-key fields will be the counter."
" If there is no tuple matching the ``field-value(s)``, a new one is "
"inserted with initial counter value set to ``1``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:465
msgid "**Complexity Factors:** Index size, Index type, WAL settings."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:469
msgid ""
"tarantool> s = box.schema.space.create('forty_second_space')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   unique = true,\n"
"         >   parts = {1, 'NUM', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> box.space.forty_second_space:inc{1, 'a'}\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.forty_second_space:inc{1, 'a'}\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:493
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:497
msgid "tuple to be inserted."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:499
msgid "the inserted tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:502
msgid ""
"**Possible errors:** If a tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:507
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:521
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:525
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:536
msgid ""
"Create a \"replace trigger\". The ``trigger-function`` will be executed "
"whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` "
"or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:547
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted. Details about trigger characteristics are in the "
":ref:`triggers <triggers-box_triggers>` section."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:551 ../doc/1.6/book/box/box_space.rst:1279
#, fuzzy
msgid "**Example #1:**"
msgstr "**Примеры:**"

#: ../doc/1.6/book/box/box_space.rst:553
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:560
msgid ""
"The ``trigger-function`` can have two parameters: old tuple, new tuple. "
"For example, the following code causes nil to be printed when the insert "
"request is processed, and causes [1, 'Hi'] to be printed when the delete "
"request is processed:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:565
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:574 ../doc/1.6/book/box/box_space.rst:1323
#, fuzzy
msgid "**Example #2:**"
msgstr "**Примеры:**"

#: ../doc/1.6/book/box/box_space.rst:576
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:581
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:599
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:606
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:613 ../doc/1.6/book/box/box_space.rst:752
msgid "**Possible errors:** No such space; wrong type."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:617
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:624
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'NUM'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:655
msgid "Rename a space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:659
msgid "new name for space"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:663
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:667
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:681
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:689
msgid "tuple to be inserted"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:694
msgid ""
"**Possible errors:** If a different tuple with the same unique-key value "
"already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen"
" if there is a unique secondary index.)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:703
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:712
msgid ""
"At the time that a trigger is defined, it is automatically enabled - that"
" is, it will be executed. Replace triggers can be disabled with "
":samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with "
":samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:721
msgid ""
"The following series of requests will associate an existing function "
"named F with an existing space named T, associate the function a second "
"time with the same space (so it will be called twice), disable all "
"triggers of T, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:726
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:738
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:745
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:758
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'NUM', 2, 'STR'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:803
msgid ""
"For examples of complex ``select`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\") and how many tuples to return, see the later "
"section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:812
msgid "Deletes all tuples."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:823
msgid ""
"Note that ``truncate`` must be called only by the user who created the "
"space OR under a `setuid` function created by that user. Read more about "
"`setuid` functions in reference on :ref:`box.schema.func.create() "
"<box_schema-func_create>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:830
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:846
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field number. When multiple operations are present, the field number for "
"each operation is assumed to be relative to the most recent state of the "
"tuple, that is, as if all previous operations in a multi-operation update"
" have already been applied. In other words, it is always safe to merge "
"multiple ``update`` invocations into a single invocation, with no change "
"in semantics."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:858
msgid "Possible operators are:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:860
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:861
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:862
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:863
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:864
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned "
"numeric)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:866
msgid "``:`` for string splice"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:867
msgid "``!`` for insertion"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:868
msgid "``#`` for deletion"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:869
msgid "``=`` for assignment"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:871
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning "
"the last field in the tuple."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:888
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:890 ../doc/1.6/book/box/box_space.rst:1007
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:893
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:895
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:899
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:907
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``num``. There is one tuple, with ``field[1]`` = "
"``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:911
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation — *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:922
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:929
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:936
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:944
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:953
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]``` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:961
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:966
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:979
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:981
msgid ""
"If there is an existing tuple which matches the key fields of "
"``tuple_value``, then the request has the same effect as "
":ref:`space_object:update() <box_space-update>` and the ``{{operator, "
"field_no, value}, ...}`` parameter is used. If there is no existing tuple"
" which matches the key fields of ``tuple_value``, then the request has "
"the same effect as :ref:`space_object:insert() <box_space-insert>` and "
"the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or "
"``update``, ``upsert`` will not read a tuple and perform error checks "
"before returning -- this is a design feature which enhances throughput "
"but requires more caution on the part of the user."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:993
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1002
msgid "null"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1004
msgid ""
"**Possible errors:** it is illegal to modify a primary-key field. It is "
"illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1012
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1025
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1032
msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1038
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1044
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1048
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1060
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1067
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1076
msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1084
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1099
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <index-box_replication>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1106
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1109
#: ../doc/1.6/book/box/box_space.rst:1161
#: ../doc/1.6/book/box/box_space.rst:1199
#: ../doc/1.6/book/box/box_space.rst:1269
#: ../doc/1.6/book/box/box_space.rst:1362
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1111
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1112
msgid "the function name,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1113
msgid "flag,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1114
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1116
msgid ""
"The ``_func`` space does not include the function’s body. You continue to"
" create Lua functions in the usual way, by saying ``function "
"function_name () ... end``, without adding anything in the ``_func`` "
"space. The ``_func`` space only exists for storing function tuples so "
"that their names can be used within grant/revoke functions."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1123
#: ../doc/1.6/book/box/box_space.rst:1208
msgid "You can:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1125
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1127
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1129
msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1134
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1138
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1159
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1163
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1164
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1165
#, fuzzy
msgid "``name``,"
msgstr "``username``"

#: ../doc/1.6/book/box/box_space.rst:1166
msgid "``type``,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1167
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1169
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1171
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'str']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'num']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'num']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'str']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'num']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'num']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'str']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'num'], [1, "
"'num']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'num'], [2, 'str']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'num'], [1, "
"'num']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'num'], [2, 'str']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'num']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'num']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'str']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1196
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1201
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1202
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1203
msgid "the type of object: 'space', 'function' or 'universe',"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1204
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1205
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, or a"
" combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1210
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1211
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1215
msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1218
msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1221
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1223
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1226
msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"user’s password."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1233
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1235
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1237
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1238
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1239
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1240
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1250
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1253
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 6, 8]"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1267
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1271
#, fuzzy
msgid "``id``,"
msgstr "``pid_file``"

#: ../doc/1.6/book/box/box_space.rst:1272
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1273
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1274
msgid "``flags`` (e.g. temporary), ``format``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1276
msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1281
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1284
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1303
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1305
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1325
msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a ``format`` clause. Then it retrieves"
" the ``_space`` tuple for the new space. This illustrates the typical use"
" of the ``format`` clause, it shows the recommended names and data types "
"for the fields."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1331
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"num\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'num'}]]\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1360
msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1364
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1365
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1366
#, fuzzy
msgid "the name,"
msgstr "telnet,"

#: ../doc/1.6/book/box/box_space.rst:1367
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1368
msgid "optional password."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1370
msgid ""
"There are four special tuples in the ``_user`` space: 'guest', 'admin', "
"'public' and 'replication'."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1381
msgid "ID"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1383
msgid "guest"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1383
msgid "0"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1383
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1386
msgid "admin"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1386
msgid "1"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1386
msgid ""
"Default user when using Tarantool as a console. Usually an administrative"
" user with all privileges."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1389
msgid "public"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1389
#: ../doc/1.6/book/box/box_space.rst:1397
msgid "role"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1389
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically assigned to"
" new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore, a convenient way to grant 'read' on space 't' to "
"every user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1397
msgid "replication"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1397
msgid "3"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1397
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, assigned by the 'admin' "
"user to users who need to use :ref:`replication <index-box_replication>` "
"features."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1402
msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1406
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1415
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1419
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1424
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1428
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1433
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1441
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1446
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1448
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1454
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1456
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1461
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1469
msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1472
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1488
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1490
msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1500
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1524
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1526
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1546
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1548
msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1551
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1553
msgid ""
"A simple way is to look at the constants in box.schema, which tell us "
"that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1557
msgid "``box.space._space:select{ 288 }``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1558
msgid "or"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1559
msgid "``box.space._space:select{ box.schema.SPACE_ID }``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1561
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us "
"that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1565
msgid "``box.space._space.index.name:select{ '_space' }``"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1567
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1569
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1579
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""

#: ../doc/1.6/book/box/box_space.rst:1584
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_stat.rst:39
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/1.6/book/box/box_stat.rst:41
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics. Show the average number of requests per second, and the total"
" number of requests since startup, broken down by request type and "
"network events statistics."
msgstr ""

#: ../doc/1.6/book/box/box_stat.rst:45
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: &0 []\n"
"- *0\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:39
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/1.6/book/box/box_tuple.rst:43
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` "
"userdata type. It allows, for a single tuple: selective retrieval of the "
"field contents, retrieval of information about size, iteration over all "
"the fields, and conversion to a Lua table."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:52
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively,"
" one can get new tuples from tarantool's :ref:`select <box_space-select>`"
" or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-"
"replace>` or :ref:`update <box_space-update>` requests, which can be "
"regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:59
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:61
msgid "a new tuple"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:64
msgid ""
"In the following example, ``x`` will be a new table object containing one"
" tuple and ``t`` will be a new tuple object. Saying ``t`` returns the "
"entire tuple ``t``."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:70
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:91
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if "
"``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:96
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"number of fields in ``t`` is returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:99
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:111
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of "
"bytes in the tuple. With the memtx storage engine the default maximum "
"number is :ref:`one megabyte <cfg_storage-slab_alloc_maximal>`. Every "
"field has one or more \"length\" bytes preceding the actual contents, so "
"``bsize()`` returns a value which is slightly greater than the sum of the"
" lengths of the contents."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:121
msgid ""
"In the following example, a tuple named ``t`` is created which has three "
"fields, and for each field it takes one byte to store the length and "
"three bytes to store the contents, and a bit for overhead, so ``bsize()``"
" returns ``3*(1+3)+1``."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:126
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:138
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field "
"numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:141
msgid "field value."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:142
msgid "lua-value"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:144
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"second field in ``t`` is returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:147
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:160
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the "
"number of the first field in ``t`` that matches the search value, and "
"``t:findall(search-value [, search-value ...])`` will return numbers of "
"all fields in ``t`` that match the search value. Optionally one can put a"
" numeric argument ``field-number`` before the search-value to indicate "
"“start searching at field number ``field-number``.”"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:167
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:170
msgid ""
"In the following example, a tuple named ``t`` is created and then: the "
"number of the first field in ``t`` which matches 'a' is returned, then "
"the numbers of all the fields in ``t`` which match 'a' are returned, then"
" the numbers of all the fields in t which match 'a' and are at or after "
"the second field are returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:176
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:197
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number"
"},{fields-to-remove})` will return a tuple where, starting from field "
"``start-field-number``, a number of fields (``fields-to-remove``) are "
"removed. Optionally one can add more arguments after ``fields-to-remove``"
" to indicate new values that will replace what was removed."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:203
msgid "base 1, may be negative"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:209
msgid ""
"In the following example, a tuple named ``t`` is created and then, "
"starting from the second field, two fields are removed but one new one is"
" added, then the result is returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:213
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:225
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, "
"``t:unpack(1)`` will return all fields starting with field number 1, "
"``t:unpack(1,5)`` will return all fields between field number 1 and field"
" number 5."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:229
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:230
msgid "lua-value(s)"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:232
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:235
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:251
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, "
"``t:totable(1)`` will return all fields starting with field number 1, "
"``t:totable(1,5)`` will return all fields between field number 1 and "
"field number 5. It is preferable to use ``t:totable()`` rather than "
"``t:unpack()``."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:256
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:257
#, fuzzy
msgid "lua-table"
msgstr "Lua table"

#: ../doc/1.6/book/box/box_tuple.rst:259
msgid ""
"In the following example, a tuple named ``t`` is created, then all its "
"fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:262
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:275
msgid ""
"In Lua, ``lua-table-value:pairs()`` is a method which returns: "
"``function``, ``lua-table-value``, ``nil``. Tarantool has extended this "
"so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, "
"``nil``. It is useful for Lua iterators, because Lua iterators traverse a"
" value's components until an end marker is reached."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:281
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:282
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:284
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:287
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:309
msgid ""
"This function updates a tuple which is not in a space. Compare the "
"function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, "
"{{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a "
"tuple in a space."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:313
msgid ""
"For details: see the description for ``operator``, ``field_no``, and "
"``value`` in the section :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:317
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:325
msgid "new tuple"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:328
msgid ""
"In the following example, a tuple named ``t`` is created and then its "
"second field is updated to equal 'B'."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:331
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:343
#: ../doc/1.6/reference/configuration/index.rst:125
#: ../doc/1.6/reference/reference_lua/digest.rst:230
#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:151
#: ../doc/1.6/reference/reference_lua/log.rst:77
#: ../doc/1.6/reference/reference_lua/msgpack.rst:74
#: ../doc/1.6/reference/reference_lua/tap.rst:213
#: ../doc/1.6/reference/reference_lua/uuid.rst:144
#: ../doc/1.6/reference/reference_lua/yaml.rst:70
#: ../doc/1.6/reference/reference_rock/dbms.rst:283
#: ../doc/1.6/reference/reference_rock/dbms.rst:625
msgid "Example"
msgstr "Пример"

#: ../doc/1.6/book/box/box_tuple.rst:345
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables "
"and lists of scalars:"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:348
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to "
"tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua "
"table\n"
"lua_table = tuple:totable()                             -- tuple to Lua "
"table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to "
"scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to "
"tuple"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:356
msgid ""
"Then it will find the field that contains 'b', remove that field from the"
" tuple, and display how many bytes remain in the tuple. The function uses"
" Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, "
"``transform()``, ``bsize()``."
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:361
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/1.6/book/box/box_tuple.rst:377
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:39
#, fuzzy
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/1.6/book/box/box_txn_management.rst:41
msgid ""
"For general information and examples, see section :ref:`Transaction "
"control <atomic-atomic_execution>`."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:44
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:46
msgid "Rule #1"
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:49
msgid ""
"The requests in a transaction must be sent to a server as a single block."
" It is not enough to enclose them between begin and commit or rollback. "
"To ensure they are sent as a single block: put them in a function, or put"
" them all on one line, or use a delimiter so that multi-line requests are"
" handled together."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:55
msgid "Rule #2"
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:58
msgid ""
"All database operations in a transaction should use the same storage "
"engine. As of Tarantool 1.6.9 February 2017 this does not matter because "
"the only engine is memtx. However, in future there will be more storage "
"engines."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:66
msgid ""
"Begin the transaction. Disable implicit yields until the transaction "
"ends. Signal that writes to the write-ahead log will be deferred until "
"the transaction ends. In effect the fiber which executes ``box.begin()`` "
"is starting an \"active multi-request transaction\", blocking all other "
"fibers."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:75
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/1.6/book/box/box_txn_management.rst:81
msgid ""
"End the transaction, but cancel all its data-change operations. An "
"explicit call to functions outside ``box.space`` that always yield, such "
"as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-"
"yield>`, will have the same effect."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:39
msgid "Data model"
msgstr "Модель данных"

#: ../doc/1.6/book/box/data_model.rst:41
msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение "
"данных и какие операции с данным он поддерживает."

#: ../doc/1.6/book/box/data_model.rst:44
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:54
msgid "Space"
msgstr "Пространство"

#: ../doc/1.6/book/box/data_model.rst:56
#, fuzzy
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../doc/1.6/book/box/data_model.rst:58
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:65
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:73
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:52
msgid "Tuple"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:75
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:79
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:80
msgid "fields don't need to have names."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:82
#, fuzzy
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, “1” or \"0\" can be used in some "
"contexts to refer to the first field of a tuple."
msgstr ""
"Кортеж может иметь любое количество полей, и это могут быть поля разных "
"типов. Идентификатором поля является его номер. Поля нумеруются, начиная "
"с 1. Так, например, “1” может использоваться в некоторых контекстах для "
"обозначения первого поля кортежа."

#: ../doc/1.6/book/box/data_model.rst:89
msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:92
msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML "
"<https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of"
" Base', 1993]``."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:100
msgid "Index"
msgstr "Индекс"

#: ../doc/1.6/book/box/data_model.rst:102
#, fuzzy
msgid "An **index** is a group of key values and pointers."
msgstr ""
"*Индекс* — в нашем примере он первичный — это совокупность значений "
"ключей и указателей."

#: ../doc/1.6/book/box/data_model.rst:104
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:107
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:112
msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:116
msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:119
#, fuzzy
msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""
"Первичный индекс для кортежа должен строиться по уникальным значениям "
"полей, но остальные (вторичные) индексы могут строиться по неуникальным "
"значениям."

#: ../doc/1.6/book/box/data_model.rst:123
#, fuzzy
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и типы данных для "
"этих полей. Индексированные поля могут содержать данные следующих типов:"

#: ../doc/1.6/book/box/data_model.rst:127
msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:130
#, fuzzy
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'NUM'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.6/book/box/data_model.rst:134
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:139
msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:142
#, fuzzy
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', unique = "
"false, parts = {2, 'STR'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.6/book/box/data_model.rst:146
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', and values in field"
" #2 need not be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:153
msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:157
msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:164
msgid "Data types"
msgstr "Типы данных"

#: ../doc/1.6/book/box/data_model.rst:166
msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:175
#, fuzzy
msgid "Lua vs MsgPack"
msgstr "Модуль `msgpack`"

#: ../doc/1.6/book/box/data_model.rst:185
#, fuzzy
msgid "Scalar / compound"
msgstr "compound"

#: ../doc/1.6/book/box/data_model.rst:185
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:185
#, fuzzy
msgid "Lua type"
msgstr "Типы данных"

#: ../doc/1.6/book/box/data_model.rst:185
#, fuzzy
msgid "Example value"
msgstr "Пример 2"

#: ../doc/1.6/book/box/data_model.rst:187
#: ../doc/1.6/book/box/data_model.rst:189
#: ../doc/1.6/book/box/data_model.rst:191
#: ../doc/1.6/book/box/data_model.rst:193
msgid "scalar"
msgstr "scalar"

#: ../doc/1.6/book/box/data_model.rst:187
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../doc/1.6/book/box/data_model.rst:187
#: ../doc/1.6/reference/reference_lua/msgpack.rst:183
msgid "msgpack.NULL"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:189
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../doc/1.6/book/box/data_model.rst:189
#: ../doc/1.6/reference/reference_lua/msgpack.rst:173
msgid "true"
msgstr "true"

#: ../doc/1.6/book/box/data_model.rst:191
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../doc/1.6/book/box/data_model.rst:191
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/1.6/book/box/data_model.rst:193
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../doc/1.6/book/box/data_model.rst:193
msgid "12345"
msgstr "12345"

#: ../doc/1.6/book/box/data_model.rst:195
#: ../doc/1.6/book/box/data_model.rst:197
#: ../doc/1.6/book/box/data_model.rst:199
msgid "compound"
msgstr "compound"

#: ../doc/1.6/book/box/data_model.rst:195
msgid "map"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:195
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:195
msgid "table: 0x410f8b10"
msgstr "table: 0x410f8b10"

#: ../doc/1.6/book/box/data_model.rst:197
#: ../doc/1.6/book/box/data_model.rst:199
msgid "array"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:197
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:197
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:199
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:199
#, fuzzy
msgid "[12345, 'A B C']"
msgstr "12345: {'A B C'}"

#: ../doc/1.6/book/box/data_model.rst:209
#, fuzzy
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"Тип *nil* (нулевой) может иметь только одно значение, также называемое "
"*nil*, но часто отображаемое как *null*. Нулевое значение можно "
"сравнивать со значениями любых типов с помощью операторов == (равен) или "
"~= (не равен), но никакие другие операции для нулевых значений не "
"доступны. Нулевые значения также нельзя использовать в Lua-таблицах; "
"вместо нулевого значения в таком случае можно указать :ref:`yaml.NULL "
"<yaml-null>`, либо :ref:`json.NULL <json-null>`, либо :ref:`msgpack.NULL "
"<msgpack-null>`."

#: ../doc/1.6/book/box/data_model.rst:217
#, fuzzy
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или "
"``false``."

#: ../doc/1.6/book/box/data_model.rst:219
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion. "
"So, string sorting and comparison are done byte-by-byte, without any "
"special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:229
#, fuzzy
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 billion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В языке Lua тип *number* (число) — это число с плавающей точкой двойной "
"точности, но в Tarantool'е можно использовать как целые числа, так и "
"числа с плавающей запятой. Tarantool по возможности сохраняет числовые "
"значения в виде чисел с плавающей точкой, если числовое значение содержит"
" десятичную запятую или если оно очень велико (более 100 триллионов = "
"1e14). Если в формате с плавающей точкой сохранить не удается, то "
"Tarantool сохраняет такое значение в виде целого числа. Чтобы даже очень "
"большие величины гарантированно обрабатывались как целые числа, "
"используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо "
"приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long)."
" Вот примеры записи чисел в различных представлениях (обычном, "
"экспоненциальном, с суффиксом ULL и с использованием функции tonumber64):"
" ``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."

#: ../doc/1.6/book/box/data_model.rst:240
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:245
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:252
msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:260
#, fuzzy
msgid "Indexed field types"
msgstr "Тип поля для индексирования"

#: ../doc/1.6/book/box/data_model.rst:262
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'NUM' is a separate **indexed field type**, compared to"
" ‘integer’ data type in MsgPack: they both store ‘integer’ values, but a "
"'NUM' index contains either *real or integer values* and a MsgPack "
"‘integer’ contains only *integer* values."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:268
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:279
#, fuzzy
msgid "Indexed field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.6/book/box/data_model.rst:279
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:279
#: ../doc/1.6/book/box/data_model.rst:608
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/1.6/book/box/data_model.rst:282
msgid "**num**"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:282
#, fuzzy
msgid "**integer** (integer between 0 and 9223372036854775807)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от "
"-9,223,372,036,854,775,808 до 9,223,372,036,854,775,807)"

#: ../doc/1.6/book/box/data_model.rst:287
msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:282
#: ../doc/1.6/book/box/data_model.rst:292
msgid "TREE or HASH"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:282
#, fuzzy
msgid "1.234"
msgstr "12345"

#: ../doc/1.6/book/box/data_model.rst:284
msgid "-44"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:286
msgid "1.447e+44"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:292
#, fuzzy
msgid "**str**"
msgstr "**scalar**"

#: ../doc/1.6/book/box/data_model.rst:292
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:292
msgid "‘A B C’"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:294
msgid "‘\\65 \\66 \\67’"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:296
msgid "**array**"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:296
msgid "**array** (arrays of integers between 0 and 9223372036854775807)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:296
#, fuzzy
msgid "RTREE"
msgstr "true"

#: ../doc/1.6/book/box/data_model.rst:296
msgid "{10, 11}"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:298
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:306
msgid "Persistence"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:308
msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
"**write ahead log (WAL)** files. This ensures data persistence. When a "
"power outage occurs or the Tarantool instance is killed incidentally, the"
" in-memory database is lost. In this situation, WAL files are used to "
"restore the data. Namely, Tarantool reads the WAL files and redoes the "
"requests (this is called the \"recovery process\"). You can change the "
"timing of the WAL writer, or turn it off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:317
#, fuzzy
msgid ""
"Tarantool also maintains a set of **checkpoint files**. These files "
"contain an on-disk copy of the entire data set for a given moment. "
"Instead of reading every WAL file since the databases were created, the "
"recovery process can load the latest checkpoint file and then read only "
"those WAL files that were produced after the checkpoint file was made. "
"After checkpointing, old WAL files can be removed to free up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(snapshots). Файл со снимком — это дисковая копия всех данных в базе на "
"какой-то момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся"
" с момента создания базы, Tarantool в процессе восстановления может "
"загрузить самый свежий снимок и затем зачитать только те WAL-файлы, "
"которые были сделаны с момента сохранения снимка. Снимки могут делаться "
"автоматически, или же пользователи могут создавать их сами в любой момент"
" с помощью запроса :ref:`box.snapshot() <admin-snapshot>`."

#: ../doc/1.6/book/box/data_model.rst:324
msgid ""
"To force immediate creation of a checkpoint, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of checkpoint files, you can use Tarantool's :ref:`snapshot "
"daemon <book_cfg_snapshot_daemon>`. The snapshot daemon sets intervals "
"for forced checkpoints. It makes sure that the state of the memtx engine "
"is saved to disk, and automatically removes old WAL files."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:332
msgid "Checkpoint files can be created even if there is no WAL file."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:336
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`snapshot daemon <book_cfg_snapshot_daemon>` configuration."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:339
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:344
msgid "Operations"
msgstr "Операции"

#: ../doc/1.6/book/box/data_model.rst:350
#, fuzzy
msgid "Data operations"
msgstr "Операции с индексами"

#: ../doc/1.6/book/box/data_model.rst:352
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:354
msgid "one data-retrieval operation (SELECT), and"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:355
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE)."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:357
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:359
#: ../doc/1.6/book/box/data_model.rst:526
#, fuzzy
msgid "**Examples**"
msgstr "**Примеры:**"

#: ../doc/1.6/book/box/data_model.rst:361
msgid "INSERT: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:363
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:365
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:367
#, fuzzy
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.6/book/box/data_model.rst:371
msgid "UPDATE: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:373
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:377
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:380
#, fuzzy
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.6/book/box/data_model.rst:384
msgid "UPSERT: Upsert the tuple, changing field field[2] again."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:386
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:392
#, fuzzy
msgid "tarantool> box.space.tester:upsert({999,''}, {{'=', 2, 'Tarantism'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.6/book/box/data_model.rst:396
msgid "REPLACE: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:398
msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:401
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:405
msgid "SELECT: Retrieve the tuple."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:407
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:409
#, fuzzy
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.6/book/box/data_model.rst:412
msgid "DELETE: Delete the tuple."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:414
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:416
#, fuzzy
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.6/book/box/data_model.rst:420
msgid ""
"All the functions operate on tuples and accept only unique key values. "
"So, the number of tuples affected is always 0 or 1, since the keys are "
"unique."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:425
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:432
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/1.6/book/box/data_model.rst:434
#, fuzzy
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"манипулированию данными меняет данные в кортеже, то меняются и ключи в "
"индексе для данного кортежа. Поэтому пользователю нужно знать только как "
"и зачем задавать индексы."

#: ../doc/1.6/book/box/data_model.rst:437
#, fuzzy
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция для создания индекса, которую мы рассматривали ранее, "
"имела следующий вид:"

#: ../doc/1.6/book/box/data_model.rst:442
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../doc/1.6/book/box/data_model.rst:444
#, fuzzy
msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю (обычно его "
"называют \"Field#1\") для всех кортежей в пространстве. Предполагается, "
"что индексируемое поле является числовым."

#: ../doc/1.6/book/box/data_model.rst:447
#, fuzzy
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/1.6/book/box/data_model.rst:452
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../doc/1.6/book/box/data_model.rst:454
#, fuzzy
msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one."
msgstr ""
"По умолчанию, такой запрос ищет нужный кортеж по значению в первом "
"(первичном) индексе. Поскольку первичный индекс всегда уникален, то "
"данный запрос вернет не более одного кортежа."

#: ../doc/1.6/book/box/data_model.rst:457
#, fuzzy
msgid "The following SELECT variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../doc/1.6/book/box/data_model.rst:459
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие "
"условия сравнения."

#: ../doc/1.6/book/box/data_model.rst:466
#, fuzzy
msgid ""
"The comparison operators are LT, LE, EQ, REQ, GE, GT (for \"less than\", "
"\"less than or equal\", \"equal\", \"reversed equal\", \"greater than or "
"equal\", \"greater than\" respectively). Comparisons make sense if and "
"only if the index type is ‘TREE'."
msgstr ""
"Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше"
" или равно), EQ (равно), REQ (неравно), GE (больше или равно), GT "
"(больше). Сравнения имеют смысл только для индексов типа 'tree'."

#: ../doc/1.6/book/box/data_model.rst:471
msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы в порядке убывания по ключу (если "
"использовался оператор LT, LE или REQ), либо в порядке возрастания (во "
"всех остальных случаях)."

#: ../doc/1.6/book/box/data_model.rst:475
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/1.6/book/box/data_model.rst:482
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При "
"поиске же по вторичному индексу имя индекса указывать необходимо."

#: ../doc/1.6/book/box/data_model.rst:485
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/1.6/book/box/data_model.rst:506
#, fuzzy
msgid "The search may be for all fields, using a table for the value:"
msgstr ""
"Поиск может производиться по всем полям (в этом случае используется "
"таблица значений):"

#: ../doc/1.6/book/box/data_model.rst:513
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"Либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../doc/1.6/book/box/data_model.rst:520
#, fuzzy
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1,"
" 'B'}``."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, "
"'B'}``. При необходимости можно задать даже нулевые поля, в результате "
"чего Tarantool вернет все три кортежа."

#: ../doc/1.6/book/box/data_model.rst:523
msgid ""
"You can specify even zero fields, causing all three tuples to be "
"returned. (Notice that partial key searches are available only in TREE "
"indexes.)"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:528
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/1.6/book/box/data_model.rst:530
#, fuzzy
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'NUM'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../doc/1.6/book/box/data_model.rst:541
#: ../doc/1.6/book/box/data_model.rst:563
#: ../doc/1.6/tutorials/lua_tutorials.rst:874
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/1.6/book/box/data_model.rst:543
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../doc/1.6/book/box/data_model.rst:550
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/1.6/book/box/data_model.rst:552
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/1.6/book/box/data_model.rst:554
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"

#: ../doc/1.6/book/box/data_model.rst:565
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../doc/1.6/book/box/data_model.rst:571
#, fuzzy
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком "
"внутри прямоугольника с углами в координатах 3,5,9,10."

#: ../doc/1.6/book/box/data_model.rst:574
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:580
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and"
" :ref:`drop() <box_index-drop>` in reference for :ref:`box.index "
"<box_index>` submodule."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:585
msgid "Complexity factors"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:587
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:597
msgid "Complexity factor"
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:600
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/1.6/book/box/data_model.rst:600
#, fuzzy
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В "
"случае с TREE-индексом: с ростом количества ключей увеличивается время "
"поиска, хотя зависимость здесь, конечно же, не линейная. В случае с "
"HASH-индексом: с ростом количества ключей увеличивается объем "
"используемой памяти, но количество низкоуровневых шагов остается примерно"
" тем же."

#: ../doc/1.6/book/box/data_model.rst:608
#, fuzzy
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу,"
" если в наборе есть более одного кортежа."

#: ../doc/1.6/book/box/data_model.rst:612
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/1.6/book/box/data_model.rst:612
#, fuzzy
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один "
"индекс. Но при обновлении значений в кортеже требуется N обращений, если "
"у набора кортежей есть N индексов."

#: ../doc/1.6/book/box/data_model.rst:616
msgid ""
"This complexity factor applies only to memtx,  since it always makes a "
"full-tuple copy update."
msgstr ""

#: ../doc/1.6/book/box/data_model.rst:619
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/1.6/book/box/data_model.rst:619
#, fuzzy
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. "
"Как правило, это наименее важный фактор из всех."

#: ../doc/1.6/book/box/data_model.rst:623
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/1.6/book/box/data_model.rst:623
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или"
" задана запись с задержкой, но этот фактор не так важен. Если же запись в"
" WAL производится при каждом запросе на изменение данных, то при каждом "
"таком запросе приходится ждать, пока отработает обращение к более "
"медленному диску, и данный фактор становится важнее всех остальных."

#: ../doc/1.6/book/box/index.rst:39
msgid "Database"
msgstr "Функционал СУБД"

#: ../doc/1.6/book/box/index.rst:41
msgid ""
"In this chapter, we introduce the basic concepts of working with "
"Tarantool as a database manager."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:39
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/1.6/book/box/limitations.rst:41
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:43
msgid ""
"For TREE or HASH indexes, the maximum is 255 "
"(``box.schema.INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but "
"the field is an ARRAY of up to 20 dimensions. For BITSET indexes, the "
"maximum is 1."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:50
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:52
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:56
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:58
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's "
":ref:`field_count <box_space-field_count>` member, or the maximal tuple "
"length."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:65
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:67
msgid ""
"The maximal number of bytes in a tuple is roughly equal to "
":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>` (with a "
"metadata overhead of about 20 bytes per tuple, which is added on top of "
"useful bytes). By default, the value of ``slab_alloc_maximal`` is "
"1,048,576. To increase it, specify a larger value when starting the "
"Tarantool instance. For example, "
"``box.cfg{slab_alloc_maximal=2*1048576}``."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:76
#, fuzzy
msgid "**Slab size**"
msgstr "**scalar**"

#: ../doc/1.6/book/box/limitations.rst:78
msgid ""
"The maximal size of an allocatable memory unit (slab) is equal to one "
"quarter of :ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>` (by"
" default, approximately 262,000 bytes). To see memory usage statistics "
"broken down by slab size, use :ref:`box.slab.stats() <box_slab_stats>`."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:85
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:87
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can"
" contain a million bytes, so the maximum is determined by factors such as"
" :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by "
"the index support."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:94
msgid "**Number of spaces**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:96
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:100
msgid "**Number of connections**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:102
msgid ""
"The practical limit is the number of file descriptors that one can set "
"with the operating system."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:107
msgid "**Space size**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:109
msgid ""
"The total maximum size for all spaces is in effect set by "
":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>`, which in turn is "
"limited by the total available memory."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:115
msgid "**Update operations count**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:117
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:122
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:124
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:128
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:130
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:134
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/1.6/book/box/limitations.rst:136
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:40
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/1.6/book/box/triggers.rst:42
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server"
" executes when certain events happen."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:45
msgid "There are three types of triggers in Tarantool:"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:47
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed "
"when a session begins or ends,"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:50
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed "
"during authentication, and"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:53
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database "
"events."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:56
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:58
msgid ""
"Triggers associate a function with an event. The request to \"define a "
"trigger\" implies passing the trigger’s function to one of the "
"\"on_event-name()\" functions: :ref:`box.session.on_connect() "
"<box_session-on_connect>`, :ref:`box.session.on_auth() <box_session-"
"on_auth>`, :ref:`box.session.on_disconnect() <box_session-"
"on_disconnect>`, or :ref:`space_object:on_replace() <box_space-"
"on_replace>`."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:66
msgid "Triggers are defined only by the 'admin' user."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:68
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the "
"database. Therefore triggers disappear when the instance is shut down. To"
" make them permanent, put function definitions and trigger settings into "
"Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:73
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the "
"overhead is minimal: merely a pointer dereference and check. If a trigger"
" is defined, then its overhead is equivalent to the overhead of calling a"
" function."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:77
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:80
msgid ""
"Triggers must work within the event context. However, effects are "
"undefined if a function contains requests which normally could not occur "
"immediately after the event, but only before the return from the event. "
"For example, putting `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or "
":ref:`box.rollback() <box-rollback>` in a trigger function would be "
"bringing in requests outside the event context."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:87
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies "
"passing a new trigger function and an old trigger function to one of the "
"\"on_event-name()\" functions."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:91
msgid ""
"The \"on_event_name()\" functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua "
"function definition such as \"function f() x = x + 1 end\" is the same as"
" \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function"
" pointer. And \"trigger = box.session.on_connect(f)\" is the same as "
"\"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in "
"both cases ``trigger`` gets the function pointer which was passed."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:99
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:101
msgid ""
"on_connect() – with no arguments – to return a table of all connect-"
"trigger functions;"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:102
msgid "on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:103
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:104
msgid "on_replace() to return all replace-trigger functions."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:108
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/1.6/book/box/triggers.rst:110
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/1.6/book/connectors/index.rst:39
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/1.6/book/connectors/index.rst:41
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/1.6/book/connectors/index.rst:45
msgid "Protocol"
msgstr "Протокол"

#: ../doc/1.6/book/connectors/index.rst:47
#, fuzzy
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O"
" and easy integration with proxies. Each client request starts with a "
"variable-length binary header, containing request id, request type, "
"instance id, log sequence number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с "
"учетом потребностей асинхронного ввода-вывода. Основная его задача — "
"облегчить интеграцию Tarantool'а с клиентскими приложениями. Клиентский "
"запрос в Tarantool-протоколе начинается с бинарного заголовка переменной "
"длины. В заголовке указывается идентификатор и тип запроса, идентификатор"
" сервера, номер записи в журнале и т.д."

#: ../doc/1.6/book/connectors/index.rst:52
msgid ""
"The mandatory length, present in request header simplifies client or "
"proxy I/O. A response to a request is sent to the client as soon as it is"
" ready. It always carries in its header the same type and id as in the "
"request. The id makes it possible to match a request to a response, even "
"if the latter arrived out of order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает "
"обработку данных. Ответ на запрос посылается по мере готовности. В "
"заголовке ответа указывается тот же идентификатор и тип запроса, что и в "
"изначальном запросе. По идентификатору можно легко соотнести запрос с "
"ответом, даже если ответ был получен не в порядке отсылки запросов."

#: ../doc/1.6/book/connectors/index.rst:58
msgid ""
"Unless implementing a client driver, you needn't concern yourself with "
"the complications of the binary protocol. Language-specific drivers "
"provide a friendly way to store domain language data structures in "
"Tarantool. A complete description of the binary protocol is maintained in"
" annotated Backus-Naur form in the source tree: please see the page about"
" :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при "
"разработке нового коннектора для Tarantool'а — см. :ref:`полное описание "
"бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде "
"аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях "
"достаточно взять уже существующий коннектор для нужного вам языка "
"программирования. Такие коннекторы позволяют легко хранить структуры "
"данных из разных языков в формате Tarantool'а."

#: ../doc/1.6/book/connectors/index.rst:67
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/1.6/book/connectors/index.rst:69
#, fuzzy
msgid ""
"The Tarantool API exists so that a client program can send a request "
"packet to a server instance, and receive a response. Here is an example "
"of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``."
" The BNF description of the components is on the page about "
":ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"С помощью Tarantool API клиентские программы могут посылать в адрес "
"Tarantool-сервера пакеты с запросами и получать на них ответы. Вот пример"
" исходящего пакета, который будет сформирован для запроса "
":code:`box.space[513]:insert{'A', 'BB'}`. Описания компонентов запроса (в"
" виде BNF-диаграмм) вы найдете на странице о :ref:`бинарном протоколе в "
"Tarantool'е <box_protocol-iproto_protocol>`."

#: ../doc/1.6/book/connectors/index.rst:85
msgid "Component"
msgstr "Компонент"

#: ../doc/1.6/book/connectors/index.rst:85
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/1.6/book/connectors/index.rst:85
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/1.6/book/connectors/index.rst:85
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/1.6/book/connectors/index.rst:85
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/1.6/book/connectors/index.rst:87
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/1.6/book/connectors/index.rst:87
#: ../doc/1.6/book/connectors/index.rst:91
msgid "02"
msgstr "02"

#: ../doc/1.6/book/connectors/index.rst:89
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/1.6/book/connectors/index.rst:89
msgid "..."
msgstr "..."

#: ../doc/1.6/book/connectors/index.rst:91
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../doc/1.6/book/connectors/index.rst:91
msgid "cd"
msgstr "cd"

#: ../doc/1.6/book/connectors/index.rst:91
msgid "01"
msgstr "01"

#: ../doc/1.6/book/connectors/index.rst:93
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/1.6/book/connectors/index.rst:93
msgid "21"
msgstr "21"

#: ../doc/1.6/book/connectors/index.rst:95
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/1.6/book/connectors/index.rst:95
msgid "92"
msgstr "92"

#: ../doc/1.6/book/connectors/index.rst:97
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/1.6/book/connectors/index.rst:97
msgid "a1"
msgstr "a1"

#: ../doc/1.6/book/connectors/index.rst:97
msgid "41"
msgstr "41"

#: ../doc/1.6/book/connectors/index.rst:99
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/1.6/book/connectors/index.rst:99
msgid "a2"
msgstr "a2"

#: ../doc/1.6/book/connectors/index.rst:99
msgid "42"
msgstr "42"

#: ../doc/1.6/book/connectors/index.rst:102
#, fuzzy
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret "
"the response (the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>` has a description of the packet format "
"for responses as well as requests). But it would be easier, and less "
"error-prone, if you could invoke a routine that formats the packet "
"according to typed parameters. Something like ``response = "
"tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs"
" exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать Tarantool-серверу и затем "
"проинтерпретировать полученный ответ (описания компонентов ответа вы "
"найдете на той же странице о :ref:`бинарном протоколе в Tarantool'е "
"<box_protocol-iproto_protocol>`). Но более простым и верным способом "
"будет вызвать процедуру, которая за вас сформирует готовый пакет с "
"заданными параметрами. Что-то вроде "
":samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. Для "
"этого в Tarantool'е существуют API для Perl, Python, PHP и других "
"программных языков."

#: ../doc/1.6/book/connectors/index.rst:115
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/1.6/book/connectors/index.rst:117
#, fuzzy
msgid ""
"This chapter has examples that show how to connect to a Tarantool "
"instance via the Perl, PHP, Python, node.js, and C connectors. The "
"examples contain hard code that will work if and only if the following "
"conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и "
"C. Обратите внимание, что в примерах исходного кода указаны фиксированные"
" значения для элементов тестового окружения, поэтому для корректной "
"работы всех примеров нужно соблюсти следующие условия:"

#: ../doc/1.6/book/connectors/index.rst:121
#, fuzzy
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) "
"and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""
"Tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``),"
" а прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen "
"= '3301'`),"

#: ../doc/1.6/book/connectors/index.rst:124
#, fuzzy
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has"
" a primary-key index for a numeric field "
"(``box.space[999].index[0].parts[1].type = \"num\"``),"
msgstr ""
"в базе есть пространство ``examples`` с идентификатором 999 "
"(:samp:`box.space.examples.id = 999`) и у него есть первичный индекс, "
"построенный по ключу числового типа "
"(:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"

#: ../doc/1.6/book/connectors/index.rst:128
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../doc/1.6/book/connectors/index.rst:130
#, fuzzy
msgid ""
"It is easy to meet all the conditions by starting the instance and "
"executing this script:"
msgstr ""
"Такое тестовое окружение легко настроить, запустив Tarantool-сервер "
"локально и выполнив следующие запросы:"

#: ../doc/1.6/book/connectors/index.rst:133
#, fuzzy
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'num'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../doc/1.6/book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../doc/1.6/book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.6/book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../doc/1.6/book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/1.6/book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../doc/1.6/book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.6/book/connectors/__erlang.rst:3
msgid "Erlang"
msgstr ""

#: ../doc/1.6/book/connectors/__erlang.rst:5
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/1.6/book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../doc/1.6/book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `DR::Tarantool "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately. The "
"most common way to install it is with `CPAN, the Comprehensive Perl "
"Archive Network <https://en.wikipedia.org/wiki/Cpan>`_. ``DR::Tarantool``"
" requires other modules which should be installed first. For example, on "
"Ubuntu, the installation could look like this:"
msgstr ""
"Наиболее популярным Tarantool-коннектором для языка Perl является "
"`DR::Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_. Он "
"устанавливается отдельно от Tarantool'а, например с помощью "
":program:`cpan` (см. `CPAN, the Comprehensive Perl Archive Network "
"<https://en.wikipedia.org/wiki/Cpan>`_), и требует предварительной "
"установки еще несколько зависимых модулей. Вот пример установки этого "
"коннектора под Ubuntu:"

#: ../doc/1.6/book/connectors/__perl.rst:13
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"

#: ../doc/1.6/book/connectors/__perl.rst:24
#, fuzzy
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.pl` and say :samp:`perl example.pl`. The program will "
"connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"end without displaying any messages. If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connection"
" refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство "
"``space[999]`` с помощью Tarantool API для языка Perl. Перед запуском "
"данной программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``)."
" Чтобы запустить тестовую программу, сохраните ее исходный код в файл с "
"именем :file:`example.pl` и выполните команду :samp:`perl example.pl`. "
"Программа установит соединение, используя указанное в ней описание "
"пространства, откроет сокет для соединения с Tarantool-сервером по адресу"
" ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё хорошо — "
"закончит работу без каких-либо сообщений. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то "
"программа выдаст сообщение об ошибке “Connection refused”."

#: ../doc/1.6/book/connectors/__perl.rst:36
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also"
" say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999]"
" ...\n"
"      name => 'examples',                      #   space[999] name = "
"'examples'\n"
"      default_type => 'STR',                   #   space[999] field type "
"is 'STR' if undefined\n"
"      fields => [ {                            #   definition of "
"space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of "
"space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера "
"по адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь "
"же можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства"
" space[999] ...\n"
"      name => 'examples',                      # имя пространства "
"space[999] = 'examples'\n"
"      default_type => 'STR',                   # если тип поля в "
"space[999] не задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля "
"space[999].field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/1.6/book/connectors/__perl.rst:60
#, fuzzy
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of "
"'string' and 'unsigned', which will be the type names for Tarantool "
"version 1.7."
msgstr ""
"Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и"
" 'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../doc/1.6/book/connectors/__perl.rst:63
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `DR::Tarantool CPAN "
"repository <http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, "
"обратитесь к документации из `CPAN-репозитория DR::Tarantool "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_."

#: ../doc/1.6/book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/1.6/book/connectors/__php.rst:5
msgid ""
"The most commonly used PHP driver is `tarantool-php "
"<https://github.com/tarantool/tarantool-php>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately, for "
"example with :program:`git`. See `installation instructions "
"<https://github.com/tarantool/tarantool-php/blob/master/#installing-and-"
"building>`_. in the driver's :file:`README` file."
msgstr ""

#: ../doc/1.6/book/connectors/__php.rst:12
#, fuzzy
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space"
" named ``examples`` via the PHP API. Before trying to run, check that the"
" server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.php` and say ``php -d extension=~/tarantool-"
"php/modules/tarantool.so example.php``. The program will open a socket "
"connection with the Tarantool instance at ``localhost:3301``, then send "
"an INSERT request, then — if all is well — print \"Insert succeeded\". If"
" the tuple already exists, the program will print “Duplicate key exists "
"in unique index 'primary' in space 'examples'”."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``examples``"
" с помощью Tarantool API для языка PHP. Перед запуском данной программы "
"проверьте, что ваше тестовое окружение настроено так, как :ref:`описано "
"выше <index-connector_setting>` (у Tarantool-сервера задан порт для "
"прослушивания и в базе создано пространство ``examples``). Чтобы "
"запустить тестовую программу, сохраните ее исходный код в файл с именем "
":file:`example.php` и выполните команду :samp:`php -d extension"
"=~/tarantool-php/modules/tarantool.so example.php`. Программа откроет "
"сокет для соединения с Tarantool-сервером по адресу ``localhost:3301``, "
"пошлет INSERT-запрос, а затем — если всё хорошо — выдаст сообщение "
"\"Insert succeeded\". Если окажется, что такой кортеж уже существует, то "
"программа выдаст сообщение об ошибке “Duplicate key exists in unique "
"index 'primary' in space 'examples'”."

#: ../doc/1.6/book/connectors/__php.rst:23
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/1.6/book/connectors/__php.rst:35
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-"
"php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""

#: ../doc/1.6/book/connectors/__php.rst:40
msgid ""
"Besides, you can use an alternative PHP driver from another GitHub "
"project: it includes a *client* (see `tarantool-php/client "
"<https://github.com/tarantool-php/client>`_) and a *mapper* for that "
"client (see `tarantool-php/mapper <https://github.com/tarantool-"
"php/mapper>`_)."
msgstr ""

#: ../doc/1.6/book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../doc/1.6/book/connectors/__python.rst:5
msgid ""
"Here is a complete Python program that inserts "
"``[99999,'Value','Value']`` into space ``examples`` via the high-level "
"Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство "
"``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../doc/1.6/book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../doc/1.6/book/connectors/__python.rst:17
#, fuzzy
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and "
"install the ``tarantool-python`` connector with either :samp:`pip install"
" tarantool\\>0.4` to install in :file:`/usr` (requires **root** "
"privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in "
":file:`~` i.e. user's default directory. Before trying to run, check that"
" the server instance is listening at ``localhost:3301`` and that the "
"space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run the program, say :samp:`python example.py`. "
"The program will connect to the Tarantool server, will send the request, "
"and will not throw any exception if all went well. If the tuple already "
"exists, the program will throw ``tarantool.error.DatabaseError: (3, "
"\"Duplicate key exists in unique index 'primary' in space "
"'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что ваше тестовое окружение "
"настроено так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано "
"пространство ``examples``), и установите коннектор ``tarantool-python``. "
"Для установки коннектора воспользуйтесь либо командой :samp:`pip install "
"tarantool\\>0.4` (для установки в директорию :file:`/usr`; вам "
"потребуются права уровня  **root**), либо командой :samp:`pip install "
"tarantool\\>0.4 --user` (для установки в директорию :file:`~`, т.е. в "
"используемую по умолчанию директорию текущего пользователя). Чтобы "
"запустить тестовую программу, сохраните ее исходный код в файл с именем "
":file:`example.py` и выполните команду :samp:`python example.py`. "
"Программа установит соединение с Tarantool-сервером, пошлет запрос и не "
"сгенерирует никакого исключения, если всё прошло хорошо. Если окажется, "
"что такой кортеж уже существует, то программа сгенерирует исключение "
":samp:`tarantool.error.DatabaseError: (3, \"Duplicate key exists in "
"unique index 'primary' in space 'examples'\")`."

#: ../doc/1.6/book/connectors/__python.rst:29
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python "
"<http://github.com/tarantool/tarantool-python>`_ project at GitHub. For "
"an example of using Python API with `queue managers for Tarantool "
"<https://github.com/tarantool/queue>`_, see `queue-python "
"<https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""

#: ../doc/1.6/book/connectors/__nodejs.rst:3
msgid "Node.js"
msgstr ""

#: ../doc/1.6/book/connectors/__nodejs.rst:5
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied "
"as part of the Tarantool repository; it must be installed separately. The"
" most common way to install it is with `npm <https://www.sitepoint.com"
"/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the "
"installation could look like this after npm has been installed:"
msgstr ""

#: ../doc/1.6/book/connectors/__nodejs.rst:13
msgid "npm install tarantool-driver --global"
msgstr ""

#: ../doc/1.6/book/connectors/__nodejs.rst:17
#, fuzzy
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.rs` and say ``node example.rs``. The program will connect "
"using an application-specific definition of the space. The program will "
"open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"end after saying \"Insert succeeded\". If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connect "
"failed”. If user ``guest`` does not have authorization to connect, the "
"program will print \"Auth failed\". If the insert request fails for any "
"reason, for example because the tuple already exists, the program will "
"print \"Insert failed\"."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство "
"``space[999]`` с помощью Tarantool API для языка Perl. Перед запуском "
"данной программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``)."
" Чтобы запустить тестовую программу, сохраните ее исходный код в файл с "
"именем :file:`example.pl` и выполните команду :samp:`perl example.pl`. "
"Программа установит соединение, используя указанное в ней описание "
"пространства, откроет сокет для соединения с Tarantool-сервером по адресу"
" ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё хорошо — "
"закончит работу без каких-либо сообщений. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то "
"программа выдаст сообщение об ошибке “Connection refused”."

#: ../doc/1.6/book/connectors/__nodejs.rst:31
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/1.6/book/connectors/__nodejs.rst:45
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-php на GitHub "
"<https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.6/book/connectors/__csharp.rst:3
msgid "C#"
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:5
msgid ""
"The most commonly used csharp driver is the `ProGaudi tarantool-csharp "
"driver <https://github.com/progaudi/tarantool-csharp>`_. It is not "
"supplied as part of the Tarantool repository; it must be installed "
"separately. The makers recommend installation on Windows and not on other"
" platforms. However, to be consistent with the other instructions in this"
" chapter, here is an unofficial way to install the driver on Ubuntu "
"16.04."
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:12
msgid ""
"Install dotnet preview from Microsoft -- mono will not work, and dotnet "
"from xbuild will not work. Read the `Microsoft End User License Agreement"
" <http://aka.ms/dotnet-cli-eula>`_ first, because it is not an ordinary "
"open-source agreement and there will be a message during installation "
"saying \"This software may collect information about you and your use of "
"the software, and send that to Microsoft.\" The dotnet instructions are "
"at `https://www.microsoft.com/net/core#ubuntu "
"<https://www.microsoft.com/net/core#linuxubuntu>`_."
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:21
msgid ""
"# Install tarantool-csharp from the github repository source -- nuget "
"will\n"
"# not work, so building from source is necessary, thus:\n"
"cd ~\n"
"mkdir dotnet\n"
"cd dotnet\n"
"git clone https://github.com/progaudi/tarantool-csharp tarantool-csharp\n"
"cd tarantool-csharp\n"
"dotnet restore\n"
"cd src/tarantool.client\n"
"dotnet build\n"
"# Find the .dll file that was produced by the \"dotnet build\" step. The "
"next\n"
"instruction assumes it was produced in 'bin/Debug/netcoreapp1.0'.\n"
"cd bin/Debug/netcoreapp1.0\n"
"# Find the project.json file used for samples. The next instruction "
"assumes\n"
"# the docker-compose/dotnet directory has a suitable one, which is true "
"at\n"
"# time of writing.\n"
"cp ~/dotnet/tarantool-csharp/samples/docker-compose/dotnet/project.json "
"project.json\n"
"dotnet restore"
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:42
msgid ""
"Do not change directories now, the example program should be in the same "
"directory as the .dll file."
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:45
#, fuzzy
msgid ""
"Here is a complete C# program that inserts ``[99999,'BB']`` into space "
"``examples`` via the tarantool-csharp API. Before trying to run, check "
"that the server is listening at  ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.cs` and say ``dotnet run example.cs``. The program will "
"connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool server at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"end without saying anything. If Tarantool is not running on ``localhost``"
" with listen port = 3301, or if user ``guest`` does not have "
"authorization to connect, or if the insert request fails for any reason, "
"the program will print an error message, among other things."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство "
"``space[999]`` с помощью Tarantool API для языка Perl. Перед запуском "
"данной программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``)."
" Чтобы запустить тестовую программу, сохраните ее исходный код в файл с "
"именем :file:`example.pl` и выполните команду :samp:`perl example.pl`. "
"Программа установит соединение, используя указанное в ней описание "
"пространства, откроет сокет для соединения с Tarantool-сервером по адресу"
" ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё хорошо — "
"закончит работу без каких-либо сообщений. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то "
"программа выдаст сообщение об ошибке “Connection refused”."

#: ../doc/1.6/book/connectors/__csharp.rst:58
msgid ""
"using System;\n"
"using System.Linq;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"using ProGaudi.Tarantool.Client.Model;\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().Wait();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var tarantoolClient = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = tarantoolClient.getSchema();\n"
"    var space = await schema.getSpace(\"examples\");\n"
"    await space.Insert(TarantoolTuple.Create(99999, \"BB\"));\n"
"  }\n"
"}"
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:80
msgid ""
"The same program should work on Windows with far less difficulty -- just "
"install with nuget and run."
msgstr ""

#: ../doc/1.6/book/connectors/__csharp.rst:83
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `The tarantool-csharp "
"driver repository <https://github.com/progaudi/tarantool-csharp>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для"
" полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-php на GitHub "
"<https://github.com/tarantool/tarantool-php>`_."

#: ../doc/1.6/book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../doc/1.6/book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../doc/1.6/book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/1.6/book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space "
":code:`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая "
"осуществляет вставку кортежа ``[99999,'B']`` в пространство ``examples`` "
"с помощью высокоуровневого Tarantool API для языка C. "

#: ../doc/1.6/book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP "
"*/\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT"
" */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE "
"REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND "
"REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET "
"REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = "
"TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = "
"НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = "
"СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = "
"СОЗДАНИЕ ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = "
"ОТПРАВКА ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = "
"ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = "
"ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.6/book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install "
"``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и "
"установите коннектор ``tarantool-c``. Вот один из способов установки "
"``tarantool-c`` (под Ubuntu):"

#: ../doc/1.6/book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.6/book/connectors/__c.rst:57 ../doc/1.6/book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую"
" команду:"

#: ../doc/1.6/book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../doc/1.6/book/connectors/__c.rst:65
#, fuzzy
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run the program, "
"say :samp:`./example`. The program will connect to the Tarantool "
"instance, and will send the request. If Tarantool is not running on "
"localhost with listen address = 3301, the program will print “Connection "
"refused”. If the insert fails, the program will print \"Insert failed\" "
"and an error number (see all error codes in the source file "
"`/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/errcode.h>`_)."
msgstr ""
"Перед запуском программы проверьте, что ваше тестовое окружение настроено"
" так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано "
"пространство ``examples``). Чтобы запустить тестовую программу, выполните"
" команду :samp:`./example`. Программа установит соединение с "
"Tarantool-сервером и пошлет запрос. Если окажется, что Tarantool-сервер "
"не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”. А если не пройдет "
"INSERT-запрос, то программа выдаст сообщение \"Insert failed\" и код "
"ошибки (все коды ошибок в Tarantool'е см. в исходном файле "
"`/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../doc/1.6/book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к "
"исходному коду тестовой программы."

#: ../doc/1.6/book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/1.6/book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/1.6/book/connectors/__c.rst:86
#, fuzzy
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on "
"the ``tnt`` stream, some options may have to be set. The most important "
"option is TNT_OPT_URI. In this program, the URI is ``localhost:3301``, "
"since that is where the Tarantool instance is supposed to be listening."
msgstr ""
"В нашей тестовой программе поток назван ``tnt``. Перед установкой "
"соединения нужно задать ряд настроечных опций. Самая важная из них — "
"TNT_OPT_URI. Для этой опции указана URI-строка ``localhost:3301``, т.е. "
"адрес, по которому должно быть настроено прослушивание на стороне "
"Tarantool-сервера."

#: ../doc/1.6/book/connectors/__c.rst:92 ../doc/1.6/book/connectors/__c.rst:108
#: ../doc/1.6/book/connectors/__c.rst:136
#: ../doc/1.6/book/connectors/__c.rst:156
#: ../doc/1.6/book/connectors/__c.rst:181
#: ../doc/1.6/book/connectors/__c.rst:200
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/1.6/book/connectors/__c.rst:572
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../doc/1.6/book/connectors/__c.rst:100
#, fuzzy
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated "
"with a URI, this example program can connect to a server."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали "
"его с конкретным URI, наша программа может устанавливать соединение с "
"Tarantool-сервером."

#: ../doc/1.6/book/connectors/__c.rst:103
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/1.6/book/connectors/__c.rst:588
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../doc/1.6/book/connectors/__c.rst:115
msgid ""
"The connection might fail for a variety of reasons, such as: the server "
"is not running, or the URI contains an invalid password. If the "
"connection fails, the return value will be -1."
msgstr ""
"Попытка соединения может и не удаться, например если Tarantool-сервер не "
"запущен или в URI-строке указан неверный пароль. В случае неудачи функция"
" ``tnt_connect()`` вернет -1."

#: ../doc/1.6/book/connectors/__c.rst:119
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such "
"as the contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../doc/1.6/book/connectors/__c.rst:122
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/1.6/book/connectors/__c.rst:127
#, python-format
msgid ""
"In this program, the request will be an INSERT, and the tuple contents "
"will be an integer and a string. This is a simple serial set of values, "
"that is, there are no sub-structures or arrays. Therefore it is easy in "
"this case to format what will be passed using the same sort of arguments "
"that one would use with a C ``printf()`` function: ``%d`` for the "
"integer, ``%s`` for the string, then the integer value, then a pointer to"
" the string value."
msgstr ""
"В данной программе мы используем запрос INSERT, а кортеж содержит целое "
"число и строку.  Это простой набор значений без каких-либо вложенных "
"структур или массивов. И передаваемые значения мы можем указать самым "
"простым образом — аналогично тому, как это сделано в стандартной "
"C-функции ``printf()``: ``%d`` для обозначения целого числа, ``%s`` для "
"обозначения строки, затем числовое значение, затем указатель на строковое"
" значение."

#: ../doc/1.6/book/connectors/__c.rst:616
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../doc/1.6/book/connectors/__c.rst:143
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the"
" requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе "
"делается аналогично тому, как это делается в Tarantool-библиотеке "
"``box``."

#: ../doc/1.6/book/connectors/__c.rst:146
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../doc/1.6/book/connectors/__c.rst:151
msgid ""
"In this program, the choice is to do an INSERT request, so the program "
"passes the ``tnt_stream`` that was used for connection (``tnt``) and the "
"``tnt_stream`` that was set up with "
":c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем "
"поток ``tnt``, который ранее использовали для установки соединения, и "
"поток :code:`tuple`, который также ранее настроили с помощью функции "
":c:func:`tarantoolc:tnt_object_format`."

#: ../doc/1.6/book/connectors/__c.rst:636
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../doc/1.6/book/connectors/__c.rst:169
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply "
"containing some indication whether the result was successful, and a set "
"of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, "
"который содержит информацию о том, был ли данный запрос успешно выполнен,"
" а также содержит набор кортежей."

#: ../doc/1.6/book/connectors/__c.rst:172
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/1.6/book/connectors/__c.rst:179
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../doc/1.6/book/connectors/__c.rst:661
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../doc/1.6/book/connectors/__c.rst:190
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with "
":c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that"
" were made in the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, "
"созданное с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить"
" объекты, созданные на этапе настройки."

#: ../doc/1.6/book/connectors/__c.rst:194
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../doc/1.6/book/connectors/__c.rst:680
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../doc/1.6/book/connectors/__c.rst:210
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/1.6/book/connectors/__c.rst:212
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, "
"from space ``examples`` via the high-level C API. To display the results,"
" the program uses functions in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of "
"`MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, "
"которая осуществляет выборку по индекс-ключу ``[99999]`` из пространства "
"``examples`` с помощью высокоуровневого Tarantool API для языка C. Для "
"вывода результатов в этой программе используются функции из библиотеки "
"`MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для "
"декодирования массивов значений в формате `MessagePack "
"<https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.6/book/connectors/__c.rst:218
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для"
" поиска */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.6/book/connectors/__c.rst:285
msgid ""
"Similarly to the first example, paste the code into a file named "
":file:`example2.c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с "
"именем :file:`example2.c`."

#: ../doc/1.6/book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/1.6/book/connectors/__c.rst:294
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/1.6/book/connectors/__c.rst:296
msgid ""
"The two example programs only show a few requests and do not show all "
"that's necessary for good practice. See more in the `tarantool-c "
"documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух "
"запросов. Для полноценной работы с Tarantool'ом с помощью C API, "
"пожалуйста, обратитесь к документации из `проекта tarantool-c на GitHub "
"<http://github.com/tarantool/tarantool-c>`_."

#: ../doc/1.6/book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/1.6/book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in "
"the MsgPack format. If the function is called using the connector's API, "
"some conversions may occur. All scalar values are returned as tuples "
"(with a MsgPack type-identifier followed by a value); all non-scalar "
"values are returned as a group of tuples (with a MsgPack array-identifier"
" followed by the scalar values). If the function is called via the binary"
" protocol command layer -- \"eval\" -- rather than via the connector's "
"API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была "
"вызвана через API коннектора, то формат возвращаемых значений будет "
"следующим: скалярные значения возвращаются в виде кортежей (сначала идет "
"идентификатор типа из формата MsgPack, а затем идет значение); все прочие"
" (не скалярные) значения возвращаются в виде групп кортежей (сначала идет"
" идентификатор массива в формате MsgPack, а затем идут скалярные "
"значения). Но если функция была вызвана в рамках бинарного протокола (с "
"помощью команды ``eval``), а не через API коннектора, то подобных "
"изменений формата возвращаемых значений не происходит."

#: ../doc/1.6/book/connectors/__results.rst:14
msgid ""
"In the following example, a Lua function will be created. Since it will "
"be accessed externally by a 'guest' user, a ``grant`` of an execute "
"privilege will be necessary. The function returns an empty array, a "
"scalar string, two booleans, and a short integer. The values are the ones"
" described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет"
" вызывать внешний пользователь 'guest', то нужно настроить привилегии на "
"исполнение с помощью ``grant``. Эта функция возвращает пустой массив, "
"строку-скаляр, два логических значения и короткое целое число. Значение "
"будут теми же, что описаны в разделе про MsgPack в таблице "
":ref:`Стандартные типы в MsgPack-кодировке <msgpack-"
"common_types_and_msgpack_encodings>`."

#: ../doc/1.6/book/connectors/__results.rst:20
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../doc/1.6/book/connectors/__results.rst:36
msgid ""
"Here is a C program which calls the function. Although C is being used "
"for the example, the result would be precisely the same if the calling "
"program was written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию."
" Хотя в примере использован код на C, результат будет одинаковым, на "
"каком бы языке ни была написана вызываемая программа: Perl, PHP, Python, "
"Go или Java."

#: ../doc/1.6/book/connectors/__results.rst:40
#, fuzzy, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */"
"\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */"
"\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА"
" */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА"
" */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА"
" */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.6/book/connectors/__results.rst:78
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/1.6/book/connectors/__results.rst:80
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/1.6/book/connectors/__results.rst:84
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for "
"\"32-bit array header with value 5\" (see `MsgPack specification "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are "
"as described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате "
"MsgPack, означающий \"32-битный заголовок массива со значением 5\" (см. "
"`спецификацию на формат MsgPack "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). Остальные "
"значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.6/book/faq.rst:39
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/1.6/book/faq.rst ../doc/1.6/book/replication/index.rst
msgid "Q"
msgstr ""

#: ../doc/1.6/book/faq.rst:43
#, fuzzy
msgid "Why Tarantool?"
msgstr "Утилита tarantoolctl"

#: ../doc/1.6/book/faq.rst ../doc/1.6/book/replication/index.rst
#, fuzzy
msgid "A"
msgstr "a2"

#: ../doc/1.6/book/faq.rst:44
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience "
"and trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/1.6/book/faq.rst:48
msgid "Why Lua?"
msgstr ""

#: ../doc/1.6/book/faq.rst:49
#, fuzzy
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also "
"happens to be very easy to embed. Lua coroutines relate very closely to "
"Tarantool fibers, and Lua architecture works well with Tarantool "
"internals. Lua acts well as a stored program language for Tarantool, "
"although connecting with other languages is also easy."
msgstr ""
"Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, "
"позволяющий использовать различные парадигмы программирования. Lua также "
"легко встраивается в различные приложения. Ко-рутины (coroutines) в Lua "
"близко соотносятся с файберами (fibers) в Tarantool'е, а вся "
"Lua-архитектура гладко ложится на его внутреннюю реализацию. Lua — это "
"первый язык, на котором можно писать хранимые процедуры для Tarantool'а. "
"В будущем список поддерживаемых языков планируется расширить."

#: ../doc/1.6/book/faq.rst:55
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/1.6/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET"
" indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/1.6/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable "
"in-memory data server which handles non-trivial application-specific "
"logic. The advantage over traditional SQL servers is in performance: low-"
"overhead, lock-free architecture means Tarantool can serve an order of "
"magnitude more requests per second, on comparable hardware. The advantage"
" over NoSQL alternatives is in flexibility: Lua allows flexible "
"processing of data stored in a compact, denormalized format."
msgstr ""

#: ../doc/1.6/book/faq.rst:69
msgid "What are your development plans?"
msgstr ""

#: ../doc/1.6/book/faq.rst:70
msgid ""
"We continuously improve server performance. On the feature front, "
"automatic sharding and synchronous replication, and a subset of SQL are "
"the major goals for 2016-2018. We have an open roadmap to which we "
"encourage anyone to add feature requests."
msgstr ""

#: ../doc/1.6/book/faq.rst:75
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/1.6/book/faq.rst:76
#, fuzzy
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit "
"logs on `github.com/tarantool <http://github.com/tarantool/>`_. The "
"development is fully open. Most of the connectors' authors, and the "
"maintainers for different distributions, come from the wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда "
"разработки в Mail.Ru — см. историю коммитов на `github.com/tarantool "
"<http://github.com/tarantool/>`_. Вся разработка ведется открытым "
"образом. Кроме того, активную роль играют члены сообщества разработчиков "
"Tarantool'а. Их силами было создано большинство коннекторов и ведутся "
"доработки под разные дистрибутивы."

#: ../doc/1.6/book/faq.rst:81
msgid "How serious is Mail.Ru about Tarantool?"
msgstr ""

#: ../doc/1.6/book/faq.rst:82
msgid ""
"Tarantool is an open source project, distributed under a BSD license, so "
"it does not depend on any one sponsor. However, it is an integral part of"
" the Mail.Ru backbone, so it gets a lot of support from Mail.Ru."
msgstr ""

#: ../doc/1.6/book/faq.rst:86
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/1.6/book/faq.rst:87
#, fuzzy
msgid ""
"The principal storage engine is designed for RAM plus persistent storage."
" It is immune to data loss because there is a write-ahead log. Its "
"memory-allocation and compression techniques ensure there is no waste. "
"And if Tarantool runs out of memory, then it will stop accepting updates "
"until more memory is available, but will continue to handle read and "
"delete requests without difficulty. However, for databases which are much"
" larger than the available RAM space, Tarantool 1.7 will have a second "
"storage engine which is only limited by the available disk space."
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory "
"решением? |br| Основной движок баз данных в Tarantool'е работает с "
"оперативной памятью, но при этом он гарантирует сохранность данных "
"благодаря механизму WAL (write ahead log), т.е. журналу упреждающей "
"записи. Также в Tarantool'е используются технологии сжатия и "
"распределения данных, которые позволяют использовать все виды памяти "
"наиболее эффективно. Если Tarantool сталкивается с нехваткой оперативной "
"памяти, то он приостанавливает прием запросов на изменение данных до тех "
"пор, пока не появится свободная память, но при этом с успехом продолжает "
"обработку запросов на чтение и удаление данных. А для больших баз, где "
"объем данных значительно превосходит имеющийся объем оперативной памяти, "
"у Tarantool'а есть второй движок, чьи возможности ограничены лишь "
"размером жесткого диска."

#: ../doc/1.6/book/getting_started/index.rst:39
msgid "Getting started"
msgstr "Начало работы"

#: ../doc/1.6/book/getting_started/index.rst:41
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, "
"and how to create a simple database."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:39
#, fuzzy
msgid "Using a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../doc/1.6/book/getting_started/using_binary.rst:41
msgid ""
"For production purposes, we recommend `official binary packages "
"<http://tarantool.org/download.html>`_. You can choose from two Tarantool"
" versions: 1.9 (stable) or 2.0 (alpha). An automatic build system "
"creates, tests and publishes packages for every push into a corresponding"
" branch (``1.9`` or ``2.0``) at `Tarantool's GitHub repository "
"<https://github.com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:48
#, fuzzy
msgid ""
"To download and install the package that’s appropriate for your OS, start"
" a shell (terminal) and enter the command-line instructions provided for "
"your OS at Tarantool's `download page "
"<https://tarantool.org/download.html>`_."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы,"
" откройте терминал с командной строкой и введите инструкции, которые даны"
" для вашей операционной системы на странице "
"http://tarantool.org/download.html."

#: ../doc/1.6/book/getting_started/using_binary.rst:54
#, fuzzy
msgid "Starting Tarantool"
msgstr "Утилита tarantoolctl"

#: ../doc/1.6/book/getting_started/using_binary.rst:56
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:58
#, fuzzy
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say "
"this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../doc/1.6/book/getting_started/using_binary.rst:65
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:67
#, fuzzy
msgid "tarantool>"
msgstr "Модуль `tarantool`"

#: ../doc/1.6/book/getting_started/using_binary.rst:71
#: ../doc/1.6/book/getting_started/using_docker.rst:118
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:75
#: ../doc/1.6/book/getting_started/using_docker.rst:122
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, "
"because the interactive mode is convenient for learning."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:81
#: ../doc/1.6/book/getting_started/using_docker.rst:128
msgid "Creating a database"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:83
msgid "Here is how to create a simple test database after installing."
msgstr ""
"Далее рассказывается, как создать простую тестовую базу данных после "
"установки Tarantool'а."

#: ../doc/1.6/book/getting_started/using_binary.rst:85
#, fuzzy
msgid ""
"Create a new directory (it’s just for tests, so you can delete it when "
"the tests are over):"
msgstr ""
"Создайте новую директорию. Она понадобится только для тестовых целей, и "
"ее можно будет удалить по окончании экспериментов."

#: ../doc/1.6/book/getting_started/using_binary.rst:88
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../doc/1.6/book/getting_started/using_binary.rst:93
msgid ""
"To start Tarantool's database module and make the instance accept TCP "
"requests on port 3001, say this:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:96
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.6/book/getting_started/using_binary.rst:100
#: ../doc/1.6/book/getting_started/using_docker.rst:132
#, fuzzy
msgid ""
"First, create the first :ref:`space <index-box_space>` (named 'tester') "
"and the first :ref:`index <index-box_index>` (named 'primary'):"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../doc/1.6/book/getting_started/using_binary.rst:103
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >  type = 'hash',\n"
"         >  parts = {1, 'NUM'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.6/book/getting_started/using_binary.rst:111
#: ../doc/1.6/book/getting_started/using_docker.rst:143
#, fuzzy
msgid ""
"Next, insert three :ref:`tuples <index-box_tuple>` (our name for "
"\"records\") into the space:"
msgstr ""
"Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство\" "
"(space) из вашей базы данных:"

#: ../doc/1.6/book/getting_started/using_binary.rst:114
#, fuzzy
msgid ""
"tarantool> t = s:insert({1, 'Roxette'})\n"
"tarantool> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.6/book/getting_started/using_binary.rst:121
#: ../doc/1.6/book/getting_started/using_docker.rst:152
#, fuzzy
msgid ""
"To select a tuple from the first space of the database, using the first "
"defined key, say:"
msgstr ""
"Произведите выборку кортежа из первого пространства в базе по первому "
"указанному ключу:"

#: ../doc/1.6/book/getting_started/using_binary.rst:124
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.6/book/getting_started/using_binary.rst:128
#: ../doc/1.6/book/getting_started/using_docker.rst:159
#, fuzzy
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.6/book/getting_started/using_binary.rst:130
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.6/book/getting_started/using_binary.rst:154
msgid "To add another index on the second field, say:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:156
#, fuzzy
msgid ""
"tarantool> s:create_index('secondary', {\n"
"         >  type = 'hash',\n"
"         >  parts = {2, 'string'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.6/book/getting_started/using_binary.rst:163
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""
"Далее, чтобы подготовиться к тестовому примеру в следующем разделе, "
"введите:"

#: ../doc/1.6/book/getting_started/using_binary.rst:165
msgid ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', "
"'universe')"

#: ../doc/1.6/book/getting_started/using_binary.rst:171
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../doc/1.6/book/getting_started/using_binary.rst:173
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the "
"``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform "
"resource identifier). In this case, it’s just a local port: port 3301. "
"You can send requests to the listen URI via:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:178
#, fuzzy
msgid "``telnet``,"
msgstr "telnet,"

#: ../doc/1.6/book/getting_started/using_binary.rst:179
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:180
#, fuzzy
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-"
"module>`, либо"

#: ../doc/1.6/book/getting_started/using_binary.rst:181
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:183
#, fuzzy
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../doc/1.6/book/getting_started/using_binary.rst:185
#, fuzzy
msgid ""
"Switch to another terminal. On Linux, for example, this means starting "
"another instance of a Bash shell. You can switch to any working directory"
" in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого "
"нужно запустить новый экземпляр Bash. При этом вам не потребуется "
"вызывать cd, чтобы переключиться на директорию "
":code:`~/tarantool_sandbox`."

#: ../doc/1.6/book/getting_started/using_binary.rst:189
msgid "Start the ``tarantoolctl`` utility:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:191
#, fuzzy
msgid "$ tarantoolctl connect '3301'"
msgstr ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"

#: ../doc/1.6/book/getting_started/using_binary.rst:195
#, fuzzy
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool "
"instance that’s listening on ``localhost:3301``\"."
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с "
"Tarantool-сервером, который слушает на ``localhost:3301``.\""

#: ../doc/1.6/book/getting_started/using_binary.rst:198
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/1.6/book/getting_started/using_binary.rst:200
#, fuzzy
msgid "tarantool> box.space.tester:select{2}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.6/book/getting_started/using_binary.rst:204
#, fuzzy
msgid ""
"This means \"send a request to that Tarantool instance, and display the "
"result\". The result in this case is one of the tuples that was inserted "
"earlier. Your terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат "
"на экран.\" Результатом в данном случае будет один из кортежей, что вы "
"вставляли ранее. На терминале теперь должно отображаться примерно "
"следующее:"

#: ../doc/1.6/book/getting_started/using_binary.rst:208
#, fuzzy
msgid ""
"$ tarantoolctl connect '3301'\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../doc/1.6/book/getting_started/using_binary.rst:219
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:222
msgid "When the testing is over:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:224
msgid ""
"To drop the space: ``s:drop()`` (do this on the terminal where tester was"
" created)"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:225
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:226
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:228
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/1.6/book/getting_started/using_binary.rst:229
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:39
msgid "Using a Docker image"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:41
msgid ""
"For trial and test purposes, we recommend using `official Tarantool "
"images for Docker <https://github.com/tarantool/docker>`_. An official "
"image contains a particular Tarantool version (1.6, 1.9 or 2.0) and all "
"popular external modules for Tarantool. Everything is already installed "
"and configured in Linux. These images are the easiest way to install and "
"use Tarantool."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:50
msgid ""
"If you're new to Docker, we recommend going over `this tutorial "
"<https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding"
" with this chapter."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:58
msgid "Launching a container"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:60
msgid ""
"If you don't have Docker installed, please follow the official "
"`installation guide "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-"
"docker>`_ for your OS."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:64
msgid ""
"To start a fully functional Tarantool instance, run a container with "
"minimal options:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:67
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1.6"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:75
msgid ""
"This command runs a new container named 'mytarantool'. Docker starts it "
"from an official image named 'tarantool/tarantool:1.6', with Tarantool "
"version 1.6 and all external modules already installed."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:79
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. "
"You may start using it as a key-value storage right away."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:82
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the "
"container. To make your test data available after you stop the container,"
" this command also mounts the host's directory ``/data/dir/on/host`` (you"
" need to specify here an absolute path to an existing local directory) in"
" the container's directory ``/var/lib/tarantool`` (by convention, "
"Tarantool in a container uses this directory to persist data). So, all "
"changes made in the mounted directory on the container's side are applied"
" to the host's disk."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:91
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, "
"unless you use Tarantool as an :ref:`application server <app_server>` and"
" run it with an application."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:98
#, fuzzy
msgid "Attaching to Tarantool"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.6/book/getting_started/using_docker.rst:100
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:102
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:106
msgid "This command:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:108
msgid ""
"Instructs Tarantool to open an interactive console port for incoming "
"connections."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:109
msgid ""
"Attaches to the Tarantool server inside the container under 'admin' user "
"via a standard Unix socket."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:112
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:114
msgid "tarantool.sock>"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:130
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:135
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"tarantool.sock> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'NUM'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.6/book/getting_started/using_docker.rst:146
#, fuzzy
msgid ""
"tarantool.sock> t = s:insert({1, 'Roxette'})\n"
"tarantool.sock> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool.sock> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.6/book/getting_started/using_docker.rst:155
#, fuzzy
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.6/book/getting_started/using_docker.rst:161
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {type = 'hash', parts = {1, "
"'NUM'}})\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.6/book/getting_started/using_docker.rst:187
#, fuzzy
msgid "Stopping a container"
msgstr "Остановка всех экземпляров:"

#: ../doc/1.6/book/getting_started/using_docker.rst:189
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/1.6/book/getting_started/using_docker.rst:191
#, fuzzy
msgid "$ docker stop mytarantool"
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.6/book/getting_started/using_docker.rst:195
msgid ""
"This was a temporary container, and its disk/memory data were flushed "
"when you stopped it. But since you mounted a data directory from the host"
" in the container, Tarantool's data files were persisted to the host's "
"disk. Now if you start a new container and mount that data directory in "
"it, Tarantool will recover all data from disk and continue working with "
"the persisted data."
msgstr ""

#: ../doc/1.6/book/index.rst:39
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/1.6/book/intro.rst:37
msgid "Preface"
msgstr "Предисловие"

#: ../doc/1.6/book/intro.rst:39
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it "
"first, and consulting :ref:`Reference <reference>` materials for more "
"detail afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство "
"пользователя\". Мы советуем начинать именно с него, а затем переходить к "
":ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные"
" сведения."

#: ../doc/1.6/book/intro.rst:45
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/1.6/book/intro.rst:47
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker"
" container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at "
"http://try.tarantool.org. Either way, as the first tryout, you can follow"
" the introductory exercises from :ref:`Chapter 2 \"Getting started\" "
"<getting_started>`. If you want more hands-on experience, proceed to "
":ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""

#: ../doc/1.6/book/intro.rst:56
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool"
" as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" "
"<app_server>` is about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о "
"возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер "
"приложений\" <app_server>` — о возможностях Tarantool'а как сервера "
"приложений Lua."

#: ../doc/1.6/book/intro.rst:60
#, fuzzy
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <index-box_replication>` are primarily for "
"administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` "
"предназначена в первую очередь для системных администраторов."

#: ../doc/1.6/book/intro.rst:64
#, fuzzy
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for "
"users who are connecting from a different language such as C or Perl or "
"Python — other users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для"
" тех пользователей, которые хотят устанавливать соединение с Tarantool'ом"
" с помощью программ на других языках программирования (например C, Perl "
"или Python) — для прочих пользователей эта глава неактуальна."

#: ../doc/1.6/book/intro.rst:68
#, fuzzy
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked "
"questions about Tarantool."
msgstr ""
":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые "
"часто задаваемые вопросы о Tarantool'е."

#: ../doc/1.6/book/intro.rst:71
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` "
"materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive "
"set of comments in the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" "
"<reference>`, :ref:`\"Руководство участника проекта\" <contrib_guide>` и "
"комментарии в исходном коде."

#: ../doc/1.6/book/intro.rst:77
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/1.6/book/intro.rst:79
msgid ""
"Please report bugs or make feature requests at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый "
"функционал можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.6/book/intro.rst:81
msgid ""
"You can contact developers directly in `telegram "
"<http://telegram.me/tarantool>`_ or in a Tarantool discussion group "
"(`English <https://groups.google.com/forum/#!forum/tarantool>`_ or "
"`Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram "
"<http://telegram.me/tarantool>`_ или на форумах (`англоязычном "
"<https://groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном "
"<https://googlegroups.com/group/tarantool-ru>`_)."

#: ../doc/1.6/book/intro.rst:88
#, fuzzy
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../doc/1.6/book/intro.rst:90
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/1.6/book/intro.rst:92
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/1.6/book/intro.rst:94
msgid ""
"A vertical bar | means the preceding and following tokens are mutually "
"exclusive alternatives."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:40
#: ../doc/1.6/reference/configuration/index.rst:248
msgid "Replication"
msgstr "Репликация"

#: ../doc/1.6/book/replication/index.rst:42
#, fuzzy
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the "
"same databases. The databases are kept in synch because each instance can"
" communicate its changes to all the other instances. A pack of instances "
"which share the same databases are a \"replica set\". Each instance in a "
"replica set also has a numeric identifier which is unique within the "
"replica set, known as the \"instance id\" or \"instance id\"."
msgstr ""
"Механизм репликации позволяет сразу многим Tarantool-серверам работать с "
"копиями одних и тех же баз данных. При этом все базы остаются в "
"синхронизированном состоянии благодаря тому, что каждый сервер может "
"сообщать другим серверам о совершенных им изменениях. Сервера, которые "
"работают над одними и теми же базами, представляют собой \"кластер\". У "
"каждого сервера в кластере есть числовой идентификатор (server id), "
"уникальный в рамках кластера."

#: ../doc/1.6/book/replication/index.rst:48
msgid ""
"To set up replication, it's necessary to set up the master instances "
"which make the original data-change requests, set up the replica "
"instances which copy data-change requests from masters, and establish "
"procedures for recovery from a degraded state."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:55
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/1.6/book/replication/index.rst:57
msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its write-ahead log (WAL). Each record in the WAL represents a "
"single Tarantool data-change request such as INSERT or UPDATE or DELETE, "
"and is assigned a monotonically growing log sequence number (LSN). In "
"essence, Tarantool replication is row-based: each data change command is "
"fully deterministic and operates on a single tuple."
msgstr ""
"Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика"
" непрерывно опрашивает главный сервер на предмет обновлений в его "
"WAL-файле (write ahead log) и применяет эти обновления на своей стороне. "
"Каждая запись в WAL-файле представляет собой один запрос на изменение "
"данных (например, INSERT, UPDATE или DELETE) и присвоенный данной записи "
"номер (LSN = log sequence number). Номера присваиваются в порядке "
"возрастания. По сути, репликация в Tarantool'е является построчной: все "
"команды на изменение данных полностью детерминированы, и каждая такая "
"команда относится только к одному кортежу."

#: ../doc/1.6/book/replication/index.rst:64
msgid ""
"A stored program invocation is not written to the write-ahead log. "
"Instead, log events for actual data-change requests, performed by the Lua"
" code, are written to the log. This ensures that possible non-determinism"
" of Lua does not cause replication to go out of sync."
msgstr ""
"Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале "
"событий (event log). Таким образом гарантируется, что не "
"детерминированное поведение логики на Lua не приведет к рассинхронизации "
"реплицированных данных."

#: ../doc/1.6/book/replication/index.rst:69
msgid ""
"A change to a temporary space is not written to the write-ahead log, and "
"therefore is not replicated."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:74
#, fuzzy
msgid "Setting up a master"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Настройка главного сервера"

#: ../doc/1.6/book/replication/index.rst:76
msgid ""
"To prepare the master for connections from the replica, it's only "
"necessary to include \":ref:`listen <cfg_basic-listen>`\" in the initial "
"``box.cfg`` request, for example ``box.cfg{listen=3301}``. A master with "
"enabled \"listen\" URI can accept connections from as many replicas as "
"necessary on that URI. Each replica has its own :ref:`replication state "
"<index-monitoring_replica_actions>`."
msgstr ""
"Чтобы настроить возможность установки соединения для реплик, на стороне "
"главного сервера требуется лишь указать значение для параметра "
"\":ref:`listen <cfg_basic-listen>`\" в init-запросе ``box.cfg``. "
"Например, ``box.cfg{listen=3301}``. Когда URI для прослушивания задан, "
"главный сервер готов принимать запросы на соединение от любого количества"
" реплик. Каждая реплика при этом находится в некотором :ref:`статусе "
"репликации <index-monitoring_replica_actions>`."

#: ../doc/1.6/book/replication/index.rst:84
msgid "Setting up a replica"
msgstr "Настройка сервера-реплики"

#: ../doc/1.6/book/replication/index.rst:86
msgid ""
"An instance requires a valid snapshot (.snap) file. A snapshot file is "
"created for a instance the first time that ``box.cfg`` occurs for it. If "
"this first ``box.cfg`` request occurs without a \"replication source\" "
"clause, then the instance is a master and starts its own new replica set "
"with a new unique UUID. If this first ``box.cfg`` request occurs with a "
"\"replication source\" clause, then the instance is a replica and its "
"snapshot file, along with the replica-set information, is constructed "
"from the write-ahead logs of the master. Therefore, to start replication,"
" specify the replication source in the :ref:`replication_source "
"<cfg_replication-replication_source>` parameter of a ``box.cfg`` request."
" When a replica contacts a master for the first time, it becomes part of "
"a replica set. On subsequent occasions, it should always contact a master"
" in the same replica set."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:99
msgid ""
"Once connected to the master, the replica requests all changes that "
"happened after the latest local LSN. It is therefore necessary to keep "
"WAL files on the master host as long as there are replicas that haven't "
"applied them yet. A replica can be \"re-seeded\" by deleting all its "
"files (the snapshot .snap file and the WAL .xlog files), then starting "
"replication again - the replica will then catch up with the master by "
"retrieving all the master's tuples. Again, this procedure works only if "
"the master's WAL files are present."
msgstr ""
"После установки соединения с главным сервером реплика запрашивает у него "
"все изменения, чьи LSN-номера в WAL-файле больше номера последнего "
"локального изменения на реплике. Поэтому WAL-файлы на главном сервере "
"нужно хранить до тех пор, пока все реплики не применят изменения из этих "
"WAL-файлов на своей стороне. Состояние реплики можно \"обнулить\", удалив"
" все файлы репликации (.snap-файл со снимком и .xlog-файлы с записями "
"WAL) и запустив сервер снова. Реплика при этом возьмет все кортежи с "
"главного сервера и придет в синхронизированное состояние. Обратите "
"внимание, что такая процедура \"обнуления\" сработает, только если на "
"главном сервере будут доступны все нужные WAL-файлы."

#: ../doc/1.6/book/replication/index.rst:109
msgid ""
"Replication parameters are \"dynamic\", which allows the replica to "
"become a master and vice versa with the help of the :ref:`box.cfg "
"<box_introspection-box_cfg>` statement."
msgstr ""
"Параметры репликации можно менять на лету, что позволяет назначать "
"реплику на роль главного сервера и наоборот. Для этого используется "
"запрос :ref:`box.cfg <box_introspection-box_cfg>`."

#: ../doc/1.6/book/replication/index.rst:115
msgid ""
"The replica does not inherit the master's configuration parameters, such "
"as the ones that cause the :ref:`snapshot daemon "
"<book_cfg_snapshot_daemon>` to run on the master. To get the same "
"behavior, one would have to set the relevant parameters explicitly so "
"that they are the same on both master and replica."
msgstr ""
"Реплика не берет настройки конфигурации с главного сервера, например "
"настройки запуска :ref:`фоновой программы для работы со снимками "
"<book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же "
"настройки на реплике, нужно задать их явным образом."

#: ../doc/1.6/book/replication/index.rst:123
#, fuzzy
msgid ""
"Replication requires privileges. Privileges for accessing spaces could be"
" granted directly to the user who will start the replica. However, it is "
"more usual to grant privileges for accessing spaces to a :ref:`role "
"<authentication-roles>`, and then grant the role to the user who will "
"start the replica."
msgstr ""
"Репликация требует настройки привилегий. Привилегии для доступа к "
"пространствам можно задать напрямую для пользователя, под чьим именем "
"запущен сервер-реплика. Но обычно привилегии на доступ к пространствам "
"задаются с помощью :ref:`роли <authentication-rep_role>`, которая затем "
"присваивается пользователю, под чьим именем запущен сервер-реплика."

#: ../doc/1.6/book/replication/index.rst:131
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/1.6/book/replication/index.rst:133
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable - "
"due to hardware or network failure, or due to a programming bug. There is"
" no automatic way for a replica to detect that the master is gone "
"forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires a human "
"inspection."
msgstr ""
"\"Сбой\" — это ситуация, когда главный сервер становится недоступен "
"вследствие проблем с оборудованием, сетевых неполадок или программной "
"ошибки. У реплики нет способа автоматически обнаружить, что связь с "
"главным сервером утеряна насовсем, поскольку причины сбоя и окружение, в "
"котором развернута репликация, могут быть очень разными. Поэтому "
"обнаруживать сбой должен человек."

#: ../doc/1.6/book/replication/index.rst:139
#, fuzzy
msgid ""
"However, once a master failure is detected, the recovery is simple: "
"declare that the replica is now the new master, by saying "
":extsamp:`box.cfg{... listen={*{URI}*} ...}` Then, if there are updates "
"on the old master that were not propagated before the old master went "
"down, they would have to be re-applied manually."
msgstr ""
"Но когда сбой уже обнаружен, процедура восстановления проста. Сначала "
"нужно назначить одну из реплик на роль нового главного сервера, задав "
"параметр :codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-"
"uri>`:codenormal:`}`. Затем, если на прежнем главном сервере остались "
"изменения, которые не успели примениться на выбранной реплике перед "
"сбоем, нужно применить эти изменения вручную."

#: ../doc/1.6/book/replication/index.rst:147
#, fuzzy
msgid "Quick startup of a new simple two-instance replica set"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#: ../doc/1.6/book/replication/index.rst:149
#, fuzzy
msgid "Step 1. Start the first instance thus:"
msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#: ../doc/1.6/book/replication/index.rst:154
msgid ""
"box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""
"box.cfg{listen = *uri#1*}\n"
"-- в этом запросе можно задать больше ограничений\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"

#: ../doc/1.6/book/replication/index.rst:159
#, fuzzy
msgid "... Now a new replica set exists."
msgstr "... Итак, создался новый кластер."

#: ../doc/1.6/book/replication/index.rst:161
#, fuzzy
msgid ""
"Step 2. Check where the second instance's files will go by looking at its"
" directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, "
":ref:`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty -"
" when the second instance joins for the first time, it has to be working "
"with a clean state so that the initial copy of the first instance's "
"databases can happen without conflicts."
msgstr ""
"Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы"
" репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-"
"snap_dir>` (для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для "
".xlog-файлов). В указанных директориях должно быть пусто, чтобы не "
"случилось конфликта с теми начальными данными, что придут с первого "
"сервера, когда второй сервер присоединится к кластеру."

#: ../doc/1.6/book/replication/index.rst:168
#, fuzzy
msgid "Step 3. Start the second instance thus:"
msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#: ../doc/1.6/book/replication/index.rst:173
msgid ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"

#: ../doc/1.6/book/replication/index.rst:178
#, fuzzy
msgid ""
"... where ``uri#1`` = the :ref:`URI <index-uri>` that the first instance "
"is listening on."
msgstr ""
"... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено "
"прослушивание у первого сервера."

#: ../doc/1.6/book/replication/index.rst:180
msgid "That's all."
msgstr "Вот и всё."

#: ../doc/1.6/book/replication/index.rst:182
#, fuzzy
msgid ""
"In this configuration, the first instance is the \"master\" and the "
"second instance is the \"replica\". Henceforth every change that happens "
"on the master will be visible on the replica. A simple two-instance "
"replica set with the master on one computer and the replica on a "
"different computer is very common and provides two benefits: FAILOVER "
"(because if the master goes down then the replica can take over), or LOAD"
" BALANCING (because clients can connect to either the master or the "
"replica for select requests). Sometimes the replica may be configured "
"with the additional parameter :ref:`read_only = true <cfg_basic-"
"read_only>`."
msgstr ""
"В описанной выше конфигурации первый сервер выполняет роль \"главного\", "
"а второй служит \"репликой\". Далее все изменения, происходящие на "
"стороне главного сервера, будут доступны с реплики. Простой кластер из "
"двух серверов, где главный сервер запущен на одном компьютере, а "
"сервер-реплика — на другом, встречается очень часто и обладает двумя "
"важными преимуществами: FAILOVER (т.е. отказоустойчивость, поскольку в "
"случае отключения главного сервера его место может занять сервер-реплика)"
" и LOAD BALANCING (т.е. балансировка нагрузки, поскольку клиенты могут "
"обращаться с SELECT-запросами как к главному серверу, так и к реплике). "
"При необходимости в настройках реплики можно задать параметр "
":ref:`read_only = true <cfg_basic-read_only>`."

#: ../doc/1.6/book/replication/index.rst:195
msgid "Monitoring a replica's actions"
msgstr "Мониторинг действий реплики"

#: ../doc/1.6/book/replication/index.rst:197
msgid ""
"In :ref:`box.info <box_introspection-box_info>` there is a "
"``box.info.replication.status`` field: \"off\", \"stopped\", "
"\"connecting\", \"auth\", \"follow\", or \"disconnected\". |br| If a "
"replica's status is \"follow\", then there will be more fields -- the "
"list is in the section :ref:`Submodule box.info <box_introspection-"
"box_info>`."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:202
#, fuzzy
msgid ""
"In the :ref:`log <log-module>` there is a record of replication activity."
" If a primary instance is started with:"
msgstr ""
"В :ref:`журнале <log>` ведется запись о действиях, связанных с "
"репликацией. Если главный сервер запущен со следующими настройками:"

#: ../doc/1.6/book/replication/index.rst:208
msgid ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *имя_файла_для_ведения_журнала*,\n"
"  <...>\n"
"}"

#: ../doc/1.6/book/replication/index.rst:214
msgid ""
"then there will be lines in the log file, containing the word \"relay\", "
"when a replica connects or disconnects."
msgstr ""
"то на каждую установку/потерю соединения реплики с главным сервером в "
"журнале будут появляться строчки со словом \"relay\"."

#: ../doc/1.6/book/replication/index.rst:221
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/1.6/book/replication/index.rst:223
msgid ""
"Suppose that the replica tries to do something that the master has "
"already done. For example: |br| ``box.schema.space.create('X')`` |br| "
"This would cause an error, \"Space X exists\". For this particular "
"situation, the code could be changed to: |br| "
"``box.schema.space.create('X', {if_not_exists=true})`` |br| But there is "
"a more general solution: the :samp:`box.once({key}, {function})` method. "
"If ``box.once()`` has been called before with the same :samp:`{key}` "
"value, then :samp:`{function}` is ignored; otherwise :samp:`{function}` "
"is executed. Therefore, actions which should only occur once during the "
"life of a replicated session should be placed in a function which is "
"executed via ``box.once()``. For example:"
msgstr ""
"Предположим, что реплика пытается сделать нечто, что уже было сделано на "
"главном сервере. Например: |br| :code:`box.schema.space.create('X')` |br|"
" Это приведет к ошибке \"Space X exists\" (\"Пространство X уже "
"существует\"). В данном частном случае можно скорректировать инструкцию "
"следующим образом: |br| :code:`box.schema.space.create('X', "
"{if_not_exists=true})` |br| Но существует и более общее решение: "
"использовать метод :samp:`box.once({key}, {function})`. Если "
":code:`box.once()` был вызван ранее с тем же значением параметра "
":samp:`{key}`, то функция :samp:`{function}` игнорируется; в противном "
"случае функция :samp:`{function}` будет выполнена. Поэтому действия, "
"которые должны совершаться только один раз за время текущей сессии "
"репликации, нужно помещать в функцию и вызывать ее с помощью метода "
":code:`box.once()`. Например:"

#: ../doc/1.6/book/replication/index.rst:238
msgid ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../doc/1.6/book/replication/index.rst:247
msgid "Master-master replication"
msgstr "Репликация по схеме master-master"

#: ../doc/1.6/book/replication/index.rst:249
#, fuzzy
msgid ""
"In the simple master-replica configuration, the master's changes are seen"
" by the replica, but not vice versa, because the master was specified as "
"the sole replication source. In the master-master configuration, also "
"sometimes called multi-master configuration, it's possible to go both "
"ways. Starting with the simple configuration, the first instance has to "
"say:"
msgstr ""
"В случае настройки репликации по схеме master-replica изменения на "
"главном сервере доступны для просмотра с реплики, но не наоборот, потому "
"как главный сервер в такой схеме указан в качестве единственного "
"источника репликации. В случае схемы master-master (иногда ее также "
"называет multi-master) просмотр изменений возможен в любом направлении. В"
" простом случае (master-master с двумя серверами) на первом сервере нужно"
" задать следующие настройки:"

#: ../doc/1.6/book/replication/index.rst:259
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../doc/1.6/book/replication/index.rst:261
msgid ""
"This request can be performed at any time -- :ref:`replication_source "
"<cfg_replication-replication_source>` is a dynamic parameter."
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр "
":ref:`replication_source <cfg_replication-replication_source>` можно "
"задавать на ходу."

#: ../doc/1.6/book/replication/index.rst:264
#, fuzzy
msgid ""
"In this configuration, both instances are \"masters\" and both instances "
"are \"replicas\". Henceforth every change that happens on either instance"
" will be visible on the other. The failover benefit is still present, and"
" the load-balancing benefit is enhanced (because clients can connect to "
"either instance for data-change requests as well as select requests)."
msgstr ""
"В данном примере оба сервера являются одновременно и \"главными\", и "
"\"репликами\". Поэтому каждое изменение, которое случается на одном "
"сервере, становится доступно для просмотра с другого сервера. "
"Отказоустойчивость в такой конфигурации сохраняется, а возможности по "
"балансировке нагрузки становятся еще шире (теперь клиенты могут "
"обращаться к обоим серверам со всеми типами запросов — как на чтение "
"данных, так и на изменение)."

#: ../doc/1.6/book/replication/index.rst:270
#, fuzzy
msgid ""
"If two operations for the same tuple take place \"concurrently\" (which "
"can involve a long interval because replication is asynchronous), and one"
" of the operations is ``delete`` or ``replace``, there is a possibility "
"that instances will end up with different contents."
msgstr ""
"Если две операции над одним и тем же кортежем производятся "
"\"параллельно\" (а это может потребовать много времени, поскольку "
"репликация — это асинхронный процесс), причем одна из операций — это "
"``delete``, а вторая — ``replace``, то существует вероятность, что данные"
" на серверах станут различаться."

#: ../doc/1.6/book/replication/index.rst:277
msgid "All the \"What If?\" questions"
msgstr "Ответы на вопросы \"Что если?\""

#: ../doc/1.6/book/replication/index.rst:281
msgid "What if there are more than two instances with master-master?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:282
msgid ""
"On each instance, specify the :ref:`replication source <cfg_replication-"
"replication_source>` for all the others. For example, instance #3 would "
"have a request:"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:292
msgid "What if an instance should be taken out of the replica set?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:293
#, fuzzy
msgid ""
"For a replica, run ``box.cfg{}`` again specifying a blank replication "
"source: ``box.cfg{replication_source=''}``"
msgstr ""
"Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: "
"Для реплики — выполните запрос ``box.cfg{}``, указав пустой источник "
"репликации: |br| ``box.cfg{replication_source=''}``"

#: ../doc/1.6/book/replication/index.rst:296
msgid "What if an instance leaves the replica set?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:297
#, fuzzy
msgid ""
"The other instances carry on. If the wayward instance rejoins, it will "
"receive all the updates that the other instances made while it was away."
msgstr ""
"Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: "
"Остальные сервера продолжают работать. Если выбывший сервер снова "
"возвращается в кластер, то он получит информацию о всех изменениях, "
"которые произошли на остальных серверах за время его отсутствия."

#: ../doc/1.6/book/replication/index.rst:300
msgid "What if two instances both change the same tuple?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:301
#, fuzzy
msgid ""
"The last changer wins. For example, suppose that instance#1 changes the "
"tuple, then instance#2 changes the tuple. In that case instance#2's "
"change overrides whatever instance#1 did. In order to keep track of who "
"came last, Tarantool implements a `vector clock "
"<https://en.wikipedia.org/wiki/Vector_clock>`_."
msgstr ""
"Вопрос: Что если два сервера совершают изменения, связанные с одним и тем"
" же кортежем? |br| Ответ: Применятся последние из совершенных изменений. "
"Для примера предположим, что сервер #1 меняет некоторый кортеж, а затем "
"сервер #2 меняет тот же кортеж. В данном случае изменения сервера #2 "
"затрут изменения сервера #1. Чтобы отслеживать, кто был последним, в "
"Tarantool'е используются `векторные часы "
"<https://en.wikipedia.org/wiki/Vector_clock>`_."

#: ../doc/1.6/book/replication/index.rst:307
msgid "What if two instances both insert the same tuple?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:308
#, fuzzy
msgid ""
"If a master tries to insert a tuple which a replica has inserted already,"
" this is an example of a severe error. Replication stops. It will have to"
" be restarted manually."
msgstr ""
"Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? "
"|br| Ответ: Если главный сервер попытается вставить кортеж, который уже "
"был вставлен на реплике, то это будет пример серьезной ошибки. Репликация"
" остановится, и ее придется перезапускать в ручную."

#: ../doc/1.6/book/replication/index.rst:312
msgid "What if a master disappears and the replica must take over?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:313
#, fuzzy
msgid ""
"A message will appear on the replica stating that the connection is lost."
" The replica must now become independent, which can be done by saying "
"``box.cfg{replication_source=''}``."
msgstr ""
"Вопрос: Что если главный сервер становится недоступен и пользователям "
"приходится переключаться реплику? |br| Ответ: Реплика получает сообщение,"
" что связь потеряна. Теперь реплика должна начать работать независимо. "
"Для этого ей нужно задать пустой источник репликации, выполнив на стороне"
" реплики запрос ``box.cfg{replication_source=''}``."

#: ../doc/1.6/book/replication/index.rst:317
msgid "What if it's necessary to know what replica set an instance is in?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:318
msgid ""
"The identification of the replica set is a UUID which is generated when "
"the first master starts for the first time. This UUID is stored in a "
"tuple of the :ref:`box.space._schema <box_space-schema>` system space. So"
" to see it, say: ``box.space._schema:select{'cluster'}``"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:323
msgid ""
"What if it's necessary to know what other instances belong in the replica"
" set?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:324
msgid ""
"The universal identification of an instance is a UUID in "
"``box.info.server.uuid``. The ordinal identification of an instance "
"within a replica set is a number in ``box.info.server.id``. To see all "
"the instances in the replica set, say: ``box.space._cluster:select{}``. "
"This will return a table with all {server.id, server.uuid} tuples for "
"every instance that has ever joined the replica set."
msgstr ""

#: ../doc/1.6/book/replication/index.rst:331
msgid "What if one of the instance's files is corrupted or deleted?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:332
#, fuzzy
msgid ""
"Stop the instance, destroy all the database files (the ones with "
"extension \"snap\" or \"xlog\" or \".inprogress\"), restart the instance,"
" and catch up with the master by contacting it again (just say "
"``box.cfg{...replication_source=...}``)."
msgstr ""
"Вопрос: Что если какой-то из файлов репликации на реплике поврежден или "
"удален? |br| Ответ: Нужно остановить сервер, удалить все файлы, "
"относящиеся к базе данных (это файлы с расширениями \"snap\", \"xlog\" и "
"\".inprogress\"), снова запустить сервер и ввести запрос "
"``box.cfg{...replication_source=...}``, чтобы восстановить соединение с "
"главным сервером и загрузить данные с него."

#: ../doc/1.6/book/replication/index.rst:337
msgid "What if replication causes security concerns?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:338
#, fuzzy
msgid ""
"Prevent unauthorized replication sources by associating a password with "
"every user that has access privileges for the relevant spaces, and every "
"user that has a replication :ref:`role <authentication-roles>`. That way,"
" the :ref:`URI <index-uri>` for the :ref:`replication source "
"<cfg_replication-replication_source>` parameter will always have to have "
"the long form ``replication_source='username:password@host:port'``"
msgstr ""
"Вопрос: Что если при репликации возникают вопросы, связанные с "
"безопасностью? |br| Ответ: Чтобы предотвратить появление "
"несанкционированных источников репликации, нужно задать пароль для "
"каждого пользователя, у которого есть привилегии доступа к "
"соответствующим пространствам, а также для каждого пользователя, у "
"которого настроена :ref:`репликационная роль <authentication-rep_role>`. "
"Заметьте, что :ref:`URI <index-uri>` для параметра "
":ref:`replication_source <cfg_replication-replication_source>` теперь "
"нужно всегда указывать в полном виде: |br| "
"``replication_source='username:password@host:port'``"

#: ../doc/1.6/book/replication/index.rst:345
msgid "What if advanced users want to understand better how it all works?"
msgstr ""

#: ../doc/1.6/book/replication/index.rst:346
#, fuzzy
msgid ""
"See the description of instance startup with replication in the "
":ref:`Internals <internals-replication>` section."
msgstr ""
"Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем,"
" как работает репликация? |br| Ответ: См. информацию о запуске сервера с "
"репликацией в Приложении B. :ref:`Детали реализации <b_internals-"
"replication>`."

#: ../doc/1.6/book/replication/index.rst:351
msgid "Hands-on replication tutorial"
msgstr "Практическое руководство по репликации"

#: ../doc/1.6/book/replication/index.rst:353
#, fuzzy
msgid ""
"After following the steps here, an administrator will have experience "
"creating a replica set and adding a replica."
msgstr ""
"Ниже приводятся пошаговые инструкции, которые помогут вам получить "
"практический опыт администрирования кластера, а именно опыт создания "
"кластера и добавления реплики."

#: ../doc/1.6/book/replication/index.rst:356
msgid ""
"Start two shells. Put them side by side on the screen. (This manual has a"
" tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to"
" switch to the display of the other shell.)"
msgstr ""
"Запустите два терминала, каждый в своем окне, и расположите их рядом на "
"экране. (Далее в примерах оба терминала показаны в виде закладок. "
"Щелкните на заголовок закладки — \"Terminal #1\" или \"Terminal #2\", — "
"чтобы увидеть вывод на соответствующем терминале.)"

#: ../doc/1.6/book/replication/1_2.rst:1
#: ../doc/1.6/book/replication/index.rst:382
#: ../doc/1.6/book/replication/index.rst:389
msgid "$"
msgstr "$"

#: ../doc/1.6/book/replication/index.rst:393
msgid "On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#: ../doc/1.6/book/replication/index.rst:395
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../doc/1.6/book/replication/index.rst:407
#, fuzzy
msgid ""
"The result is that a new replica set is configured, and the instance's "
"UUID is displayed. Now the screen looks like this: (except that UUID "
"values are always different):"
msgstr ""
"В результате были заданы настройки нового кластера, а на экране был "
"выведен UUID текущего сервера. Теперь вывод на экране выглядит следующим "
"образом (за тем исключением, что UUID у вас будут другие):"

#: ../doc/1.6/book/replication/1_1.rst:1
#, fuzzy
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.6.9-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../doc/1.6/book/replication/index.rst:439
msgid "On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#: ../doc/1.6/book/replication/index.rst:441
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../doc/1.6/book/replication/index.rst:454
#, fuzzy
msgid ""
"The result is that a replica is set up. Messages appear on Terminal #1 "
"confirming that the replica has connected and that the WAL contents have "
"been shipped to the replica. Messages appear on Terminal #2 showing that "
"replication is starting. Also on Terminal#2 the _cluster UUID values are "
"displayed, and one of them is the same as the _cluster UUID value that "
"was displayed on Terminal #1, because both instances are in the same "
"replica set."
msgstr ""
"В результате были заданы настройки сервера-реплики. На экране первого "
"терминала (Terminal #1) появились сообщения с подтверждениями, что "
"реплика установила соединение с главным сервером и что содержимое "
"WAL-файла было отправлено на реплику. На экране второго терминала "
"(Terminal #2) появились сообщения о том, что репликация начинается, а "
"также там были выведены UUID из системного пространства _cluster (один из"
" них совпадает с UUID в первом терминале, поскольку оба сервера входят в "
"общий кластер)."

#: ../doc/1.6/book/replication/2_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/1.6/book/replication/2_2.rst:1 ../doc/1.6/book/replication/3_2.rst:1
#, fuzzy
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.6.9-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.6.9 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot "
"from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating "
"`./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot "
"from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating "
"`./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../doc/1.6/book/replication/index.rst:490
msgid "On Terminal #1, execute these requests:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../doc/1.6/book/replication/index.rst:492
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#: ../doc/1.6/book/replication/index.rst:498
#: ../doc/1.6/book/replication/index.rst:666
msgid "Now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.6/book/replication/3_1.rst:1 ../doc/1.6/book/replication/4_1.rst:1
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/1.6/book/replication/index.rst:529
msgid ""
"The creation and insertion were successful on Terminal #1. Nothing has "
"happened on Terminal #2."
msgstr ""
"В первом терминале успешно отработали операции CREATE и INSERT. Но во "
"втором терминале ничего не произошло."

#: ../doc/1.6/book/replication/index.rst:532
msgid "On Terminal #2, execute these requests:"
msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#: ../doc/1.6/book/replication/index.rst:534
msgid ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#: ../doc/1.6/book/replication/index.rst:540
msgid ""
"Now the screen looks like this (remember to click on the \"Terminal #2\" "
"tab when looking at Terminal #2 results):"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.6/book/replication/4_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../doc/1.6/book/replication/index.rst:572
msgid ""
"The selection and insertion were successful on Terminal #2. Nothing has "
"happened on Terminal #1."
msgstr ""
"Во втором терминале успешно отработали операции SELECT и INSERT. Но в "
"первом терминале ничего не произошло."

#: ../doc/1.6/book/replication/index.rst:575
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#: ../doc/1.6/book/replication/index.rst:577
msgid ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"

#: ../doc/1.6/book/replication/index.rst:583
#, fuzzy
msgid ""
"Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing "
"that fact. The ``ls -l`` commands show that both instances have made "
"snapshots, which have similar sizes because they both contain the same "
"tuples."
msgstr ""
"Теперь Tarantool-сервер в первом терминале остановлен. В окне второго "
"терминала появились сообщения об этом событии. С помощью команд ``ls -l``"
" мы убедились, что на обоих серверах создались файлы-снимки с одинаковыми"
" размерами, поскольку там содержатся одни и те же кортежи."

#: ../doc/1.6/book/replication/5_1.rst:1 ../doc/1.6/book/replication/6_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../doc/1.6/book/replication/5_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../doc/1.6/book/replication/index.rst:616
msgid "On Terminal #2, ignore the error messages, and execute these requests:"
msgstr ""
"Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и "
"выполните следующие запросы:"

#: ../doc/1.6/book/replication/index.rst:619
msgid ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"

#: ../doc/1.6/book/replication/index.rst:624
msgid "Now the screen looks like this (ignoring the error messages):"
msgstr ""
"Теперь вывод на экране выглядит следующим образом (сообщения об ошибках "
"мы не приводим):"

#: ../doc/1.6/book/replication/6_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../doc/1.6/book/replication/index.rst:656
msgid ""
"Terminal #2 has done a select and an insert, even though Terminal #1 is "
"down."
msgstr ""
"Запросы SELECT и INSERT во втором терминале отработали несмотря на то, "
"что сервер в первом терминале остановлен."

#: ../doc/1.6/book/replication/index.rst:658
msgid "On Terminal #1 execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../doc/1.6/book/replication/index.rst:660
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.6/book/replication/7_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/1.6/book/replication/7_2.rst:1
#, fuzzy
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.6.9 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../doc/1.6/book/replication/index.rst:697
#, fuzzy
msgid ""
"The master has reconnected to the replica set, and has NOT found what the"
" replica wrote while the master was away. That is not a surprise -- the "
"replica has not been asked to act as a replication source."
msgstr ""
"Главный сервер снова установил соединение с кластером и НЕ обнаружил "
"изменения, сделанные репликой за время его недоступности. Это и не "
"удивительно: мы же не просили реплику выступать в качестве источника "
"репликации."

#: ../doc/1.6/book/replication/index.rst:701
#: ../doc/1.6/reference/reference_rock/shard.rst:303
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../doc/1.6/book/replication/index.rst:703
msgid ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.6/book/replication/index.rst:710
#: ../doc/1.6/tutorials/lua_tutorials.rst:119
#: ../doc/1.6/tutorials/lua_tutorials.rst:163
#: ../doc/1.6/tutorials/lua_tutorials.rst:215
#: ../doc/1.6/tutorials/lua_tutorials.rst:271
#: ../doc/1.6/tutorials/lua_tutorials.rst:317
#: ../doc/1.6/tutorials/lua_tutorials.rst:375
#: ../doc/1.6/tutorials/lua_tutorials.rst:468
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.6/book/replication/8_1.rst:1
#, fuzzy
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.6.9 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'"
"\n"
"[22612] relay/127.0.0.1:33510/102/main I> done "
"`./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'"
"\n"
"[22612] relay/127.0.0.1:33510/102/main I> done "
"`./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../doc/1.6/book/replication/8_2.rst:1
#, fuzzy
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.6.9 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/1.6/book/replication/index.rst:755
#, fuzzy
msgid ""
"This shows that the two instances are once again in synch, and that each "
"instance sees what the other instance wrote."
msgstr ""
"Тут мы видим, что оба сервера снова синхронизовались и что каждый из них "
"видит те записи, которые сделал другой."

#: ../doc/1.6/book/replication/index.rst:758
msgid ""
"To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, "
"and then on either terminal say:"
msgstr ""
"Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих "
"терминалах, а затем на каждом из них выполните следующие команды:"

#: ../doc/1.6/book/replication/index.rst:761
msgid ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"

#: ../doc/1.6/dev_guide/build_contribute_index.rst:37
msgid "Build and contribute"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:39
msgid "Building documentation"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:41
msgid ""
"Tarantool documentation is built using a simplified markup system named "
"``Sphinx`` (see http://sphinx-doc.org). You can build a local version of "
"this documentation and you can contribute to Tarantool's version."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:45
msgid "You need to install these packages:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:47
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:48
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:49
msgid ""
"``Python`` version greater than 2.6 -- preferably 2.7 -- and less than "
"3.0 (Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:51
msgid ""
"``LaTeX`` (a system for document preparation, the installable package "
"name usually begins with the word texlive or tetex, on Ubuntu the name is"
" texlive-latex-base)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:55
msgid "You need to install these Python modules:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:57
#: ../doc/1.6/dev_guide/building_from_source.rst:87
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:58
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:59
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:60
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:62
msgid ""
"See more details about installation in the :ref:`build-from-source "
"<building_from_source>` section of this documentation."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:65
msgid ""
"Use ``git`` to download the latest source code of this documentation from"
" the GitHub repository ``tarantool/doc``, branch 1.6. For example, to "
"download to a local directory named ``~/tarantool-doc``:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:69
#, fuzzy
msgid "$ git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.6/dev_guide/building_documentation.rst:73
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:75
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make clean         # unnecessary, added for good luck\n"
"$ rm CMakeCache.txt  # unnecessary, added for good luck\n"
"$ cmake .            # initiate"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:82
#, fuzzy
msgid "Build a local version of the documentation."
msgstr "Как пользоваться документацией"

#: ../doc/1.6/dev_guide/building_documentation.rst:84
msgid ""
"Run the ``make`` command with an appropriate option to specify which "
"documentation version to build."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:87
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html           # multi-page English version\n"
"$ make sphinx-singlehtml     # one-page English version\n"
"$ make sphinx-html-ru        # multi-page Russian version\n"
"$ make sphinx-singlehtml-ru  # one-page Russian version\n"
"$ make all                   # all versions plus the entire web-site"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:96
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:98
msgid "``/output/en`` (files of the English version)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:99
msgid "``/output/ru`` (files of the Russian version)"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:101
msgid ""
"The entry point for each version is the ``index.html`` file in the "
"appropriate directory."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:104
msgid "Set up a web server."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:106
msgid ""
"One way is to say ``make sphinx-webserver``. This will set up and run the"
" web server on port ``8000``:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:109
msgid ""
"$ cd ~/tarantool-doc\n"
"$ make sphinx-html       # as an example, build the multi-page English "
"documentation\n"
"$ make sphinx-webserver  # set up and run the web server"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:115
msgid ""
"In case port ``8000`` is already in use, you can specify any other port "
"number that is bigger than ``1000`` in the ``tarantool-"
"doc/CMakeLists.txt`` file (search it for the ``sphinx-webserver`` target)"
" and rebuild cmake files:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:120
msgid ""
"$ cd ~/tarantool-doc\n"
"$ git clean -qfxd        # clean up old cmake files\n"
"$ cmake .                # rebuild cmake files\n"
"$ make sphinx-html       # as an example, build the multi-page English "
"documentation\n"
"$ make sphinx-webserver  # set up and run the web server on the custom "
"port"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:128
msgid "Or you can release the port:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:130
msgid ""
"$ sudo lsof -i :8000  # get the process ID (PID)\n"
"COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME\n"
"Python 19516 user 3u IPv4 0xe7f8gc6be1b43c7 0t0 TCP *:irdmi (LISTEN)\n"
"$ sudo kill -9 19516  # kill the process"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:137
msgid ""
"The other way is to run the built-in web server in Python. Make sure to "
"run it from the documentation ``output`` folder:"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:140
msgid ""
"$ cd ~/tarantool-doc/output\n"
"$ python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:145
msgid ""
"In case port ``8000`` is already in use, you can specify any other port "
"number that is bigger than ``1000``."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:148
msgid ""
"Open your browser and enter ``127.0.0.1:8000/en/doc/1.6/`` into the "
"address box (or ``127.0.0.1:8000/ru/doc/1.6/`` if you built the Russian "
"documentation). Mind the trailing slash \"/\" in the address string."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:152
msgid ""
"If your local documentation build is valid, the manual will appear in the"
" browser."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:155
msgid ""
"To contribute to documentation, use the `REST "
"<http://docutils.sourceforge.net/docs/user/rst/quickstart.html>`_ format "
"for drafting and submit your updates as a `pull request "
"<https://help.github.com/articles/creating-a-pull-request/>`_ via GitHub."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:161
msgid ""
"To comply with the writing and formatting style, use the :ref:`guidelines"
" <documentation_guidelines>` provided in the documentation, common sense "
"and existing documents."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:167
msgid ""
"If you suggest creating a new documentation section (a whole new page), "
"it has to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/1.6/dev_guide/building_documentation.rst:170
msgid ""
"If you want to contribute to localizing this documentation (for example "
"into Russian), add your translation strings to ``.po`` files stored in "
"the corresponding locale directory (for example "
"``/locale/ru/LC_MESSAGES/`` for Russian). See more about localizing with "
"Sphinx at http://www.sphinx-doc.org/en/stable/intl.html"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:39
msgid "Building from source"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:41
msgid ""
"For downloading Tarantool source and building it, the platforms can "
"differ and the preferences can differ. But the steps are always the same."
" Here in the manual we'll explain what the steps are, and after that you "
"can look at some example scripts on the Internet."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:46
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:49
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:51
msgid ""
"A program for downloading source repositories. |br| For all platforms, "
"this is ``git``. It allows to download the latest complete set of source "
"files from the Tarantool repository at GitHub."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:55
msgid ""
"A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version "
"4.6 or later. On Mac OS X, this is ``Clang`` version 3.2 or later."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:58
msgid ""
"A program for managing the build process. |br| For all platforms, this is"
" ``CMake``. The CMake version should be 2.8 or later."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:61
msgid ""
"Command-line interpreter for Python-based code (namely, for Tarantool "
"test suite). |br| For all platforms, this is ``python``. The Python "
"version should be greater than 2.6 -- preferably 2.7 -- and less than "
"3.0."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:65
msgid ""
"Here are names of tools and libraries which may have to be installed in "
"advance, using ``sudo apt-get`` (for Ubuntu), ``sudo yum install`` (for "
"CentOS), or the equivalent on other platforms. Different platforms may "
"use slightly different names. Ignore the ones marked `optional, only in "
"Mac OS scripts` unless the platform is Mac OS."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:71
msgid "**gcc** and **g++**, or **clang**        # see above"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:72
msgid "**git**                                  # see above"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:73
msgid "**cmake**                                # see above"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:74
msgid "**python**                               # see above; for test suite"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:75
msgid ""
"**libreadline-dev** or **libreadline6-dev** or **readline-devel**  # for "
"interactive mode"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:76
msgid "**libssl-dev**                           # for `digest` module"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:77
msgid ""
"**autoconf**                             # optional, only in Mac OS "
"scripts"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:78
msgid ""
"**zlib1g** or **zlib**                   # optional, only in Mac OS "
"scripts"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:80
msgid "Set up Python modules for running the test suite."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:82
msgid ""
"This step is optional. Python modules are not necessary for building "
"Tarantool itself, unless you intend to use the \"Run the test suite\" "
"option in step 7."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:85
msgid "You need the following Python modules:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:88
msgid "`dev <https://pypi.python.org/pypi/dev>`_, any version"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:89
msgid "`pyYAML <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:90
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:91
msgid ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version "
"0.4.6"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:92
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1b5"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:93
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:95
msgid "On Ubuntu, you can get the modules from the repository:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:97
msgid "sudo apt-get install python-pip python-dev python-yaml <...>"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:101
msgid "On CentOS 6, you can likewise get the modules from the repository:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:103
msgid "sudo yum install python26 python26-PyYAML <...>"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:107
msgid ""
"If some modules are not available on a repository, it is best to set up "
"the modules by getting a tarball and doing the setup with ``python "
"setup.py``, thus:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:111
msgid ""
"# On some machines, this initial command may be necessary:\n"
"# wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"# Python module for parsing YAML (pyYAML), for test suite:\n"
"# (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"# what the current version is.)\n"
"cd ~\n"
"wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"tar -xzf PyYAML-3.10.tar.gz\n"
"cd PyYAML-3.10\n"
"sudo python setup.py install"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:125
msgid ""
"Finally, use Python :code:`pip` to bring in Python packages that may not "
"be up-to-date in the distro repositories. (On CentOS 7, it will be "
"necessary to install ``pip`` first, with :code:`sudo yum install epel-"
"release` followed by :code:`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:131
msgid "pip install tarantool\\>0.4 --user"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:135
msgid ""
"Use ``git`` to download the latest Tarantool source code from the GitHub "
"repository ``tarantool/tarantool``, branch 1.6. For example, to a local "
"directory named `~/tarantool`:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:139
msgid "git clone https://github.com/tarantool/tarantool.git ~/tarantool"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:143
msgid "Use ``git`` again so that third-party contributions will be seen as well."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:145
msgid "The build depends on the following external libraries:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:147
msgid "Readline development files (``libreadline-dev/readline-devel`` package)."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:148
msgid "OpenSSL development files (``libssl-dev/openssl-devel`` package)."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:149
msgid "``libyaml`` (``libyaml-dev/libyaml-devel`` package)."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:150
msgid "``liblz4`` (``liblz4-dev/lz4-devel`` package)."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:151
msgid ""
"GNU ``bfd`` which is the part of GNU ``binutils`` (``binutils-dev"
"/binutils-devel`` package)."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:154
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:156
msgid ""
"cd ~/tarantool\n"
"git submodule init\n"
"git submodule update --recursive\n"
"cd ../"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:163
msgid ""
"On rare occasions, the submodules will need to be updated again with the "
"command:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:166
msgid "git submodule update --init --recursive"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:170
msgid ""
"Note: There is an alternative -- to say ``git clone --recursive`` earlier"
" in step 3, -- but we prefer the method above because it works with older"
" versions of ``git``."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:174
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:176
msgid ""
"cd ~/tarantool\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:183
msgid ""
"On some platforms, it may be necessary to specify the C and C++ versions,"
" for example:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:186
msgid "CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:190
msgid ""
"The CMake option for specifying build type is "
":samp:`-DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:193
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:194
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:195
msgid ""
"``RelWithDebInfo`` -- used for production, also provides debugging "
"capabilities"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:197
msgid ""
"The CMake option for hinting that the result will be distributed is "
":code:`-DENABLE_DIST=ON`. If this option is on, then later ``make "
"install`` will install tarantoolctl files in addition to tarantool files."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:201
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:203
msgid "make"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:207
msgid "This creates the 'tarantool' executable in the directory `src/`"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:209
msgid ""
"Next, it's highly recommended to say ``make install`` to install "
"Tarantool to the `/usr/local` directory and keep your system clean. "
"However, it is possible to run the Tarantool executable without "
"installation."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:213
msgid "Run the test suite."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:215
msgid ""
"This step is optional. Tarantool's developers always run the test suite "
"before they publish new versions. You should run the test suite too, if "
"you make any changes in the code. Assuming you downloaded to "
"``~/tarantool``, the principal steps are:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:220
msgid ""
"# make a subdirectory named `bin`\n"
"mkdir ~/tarantool/bin\n"
"# link python to bin (this may require superuser privilege)\n"
"ln /usr/bin/python ~/tarantool/bin/python\n"
"# get on the test subdirectory\n"
"cd ~/tarantool/test\n"
"# run tests using python\n"
"PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:231
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:233
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:246
msgid "To prevent later confusion, clean up what's in the `bin` subdirectory:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:248
msgid ""
"rm ~/tarantool/bin/python\n"
"rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:253
msgid "Make an rpm package."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:255
msgid ""
"This step is optional. It's only for people who want to redistribute "
"Tarantool. Package maintainers who want to build with ``rpmbuild`` should"
" consult the ``rpm-build`` instructions for the appropriate platform."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:259
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:261
msgid "tarantool $ ./src/tarantool"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:265
msgid "This will start Tarantool in the interactive mode."
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:267
msgid ""
"For your added convenience, we provide OS-specific README files with "
"example scripts at GitHub:"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:270
msgid ""
"`README.FreeBSD "
"<https://github.com/tarantool/tarantool/blob/1.6/README.FreeBSD>`_ for "
"FreeBSD 10.1"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:272
msgid ""
"`README.MacOSX "
"<https://github.com/tarantool/tarantool/blob/1.6/README.MacOSX>`_ for Mac"
" OS X `El Capitan`"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:274
msgid ""
"`README.md <https://github.com/tarantool/tarantool/blob/1.6/README.md>`_ "
"for generic GNU/Linux"
msgstr ""

#: ../doc/1.6/dev_guide/building_from_source.rst:276
msgid ""
"These example scripts assume that the intent is to download from the 1.6 "
"branch, build the server and run tests after build."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:37
msgid "C Style Guide"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:39
msgid ""
"The project's coding style is based on a version of the Linux kernel "
"coding style."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:41
msgid ""
"The latest version of the Linux style can be found at: "
"http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:44
msgid ""
"Since it is open for changes, the version of style that we follow, one "
"from 2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:47
msgid ""
"There are a few additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:50
msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-"
"invent the kernel macros\" do not apply, since they are specific to Linux"
" kernel programming environment."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:55
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:59
msgid "General guidelines"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:61
msgid ""
"We use Git for revision control. The latest development is happening in "
"the 'master' branch. Our git repository is hosted on github, and can be "
"checked out with git clone git://github.com/tarantool/tarantool.git # "
"anonymous read-only access"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:65
msgid ""
"If you have any questions about Tarantool internals, please post them on "
"the developer discussion list, "
"https://groups.google.com/forum/#!forum/tarantool. However, please be "
"warned: Launchpad silently deletes posts from non-subscribed members, "
"thus please be sure to have subscribed to the list prior to posting. "
"Additionally, some engineers are always present on #tarantool channel on "
"irc.freenode.net."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:73
msgid "Commenting style"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:75
msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than "
"`\\tag`. The main tags in use are @param, @retval, @return, @see, @note "
"and @todo."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:78
msgid ""
"Every function, except perhaps a very short and obvious one, should have "
"a comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:81
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:96
msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:100
msgid "Header files"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:102
msgid ""
"Use header guards. Put the header guard in the first line in the header, "
"before the copyright or declarations. Use all-uppercase name for the "
"header guard. Derive the header guard name from the file name, and append"
" _INCLUDED to get a macro name. For example, core/log_io.h -> "
"CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the "
"respective declaration header before all other headers, to ensure that "
"the header is self- sufficient. Header \"header.h\" is self-sufficient if"
" the following compiles without errors:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:110
msgid "#include \"header.h\""
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:116
msgid "Allocating memory"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:118
msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to "
"malloc()/free() for any performance-intensive or large  memory "
"allocations. Repetitive use of malloc()/free() can lead to memory "
"fragmentation and should therefore be avoided."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:122
msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"free() the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a "
"plug-in can be dynamically loaded and unloaded multiple times, reload "
"should not lead to a memory leak."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:130
msgid "Other"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:132
msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and"
" statements, use true and false."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:135
msgid ""
"The not-so-current list of all GCC C extensions can be found at: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:140
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:142
msgid ""
"This is a short document describing the preferred coding style for the "
"linux kernel.  Coding style is very personal, and I won't _force_ my "
"views on anybody, but this is what goes for anything that I have to be "
"able to maintain, and I'd prefer it for most other things too.  Please at"
" least consider the points made here."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:148
msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, "
"and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:151
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:155
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:157
msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There"
" are heretic movements that try to make indentations 4 (or even 2!) "
"characters deep, and that is akin to trying to define the value of PI to "
"be 3."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:162
msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a"
" block of control starts and ends.  Especially when you've been looking "
"at your screen for 20 straight hours, you'll find it a lot easier to see "
"how the indentation works if you have large indentations."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:167
msgid ""
"Now, some people will claim that having 8-character indentations makes "
"the code move too far to the right, and makes it hard to read on a "
"80-character terminal screen.  The answer to that is that if you need "
"more than 3 levels of indentation, you're screwed anyway, and should fix "
"your program."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:173
msgid ""
"In short, 8-char indents make things easier to read, and have the added "
"benefit of warning you when you're nesting your functions too deep. Heed "
"that warning."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:177
msgid ""
"The preferred way to ease multiple indentation levels in a switch "
"statement is to align the \"switch\" and its subordinate \"case\" labels "
"in the same column instead of \"double-indenting\" the \"case\" labels. "
"e.g.:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:181
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:201
msgid ""
"Don't put multiple statements on a single line unless you have something "
"to hide:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:204
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:209
msgid ""
"Don't put multiple assignments on a single line either. Kernel coding "
"style is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:212
msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are "
"never used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:215
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:220
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:222
msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:225
msgid ""
"The limit on the length of lines is 80 columns and this is a strongly "
"preferred limit."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:228
msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are "
"placed substantially to the right. The same applies to function headers "
"with a long argument list. Long strings are as well broken into shorter "
"strings. The only exception to this is where exceeding 80 columns "
"significantly increases readability and does not hide information."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:235
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:249
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:251
msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces.  Unlike the indent size, there are few technical reasons to "
"choose one placement strategy over the other, but the preferred way, as "
"shown to us by the prophets Kernighan and Ritchie, is to put the opening "
"brace last on the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:257
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:263
msgid ""
"This applies to all non-function statement blocks (if, switch, for, "
"while, do). e.g.:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:266
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:279
msgid ""
"However, there is one special case, namely functions: they have the "
"opening brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:282
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:289
msgid ""
"Heretic people all over the world have claimed that this inconsistency is"
" ...  well ...  inconsistent, but all right-thinking people know that (a)"
" K&R are _right_ and (b) K&R are right.  Besides, functions are special "
"anyway (you can't nest them in C)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:294
msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in "
"the cases where it is followed by a continuation of the same statement, "
"ie a \"while\" in a do-statement or an \"else\" in an if-statement, like "
"this:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:299
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:305
msgid "and"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:307
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:317
msgid "Rationale: K&R."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:319
msgid ""
"Also, note that this brace-placement also minimizes the number of empty "
"(or almost empty) lines, without any loss of readability.  Thus, as the "
"supply of new-lines on your screen is not a renewable resource (think "
"25-line terminal screens here), you have more empty lines to put comments"
" on."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:325
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:327
msgid ""
"if (condition)\n"
"    action();"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:332
msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:335
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:346
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:348
msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-"
"keyword usage.  Use a space after (most) keywords.  The notable "
"exceptions are sizeof, typeof, alignof, and __attribute__, which look "
"somewhat like functions (and are usually used with parentheses in Linux, "
"although they are not required in the language, as in: \"sizeof info\" "
"after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:355
msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but"
" not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:358
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:362
msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example"
" is **bad**:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:365
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:369
msgid ""
"When declaring pointer data or a function that returns a pointer type, "
"the preferred use of '*' is adjacent to the data name or function name "
"and not adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:373
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:379
msgid ""
"Use one space around (on each side of) most binary and ternary operators,"
" such as any of these:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:382
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:384
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:386
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:388
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:390
#: ../doc/1.6/dev_guide/c_style_guide.rst:394
msgid "++  --"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:392
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:396
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:398
msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with"
" \"smart\" indentation will insert whitespace at the beginning of new "
"lines as appropriate, so you can start typing the next line of code right"
" away. However, some such editors do not remove the whitespace if you end"
" up not putting a line of code there, such as if you leave a blank line."
"  As a result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:405
msgid ""
"Git will warn you about patches that introduce trailing whitespace, and "
"can optionally strip the trailing whitespace for you; however, if "
"applying a series of patches, this may make later patches in the series "
"fail by changing their context lines."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:413
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:415
msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 "
"and Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable"
" \"tmp\", which is much easier to write, and not the least more difficult"
" to understand."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:421
msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must.  To call a global function \"foo\" is a "
"shooting offense."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:425
msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have"
" descriptive names, as do global functions.  If you have a function that "
"counts the number of active users, you should call that "
"\"count_active_users()\" or similar, you should _not_ call it "
"\"cntusr()\"."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:430
msgid ""
"Encoding the type of a function into the name (so-called Hungarian "
"notation) is brain damaged - the compiler knows the types anyway and can "
"check those, and it only confuses the programmer.  No wonder MicroSoft "
"makes buggy programs."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:435
msgid ""
"LOCAL variable names should be short, and to the point.  If you have some"
" random integer loop counter, it should probably be called \"i\". Calling"
" it \"loop_counter\" is non-productive, if there is no chance of it being"
" mis-understood.  Similarly, \"tmp\" can be just about any type of "
"variable that is used to hold a temporary value."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:441
msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. "
"See chapter 6 (Functions)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:448
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:450
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:452
msgid ""
"It's a _mistake_ to use typedef for structures and pointers. When you see"
" a"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:454
msgid "vps_t a;"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:458
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:460
msgid "In contrast, if it says"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:462
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:466
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:468
msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are"
" useful only for:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:471
msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what"
" the object is)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:474
msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the"
" proper accessor functions."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:477
msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. "
"The reason we have them for things like pte_t etc. is that there really "
"is absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:481
msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion "
"whether it is \"int\" or \"long\"."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:484
msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category "
"(d) better than here."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:487
msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is "
"\"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:490
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:494
msgid ""
"but if there is a clear reason for why it under certain circumstances "
"might be an \"unsigned int\" and under other configurations might be "
"\"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:498
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:501
msgid ""
"New types which are identical to standard C99 types, in certain "
"exceptional circumstances."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:504
msgid ""
"Although it would only take a short amount of time for the eyes and brain"
" to become accustomed to the standard types like 'uint32_t', some people "
"object to their use anyway."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:508
msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- "
"although they are not mandatory in new code of your own."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:513
msgid ""
"When editing existing code which already uses one or the other set of "
"types, you should conform to the existing choices in that code."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:516
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:518
msgid ""
"In certain structures which are visible to userspace, we cannot require "
"C99 types and cannot use the 'u32' form above. Thus, we use __u32 and "
"similar types in all structures which are shared with userspace."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:523
msgid ""
"Maybe there are other cases too, but the rule should basically be to "
"NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:526
msgid ""
"In general, a pointer, or a struct that has elements that can reasonably "
"be directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:532
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:534
msgid ""
"Functions should be short and sweet, and do just one thing.  They should "
"fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, "
"as we all know), and do one thing and do that well."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:538
msgid ""
"The maximum length of a function is inversely proportional to the "
"complexity and indentation level of that function.  So, if you have a "
"conceptually simple function that is just one long (but simple) case-"
"statement, where you have to do lots of small things for a lot of "
"different cases, it's OK to have a longer function."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:544
msgid ""
"However, if you have a complex function, and you suspect that a less-"
"than-gifted first-year high-school student might not even understand what"
" the function is all about, you should adhere to the maximum limits all "
"the more closely.  Use helper functions with descriptive names (you can "
"ask the compiler to in-line them if you think it's performance-critical, "
"and it will probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:552
msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the "
"function, and split it into smaller pieces.  A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confu/sed.  You know you're brilliant, but maybe you'd like to understand"
" what you did 2 weeks from now."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:559
msgid ""
"In source files, separate functions with one blank line.  If the function"
" is exported, the EXPORT* macro for it should follow immediately after "
"the closing function brace line.  E.g.:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:563
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:571
msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in Linux"
" because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:577
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:579
msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is"
" used frequently by compilers in form of the unconditional jump "
"instruction."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:582
msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:585
msgid "The rationale is:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:587
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:588
msgid "nesting is reduced"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:589
msgid ""
"errors by not updating individual exit points when making modifications "
"are prevented"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:591
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:593
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:618
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:620
msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER "
"try to explain HOW your code works in a comment: it's much better to "
"write the code so that the _working_ is obvious, and it's a waste of time"
" to explain badly written code. с Generally, you want your comments to "
"tell WHAT your code does, not HOW. Also, try to avoid putting comments "
"inside a function body: if the function is so complex that you need to "
"separately comment parts of it, you should probably go back to chapter 6 "
"for a while.  You can make small comments to note or warn about something"
" particularly clever (or ugly), but try to avoid excess.  Instead, put "
"the comments at the head of the function, telling people what it does, "
"and possibly WHY it does it."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:634
msgid ""
"When commenting the kernel API functions, please use the kernel-doc "
"format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts"
"/kernel-doc for details."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:638
msgid ""
"Linux style for comments is the C89 ``\"/\\* ... \\*/\"`` style. Don't "
"use C99-style ``\"// ...\"`` comments."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:641
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:643
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:654
msgid ""
"It's also important to comment data, whether they are basic types or "
"derived types.  To this end, use just one data declaration per line (no "
"commas for multiple data declarations).  This leaves you room for a small"
" comment on each item, explaining its use."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:661
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:663
msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix "
"user helper that \"GNU emacs\" automatically formats the C sources for "
"you, and you've noticed that yes, it does do that, but the defaults it "
"uses are less than desirable (in fact, they are worse than random typing "
"- an infinite number of monkeys typing into GNU emacs would never make a "
"good program)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:670
msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner "
"values.  To do the latter, you can stick the following in your .emacs "
"file:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:673
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:704
msgid ""
"This will make emacs go better with the kernel coding style for C files "
"below ~/src/linux-trees."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:707
msgid ""
"But even if you fail in getting emacs to do sane formatting, not "
"everything is lost: use \"indent\"."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:710
msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs "
"has, which is why you need to give it a few command line options. "
"However, that's not too bad, because even the makers of GNU indent "
"recognize the authority of K&R (the GNU people aren't evil, they are just"
" severely misguided in this matter), so you just give indent the options "
"\"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use "
"\"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:718
msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment "
"re-formatting you may want to take a look at the man page.  But remember:"
" \"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:725
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:727
msgid ""
"For all of the Kconfig* configuration files throughout the source tree, "
"the indentation is somewhat different.  Lines under a \"config\" "
"definition are indented with one tab, while help text is indented an "
"additional two spaces. Example:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:732
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:743
msgid ""
"Features that might still be considered unstable should be defined as "
"dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:746
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:753
msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:756
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:763
msgid ""
"For full documentation on the configuration files, see the file "
"Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:769
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:771
msgid ""
"Data structures that have visibility outside the single-threaded "
"environment they are created and destroyed in should always have "
"reference counts.  In the kernel, garbage collection doesn't exist (and "
"outside the kernel garbage collection is slow and inefficient), which "
"means that you absolutely _have_ to reference count all your uses."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:777
msgid ""
"Reference counting means that you can avoid locking, and allows multiple "
"users to have access to the data structure in parallel - and not having "
"to worry about the structure suddenly going away from under them just "
"because they slept or did something else for a while."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:782
msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking "
"is used to keep data structures coherent, while reference counting is a "
"memory management technique.  Usually both are needed, and they are not "
"to be confused with each other."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:787
msgid ""
"Many data structures can indeed have two levels of reference counting, "
"when there are users of different \"classes\".  The subclass count counts"
" the number of subclass users, and decrements the global count just once "
"when the subclass count goes to zero."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:792
msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found "
"in memory management (\"struct mm_struct\": mm_users and mm_count), and "
"in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:796
msgid ""
"Remember: if another thread can find your data structure, and you don't "
"have a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:801
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:803
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:805
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:809
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:811
msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions "
"may be named in lower case."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:814
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:816
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:818
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:826
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:828
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:830
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:838
msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the "
"\"calling\" function; don't break the internal parsers of those who will "
"read the code."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:841
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:843
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:847
msgid ""
"might look like a good thing, but it's confusing as hell when one reads "
"the code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:850
msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite "
"you if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:853
msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with"
" macros using parameters."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:857
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:862
msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual "
"also covers RTL which is used frequently with assembly language in the "
"kernel."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:867
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:869
msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of "
"kernel messages to make a good impression. Do not use crippled words like"
" \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages "
"concise, clear, and unambiguous."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:874
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:876
#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:878
msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> "
"which you should use to make sure messages are matched to the right "
"device and driver, and are tagged with the right level:  dev_err(), "
"dev_warn(), dev_info(), and so forth.  For messages that aren't "
"associated with a particular device, <linux/kernel.h> defines pr_debug() "
"and pr_info()."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:884
msgid ""
"Coming up with good debugging messages can be quite a challenge; and once"
" you have them, they can be a huge help for remote troubleshooting.  Such"
" messages should be compiled out when the DEBUG symbol is not defined "
"(that is, by default they are not included).  When you use dev_dbg() or "
"pr_debug(), that's automatic.  Many subsystems have Kconfig options to "
"turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add "
"dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:894
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:896
msgid ""
"The kernel provides the following general purpose memory allocators: "
"kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API "
"documentation for further information about them."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:900
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:902
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:906
msgid ""
"The alternative form where struct name is spelled out hurts readability "
"and introduces an opportunity for a bug when the pointer variable type is"
" changed but the corresponding sizeof that is passed to a memory "
"allocator is not."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:910
msgid ""
"Casting the return value which is a void pointer is redundant. The "
"conversion from void pointer to any other pointer type is guaranteed by "
"the C programming language."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:916
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:918
msgid ""
"There appears to be a common misperception that gcc has a magic \"make me"
" faster\" speedup option called \"inline\". While the use of inlines can "
"be appropriate (for example as a means of replacing macros, see Chapter "
"12), it very often is not. Abundant use of the inline keyword leads to a "
"much bigger kernel, which in turn slows the system as a whole down, due "
"to a bigger icache footprint for the CPU and simply because there is less"
" memory available for the pagecache. Just think about it; a pagecache "
"miss causes a disk seek, which easily takes 5 milliseconds. There are a "
"LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:928
msgid ""
"A reasonable rule of thumb is to not put inline at functions that have "
"more than 3 lines of code in them. An exception to this rule are the "
"cases where a parameter is known to be a compiletime constant, and as a "
"result of this constantness you *know* the compiler will be able to "
"optimize most of your function away at compile time. For a good example "
"of this later case, see the kmalloc() inline function."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:935
msgid ""
"Often people argue that adding inline to functions that are static and "
"used only once is always a win since there is no space tradeoff. While "
"this is technically correct, gcc is capable of inlining these "
"automatically without help, and the maintenance issue of removing the "
"inline when a second user appears outweighs the potential value of the "
"hint that tells gcc to do something it would have done anyway."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:944
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:946
msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed.  "
"Such a value can be represented as an error-code integer (-Exxx = "
"failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero ="
" success)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:952
msgid ""
"Mixing up these two sorts of representations is a fertile source of "
"difficult-to-find bugs.  If the C language included a strong distinction "
"between integers and booleans then the compiler would find these mistakes"
" for us... but it doesn't.  To help prevent such bugs, always follow this"
" convention:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:960
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:964
msgid ""
"For example, \"add work\" is a command, and the add_work() function "
"returns 0 for success or -EBUSY for failure.  In the same way, \"PCI "
"device present\" is a predicate, and the pci_dev_present() function "
"returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:969
msgid ""
"All EXPORTed functions must respect this convention, and so should all "
"public functions.  Private (static) functions need not, but it is "
"recommended that they do."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:973
msgid ""
"Functions whose return value is the actual result of a computation, "
"rather than an indication of whether the computation succeeded, are not "
"subject to this rule.  Generally they indicate failure by returning some "
"out-of-range result.  Typical examples would be functions that return "
"pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:982
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:984
msgid ""
"The header file include/linux/kernel.h contains a number of macros that "
"you should use, rather than explicitly coding some variant of them "
"yourself. For example, if you need to calculate the length of an array, "
"take advantage of the macro"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:989
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:993
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:995
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:999
msgid ""
"There are also min() and max() macros that do strict type checking if you"
" need them.  Feel free to peruse that header file to see what else is "
"already defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1005
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1007
msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers.  For example, emacs interprets "
"lines marked like this:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1011
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1015
msgid "Or like this:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1017
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1025
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1027
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1031
msgid ""
"Do not include any of these in source files.  People have their own "
"personal editor configurations, and your source files should not override"
" them.  This includes markers for indentation and mode configuration.  "
"People may use their own custom mode, or may have some other magic method"
" for making indentation work correctly."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1039
msgid "Appendix I: References"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1041
msgid ""
"`The C Programming Language, Second Edition "
"<https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. "
"Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| "
"ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1046
msgid ""
"`The Practice of Programming "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W."
" Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN "
"0-201-61586-X."
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1051
msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with "
"K&R and this text - for **cpp**, **gcc**, **gcc internals** and "
"**indent**"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1054
msgid ""
"`WG14 International standardization workgroup for the programming "
"language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/1.6/dev_guide/c_style_guide.rst:1057
msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:37
msgid "Developer guidelines"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:41
msgid "How to work on a bug"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:43
msgid ""
"Any defect, even minor, if it changes the user-visible server behavior, "
"needs a bug report. Report a bug at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:46
msgid ""
"When reporting a bug, try to come up with a test case right away. Set the"
" current maintenance milestone for the bug fix, and specify the series. "
"Assign the bug to yourself. Put the status to 'In progress' Once the "
"patch is ready, put the bug the bug to 'In review' and solicit a review "
"for the fix."
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:51
msgid ""
"Once there is a positive code review, push the patch and set the status "
"to 'Closed'"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:53
msgid ""
"Patches for bugs should contain a reference to the respective Launchpad "
"bug page or at least bug id. Each patch should have a test, unless coming"
" up with one is difficult in the current framework, in which case QA "
"should be alerted."
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:57
msgid ""
"There are two things you need to do when your patch makes it into the "
"master:"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:59
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/1.6/dev_guide/developer_guidelines.rst:60
msgid "delete the remote branch."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:39
msgid "Documentation guidelines"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:41
msgid ""
"These guidelines are updated on the on-demand basis, covering only those "
"issues that cause pains to the existing writers. At this point, we do not"
" aim to come up with an exhaustive Documentation Style Guide for the "
"Tarantool project."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:47
msgid "Markup issues"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:51
msgid "Wrapping text"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:53
msgid ""
"The limit is 80 characters per line for plain text, and no limit for any "
"other constructions when wrapping affects ReST readability and/or HTML "
"output. Also, it makes no sense to wrap text into lines shorter than 80 "
"characters unless you have a good reason to do so."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:58
msgid ""
"The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, "
"and it's unlikely that readers/writers will use 80-character consoles. "
"Yet it's still a standard for many coding guidelines (including "
"Tarantool). As for writers, the benefit is that an 80-character page "
"guide allows keeping the text window rather narrow most of the time, "
"leaving more space for other applications in a wide-screen environment."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:67
msgid "Formatting code snippets"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:69
msgid ""
"For code snippets, we mainly use the ``code-block`` directive with an "
"appropriate highlighting language. The most commonly used highlighting "
"languages are:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:73
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:74
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:75
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:77
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:79
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:86
msgid ""
"In rare cases, when we need custom highlight for specific parts of a code"
" snippet and the ``code-block`` directive is not enough, we use the per-"
"line ``codenormal`` directive together and explicit output formatting "
"(defined in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:91
msgid "Examples:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:93
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:95
msgid ""
":codenormal:`box.space.`:codeitalic:`space-"
"name`:codenormal:`:create_index('index-name')`"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:97
msgid ""
"A tdb session (user input is in bold, command prompt is in blue, computer"
" output is in green):"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:109
msgid ""
"Warning: Every entry of explicit output formatting (``codenormal``, "
"``codebold``, etc) tends to cause troubles when this documentation is "
"translated to other languages. Please avoid using explicit output "
"formatting unless it is REALLY needed."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:116
msgid "Using separated links"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:118
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:120
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:126
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:128
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:132
msgid ""
"Warning: Every separated link tends to cause troubles when this "
"documentation is translated to other languages. Please avoid using "
"separated links unless it is REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:138
msgid "Creating labels for local links"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:140
msgid ""
"We avoid using links that sphinx generates automatically for most "
"objects. Instead, we add our own labels for linking to any place in this "
"documentation."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:143
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:145
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:147
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:149
msgid ""
"Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is"
" the directory name, |br| ``box_index`` is the file name (without "
"\".rst\"), and |br| ``iterator_type`` is the tag."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:155
msgid ""
"The file name is useful for knowing, when you see \"ref\", where it is "
"pointing to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:158
msgid ""
"The file name alone, without a path, is enough when the file name is "
"unique within ``doc/sphinx``. So, for ``fiber.rst`` it should be just "
"\"fiber\", not \"reference-fiber\". While for \"index.rst\" (we have a "
"handful of \"index.rst\" in different directories) please specify the "
"path before the file name, e.g. \"reference-index\"."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:165
msgid ""
"Use a dash \"-\" to delimit the path and the file name. In the "
"documentation source, we use only underscores \"_\" in paths and file "
"names, reserving dash \"-\" as the delimiter for local links."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:169
msgid ""
"The tag can be anything meaningful. The only guideline is for Tarantool "
"syntax items (such as members), where the preferred tag syntax is "
"``module_or_object_name dash member_name``. For example, ``box_space-"
"drop``."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:175
msgid "Making comments"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:177
msgid ""
"Sometimes we may need to leave comments in a ReST file. To make sphinx "
"ignore some text during processing, use the following per-line notation "
"with \".. //\" as the comment marker:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:181
msgid ".. // your comment here"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:185
msgid ""
"The starting symbols \".. //\" do not interfere with the other ReST "
"markup, and they are easy to find both visually and using grep. There are"
" no symbols to escape in grep search, just go ahead with something like "
"this:"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:189
msgid "grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:193
msgid ""
"These comments don't work properly in nested documentation, though (e.g. "
"if you leave a comment in module -> object -> method, sphinx ignores the "
"comment and all nested content that follows in the method description)."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:199
msgid "Language and style issues"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:203
msgid "US vs British spelling"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:205
msgid "We use English US spelling."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:209
msgid "Instance vs server"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:211
msgid ""
"We say \"instance\" rather than \"server\" to refer to an instance of "
"Tarantool server. This keeps the manual terminology consistent with names"
" like ``/etc/tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:215
msgid ""
"Wrong usage: \"Replication allows multiple Tarantool *servers* to work on"
" copies of the same databases.\""
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:218
msgid ""
"Correct usage: \"Replication allows multiple Tarantool *instances* to "
"work on copies of the same databases.\""
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:223
msgid "Examples and templates"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:227
msgid "Module and function"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:229
msgid ""
"Here is an example of documenting a module (``my_fiber``) and a function "
"(``my_fiber.create``)."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:236
msgid ""
"Create and start a ``my_fiber`` object. The object is created and begins "
"to run immediately."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:239
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:240
#: ../doc/1.6/reference/reference_lua/fiber.rst:94
msgid "what will be passed to function"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:242
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:247
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:263
msgid "Module, class and method"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:265
msgid ""
"Here is an example of documenting a module (``my_box.index``), a class "
"(``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:276
msgid "an object reference"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:277
msgid "a new name for the index (type = string)"
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:281
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/1.6/dev_guide/documentation_guidelines.rst:291
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.6/dev_guide/guidelines_index.rst:37
msgid "Guidelines"
msgstr ""

#: ../doc/1.6/dev_guide/index.rst:39
msgid "Contributor's Guide"
msgstr ""

#: ../doc/1.6/dev_guide/internals_index.rst:37
msgid "Internals"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:5
msgid "Tarantool's binary protocol"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:7
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:11
msgid "Notation in diagrams"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:32
msgid "MsgPack data types:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:34
msgid "**MP_INT** - Integer"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:35
msgid "**MP_MAP** - Map"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:36
msgid "**MP_ARR** - Array"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:37
msgid "**MP_STRING** - String"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:38
msgid "**MP_FIXSTR** - Fixed size string"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:39
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:40
msgid "**MP_BIN** - MsgPack binary format"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:44
msgid "Greeting packet"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:46
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:62
msgid ""
"The server instance begins the dialogue by sending a fixed-size "
"(128-byte) text greeting to the client. The greeting always contains two "
"64-byte lines of ASCII text, each line ending with a newline character "
"('\\\\n'). The first line contains the instance version and protocol "
"type. The second line contains up to 44 bytes of base64-encoded random "
"string, to use in the authentication packet, and ends with up to 23 "
"spaces."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:70
msgid "Unified packet structure"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:72
msgid ""
"Once a greeting is read, the protocol becomes pure request/response and "
"features a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:75
msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple "
"requests via the same connection"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:77
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:79
msgid ""
"For data structuring and encoding, the protocol uses msgpack data format,"
" see http://msgpack.org"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:82
msgid ""
"The Tarantool protocol mandates use of a few integer constants serving as"
" keys in maps used in the protocol. These constants are defined in "
"`src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/iproto_constants.h>`_"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:86
msgid "We list them here too:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:88
msgid ""
"-- user keys\n"
"<code>          ::= 0x00\n"
"<sync>          ::= 0x01\n"
"<schema_id>     ::= 0x05\n"
"<space_id>      ::= 0x10\n"
"<index_id>      ::= 0x11\n"
"<limit>         ::= 0x12\n"
"<offset>        ::= 0x13\n"
"<iterator>      ::= 0x14\n"
"<key>           ::= 0x20\n"
"<tuple>         ::= 0x21\n"
"<function_name> ::= 0x22\n"
"<username>      ::= 0x23\n"
"<expression>    ::= 0x27\n"
"<ops>           ::= 0x28\n"
"<data>          ::= 0x30\n"
"<error>         ::= 0x31"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:108
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>  ::= 0x01\n"
"<insert>  ::= 0x02\n"
"<replace> ::= 0x03\n"
"<update>  ::= 0x04\n"
"<delete>  ::= 0x05\n"
"<call_16> ::= 0x06\n"
"<auth>    ::= 0x07\n"
"<eval>    ::= 0x08\n"
"<upsert>  ::= 0x09\n"
"-- Admin command codes\n"
"<ping>    ::= 0x40\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:129
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:131
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:143
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:155
msgid ""
"They only differ in the allowed set of keys and values. The key defines "
"the type of value that follows. If a body has no keys, the entire msgpack"
" map for the body may be missing. Such is the case, for example, for a "
"<ping> request. ``schema_id`` may be absent in the request's header, "
"meaning that there will be no version checking, but it must be present in"
" the response. If ``schema_id`` is sent in the header, then it will be "
"checked."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:166
msgid "Authentication"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:168
msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message. Part of the greeting is base-64 "
"encoded session salt - a random string which can be used for "
"authentication. The length of decoded salt (44 bytes) exceeds the amount "
"necessary to sign the authentication message (first 20 bytes). An excess "
"is reserved for future authentication schemas."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:175
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:203
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and password, encrypted according to the specified "
"mechanism. Authentication in Tarantool is optional, if no authentication "
"is performed, session user is 'guest'. The instance responds to "
"authentication packet with a standard response with 0 tuples."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:211
msgid "Requests"
msgstr "Запросы"

#: ../doc/1.6/dev_guide/box_protocol.rst:213
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:216
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:233
msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same "
"unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:235
msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing"
" one."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:238
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:251
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:254
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:273
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:296
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:318
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:330
msgid ""
"It is an error to specify an argument of a type that differs from the "
"expected type."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:332
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:335
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:348
msgid ""
"CALL: CODE - 0x06 Call a stored function, returning an array of tuples. "
"This is applicable for Tarantool version 1.6. In future versions this "
"request will be renamed to CALL_16 and a different code will be "
"recommended for CALL."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:355
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:369
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:372
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:385
msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to "
"insert tuple. Always use primary index for key."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:388
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is "
"MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not "
"exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create"
" no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field "
"between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is "
"skipped.\n"
"      It's not possible to change with update operations a part of the "
"primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:432
msgid "Response packet structure"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:434
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:436
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:450
msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of "
"tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary "
"MsgPack values."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:453
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:468
msgid ""
"An error message is present in the response only if there is an error; "
":code:`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:471
msgid ""
"Convenience macros which define hexadecimal constants for return codes "
"can be found in `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/errcode.h>`_"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:477
msgid "Replication packet structure"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:479
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:489
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:496
msgid ""
"JOIN:\n"
"\n"
" In the beginning you must send initial JOIN\n"
"                HEADER                      BODY\n"
" +================+================++===================+\n"
" |                |                ||   SERVER_UUID     |\n"
" |   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
" | MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
" |                |                ||                   |\n"
" +================+================++===================+\n"
"                MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x42    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:556
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:558
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:560
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:568
msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:575
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.6/dev_guide/box_protocol.rst:592
msgid "See the example in the following section."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:9
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:11
msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(insert, update, delete, replace, upsert) into a write-ahead log (WAL) "
"file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file "
"is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
"rows_per_wal>` records. Each data change request gets assigned a "
"continuously growing 64-bit log sequence number. The name of the WAL file"
" is based on the log sequence number of the first record in the file, "
"plus an extension ``.xlog``."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:19
msgid ""
"Apart from a log sequence number and the data change request (formatted "
"as in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`),"
" each WAL record contains a header, some metadata, and then the data "
"formatted according to `msgpack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is"
" what the WAL file looks like after the first INSERT request "
"(\"s:insert({1})\") for the sandbox database created in our "
":ref:`\"Getting started\" exercises <getting_started>`. On the left are "
"the hexadecimal bytes that you would see with:"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:28
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:32
msgid "and on the right are comments."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:34
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:63
msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this "
"happens, using the REPLACE request as an example:"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:67
msgid ""
"The server instance attempts to locate the original tuple by primary key."
" If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:70
msgid ""
"The new tuple is validated. If for example it does not contain an indexed"
" field, or it has an indexed field whose type does not match the type "
"according to the index definition, the change is aborted."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:74
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:76
msgid ""
"A message is sent to WAL writer running in a separate thread, requesting "
"that the change be recorded in the WAL. The instance switches to work on "
"the next request until the write is acknowledged."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:80
msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction "
"processor rolls back all changes to the database which occurred after the"
" first failed change, from latest to oldest, up to the first failed "
"change. All rolled back requests are aborted with :errcode:`ER_WAL_IO "
"<ER_WAL_IO>` error. No new change is applied while rollback is in "
"progress. When the rollback procedure is finished, the server restarts "
"the processing pipeline."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:88
msgid ""
"One advantage of the described algorithm is that complete request "
"pipelining is achieved, even for requests on the same value of the "
"primary key. As a result, database performance doesn't degrade even if "
"all requests refer to the same key in the same space."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:93
msgid ""
"The transaction processor thread communicates with the WAL writer thread "
"using asynchronous (yet reliable) messaging; the transaction processor "
"thread, not being blocked on WAL tasks, continues to handle requests "
"quickly even at high volumes of disk I/O. A response to a request is sent"
" as soon as it is ready, even if there were earlier incomplete requests "
"on the same connection. In particular, SELECT performance, even for "
"SELECTs running on a connection packed with UPDATEs and DELETEs, remains "
"unaffected by disk load."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:101
msgid ""
"The WAL writer employs a number of durability modes, as defined in "
"configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible "
"to turn the write-ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the "
"write-ahead log it's still possible to take a persistent copy of the "
"entire data set with the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:108
msgid ""
"An .xlog file always contains changes based on the primary key. Even if "
"the client requested an update or delete using a secondary key, the "
"record in the .xlog file will contain the primary key."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:114
msgid "The snapshot file format"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:116
msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a"
" WAL .xlog file. However, the snapshot header differs: it contains the "
"instance's global unique identifier and the snapshot file's position in "
"history, relative to earlier snapshot files. Also, the content differs: "
"an .xlog file may contain records for any data-change requests (inserts, "
"updates, upserts, and deletes), a .snap file may only contain records of "
"inserts to memtx spaces."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:123
msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore "
"the records of system spaces -- such as ``_schema``, ``_space``, "
"``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start"
" of the .snap file, before the records of any spaces that were created by"
" users."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:128
msgid ""
"Secondarily, the .snap file's records are ordered by primary key within "
"space id."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:134
msgid "The recovery process"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:136
msgid ""
"The recovery process begins when box.cfg{} happens for the first time "
"after the Tarantool server instance starts."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:139
msgid ""
"The recovery process must recover the databases as of the moment when the"
" instance was last shut down. For this it may use the latest snapshot "
"file and any WAL files that were written after the snapshot. The memtx "
"data must be reconstructed entirely from the snapshot and the WAL files."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:150
msgid "Step 1"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:146
msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. "
"Parameters which affect recovery may include :ref:`work_dir <cfg_basic-"
"work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`snap_dir "
"<cfg_basic-snap_dir>`, and :ref:`panic_on_snap_error "
"<cfg_binary_logging_snapshots-panic_on_snap_error>`. and "
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error>`."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:172
msgid "Step 2"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:153
msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:156
msgid ""
"There are actually two variations of the reconstruction procedure for "
"memtx databases, depending on whether the recovery process is "
"\"default\"."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:159
msgid ""
"If the recovery process is default (``panic_on_snap_error`` is ``true`` "
"and ``panic_on_wal_error`` is ``true``), memtx can read data in the "
"snapshot with all indexes disabled. First, all tuples are read into "
"memory. Then, primary keys are built in bulk, taking advantage of the "
"fact that the data is already sorted by primary key within each space."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:166
msgid ""
"If the recovery process is non-default (``panic_on_snap_error`` is "
"``false`` or ``panic_on_wal_error`` is ``false``), Tarantool performs "
"additional checking. Indexes are enabled at the start, and tuples are "
"added one by one. This means that any unique-key constraint violations "
"will be caught, and any duplicates will be skipped. Normally there will "
"be no constraint violations or duplicates, so these checks are only made "
"if an error has occurred."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:179
msgid "Step 3"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:175
msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot "
"file. Read its log entries until the log-entry LSN is greater than the "
"LSN of the snapshot. This is the recovery process's \"start position\"; "
"it matches the current state of the engine."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:183
msgid "Step 4"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:182
msgid ""
"Redo the log entries, from the start position to the end of the WAL. The "
"engine skips a redo instruction if it is older than the engine's "
"checkpoint."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:186
msgid "Step 5"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:186
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:192
msgid "Server startup with replication"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:194
msgid ""
"In addition to the recovery process described above, the server must take"
" additional steps and precautions if :ref:`replication <index-"
"box_replication>` is enabled."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:198
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` "
"request. One of the ``box.cfg`` parameters may be "
":ref:`replication_source <cfg_replication-replication_source>` that "
"specifies replication source(-s). We will refer to this replica, which is"
" starting up due to ``box.cfg``, as the \"local\" replica to distinguish "
"it from the other replicas in a replica set, which we will refer to as "
"\"distant\" replicas."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:205
msgid ""
"*If there is no snapshot .snap file and the ``replication_source`` "
"parameter is empty*: |br| then the local replica assumes it is an "
"unreplicated \"standalone\" instance, or is the first replica of a new "
"replica set. It will generate new UUIDs for itself and for the replica "
"set. The replica UUID is stored in the ``_cluster`` space; the replica "
"set UUID is stored in the ``_schema`` space. Since a snapshot contains "
"all the data in all the spaces, that means the local replica's snapshot "
"will contain the replica UUID and the replica set UUID. Therefore, when "
"the local replica restarts on later occasions, it will be able to recover"
" these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:215
msgid ""
"*If there is no snapshot .snap file and the ``replication_source`` "
"parameter is not empty and the ``_cluster`` space contains no other "
"replica UUIDs*: |br| then the local replica assumes it is not a "
"standalone instance, but is not yet part of a replica set. It must now "
"join the replica set. It will send its replica UUID to the first distant "
"replica which is listed in ``replication`` and which will act as a "
"master. This is called the \"join request\". When a distant replica "
"receives a join request, it will send back:"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:223
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:224
msgid ""
"the contents of the distant replica's .snap file. |br| When the local "
"replica receives this information, it puts the replica set UUID in its "
"``_schema`` space, puts the distant replica's UUID and connection "
"information in its ``_cluster`` space, and makes a snapshot containing "
"all the data sent by the distant replica. Then, if the local replica has "
"data in its WAL .xlog files, it sends that data to the distant replica. "
"The distant replica will receive this and update its own copy of the "
"data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:233
msgid ""
"*If there is no snapshot .snap file and the ``replication_source`` "
"parameter is not empty and the ``_cluster`` space contains other replica "
"UUIDs*: |br| then the local replica assumes it is not a standalone "
"instance, and is already part of a replica set. It will send its replica "
"UUID and replica set UUID to all the distant replicas which are listed in"
" ``replication``. This is called the \"on-connect handshake\". When a "
"distant replica receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:240
msgid ""
"the distant replica compares its own copy of the replica set UUID to the "
"one in the on-connect handshake. If there is no match, then the handshake"
" fails and the local replica will display an error."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:243
msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| "
"Otherwise the handshake is successful. The distant replica will read any "
"new information from its own .snap and .xlog files, and send the new "
"requests to the local replica."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:249
msgid ""
"In the end ... the local replica knows what replica set it belongs to, "
"the distant replica knows that the local replica is a member of the "
"replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:255
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local replica goes through the recovery process described in "
"the previous section, using its own .snap and .xlog files. Then it sends "
"a \"subscribe\" request to all the other replicas of the replica set. The"
" subscribe request contains the server vector clock. The vector clock has"
" a collection of pairs 'server id, lsn' for every replica in the "
"``_cluster`` system space. Each distant replica, upon receiving a "
"subscribe request, will read its .xlog files' requests and send them to "
"the local replica if (lsn of .xlog file request) is greater than (lsn of "
"the vector clock in the subscribe request). After all the other replicas "
"of the replica set have responded to the local replica's subscribe "
"request, the replica startup is complete."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:267
msgid "The following temporary limitations will apply for version 1.6:"
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:269
msgid ""
"The URIs in the ``replication_source`` parameter should all be in the "
"same order on all replicas. This is not mandatory but is an aid to "
"consistency."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:271
msgid ""
"The replicas of a replica set should be started up at slightly different "
"times. This is not mandatory but prevents a situation where each replica "
"is waiting for the other replica to be ready."
msgstr ""

#: ../doc/1.6/dev_guide/internals.rst:274
msgid ""
"The maximum number of entries in the ``_cluster`` space is 32. Tuples for"
" out-of-date replicas are not automatically re-used, so if this "
"32-replica limit is reached, users may have to reorganize the "
"``_cluster`` space manually."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:37
msgid "Python Style Guide"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:41
msgid "Introduction"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:43
msgid ""
"This document gives coding conventions for the Python code comprising the"
" standard library in the main Python distribution.  Please see the "
"companion informational PEP describing style guidelines for the C code in"
" the C implementation of Python [1]_."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:48
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from "
"Guido's original Python Style Guide essay, with some additions from "
"Barry's style guide [2]_."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:55
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:57
msgid ""
"One of Guido's key insights is that code is read much more often than it "
"is written.  The guidelines provided here are intended to improve the "
"readability of code and make it consistent across the wide spectrum of "
"Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:62
msgid ""
"A style guide is about consistency.  Consistency with this style guide is"
" important.  Consistency within a project is more important. Consistency "
"within one module or function is the most important."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:66
msgid ""
"But most importantly: know when to be inconsistent -- sometimes the style"
" guide just doesn't apply.  When in doubt, use your best judgment.  Look "
"at other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:71
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:73
msgid ""
"When applying the rule would make the code less readable, even for "
"someone who is used to reading code that follows the rules."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:76
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for "
"historic reasons) -- although this is also an opportunity to clean up "
"someone else's mess (in true XP style)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:83
msgid "Code lay-out"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:87
msgid "Indentation"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:89
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:91
msgid ""
"For really old code that you don't want to mess up, you can continue to "
"use 8-space tabs."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:94
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, "
"or using a hanging indent.  When using a hanging indent the following "
"considerations should be applied; there should be no arguments on the "
"first line and further indentation should be used to clearly distinguish "
"itself as a continuation line."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:101
#: ../doc/1.6/dev_guide/python_style_guide.rst:358
#: ../doc/1.6/dev_guide/python_style_guide.rst:387
#: ../doc/1.6/dev_guide/python_style_guide.rst:406
#: ../doc/1.6/dev_guide/python_style_guide.rst:419
msgid "Yes::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:103
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:113
#: ../doc/1.6/dev_guide/python_style_guide.rst:364
#: ../doc/1.6/dev_guide/python_style_guide.rst:395
#: ../doc/1.6/dev_guide/python_style_guide.rst:411
msgid "No::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:115
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:125
msgid "Optional::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:127
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:132
msgid ""
"The closing brace/bracket/parenthesis on multi-line constructs may either"
" line up under the first non-whitespace character of the last line of "
"list, as in::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:136
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:145
msgid ""
"or it may be lined up under the first character of the line that starts "
"the multi-line construct, as in::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:148
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:160
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:162
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:164
msgid ""
"The most popular way of indenting Python is with spaces only.  The "
"second-most popular way is with tabs only.  Code indented with a mixture "
"of tabs and spaces should be converted to using spaces exclusively.  When"
" invoking the Python command line interpreter with the ``-t`` option, it "
"issues warnings about code that illegally mixes tabs and spaces.  When "
"using ``-tt`` these warnings become errors. These options are highly "
"recommended!"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:172
msgid ""
"For new projects, spaces-only are strongly recommended over tabs. Most "
"editors have features that make this easy to do."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:177
msgid "Maximum Line Length"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:179
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:181
msgid ""
"There are still many devices around that are limited to 80 character "
"lines; plus, limiting windows to 80 characters makes it possible to have "
"several windows side-by-side.  The default wrapping on such devices "
"disrupts the visual structure of the code, making it more difficult to "
"understand.  Therefore, please limit all lines to a maximum of 79 "
"characters.  For flowing long blocks of text (docstrings or comments), "
"limiting the length to 72 characters is recommended."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:189
msgid ""
"The preferred way of wrapping long lines is by using Python's implied "
"line continuation inside parentheses, brackets and braces.  Long lines "
"can be broken over multiple lines by wrapping expressions in parentheses."
" These should be used in preference to using a backslash for line "
"continuation."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:195
msgid ""
"Backslashes may still be appropriate at times.  For example, long, "
"multiple ``with``-statements cannot use implicit continuation, so "
"backslashes are acceptable::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:199
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:203
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:205
msgid ""
"Make sure to indent the continued line appropriately.  The preferred "
"place to break around a binary operator is *after* the operator, not "
"before it.  Some examples::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:209
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:226
msgid "Blank Lines"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:228
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:231
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:234
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:238
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:240
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace;"
" Many tools treat these characters as page separators, so you may use "
"them to separate pages of related sections of your file. Note, some "
"editors and web-based code viewers may not recognize control-L as a form "
"feed and will show another glyph in its place."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:248
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:250
msgid ""
"Code in the core Python distribution should always use the ASCII or "
"Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 "
"is preferred over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:254
msgid ""
"Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) "
"should only be used when a comment or docstring needs to mention an "
"author name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or "
"``\\U`` escapes is the preferred way to include non-ASCII data in string "
"literals."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:260
msgid ""
"For Python 3.0 and beyond, the following policy is prescribed for the "
"standard library (see PEP 3131): All identifiers in the Python standard "
"library MUST use ASCII-only identifiers, and SHOULD use English words "
"wherever feasible (in many cases, abbreviations and technical terms are "
"used which aren't English). In addition, string literals and comments "
"must also be in ASCII. The only exceptions are (a) test cases testing the"
" non-ASCII features, and (b) names of authors. Authors whose names are "
"not based on the latin alphabet MUST provide a latin transliteration of "
"their names."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:271
msgid ""
"Open source projects with a global audience are encouraged to adopt a "
"similar policy."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:277
msgid "Imports"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:279
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:286
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:290
msgid ""
"Imports are always put at the top of the file, just after any module "
"comments and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:293
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:295
msgid "standard library imports"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:296
msgid "related third party imports"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:297
msgid "local application/library specific imports"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:299
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:301
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:303
msgid ""
"Relative imports for intra-package imports are highly discouraged. Always"
" use the absolute package path for all imports.  Even now that PEP 328 is"
" fully implemented in Python 2.5, its style of explicit relative imports "
"is actively discouraged; absolute imports are more portable and usually "
"more readable."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:309
msgid ""
"When importing a class from a class-containing module, it's usually okay "
"to spell this::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:315
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:320
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:325
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:329
msgid "Pet Peeves"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:331
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:333
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:338
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:343
msgid ""
"Immediately before the open parenthesis that starts the argument list of "
"a function call::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:349
msgid ""
"Immediately before the open parenthesis that starts an indexing or "
"slicing::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:355
msgid ""
"More than one space around an assignment (or other) operator to align it "
"with another."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:373
msgid "Other Recommendations"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:375
msgid ""
"Always surround these binary operators with a single space on either "
"side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), "
"comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, "
"``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, "
"``not``)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:381
msgid ""
"If operators with different priorities are used, consider adding "
"whitespace around the operators with the lowest priority(ies). Use your "
"own judgement; however, never use more than one space, and always have "
"the same amount of whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:403
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword "
"argument or a default parameter value."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:416
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:427
#: ../doc/1.6/dev_guide/python_style_guide.rst:436
msgid "Rather not::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:432
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the"
" same line, never do this for multi-clause statements.  Also avoid "
"folding such long lines!"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:442
msgid "Definitely not::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:457
msgid "Comments"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:459
msgid ""
"Comments that contradict the code are worse than no comments.  Always "
"make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:463
msgid ""
"Comments should be complete sentences.  If a comment is a phrase or "
"sentence, its first word should be capitalized, unless it is an "
"identifier that begins with a lower case letter (never alter the case of "
"identifiers!)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:468
msgid ""
"If a comment is short, the period at the end can be omitted.  Block "
"comments generally consist of one or more paragraphs built out of "
"complete sentences, and each sentence should end in a period."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:472
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:474
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:476
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your "
"comments in English, unless you are 120% sure that the code will never be"
" read by people who don't speak your language."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:482
msgid "Block Comments"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:484
msgid ""
"Block comments generally apply to some (or all) code that follows them, "
"and are indented to the same level as that code.  Each line of a block "
"comment starts with a ``#`` and a single space (unless it is indented "
"text inside the comment)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:489
msgid ""
"Paragraphs inside a block comment are separated by a line containing a "
"single ``#``."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:494
msgid "Inline Comments"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:496
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:498
msgid ""
"An inline comment is a comment on the same line as a statement. Inline "
"comments should be separated by at least two spaces from the statement.  "
"They should start with a # and a single space."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:502
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the"
" obvious.  Don't do this::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:505
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:507
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:509
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:513
msgid "Documentation Strings"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:515
msgid ""
"Conventions for writing good documentation strings (a.k.a. "
"\"docstrings\") are immortalized in PEP 257."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:518
msgid ""
"Write docstrings for all public modules, functions, classes, and methods."
"  Docstrings are not necessary for non-public methods, but you should "
"have a comment that describes what the method does.  This comment should "
"appear after the ``def`` line."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:523
msgid ""
"PEP 257 describes good docstring conventions.  Note that most "
"importantly, the ``\"\"\"`` that ends a multiline docstring should be on "
"a line by itself, and preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:533
msgid ""
"For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the"
" same line."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:539
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:541
msgid ""
"If you have to have Subversion, CVS, or RCS crud in your source file, do "
"it as follows. ::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:544
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:547
msgid ""
"These lines should be included after the module's docstring, before any "
"other code, separated by a blank line above and below."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:553
msgid "Naming Conventions"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:555
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll "
"never get this completely consistent -- nevertheless, here are the "
"currently recommended naming standards.  New modules and packages "
"(including third party frameworks) should be written to these standards, "
"but where an existing library has a different style, internal consistency"
" is preferred."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:564
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:566
msgid ""
"There are a lot of different naming styles.  It helps to be able to "
"recognize what naming style is being used, independently from what they "
"are used for."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:570
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:572
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:573
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:574
msgid "``lowercase``"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:575
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:576
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:577
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:578
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of "
"the bumpy look of its letters [3]_).  This is also sometimes known as "
"StudlyCaps."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:582
msgid ""
"Note: When using abbreviations in CapWords, capitalize all the letters of"
" the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:585
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase "
"character!)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:587
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:589
msgid ""
"There's also the style of using a short unique prefix to group related "
"names together.  This is not used much in Python, but it is mentioned for"
" completeness.  For example, the ``os.stat()`` function returns a tuple "
"whose items traditionally have names like ``st_mode``, ``st_size``, "
"``st_mtime`` and so on.  (This is done to emphasize the correspondence "
"with the fields of the POSIX system call struct, which helps programmers "
"familiar with that.)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:597
msgid ""
"The X11 library uses a leading X for all its public functions.  In "
"Python, this style is generally deemed unnecessary because attribute and "
"method names are prefixed with an object, and function names are prefixed"
" with a module name."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:602
msgid ""
"In addition, the following special forms using leading or trailing "
"underscores are recognized (these can generally be combined with any case"
" convention):"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:606
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. "
"``from M import *`` does not import objects whose name starts with an "
"underscore."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:610
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts "
"with Python keyword, e.g. ::"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:615
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes "
"name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; "
"see below)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:619
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or "
"attributes that live in user-controlled namespaces. E.g. ``__init__``, "
"``__import__`` or ``__file__``.  Never invent such names; only use them "
"as documented."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:626
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:630
msgid "Names to Avoid"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:632
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter"
" oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:636
msgid ""
"In some fonts, these characters are indistinguishable from the numerals "
"one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:641
msgid "Package and Module Names"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:643
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used "
"in the module name if it improves readability.  Python packages should "
"also have short, all-lowercase names, although the use of underscores is "
"discouraged."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:648
msgid ""
"Since module names are mapped to file names, and some file systems are "
"case insensitive and truncate long names, it is important that module "
"names be chosen to be fairly short -- this won't be a problem on Unix, "
"but it may be a problem when the code is transported to older Mac or "
"Windows versions, or DOS."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:654
msgid ""
"When an extension module written in C or C++ has an accompanying Python "
"module that provides a higher level (e.g. more object oriented) "
"interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:661
msgid "Class Names"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:663
msgid ""
"Almost without exception, class names use the CapWords convention. "
"Classes for internal use have a leading underscore in addition."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:668
msgid "Exception Names"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:670
msgid ""
"Because exceptions should be classes, the class naming convention applies"
" here.  However, you should use the suffix \"Error\" on your exception "
"names (if the exception actually is an error)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:676
msgid "Global Variable Names"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:678
msgid ""
"(Let's hope that these variables are meant for use inside one module "
"only.)  The conventions are about the same as those for functions."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:681
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older "
"convention of prefixing such globals with an underscore (which you might "
"want to do to indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:689
msgid "Function Names"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:691
msgid ""
"Function names should be lowercase, with words separated by underscores "
"as necessary to improve readability."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:694
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing"
" style (e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:700
msgid "Function and method arguments"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:702
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:704
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:706
msgid ""
"If a function argument's name clashes with a reserved keyword, it is "
"generally better to append a single trailing underscore rather than use "
"an abbreviation or spelling corruption.  Thus ``class_`` is better than "
"``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:714
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:716
msgid ""
"Use the function naming rules: lowercase with words separated by "
"underscores as necessary to improve readability."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:719
msgid ""
"Use one leading underscore only for non-public methods and instance "
"variables."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:722
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to "
"invoke Python's name mangling rules."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:725
msgid ""
"Python mangles these names with the class name: if class Foo has an "
"attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An "
"insistent user could still gain access by calling ``Foo._Foo__a``.) "
"Generally, double leading underscores should be used only to avoid name "
"conflicts with attributes in classes designed to be subclassed."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:731
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:735
msgid "Constants"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:737
msgid ""
"Constants are usually defined on a module level and written in all "
"capital letters with underscores separating words.  Examples include "
"``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:743
msgid "Designing for inheritance"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:745
msgid ""
"Always decide whether a class's methods and instance variables "
"(collectively: \"attributes\") should be public or non-public.  If in "
"doubt, choose non-public; it's easier to make it public later than to "
"make a public attribute non-public."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:750
msgid ""
"Public attributes are those that you expect unrelated clients of your "
"class to use, with your commitment to avoid backward incompatible "
"changes.  Non-public attributes are those that are not intended to be "
"used by third parties; you make no guarantees that non-public attributes "
"won't change or even be removed."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:756
msgid ""
"We don't use the term \"private\" here, since no attribute is really "
"private in Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:759
msgid ""
"Another category of attributes are those that are part of the \"subclass "
"API\" (often called \"protected\" in other languages).  Some classes are "
"designed to be inherited from, either to extend or modify aspects of the "
"class's behavior.  When designing such a class, take care to make "
"explicit decisions about which attributes are public, which are part of "
"the subclass API, and which are truly only to be used by your base class."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:767
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:769
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:771
msgid ""
"If your public attribute name collides with a reserved keyword, append a "
"single trailing underscore to your attribute name.  This is preferable to"
" an abbreviation or corrupted spelling.  (However, not withstanding this "
"rule, 'cls' is the preferred spelling for any variable or argument which "
"is known to be a class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:779
#: ../doc/1.6/dev_guide/python_style_guide.rst:790
#: ../doc/1.6/dev_guide/python_style_guide.rst:812
msgid "Note 1:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:779
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:781
msgid ""
"For simple public data attributes, it is best to expose just the "
"attribute name, without complicated accessor/mutator methods.  Keep in "
"mind that Python provides an easy path to future enhancement, should you "
"find that a simple data attribute needs to grow functional behavior.  In "
"that case, use properties to hide functional implementation behind simple"
" data attribute access syntax."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:790
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:794
#: ../doc/1.6/dev_guide/python_style_guide.rst:817
msgid "Note 2:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:793
msgid ""
"Try to keep the functional behavior side-effect free, although side-"
"effects such as caching are generally fine."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:799
#: ../doc/1.6/dev_guide/python_style_guide.rst:822
msgid "Note 3:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:797
msgid ""
"Avoid using properties for computationally expensive operations; the "
"attribute notation makes the caller believe that access is (relatively) "
"cheap."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:801
msgid ""
"If your class is intended to be subclassed, and you have attributes that "
"you do not want subclasses to use, consider naming them with double "
"leading underscores and no trailing underscores.  This invokes Python's "
"name mangling algorithm, where the name of the class is mangled into the "
"attribute name.  This helps avoid attribute name collisions should "
"subclasses inadvertently contain attributes with the same name."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:810
msgid ""
"Note that only the simple class name is used in the mangled name, so if a"
" subclass chooses both the same class name and attribute name, you can "
"still get name collisions."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:815
msgid ""
"Name mangling can make certain uses, such as debugging and "
"``__getattr__()``, less convenient.  However the name mangling algorithm "
"is well documented and easy to perform manually."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:820
msgid ""
"Not everyone likes name mangling.  Try to balance the need to avoid "
"accidental name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:826
msgid "References"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:828
msgid ""
"`PEP 7, Style Guide for C Code, van Rossum "
"<https://www.python.org/dev/peps/pep-0007/>`_"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:829
msgid ""
"`Barry's GNU Mailman style guide "
"<http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:830
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:834
msgid "Copyright"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:836
msgid "Author:"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:838
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/1.6/dev_guide/python_style_guide.rst:839
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:37
#: ../doc/1.6/reference/reference_lua/box.rst:39
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/1.6/dev_guide/reference_capi/box.rst:41
msgid "Opaque structure passed to the stored C procedure"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:45
msgid "Return a tuple from stored C procedure."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:47
msgid "Returned tuple is automatically reference counted by Tarantool."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:49
msgid "an opaque structure passed to the stored C procedure by Tarantool"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:51
msgid "a tuple to return"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst
#: ../doc/1.6/dev_guide/reference_capi/coio.rst
#: ../doc/1.6/dev_guide/reference_capi/error.rst
#: ../doc/1.6/dev_guide/reference_capi/fiber.rst
#: ../doc/1.6/dev_guide/reference_capi/latch.rst
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst
#: ../doc/1.6/dev_guide/reference_capi/txn.rst
#: ../doc/1.6/dev_guide/reference_capi/utils.rst
msgid "Returns"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:53
msgid ""
"-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-"
"error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:55
#: ../doc/1.6/dev_guide/reference_capi/box.rst:103
#: ../doc/1.6/dev_guide/reference_capi/box.rst:118
#: ../doc/1.6/dev_guide/reference_capi/box.rst:134
#: ../doc/1.6/dev_guide/reference_capi/box.rst:156
#: ../doc/1.6/dev_guide/reference_capi/box.rst:178
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:91
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:104
msgid "0 otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:61
msgid "Find space id by name."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:63
msgid "This function performs SELECT request to _vspace system space."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:65
msgid "space name"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:66
#: ../doc/1.6/dev_guide/reference_capi/box.rst:80
msgid "length of ``name``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:68
#: ../doc/1.6/dev_guide/reference_capi/box.rst:82
msgid ""
":c:macro:`BOX_ID_NIL` on error or if not found (check "
":ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:70
#: ../doc/1.6/dev_guide/reference_capi/box.rst:84
msgid "space_id otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:72
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:76
msgid "Find index id by name."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:78
#: ../doc/1.6/dev_guide/reference_capi/box.rst:96
#: ../doc/1.6/dev_guide/reference_capi/box.rst:111
#: ../doc/1.6/dev_guide/reference_capi/box.rst:126
#: ../doc/1.6/dev_guide/reference_capi/box.rst:142
#: ../doc/1.6/dev_guide/reference_capi/box.rst:164
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:119
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:158
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:168
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:178
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:195
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:211
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:227
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:243
msgid "space identifier"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:79
msgid "index name"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:86
msgid "This function performs SELECT request to _vindex system space."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:88
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:94
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:97
#: ../doc/1.6/dev_guide/reference_capi/box.rst:112
#: ../doc/1.6/dev_guide/reference_capi/box.rst:166
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:98
#: ../doc/1.6/dev_guide/reference_capi/box.rst:113
#: ../doc/1.6/dev_guide/reference_capi/box.rst:167
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:99
#: ../doc/1.6/dev_guide/reference_capi/box.rst:114
msgid "output argument. Resulted tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:102
#: ../doc/1.6/dev_guide/reference_capi/box.rst:117
#: ../doc/1.6/dev_guide/reference_capi/box.rst:133
#: ../doc/1.6/dev_guide/reference_capi/box.rst:155
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:105
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:109
msgid "Execute an REPLACE request."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:120
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:124
msgid "Execute an DELETE request."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:127
#: ../doc/1.6/dev_guide/reference_capi/box.rst:143
#: ../doc/1.6/dev_guide/reference_capi/box.rst:165
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:120
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:159
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:169
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:179
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:196
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:212
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:228
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:244
msgid "index identifier"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:128
#: ../doc/1.6/dev_guide/reference_capi/box.rst:144
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:129
#: ../doc/1.6/dev_guide/reference_capi/box.rst:145
msgid "end of a ``key``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:130
#: ../doc/1.6/dev_guide/reference_capi/box.rst:152
#: ../doc/1.6/dev_guide/reference_capi/box.rst:174
msgid "output argument. Result an old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:136
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:140
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:146
#: ../doc/1.6/dev_guide/reference_capi/box.rst:168
msgid ""
"encoded operations in MsgPack Arrat format, e.g. ``[[ '=', field_id,  "
"value ], ['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:148
#: ../doc/1.6/dev_guide/reference_capi/box.rst:170
msgid "end of a ``ops``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:149
#: ../doc/1.6/dev_guide/reference_capi/box.rst:171
msgid ""
"0 if field_ids in update operation are zero-based indexed (like C) or 1 "
"if for one-based indexed field ids (like Lua)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:158
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:162
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:177
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box.rst:180
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:37
msgid "Module `index`"
msgstr "Модуль `index`"

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:41
msgid "A space iterator"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:47
msgid ""
"Controls how to iterate over tuples in an index. Different index types "
"support different iterator types. For example, one can start iteration "
"from a particular value (request key) and then retrieve all tuples where "
"keys are greater or equal (= GE) to this key."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:52
msgid ""
"If iterator type is not supported by the selected index type, iterator "
"constructor must fail with ER_UNSUPPORTED. To be selectable for primary "
"key, an index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:56
msgid ""
"NULL value of request key corresponds to the first or last key in the "
"index, depending on iteration direction. (first key for GE and GT types, "
"and last key for LE and LT). Therefore, to iterate over all tuples in an "
"index, one can use ITER_GE or ITER_LE iteration types with start key "
"equal to NULL. For ITER_EQ, the key must not be NULL."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:64
msgid "key == x ASC order"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:68
msgid "key == x DESC order"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:72
msgid "all tuples"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:76
msgid "key < x"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:80
msgid "key <= x"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:84
msgid "key >= x"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:88
msgid "key > x"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:92
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:96
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:100
msgid "all bits are not set"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:104
msgid "key overlaps x"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:108
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:114
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:116
msgid ""
"The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-"
"box_index-box_iterator_free>`."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:121
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:245
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:122
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:197
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:213
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:229
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:246
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:123
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:198
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:214
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:230
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:247
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:125
msgid "NULL on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:126
msgid "iterator otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:128
msgid ""
"See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, "
":ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:135
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:137
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:151
msgid ""
"an iterator returned by :ref:box_index_iterator`c_api-box_index-"
"box_index_iterator>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:139
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:142
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:161
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:171
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:202
msgid "-1 on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:143
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:149
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:156
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:162
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:172
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:166
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:176
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:180
msgid "random seed"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:181
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:199
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:215
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:231
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:184
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:188
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:190
msgid ""
"Please note that this function works much more faster than "
":ref:`index_object.select<box_index-select>` or :ref:`box_index_iterator"
"<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-"
"box_index-box_iterator_next>`."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:203
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:219
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:235
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:250
#: ../doc/1.6/dev_guide/reference_capi/txn.rst:50
#: ../doc/1.6/dev_guide/reference_capi/txn.rst:57
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:99
msgid "0 on success"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:205
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:209
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:218
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:234
#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:249
msgid "-1 on error (check :ref:box_error_last()`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:221
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:225
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:237
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:241
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/box_index.rst:252
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/clock.rst:37
#: ../doc/1.6/reference/reference_lua/clock.rst:39
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:37
msgid "Module `coio`"
msgstr "Модуль `coio`"

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:43
msgid "READ event"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:47
msgid "WRITE event"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:51
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:53
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:54
msgid ""
"requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:56
msgid "timeout in seconds."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:58
msgid "0 - timeout"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:59
msgid ""
">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:63
msgid ""
"Create new eio task with specified function and arguments. Yield and wait"
" until the task is complete or a timeout occurs."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:66
msgid ""
"This function doesn't throw exceptions to avoid double error checking: in"
" most cases it's also necessary to check the return value of the called "
"function and perform necessary actions. If func sets errno, the errno is "
"preserved across the call."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:71
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:72
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:76
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/coio.rst:92
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:37
msgid "Module `error`"
msgstr "Модуль `error`"

#: ../doc/1.6/dev_guide/reference_capi/error.rst:163
msgid "Error - contains information about error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:167
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:169
#: ../doc/1.6/dev_guide/reference_capi/error.rst:176
#: ../doc/1.6/dev_guide/reference_capi/error.rst:183
msgid "error"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:170
#: ../doc/1.6/dev_guide/reference_capi/error.rst:184
msgid "not-null string"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:174
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:177
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:181
msgid "Return the error message"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:190
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:192
msgid ""
"The Tarantool error handling works most like libc's errno. All API calls "
"return -1 or NULL in the event of error. An internal pointer to "
"box_error_t type is set by API functions to indicate what went wrong. "
"This value is only significant if API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:197
msgid ""
"Successful function can also touch the last error in some cases. You "
"don't have to clear the last error before calling API functions. The "
"returned object is valid only until next call to **any** API function."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:201
msgid ""
"You must set the last error using box_error_set() in your stored C "
"procedures if you want to return a custom error message. You can re-throw"
" the last API error to IPROTO client by keeping the current value and "
"returning -1 to Tarantool from your stored procedure."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:206
msgid "last error"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:210
msgid "Clear the last error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:214
msgid "Set the last error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:218
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:220
#: ../doc/1.6/dev_guide/reference_capi/say.rst:65
#: ../doc/1.6/dev_guide/reference_capi/say.rst:79
msgid "format arguments"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:222
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/error.rst:226
msgid "A backward-compatible API define."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:37
#: ../doc/1.6/reference/reference_lua/fiber.rst:39
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:41
msgid "Fiber - contains information about fiber"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:47
msgid "Create a new fiber."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:49
msgid ""
"Takes a fiber from fiber cache, if it's not empty. Can fail only if there"
" is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:52
msgid ""
"The created fiber automatically returns itself to the fiber cache when "
"its \"main\" function completes."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:55
msgid "string with fiber name"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:56
msgid "func for run inside fiber"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:58
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:62
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:64
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:70
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:72
msgid "fiber to start"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:73
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:79
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:81
#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:117
msgid "fiber to be woken up"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:85
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:87
msgid ""
"If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be "
"woken up (maybe prematurely). Then current fiber yields until the target "
"fiber is dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-"
"fiber_wakeup>`)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:91
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:95
msgid ""
"Make it possible or not possible to wakeup the current fiber immediately "
"when it's cancelled."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:98
#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:109
msgid "fiber"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:99
#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:110
msgid "status to set"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:101
msgid "previous state"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:107
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:114
msgid ""
"Wait until the fiber is dead and then move its execution status to the "
"caller. The fiber must not be detached."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:119
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:121
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:125
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:127
msgid "time to sleep"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:129
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:131
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:137
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:141
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:145
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:149
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/fiber.rst:155
msgid "Return slab_cache suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/index.rst:39
msgid "C API reference"
msgstr "Справочник по C API"

#: ../doc/1.6/dev_guide/reference_capi/index.rst:41
#, fuzzy
msgid "List of C API headers"
msgstr "остаток заголовка"

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:37
msgid "Module `latch`"
msgstr "Модуль `latch`"

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:41
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:45
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:47
msgid "allocated latch object"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst
#, fuzzy
msgid "Return type"
msgstr "Общий тип"

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:48
msgid "box_latch_t *"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:52
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:54
msgid "latch to destroy"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:58
msgid ""
"Lock a latch. Waits indefinitely until the current fiber can gain access "
"to the latch."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst
msgid "param box_latch_t* latch"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:61
#: ../doc/1.6/dev_guide/reference_capi/latch.rst:67
msgid "latch to lock"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:65
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:68
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:69
msgid "int"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:73
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/latch.rst:75
msgid "latch to unlock"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:37
msgid "Module `say` (logging)"
msgstr "Модуль `say` (логирование)"

#: ../doc/1.6/dev_guide/reference_capi/say.rst:45
msgid "do not use this value directly"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:61
#: ../doc/1.6/dev_guide/reference_capi/say.rst:76
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:63
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:64
#: ../doc/1.6/dev_guide/reference_capi/say.rst:78
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:67
#: ../doc/1.6/dev_guide/reference_capi/say.rst:81
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/say.rst:85
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:37
msgid "Module `schema`"
msgstr "Модуль `schema`"

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:45
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:49
msgid "Space id of _schema."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:53
msgid "Space id of _space."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:57
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:61
msgid "Space id of _index."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:65
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:69
msgid "Space id of _func."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:73
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:77
msgid "Space id of _user."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:81
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:85
msgid "Space id of _priv."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:89
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:93
msgid "Space id of _cluster."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:97
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/schema.rst:101
msgid "NULL value, returned on error."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:37
msgid "Module `trivia/config`"
msgstr "Модуль `trivia/config`"

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:41
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:45
msgid "Package major version - 1 for 1.6.9."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:49
msgid "Package minor version - 6 for 1.6.9."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:53
msgid "Package patch version - 9 for 1.6.9."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:57
msgid ""
"A string with major-minor-patch-commit-id identifier of the release, e.g."
" 1.6.9-1216-g73f7154."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:62
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:66
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:70
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:74
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:78
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:82
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:86
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:90
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:94
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:98
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:102
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:106
msgid ""
"A constant added to ``package.path`` in Lua to find ``*.lua`` module "
"files."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/trivia.rst:110
msgid ""
"A constant added to ``package.cpath`` in Lua to find ``*.so`` module "
"files."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:37
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:45
msgid "Tuple format."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:47
msgid ""
"Each Tuple has associated format (class). Default format is used to "
"create tuples which are not attach to any particular space."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:58
msgid "Allocate and initialize a new tuple from a raw MsgPack Array data."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:60
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:63
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:64
msgid "the end of ``data``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:66
#: ../doc/1.6/dev_guide/reference_capi/txn.rst:71
msgid "NULL on out of memory"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:67
msgid "tuple otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:69
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:75
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:77
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee "
"that the last returned tuple is refcounted internally until the next call"
" to API function that yields or returns another tuple."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:81
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. Such tuples will not be garbage collected even "
"if another fiber remove they from space. After processing please "
"decrement the reference counter using :ref:`box_tuple_unref()<c_api-"
"tuple-box_tuple_unref>`, otherwise the tuple will leak."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:88
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:101
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:114
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:120
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:139
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:149
msgid "a tuple"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:90
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:103
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:132
msgid "-1 on error"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:93
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:99
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:106
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:112
msgid "Return the number of fields in tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:118
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack "
"Array)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:124
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:126
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:128
msgid ""
"Upon successful return, the function returns the number of bytes written."
" If buffer size is not enough then the return value is the number of "
"bytes which would have been written if enough space had been available."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:133
msgid "number of bytes written on success."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:137
msgid "Return the associated format."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:141
msgid "tuple format"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:145
msgid "Return the raw tuple field in MsgPack format."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:147
msgid "The buffer is valid until next call to box_tuple_* functions."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:150
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:152
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:153
msgid "msgpack otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:157
msgid "Tuple iterator"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:161
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allow to"
" iterate over fields at root level of MsgPack array."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:166
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind iterator to first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:189
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:195
msgid ""
"Return zero-based next position in iterator. That is, this function "
"return the field id of field that will be returned by the next call to "
":ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is "
"zero after initialization or rewind and :ref:`box_tuple_field_count"
"()<c_api-tuple-box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:202
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:209
#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:220
msgid "a tuple iterator"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:203
msgid "position"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:207
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:211
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:215
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:217
msgid ""
"The returned buffer is valid until next call to box_tuple_* API. "
"Requested field_no returned by next call to box_tuple_next(it)."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:221
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:224
msgid "After:"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:226
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:227
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned "
"value is NULL."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:234
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:236
msgid "The returned buffer is valid until next call to box_tuple_* API."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:239
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:240
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:242
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is "
"zero-based ID of returned field."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/tuple.rst:245
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if "
"returned value is NULL."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:37
msgid "Module `txn`"
msgstr "Модуль `txn`"

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:41
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:45
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:47
msgid ""
"A transaction is attached to caller fiber, therefore one fiber can have "
"only one active transaction."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:51
msgid "-1 on error. Perhaps a transaction has already been started"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:55
msgid "Commit the current transaction."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:58
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:62
msgid "Rollback the current transaction."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:66
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/txn.rst:68
msgid ""
"The memory is automatically deallocated when the transaction is committed"
" or rolled back."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:37
msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:43
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:45
msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:48
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:61
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:76
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:83
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:96
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:108
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:115
msgid "Lua State"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:49
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:51
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:65
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:53
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:59
msgid "Checks whether the function argument ``idx`` is a cdata"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:62
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:77
msgid "stack index"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:63
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:67
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:71
msgid "Sets finalizer function on a cdata object."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:73
msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on"
" the top of the stack."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:81
msgid "Return CTypeID (FFI) of given СDATA type"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:84
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:87
msgid "CTypeID"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:89
msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:94
msgid "Declare symbols for FFI"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:97
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:100
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:102
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:106
msgid "Push uint64_t onto the stack"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:109
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:116
msgid "value to push"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:113
msgid "Push int64_t onto the stack"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:120
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:134
msgid ""
"Checks whether the argument idx is a uint64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst
msgid "throws"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:123
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:130
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:127
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:141
msgid ""
"Checks whether the argument idx is a int64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/1.6/dev_guide/reference_capi/utils.rst:137
#: ../doc/1.6/dev_guide/reference_capi/utils.rst:144
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:37
msgid "Release management"
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:40
msgid "How to make a minor release"
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:42
msgid ""
"$ git tag -a 1.4.4 -m \"Next minor in 1.4 series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:48
msgid "Update the Web site in doc/www"
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:50
msgid ""
"Update all issues, upload the ChangeLog based on ``git log`` output. The "
"ChangeLog must only include items which are mentioned as issues on "
"github. If anything significant is there, which is not mentioned, "
"something went wrong in release planning and the release should be held "
"up until this is cleared."
msgstr ""

#: ../doc/1.6/dev_guide/release_management.rst:56
msgid ""
"Click 'Release milestone'. Create a milestone for the next minor release."
" Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/1.6/index.rst:40
msgid "Tarantool - Documentation"
msgstr ""

#: ../doc/1.6/index.rst:47
msgid "|nbspc|"
msgstr ""

#: ../doc/1.6/index.rst:97
msgid ""
"Tarantool 1.6 manual  This manual embraces all aspects of using "
"Tarantool: from introductory information and exercises for beginners -- "
"to advanced instructions and detailed references for power users and "
"contributors.  Документация находится в процессе перевода и может "
"отставать от английской версии.      <div class=\"badge-icon\"></div>  "
"Other formats:  Single-page HTML  PDF  "
"/Users/artembo/work/doc/doc/1.6/index.rst:84: (WARNING/2) Bullet list "
"ends without a blank line; unexpected unindent.  See also:  Documentation"
" archive  Articles  /Users/artembo/work/doc/doc/1.6/index.rst:87: "
"(WARNING/2) Bullet list ends without a blank line; unexpected unindent.  "
"Support:  Форум в Google  Чат в Telegram  Support:  Google forum  "
"Telegram chat"
msgstr ""

#: ../doc/1.6/index.rst:56
msgid "Tarantool 1.6 manual"
msgstr "Руководство по Tarantool 1.6"

#: ../doc/1.6/index.rst:60
msgid ""
"This manual embraces all aspects of using Tarantool: from introductory "
"information and exercises for beginners -- to advanced instructions and "
"detailed references for power users and contributors."
msgstr ""
"Данное руководство охватывает все аспекты использования Tarantool'а: от "
"вводной информации и упражнений для начинающих -- до продвинутых "
"инструкций и подробных справочников для опытных пользователей и сторонних"
" разработчиков."

#: ../doc/1.6/index.rst:81
msgid "**Other formats:**"
msgstr "**Другие форматы:**"

#: ../doc/1.6/index.rst:82
msgid "`Single-page HTML <singlehtml.html>`_"
msgstr "`HTML одной страницей <singlehtml.html>`_"

#: ../doc/1.6/index.rst:83
msgid "`PDF <Tarantool.pdf>`_"
msgstr "`PDF <Tarantool.pdf>`_"

#: ../doc/1.6/index.rst:84
msgid "**See also:**"
msgstr "**См. также:**"

#: ../doc/1.6/index.rst:85
msgid "`Documentation archive`_"
msgstr "`Архив документации`_"

#: ../doc/1.6/index.rst:86
msgid "`Articles`_"
msgstr "`Статьи`_"

#: ../doc/1.6/index.rst:94
msgid "**Support:**"
msgstr "**Поддержка:**"

#: ../doc/1.6/index.rst:95
msgid "`Google forum`_"
msgstr ""

#: ../doc/1.6/index.rst:96
msgid "`Telegram chat`_"
msgstr ""

#: ../doc/1.6/intro.rst:37
msgid "Overview"
msgstr "Общие сведения"

#: ../doc/1.6/intro.rst:41
msgid "An application server together with a database manager"
msgstr "Сервер приложений + СУБД"

#: ../doc/1.6/intro.rst:43
#, fuzzy
msgid ""
"Tarantool is a Lua application server integrated with a database "
"management system. It has a \"fiber\" model which means that many "
"Tarantool applications can run simultaneously on a single thread, while "
"each instance of the Tarantool server itself can run multiple threads for"
" input-output and background maintenance. It incorporates the LuaJIT -- "
"\"Just In Time\" -- Lua compiler, Lua libraries for most common "
"applications, and the Tarantool Database Server which is an established "
"NoSQL DBMS. Thus Tarantool serves all the purposes that have made node.js"
" and Twisted popular, plus it supports data persistence."
msgstr ""
"Tarantool представляет собой сервер приложений на языке Lua, "
"интегрированный с СУБД. В основе Tarantool лежат файберы (fibers), что "
"позволяет нескольким Lua-приложениям работать в одном потоке (thread), "
"при этом Tarantool-сервер может одновременно запускать другие потоки для "
"обработки ввода-вывода данных и фоновых сервисных задач. Tarantool "
"включает в себя LuaJIT (Just In Time) Lua-компилятор, Lua-библиотеки для "
"решения наиболее частых задач, а также сервер баз данных Tarantool, "
"представляющий собой NoSQL СУБД. Таким образом, Tarantool может всё то "
"же, что node.js и Twisted, а кроме того обеспечивает сохранность данных."

#: ../doc/1.6/intro.rst:51
msgid ""
"The code is free. The open-source license is `BSD license`_. The "
"supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""
"Tarantool — это open-source проект. Исходный код открыт для всех и "
"распространяется бесплатно согласно лицензии `BSD license`_. "
"Поддерживаемые платформы: GNU / Linux, Mac OS и FreeBSD."

#: ../doc/1.6/intro.rst:54
msgid ""
"Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet "
"company in Russia, with 30 million users, 25 million emails per day, and "
"a web site whose Alexa global rank is in the `top 40`_ worldwide. "
"Tarantool services Mail.Ru's hottest data, such as the session data of "
"online users, the properties of online applications, the caches of the "
"underlying data, the distribution and sharding algorithms, and much more."
" Outside Mail.Ru the software is used by a growing number of projects in "
"online gaming, digital marketing, and social media industries. Although "
"Mail.Ru is the sponsor for product development, the roadmap and the bugs "
"database and the development process are fully open. The software "
"incorporates patches from dozens of community contributors. The Tarantool"
" community writes and maintains most of the drivers for programming "
"languages.  The greater Lua community has hundreds of useful packages "
"most of which can become Tarantool extensions."
msgstr ""
"Создателем Tarantool'а — а также его основным пользователем — является "
"компания `Mail.Ru`_, крупнейшая Интернет-компания России (30 млн "
"пользователей, 25 млн электронных писем в день, веб-сайт в списке `top "
"40`_ международного Alexa-рейтинга). Tarantool используется для обработки"
" самых \"горячих\" данных Mail.Ru, таких как данные пользовательских "
"онлайн-сессий, настройки онлайн-приложений, кеширование сервисных данных,"
" алгоритмы распределения данных и шардинга, и т.д. Tarantool также "
"используется во всё большем количестве проектов вне стен Mail.Ru. Это, к "
"примеру, онлайн-игры, цифровой маркетинг, социальные сети. Несмотря на то"
" что Mail.Ru спонсирует разработку Tarantool'а, весь процесс разработки, "
"в т.ч. дальнейшие планы и база обнаруженных ошибок, является полностью "
"открытым. В Tarantool включены патчи от большого числа сторонних "
"разработчиков. Усилиями сообщества разработчиков Tarantool'а были "
"написаны (и далее поддерживаются) библиотеки для подключения модулей на "
"внешних языках программирования. А сообщество Lua-разработчиков "
"предоставило сотни полезных пакетов, большинство из которых можно "
"использовать в качестве расширений для Tarantool'а."

#: ../doc/1.6/intro.rst:68
msgid ""
"Users can create, modify and drop **Lua functions** at runtime. Or they "
"can define **Lua programs** that are loaded during startup for triggers, "
"background tasks, and interacting with networked peers. Unlike popular "
"application development frameworks based on a \"reactor\" pattern, "
"networking in server-side Lua is sequential, yet very efficient, as it is"
" built on top of the **cooperative multitasking** environment that "
"Tarantool itself uses."
msgstr ""
"Пользователи Tarantool'а могут создавать, изменять и удалять "
"**Lua-функции** прямо во время исполнения кода. Также они могут указывать"
" **Lua-программы**, которые будут загружаться во время запуска "
"Tarantool'а. Такие программы могут служить триггерами, выполнять фоновые "
"задачи и взаимодействовать с другими программами по сети. В отличие от "
"многих популярных сред разработки приложений, которые используют "
"\"реактивный\" принцип, сетевое взаимодействие в Lua устроено "
"последовательно, но очень эффективно, т.к. оно использует среду "
"**взаимной многозадачности** самого Tarantool'а."

#: ../doc/1.6/intro.rst:76
msgid ""
"One of the built-in Lua packages provides an API for the Database "
"Management System. Thus some developers see Tarantool as a DBMS with a "
"popular stored procedure language, while others see it as a Lua "
"interpreter, while still others see it as a replacement for many "
"components of multi-tier Web applications. Performance can be a few "
"hundred thousand transactions per second on a laptop, scalable upwards or"
" outwards to server farms."
msgstr ""
"Один из встраиваемых Lua-пакетов — это API для функционала СУБД. Таким "
"образом, некоторые разработчики рассматривают Tarantool как СУБД с "
"популярным языком для написания хранимых процедур, другие рассматривают "
"его как Lua-интерпретатор, а третьи -- как вариант замены сразу "
"нескольких компонентов в многозвенных веб-приложениях. Производительность"
" Tarantool'а может достигать сотен тысяч транзакций в секунду на "
"ноутбуке, и ее можно наращивать \"вверх\" или \"вширь\" за счет новых "
"серверных ферм."

#: ../doc/1.6/intro.rst:86
msgid "Database features"
msgstr "Возможности СУБД"

#: ../doc/1.6/intro.rst:88
msgid ""
"Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a "
"strong distinguishing feature."
msgstr ""
"Компонент \"box\" — серверная часть с функционалом СУБД — это важная "
"часть Tarantool'а, хотя он может работать и без данного компонента."

#: ../doc/1.6/intro.rst:91
msgid ""
"The database API allows for permanently storing Lua objects, managing "
"object collections, creating or dropping secondary keys, making changes "
"atomically, configuring and monitoring replication, performing controlled"
" fail-over, and executing Lua code triggered by database events. Remote "
"database instances are accessible transparently via a remote-procedure-"
"invocation API."
msgstr ""
"API для функционала СУБД позволяет хранить Lua-объекты, управлять "
"коллекциями объектов, создавать и удалять вторичные ключи, делать "
"атомарные изменения, конфигурировать и мониторить репликацию, производить"
" контролируемое переключение при отказе (failover), а также исполнять код"
" на Lua, который вызывается событиями в базе. А для прозрачного доступа к"
" удаленным (remote) экземплярам баз данных разработан API для вызова "
"удаленных процедур."

#: ../doc/1.6/intro.rst:99
msgid ""
"Tarantool's DBMS server uses the **storage engine** concept, where "
"different sets of algorithms and data structures can be used for "
"different situations. Currently a single storage engine is built-in: an "
"in-memory engine which has all the data and indexes in RAM (in a later "
"version there will be two-level B-tree engine for data sets whose size is"
" 10 to 1000 times the amount of available RAM). All storage engines in "
"Tarantool will support transactions and replication by using a common "
"**write ahead log** (WAL). This ensures consistency and crash safety of "
"the persistent state. Changes are not considered complete until the WAL "
"is written. The logging subsystem supports group commit."
msgstr ""

#: ../doc/1.6/intro.rst:110
#, fuzzy
msgid ""
"**Tarantool's in-memory storage engine** (memtx) keeps all the data in "
"random-access memory, and therefore has very low read latency. It also "
"keeps persistent copies of the data in non-volatile storage, such as "
"disk, when users request \"snapshots\". If an instance of the server "
"stops and the random-access memory is lost, then restarts, it reads the "
"latest snapshot and then replays the transactions that are in the log -- "
"therefore no data is lost."
msgstr ""
"**In-memory движок** (memtx) хранит все данные в оперативной памяти, "
"поэтому время ожидания при чтении у него очень мало. Также, когда "
"пользователи запрашивают статические снимки (snapshots), этот движок "
"создает персистентные копии данных в постоянной памяти, например на "
"жестком диске. Если Tarantool-сервер прекращает работать и данные в "
"оперативной памяти теряются, то при следующем запуске Tarantool-сервер "
"загружает в память самую свежую копию данных с диска и применяет к ней "
"все транзакции из лога, которые были сделаны с момента создания копии. "
"Таким образом, данные при сбое не теряются."

#: ../doc/1.6/intro.rst:119
#, fuzzy
msgid ""
"**Tarantool's in-memory engine is lock-free** in typical situations. "
"Instead of the operating system's concurrency primitives, such as "
"mutexes, Tarantool uses cooperative multitasking to handle thousands of "
"connections simultaneously. There is a fixed number of independent "
"execution threads. The threads do not share state. Instead they exchange "
"data using low-overhead message queues. While this approach limits the "
"number of cores that the instance will use, it removes competition for "
"the memory bus and ensures peak scalability of memory access and network "
"throughput. CPU utilization of a typical highly-loaded Tarantool instance"
" is under 10%. Searches are possible via **secondary index keys** as well"
" as primary keys."
msgstr ""
"В штатных ситуациях **in-memory движок работает без блокировок**. Вместо "
"низкоуровневых механизмов параллельной обработки данных, которые "
"предлагает операционная система (например, mutex'ов), Tarantool "
"использует среду взаимной многозадачности, и таким образом может работать"
" с тысячами соединений одновременно. В Tarantool'е есть фиксированное "
"количество независимых нитей (thread), и у них нет общего состояния. Для "
"обмена данными между нитями используются очереди сообщений, что позволяет"
" уменьшить накладные расходы. Такой подход накладывает ограничение на "
"количество процессорных ядер, которые Tarantool-сервер может "
"использовать, но в то же время он позволяет избежать конкуренции за шину "
"памяти, а также дает запас масштабируемости по скорости доступа к памяти "
"и производительности сети. В результате даже сильно нагруженный "
"Tarantool-сервер в среднем использует процессор не более чем на 10%. "
"Кроме того, Tarantool поддерживает поиск как по первичным, так и по "
"**вторичным ключам в индексах**."

#: ../doc/1.6/intro.rst:129
msgid ""
"Tarantool supports **multi-part index keys**. The possible index types "
"are HASH, TREE, BITSET, and RTREE."
msgstr ""
"Tarantool поддерживает работу с **составными ключами в индексах**. "
"Возможные типы ключей: HASH, TREE, BITSET и RTREE."

#: ../doc/1.6/intro.rst:132
msgid ""
"Tarantool supports **asynchronous replication**, locally or to remote "
"hosts. The replication architecture can be **master-master**, that is, "
"many nodes may both handle the loads and receive what others have "
"handled, for the same data sets."
msgstr ""
"Tarantool также поддерживает **асинхронную репликацию** — как локальную, "
"так и на удаленных серверах. При этом репликацию можно настроить по "
"принципу **мастер-мастер**, когда несколько узлов могут не только "
"обрабатывать входящую нагрузку, но и получать данные от других узлов."

#: ../doc/1.6/reference/configuration/index.rst:39
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/1.6/reference/configuration/index.rst:41
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an :ref:`initialization file <index-"
"init_label>`."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:44
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:49
msgid ""
"$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:57
msgid "Command options"
msgstr "Опции комнандной строки"

#: ../doc/1.6/reference/configuration/index.rst:61
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:67
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:69
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.6.9-1-g3a3f705\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:76
msgid "In this example:"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:78
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking "
"programming framework."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:81
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` "
"is incremented for each new milestone and indicates possible incompatible"
" changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there "
"may be a commit number and commit SHA1 to indicate how much this "
"particular build has diverged from the last release."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:89
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:94
msgid ""
"Tarantool uses `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to "
"produce its version id, and this id can be used at any time to check out "
"the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:104
msgid "URI"
msgstr "Универсальный код ресурса (URI)"

#: ../doc/1.6/reference/configuration/index.rst:106
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to "
"the `generic syntax for a URI schema "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may "
"contain (in order) a user name for login, a password, a host name or host"
" IP address, and a port number. Only the port number is always mandatory."
" The password is mandatory if the user name is specified, unless the user"
" name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or "
"``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or "
"'[::]' is assumed, meaning respectively any IPv4 address or any IPv6 "
"address, on the local machine. If username:password is omitted, then "
"'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:125
msgid "URI fragment"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:127
msgid "port"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:127
msgid "3301"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:129
msgid "host:port"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:129
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:131
msgid "username:password@host:port"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:131
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:134
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply "
"\"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:138
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:144
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/1.6/reference/configuration/index.rst:146
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-"
"initialization-file`, then Tarantool begins by invoking the Lua program "
"in the file, which by convention may have the name \"``script.lua``\". "
"The Lua program may get further arguments from the command line or may "
"use operating-system functions, such as ``getenv()``. The Lua program "
"almost always begins by invoking ``box.cfg()``, if the database server "
"will be used or if ports need to be opened. For example, suppose "
"``script.lua`` contains the lines"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:154
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:165
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and "
"suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``."
" Then the screen might look like this:"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:169
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.6.9-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:183
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-"
"start>`."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:198
msgid "Configuration parameters"
msgstr "Параметры конфигурации"

#: ../doc/1.6/reference/configuration/index.rst:200
#, fuzzy
msgid "Configuration parameters have the form:"
msgstr "Параметры конфигурации"

#: ../doc/1.6/reference/configuration/index.rst:202
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:204
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since "
"some of the parameters (such as directory addresses) are semi-permanent, "
"it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is "
"the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:209
msgid ""
"Most configuration parameters are for allocating resources, opening "
"ports, and specifying database behavior. All parameters are optional. A "
"few parameters are dynamic, that is, they can be changed at runtime by "
"calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:214
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To "
"see a particular parameter, for example the listen address, say "
"``box.cfg.listen``."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:217
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for "
"networking, and for logging."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:222
msgid "Basic parameters"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:1
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:2
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:3
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:4
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:5
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:6
msgid ":ref:`snap_dir <cfg_basic-snap_dir>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:7
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:8
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:9
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:15
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-logger>` "
"and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:19
#: ../doc/1.6/reference/configuration/cfg_basic.rst:99
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:27
#: ../doc/1.6/reference/configuration/cfg_logging.rst:109
msgid "Type: boolean"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:20
#: ../doc/1.6/reference/configuration/cfg_basic.rst:100
msgid "Default: false"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:21
#: ../doc/1.6/reference/configuration/cfg_basic.rst:90
#: ../doc/1.6/reference/configuration/cfg_basic.rst:113
#: ../doc/1.6/reference/configuration/cfg_basic.rst:123
#: ../doc/1.6/reference/configuration/cfg_basic.rst:137
#: ../doc/1.6/reference/configuration/cfg_basic.rst:162
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:29
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:42
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:85
#: ../doc/1.6/reference/configuration/cfg_logging.rst:97
#: ../doc/1.6/reference/configuration/cfg_logging.rst:111
#: ../doc/1.6/reference/configuration/cfg_storage.rst:42
#: ../doc/1.6/reference/configuration/cfg_storage.rst:54
msgid "Dynamic: no"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:25
msgid "Deprecated. Do not use."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:27
msgid "Type: boolean |br| Default: false |br| Dynamic: no |br|"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:35
msgid ""
"Add the given string to the server's process title (what’s shown in the "
"COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:39
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process"
" thus:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:42
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:47
msgid ""
"But if the configuration parameters include "
"``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:50
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:55
#: ../doc/1.6/reference/configuration/cfg_basic.rst:88
#: ../doc/1.6/reference/configuration/cfg_basic.rst:111
#: ../doc/1.6/reference/configuration/cfg_basic.rst:121
#: ../doc/1.6/reference/configuration/cfg_basic.rst:135
#: ../doc/1.6/reference/configuration/cfg_basic.rst:160
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:71
#: ../doc/1.6/reference/configuration/cfg_logging.rst:95
#: ../doc/1.6/reference/configuration/cfg_replication.rst:31
msgid "Type: string"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:56
#: ../doc/1.6/reference/configuration/cfg_basic.rst:78
#: ../doc/1.6/reference/configuration/cfg_basic.rst:89
#: ../doc/1.6/reference/configuration/cfg_basic.rst:122
#: ../doc/1.6/reference/configuration/cfg_basic.rst:161
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:56
#: ../doc/1.6/reference/configuration/cfg_logging.rst:96
#: ../doc/1.6/reference/configuration/cfg_networking.rst:14
#: ../doc/1.6/reference/configuration/cfg_replication.rst:32
msgid "Default: null"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:57
#: ../doc/1.6/reference/configuration/cfg_basic.rst:79
#: ../doc/1.6/reference/configuration/cfg_basic.rst:101
#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:36
#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:60
msgid "Dynamic: yes"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:63
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be "
"specified** if connections will occur from remote clients that do not use"
" the :ref:`“admin port” <admin-security>`. Connections made with "
":samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" "
"connections."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:70
msgid "A typical value is 3301."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:74
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:77
msgid "Type: integer or string"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:85
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:96
msgid ""
"Put the server instance in read-only mode. After this, any requests that "
"try to change data will fail with error :errcode:`ER_READONLY`."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:107
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to"
" :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:112
#: ../doc/1.6/reference/configuration/cfg_basic.rst:136
msgid "Default: \".\""
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:119
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:129
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` "
"and :ref:`snap_dir <cfg_basic-snap_dir>` are specified with different "
"values, so that write-ahead log files and snapshot files can be stored on"
" different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:143
msgid ""
"A directory where database working files will be stored. The server "
"instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. "
"Can be relative to the current directory. If not specified, defaults to "
"the current directory. Other directory parameters may be relative to "
"``work_dir``, for example:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:149
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    snap_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_basic.rst:157
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in "
"``/home/user/A/C``, and all other files or subdirectories in "
"``/home/user/A``."
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:228
msgid "Configuring the storage"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:1
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:2
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:3
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:9
msgid ""
"How much memory Tarantool allocates to actually store tuples, in "
"gigabytes. When the limit is reached, INSERT or UPDATE requests begin "
"failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not "
"go beyond the defined limit to allocate tuples, there is additional "
"memory used to store indexes and connection information. Depending on "
"actual configuration and workload, Tarantool can consume up to 20% more "
"than the limit set here."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:16
msgid "Type: float |br| Default: 1.0 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:24
msgid ""
"Use slab_alloc_factor as the multiplier for computing the sizes of memory"
" chunks that tuples are stored in. A lower value may result in less "
"wasted memory depending on the total amount of memory available and the "
"distribution of item sizes."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:29
msgid "Type: float |br| Default: 1.1 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:37
msgid ""
"Size of the largest allocation unit, in bytes. It can be increased if it "
"is necessary to store large tuples."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:40
#: ../doc/1.6/reference/configuration/cfg_logging.rst:26
#: ../doc/1.6/reference/configuration/cfg_networking.rst:30
#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:34
#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:58
#: ../doc/1.6/reference/configuration/cfg_storage.rst:40
#: ../doc/1.6/reference/configuration/cfg_storage.rst:52
msgid "Type: integer"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:41
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:48
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if "
"most of the tuples are very small. The value must be between 8 and "
"1048280 inclusive."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_storage.rst:53
msgid "Default: 16"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:236
msgid "Snapshot daemon"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:1
msgid ":ref:`snapshot_count <cfg_snapshot_daemon-snapshot_count>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:2
msgid ":ref:`snapshot_period <cfg_snapshot_daemon-snapshot_period>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:4
msgid ""
"The snapshot daemon is a fiber which is constantly running. At intervals,"
" it may make new snapshot (.snap) files and then may remove old snapshot "
"files. If the snapshot daemon removes an old snapshot file, it will also "
"remove any write-ahead log (.xlog) files that are older than the snapshot"
" file and contain information that is present in the snapshot file."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:10
msgid ""
"The :ref:`snapshot_period <cfg_snapshot_daemon-snapshot_period>` and "
":ref:`snapshot_count <cfg_snapshot_daemon-snapshot_count>` configuration "
"settings determine how long the intervals are, and how many snapshots "
"should exist before removals occur."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:19
msgid ""
"The interval between actions by the snapshot daemon, in seconds. If "
"``snapshot_period`` is set to a value greater than zero, and there is "
"activity which causes change to a database, then the snapshot daemon will"
" call :ref:`box.snapshot <box-snapshot>` every ``snapshot_period`` "
"seconds, creating a new snapshot file each time."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:27
msgid "box.cfg{snapshot_period=3600}"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:31
msgid ""
"will cause the snapshot daemon to create a new database snapshot once per"
" hour."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:35
msgid "Default: 0 (disabled)"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:42
msgid ""
"The maximum number of snapshots that may exist on the ``snap_dir`` "
"directory before the snapshot daemon will remove old snapshots. If "
"``snapshot_count`` equals zero, then the snapshot daemon does not remove "
"old snapshots. For example:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:47
msgid ""
"box.cfg{\n"
"    snapshot_period = 3600,\n"
"    snapshot_count  = 10\n"
"}"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:54
msgid ""
"will cause the snapshot daemon to create a new snapshot each hour until "
"it has created ten snapshots. After that, it will remove the oldest "
"snapshot (and any associated write-ahead-log files) after creating a new "
"one."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_snapshot_daemon.rst:59
msgid "Default: 6"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:242
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:2
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:3
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:4
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:5
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:6
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid ""
"If there is an error while reading the snapshot file (at server start), "
"abort."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:15
msgid "Type: boolean |br| Default: true |br| Dynamic: no |br|"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:23
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start) or a write-ahead log file (at server instance start or to relay to"
" a replica), abort."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:28
#: ../doc/1.6/reference/configuration/cfg_logging.rst:110
msgid "Default: true"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:35
msgid ""
"How many log records to store in a single write-ahead log file. When this"
" limit is reached, Tarantool creates another WAL file named :samp"
":`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based "
"backups."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:41
msgid "Default: 500000"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:48
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes"
" per second it can write to disk. The same can be achieved by splitting "
":ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`snap_dir <cfg_basic-"
"snap_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:55
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:83
#: ../doc/1.6/reference/configuration/cfg_logging.rst:121
#: ../doc/1.6/reference/configuration/cfg_networking.rst:13
msgid "Type: float"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:57
#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:73
#: ../doc/1.6/reference/configuration/cfg_logging.rst:28
#: ../doc/1.6/reference/configuration/cfg_logging.rst:123
#: ../doc/1.6/reference/configuration/cfg_networking.rst:15
#: ../doc/1.6/reference/configuration/cfg_networking.rst:32
#: ../doc/1.6/reference/configuration/cfg_replication.rst:33
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:63
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:65
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:66
msgid ""
"``write``: fibers wait for their data to be written to the write-ahead "
"log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:68
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each "
":manpage:`write(2)`;"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:72
msgid "Default: \"write\""
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the "
"sake of replication or :ref:`local hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_binary_logging_snapshots.rst:84
msgid "Default: 2"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:1
#, fuzzy
msgid ":ref:`replication_source <cfg_replication-replication_source>`"
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр "
":ref:`replication_source <cfg_replication-replication_source>` можно "
"задавать на ходу."

#: ../doc/1.6/reference/configuration/cfg_replication.rst:7
msgid ""
"If ``replication_source`` is not an empty string, the instance is "
"considered to be a Tarantool :ref:`replica <index-box_replication>`. The "
"replica will try to connect to the master specified in "
"``replication_source`` with a :ref:`URI <index-uri>` (Universal Resource "
"Identifier), for example:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:12
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:14
msgid ""
"If there is more than one replication source in a replica set, specify an"
" array of URIs, for example: (replace 'uri' and 'uri2' in this example "
"with valid URIs):"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:17
#, fuzzy
msgid ":extsamp:`box.cfg{ replication_source = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../doc/1.6/reference/configuration/cfg_replication.rst:19
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. "
"Thus it is possible to use the same ``replication`` specification on "
"multiple servers."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:24
msgid ""
"The default user name is ‘guest’. A replica does not accept data-change "
"requests on the :ref:`listen <cfg_basic-listen>` port. The "
"``replication_source`` parameter is dynamic, that is, to enter master "
"mode, simply set ``replication_source`` to an empty string and issue:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_replication.rst:29
#, fuzzy
msgid ":extsamp:`box.cfg{ replication_source = {*{new-value}*} }`"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../doc/1.6/reference/configuration/index.rst:254
msgid "Networking"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_networking.rst:2
msgid ":ref:`readahead <cfg_networking-readahead>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_networking.rst:8
msgid ""
"The instance will sleep for io_collect_interval seconds between "
"iterations of the event loop. Can be used to reduce CPU load in "
"deployments in which the number of client connections is large, but "
"requests are not so frequent (for example, each connection issues just a "
"handful of requests per second)."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_networking.rst:21
msgid ""
"The size of the read-ahead buffer associated with a client connection. "
"The larger the buffer, the more memory an active connection consumes and "
"the more requests can be read from the operating system buffer in a "
"single system call. The rule of thumb is to make sure the buffer can "
"contain at least a few dozen requests. Therefore, if a typical tuple in a"
" request is large, e.g. a few kilobytes or even megabytes, the read-ahead"
" buffer size should be increased. If batched request processing is not "
"used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_networking.rst:31
msgid "Default: 16320"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:3
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:4
msgid ":ref:`logger <cfg_logging-logger>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:5
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:6
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:12
msgid "How verbose the logging is. There are six log verbosity classes:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:14
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:15
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:16
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:17
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:18
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:19
msgid "6 – ``DEBUG``"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:21
msgid ""
"By setting log_level, one can enable logging of all classes below or "
"equal to the given level. Tarantool prints its logs to the standard error"
" stream by default, but this can be changed with the :ref:`log "
"<cfg_logging-logger>` configuration parameter."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:27
msgid "Default: 5"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:34
msgid ""
"By default, Tarantool sends the log to the standard error stream "
"(``stderr``). If ``logger`` is specified, Tarantool sends the log to a "
"file, or to a pipe, or to the system logger."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:38
#: ../doc/1.6/reference/configuration/cfg_logging.rst:50
#: ../doc/1.6/reference/configuration/cfg_logging.rst:64
msgid "Example setting:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:40
msgid ""
"box.cfg{logger = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'file: tarantool.log'}"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:46
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s "
"default directory. If the ``logger`` string has no prefix or has the "
"prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:52
msgid ""
"box.cfg{logger = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:58
msgid ""
"This will start the program ``cronolog`` when the server starts, and will"
" send all log messages to the standard input (``stdin``) of cronolog. If "
"the ``log`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline "
"<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:66
msgid ""
"box.cfg{logger = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:74
msgid ""
"If the ``logger`` string has the prefix \"syslog:\", then the string is "
"interpreted as a message for the `syslogd <http://www.rfc-"
"base.org/txt/rfc-5424.txt>`_ program which normally is running in the "
"background of any Unix-like platform. One can optionally specify an "
"``identity``, a ``facility``, or both. The ``identity`` is an arbitrary "
"string, default value = ``tarantool``, which will be placed at the "
"beginning of all messages. The facility is an abbreviation for the name "
"of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ "
"facilities, default value = ``user``, which tell syslogd where the "
"message should go."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:85
msgid ""
"Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, "
"kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, "
"local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:89
msgid ""
"The ``facility`` setting is currently ignored but will be used in the "
"future."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:91
msgid ""
"When logging to a file, Tarantool reopens the log on SIGHUP. When log is "
"a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>`"
" variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:103
msgid ""
"If ``logger_nonblock`` equals true, Tarantool does not block on the log "
"file descriptor when it’s not ready for write, and drops the message "
"instead. If :ref:`log_level <cfg_logging-log_level>` is high, and a lot "
"of messages go to the log file, setting ``logger_nonblock`` to true may "
"improve logging performance at the cost of some log messages getting "
"lost."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:117
msgid ""
"If processing a request takes longer than the given value (in seconds), "
"warn about it in the log. Has effect only if :ref:`log_level "
"<cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:122
msgid "Default: 0.5"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:129
#, fuzzy
msgid "Logging example"
msgstr "Например:"

#: ../doc/1.6/reference/configuration/cfg_logging.rst:131
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when "
"the server instance is writing to a log and signals are used when "
"archiving it."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:134
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:136
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the "
"logging will go to `Log_file`, then put a message \"Log Line #1\" in the "
"log file:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:139
msgid ""
"box.cfg{logger='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:145
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. "
"The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:857
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:153
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:155
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:159
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool "
"instance."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:870
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:166
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the "
"Tarantool instance. The result of this is: Tarantool will open `Log_file`"
" again, and the next log message will go to `Log_file`. (The same effect "
"could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:880
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:176
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:178
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:182
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the "
"example is done:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:894
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_logging.rst:191
msgid "and `Log_file` will have"
msgstr ""

#: ../internal after doc/1.6/reference/configuration/cfg_logging.rst:902
#: padding
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/1.6/reference/configuration/index.rst:269
msgid "Local hot standby"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:1
msgid ""
"Local hot standby is a feature which provides a simple form of failover "
"without replication."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:4
msgid ""
"The expectation is that there will be two instances of the server using "
"the same configuration. The first one to start will be the \"primary\" "
"instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:8
msgid ""
"To initiate the standby instance, start a second instance of the "
"Tarantool server on the same computer with the same :ref:`box.cfg "
"<box_introspection-box_cfg>` configuration settings -- including the same"
" directories and same non-null URIs. The standby instance will initialize"
" and will try to connect on listen address, but will fail because the "
"primary instance has already taken it. Expect to see a warning with the "
"words ``W> binary: [URI] is already in use, will retry binding after [n] "
"seconds``."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:18
msgid ""
"This is fine. It means that the second instance is ready to take over if "
"the first instance goes down."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:21
msgid ""
"So the standby instance goes into a loop, reading the write ahead log "
"which the primary instance is writing (so the two instances are always in"
" synch), and trying to connect on the port. If the primary instance goes "
"down for any reason, the port will become free so the standby instance "
"will succeed in connecting, and will become the primary instance."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:28
msgid ""
"Expect to see a notification ending with the words ``I> ready to accept "
"requests``."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:31
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:33
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:35
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and "
"FreeBSD); on these platforms, it is designed so that the loop repeats "
"every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/1.6/reference/configuration/cfg_hot_standby.rst:39
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it "
"is designed to work with ``wal_mode = 'write'`` or ``wal_mode = "
"'fsync'``."
msgstr ""

#: ../doc/1.6/reference/index.rst:39
msgid "Reference"
msgstr "Справочники"

#: ../doc/1.6/reference/lua_tips.rst:39
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/1.6/reference/lua_tips.rst:41
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with "
"``select()`` requests. The same rules exist for the other data-"
"manipulation functions."
msgstr ""

#: ../doc/1.6/reference/lua_tips.rst:45
#, fuzzy
msgid ""
"Every one of the examples does the same thing: select a tuple set from a "
"space named 'tester' where the primary-key field value equals 1. For "
"these examples, we assume that the numeric id of 'tester' is 512, which "
"happens to be the case in our sandbox example only."
msgstr ""
"Lua-синтаксис в данных функциях может различаться. Далее приводятся "
"варианты таких различий на примере SELECT-запросов. Аналогичные правила "
"существуют и для остальных функций. В каждом из приведенных примеров "
"выполняются следующие действия: производится выборка по набору кортежей "
"из пространства с именем 'tester', где значение поля, которое "
"соответствует ключу в первичном индексе, равно 1. Также во всех примерах "
"мы подразумеваем, что числовой идентификатор пространства 'tester' равен "
"512, но это верно только для нашей тестовой базы."

#: ../doc/1.6/reference/lua_tips.rst:52
#, fuzzy
msgid "First, there are three **object reference variations**:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../doc/1.6/reference/lua_tips.rst:54
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/1.6/reference/lua_tips.rst:64
#, fuzzy
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" "
"form (#1). However, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""
"Для примеров в остальной части документации мы будем, как правило, "
"использовать вариант синтаксиса #1, например "
"\":samp:`box.space.{tester}:`\". Но вы можете с тем же успехом "
"пользоваться любым из пяти описанных выше вариантов."

#: ../doc/1.6/reference/lua_tips.rst:68
#, fuzzy
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" "
"for references to objects which are spaces, and \"``index_object:``\" for"
" references to objects which are indexes (for example "
":samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""
"Также мы в дальнейшем будем использовать синтаксис типа  "
"\":code:`space_object:`\" для ссылки на пространства (как в приведенных "
"выше примерах) и \":code:`index_object:`\" для ссылки на индексы "
"(например, :samp:`box.space.{tester}.index.{primary}:`)."

#: ../doc/1.6/reference/lua_tips.rst:75
#, fuzzy
msgid "Then, there are seven **parameter variations**:"
msgstr "Во-вторых, есть семь *способов задания параметров*:"

#: ../doc/1.6/reference/lua_tips.rst:77
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../doc/1.6/reference/lua_tips.rst:96
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its "
"only argument is a Lua table, and we use it sometimes in our examples. "
"This is why ``select{1}`` is equivalent to ``select({1})``. Literal "
"values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may "
"be replaced by variable names, as in examples #6 and #7. Although there "
"are special cases where braces can be omitted, they are preferable "
"because they signal \"Lua table\". Examples and descriptions in this "
"manual have the ``{1}`` form. However, this too is a matter of user "
"preference and all the variations exist in the wild."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box.rst:41
msgid ""
"As well as executing Lua chunks or defining their own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its"
" submodules."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box.rst:44
msgid ""
"The contents of the ``box`` module can be inspected at runtime with "
"``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box.rst:67
msgid ""
"Every submodule contains one or more Lua functions. A few submodules "
"contain members as well as functions. The functions allow data definition"
" (create alter drop), data manipulation (insert delete update upsert "
"select replace), and introspection (inspecting contents of spaces, "
"accessing server configuration)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:37
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/1.6/reference/reference_lua/box_error.rst:41
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in ``error()`` function is that "
"when the error reaches the client, its error code is preserved. In "
"contrast, a Lua error would always be presented to the client as "
":errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:48
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:56
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:63
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.6/src/box/errcode.h>`_ in "
"the source tree. Lua constants which correspond to those Tarantool errors"
" are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:69
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:70
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:74
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst
msgid "except"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:80
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:84
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:103
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:113
msgid "rtype: table"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:117
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_error.rst:122
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.6.9.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:39
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/1.6/reference/reference_lua/box_once.rst:43
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked. For an explanation why "
"``box.once()`` is useful, see the section :ref:`Preventing duplicate "
"actions <index-preventing_duplicate_actions>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:50
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, "
"you can re-execute the failed ``box.once()`` block without stopping the "
"database. The solution is to delete the ``once`` object from the system "
"space :ref:`_schema <box_space-schema>`. Say "
"``box.space._schema:select{}``, find your ``once`` object there and "
"delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:57
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 6, 8]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:77
msgid "a value that will be checked"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:78
msgid "a function"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_once.rst:79
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:39
#, fuzzy
msgid "Function `box.snapshot`"
msgstr "Функция `box.once`"

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:43
msgid ""
"Take a snapshot of all data and store it in :ref:`snap_dir <cfg_basic-"
"snap_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, tuples which were allocated before the snapshot has started are not"
" freed until the snapshot has finished. To preserve consistency of the "
"primary key, used to iterate over tuples, a copy-on-write technique is "
"employed. If the master process changes part of a primary key, the "
"corresponding process page is split, and the snapshot process obtains an "
"old copy of the page. In effect, the snapshot process uses multi-version "
"concurrency control in order to avoid copying changes which are "
"superseded while it is running."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:55
msgid ""
"Since a snapshot is written sequentially, one can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:61
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:69
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and writes this view to the snapshot file from a separate "
"thread."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:74
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`snapshot daemon <book_cfg_snapshot_daemon>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:80
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.6.9-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:95
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/box_snapshot.rst:101
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:41
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:53
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:57
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:58
#: ../doc/1.6/reference/reference_lua/clock.rst:81
#: ../doc/1.6/reference/reference_lua/clock.rst:100
#: ../doc/1.6/reference/reference_lua/clock.rst:119
msgid "number or number64"
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:62
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:68
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function"
" `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:74
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:80
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:85
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:94
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to"
" use with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:99
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:104
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:113
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to "
"use with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:118
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:123
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:131
msgid ""
"The time that a function takes within a processor. This function uses "
"``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it "
"is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:135
#, fuzzy
msgid "function or function reference"
msgstr "Справочник по настройке"

#: ../doc/1.6/reference/reference_lua/clock.rst:136
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:138
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever"
" the function returns."
msgstr ""

#: ../doc/1.6/reference/reference_lua/clock.rst:143
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:39
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/1.6/reference/reference_lua/console.rst:41
msgid ""
"The console module allows one Tarantool instance to access another "
"Tarantool instance, and allows one Tarantool instance to start listening "
"on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:51
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from"
" '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:55
msgid ""
"The console.connect function allows one Tarantool instance, in "
"interactive mode, to access another Tarantool instance. Subsequent "
"requests will appear to be handled locally, but in reality the requests "
"are being sent to the remote instance and the local instance is acting as"
" a client. Once connection is successful, the prompt will change and "
"subsequent requests are sent to, and executed on, the remote instance. "
"Results are displayed on the local instance. To return to local mode, "
"enter ``control-D``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:63
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the "
"connection might look something like: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:67
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote instance is done with user name = 'guest'. The remote"
" instance could allow for this by granting at least one privilege: "
"``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:73
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:76
msgid ""
"Possible errors: the connection will fail if the target Tarantool "
"instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:81
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:95
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in ``box.cfg{listen=...}``. The alternative way of listening is"
" via the URI specified in ``console.listen(...)``. This alternative way "
"is called \"administrative\" or simply :ref:`\"admin port\" <admin-"
"security>`. The listening is usually over a local host with a Unix domain"
" socket."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:102
msgid "the URI of the local instance"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:104
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, "
"so it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, "
"for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:112
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:133
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:137
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the Tarantool instance with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:142
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:151
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using Tarantool as a client or the user is using Tarantool via "
"``console.connect()``, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is "
"`true`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:160
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:162
msgid ""
"The default end-of-request marker is a newline (line feed). Custom "
"markers are not necessary because Tarantool can tell when a multi-line "
"request has not ended (for example, if it sees that a function "
"declaration does not have an end keyword). Nonetheless for special needs,"
" or for entering multi-line requests in older Tarantool versions, you can"
" change the end-of-request marker. As a result, newline alone is not "
"treated as end of request."
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:170
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:172
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/1.6/reference/reference_lua/console.rst:176
#, fuzzy
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"    statement_1 = 'a'\n"
"    statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"

#: ../doc/1.6/reference/reference_lua/crypto.rst:39
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/1.6/reference/reference_lua/crypto.rst:43
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's crypto module "
"supports ten types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` module. The functions "
"in crypto are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:55
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:58
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:59
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:60
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:61
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:64
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:66
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:67
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:68
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:69
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:71
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:75
msgid "crypto.cipher.aes128.cbc.encrypt('string','KEY-567890123456','INITIALIZATION-6')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:85
msgid ""
"Pass or return a digest derived from the string. The twelve choices of "
"algorithms:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:88
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:89
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:90
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:91
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:92
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:93
msgid "ripemd160 -"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:94
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:95
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:96
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:97
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:98
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:99
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:103
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:110
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:112
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions.."
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:118
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:133
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:135
msgid ""
"The following functions are equivalent. For example, the ``digest`` "
"function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/1.6/reference/reference_lua/crypto.rst:138
msgid ""
"crypto.cipher.aes256.cbc.encrypt(string, key) == "
"digest.aes256cbc.encrypt(string, key)\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:37
msgid "Module `csv`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:41
msgid ""
"The csv module handles records formatted according to Comma-Separated-"
"Values (CSV) rules."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:44
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:46
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:48
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:49
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:50
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:51
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:52
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:58
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:60
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to"
" designate end-of-field"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:62
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte "
"character to designate encloser of string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:64
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to "
"read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:66
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to "
"skip at the start (usually for a header)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:73
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:77
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:79
#: ../doc/1.6/reference/reference_lua/csv.rst:205
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:80
msgid "loaded_value"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:85
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:88
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:100
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:103
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:110
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:112
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:120
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and "
"example respectively:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:124
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:151
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:157
#: ../doc/1.6/reference/reference_lua/csv.rst:203
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:159
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:160
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:162
msgid "dumped_value"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:163
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:167
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:169
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:181
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:183
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:199
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time. Use of an iterator is strongly recommended if the amount of data "
"is large (ten or more megabytes)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:207
msgid "Lua iterator function"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:208
msgid "iterator function"
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:212
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/csv.rst:217
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:39
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/1.6/reference/reference_lua/digest.rst:43
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"digest module supports several types of cryptographic hash functions "
"(AES_, MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function"
" (CRC32_), two functions for base64_, and two non-cryptographic hash "
"functions (guava_, murmur_). Some of the digest functionality is also "
"present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:51
msgid "The functions in digest are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:56
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:60
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:64
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:68
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:72
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:76
msgid ""
"Returns 160-bit binary string = digest made with SHA-0.|br| Not "
"recommended."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:81
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:85
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:89
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:93
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:97
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:101
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:105
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:109
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:113
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:117
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:121
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:125
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:129
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:133
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:137
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:139
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ "
"polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to "
"be compatible with other checksum functions in other programming "
"languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:144
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:151
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:153
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:160
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:166
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:173
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:175
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:180
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:190
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:195
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:202
msgid "Incremental methods in the digest module"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:204
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:210
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:232
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:236
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:262
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/digest.rst:265
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:39
msgid "Database error codes"
msgstr "Коды ошибок от базы данных"

#: ../doc/1.6/reference/reference_lua/errcodes.rst:41
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:52
msgid "**List of error codes**"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:58
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:58
msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:61
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:61
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:64
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:64
msgid ""
"Out of memory: :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` "
"limit has been reached."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:68
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:68
msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:72
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:72
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:75
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:75
msgid "The specified space does not exist."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:78
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:78
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:81
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:81
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:84
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:84
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:89
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:89
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:92
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:92
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:98
msgid "Handling errors"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:100
msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:103
msgid "Invoke with pcall."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst
#, fuzzy
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../doc/1.6/reference/reference_lua/errcodes.rst
msgid "say"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst
#, fuzzy
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../doc/1.6/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:118
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:121
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:123
msgid ""
"To make a new error and pass it on, the box.error module provides "
":ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:126
msgid ""
"To find the last error, the box.error module provides "
":ref:`box.error.last() <box_error-last>`. (There is also a way to find "
"the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:131
msgid "Log."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:133
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errcodes.rst:135
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-logger>` configuration parameter."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:39
msgid "Module `errno`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:43
msgid "The ``errno`` module provides:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:45
msgid "a function :ref:`strerror() <errno-strerror>`,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:46
msgid "an operator :ref:`errno() <errno-errno>`, and"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:47
msgid ""
"a `metatable <https://www.lua.org/pil/13.html>`_ with constant error "
"names."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:49
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return "
"operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:57
msgid ""
"Return an error number for the last operating-system-related function, or"
" 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:60
msgid "integer"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:66
msgid ""
"Return a string, given an error number. The string will contain the text "
"of the conventional error message for the current operating system. If "
"``code`` is not supplied, the error message will be for the last "
"operating-system-related function, or 0."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:71
msgid "number of an operating-system error"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:77
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-"
"open>` which causes error 2 (``errno.ENOENT``). The display includes the "
"error number, the associated error string, and the error name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:81
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:106
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/1.6/reference/reference_lua/errno.rst:109
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:41
msgid "The ``fiber`` module allows for creating, running and managing *fibers*."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:43
msgid ""
"A fiber is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*. A fiber has three "
"possible states: **running**, **suspended** or **dead**. When a fiber is "
"created with :ref:`fiber.create() <fiber-create>`, it is running. When a "
"fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is "
"suspended. When a fiber ends (because the fiber function ends), it is "
"dead."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:51
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:55
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:66
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:73
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:78
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:91
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:93
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst
msgid "Return"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:96
msgid "created fiber object"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst
msgid "Rtype"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:101
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:120
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:125
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:138
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:140
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:145
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:158
msgid ""
"Yield control to the transaction processor thread and sleep for the "
"specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:161
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:165
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:175
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:179
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:189
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:191
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:196
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:207
msgid "Return information about all fibers."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:209
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:215
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:233
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:237
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst
#, fuzzy
msgid "Exception"
msgstr "Репликация"

#: ../doc/1.6/reference/reference_lua/fiber.rst:238
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:242
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:254
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:259
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:272
#: ../doc/1.6/reference/reference_lua/fiber.rst:293
#: ../doc/1.6/reference/reference_lua/fiber.rst:317
#: ../doc/1.6/reference/reference_lua/fiber.rst:337
#: ../doc/1.6/reference/reference_lua/fiber.rst:361
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create"
" <fiber-create>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:274
msgid "id of the fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:279
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:295
msgid "name of the fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:300
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:311
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:319
msgid "the new name of the fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:325
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:335
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:340
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:345
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:356
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:id() <fiber_object-id>` will cause "
"``error: the fiber is dead``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:366
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:370
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program send\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:381
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The storage is garbage-collected when "
":samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:390
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: "
"fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:421
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:427
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:431
#: ../doc/1.6/reference/reference_lua/fiber.rst:450
msgid "num"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:435
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:447
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:454
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:464
msgid "Example Of Fiber Use"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:466
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each "
"iteration of the loop adds 1 to a global variable named gvar, then goes "
"to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() "
"<fiber-yield>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:471
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:484
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:487
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:495
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:497
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:503
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:508
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:515
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber.rst:520
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:37
msgid "Submodule `fiber-ipc`"
msgstr "Модуль `fiber-ipc`"

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:39
msgid ""
"The ``fiber-ipc`` submodule allows sending and receiving messages between"
" different processes. The words \"different processes\" in this context "
"mean different connections, different sessions, or different fibers."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:44
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section. Call the other"
" ``fiber-ipc`` routines, via channel, to send messages, receive messages,"
" or check ipc status. Message exchange is synchronous. The channel is "
"garbage collected when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:57
msgid "Channel"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:61
msgid "Create a new communication channel."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:63
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:67
msgid "new channel."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:68
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:74
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:77
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:78
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:79
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:87
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:93
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:96
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:97
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:102
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:106
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:108
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:113
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:115
msgid "the number of messages."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:120
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:122
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:129
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:132
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:137
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:140
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:145
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:153
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fiber_ipc.rst:157
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:39
msgid "Module `fio`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:43
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:47
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:49
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:50
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:51
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for "
"example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:60
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:64
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:66
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:67
#: ../doc/1.6/reference/reference_lua/fio.rst:84
#: ../doc/1.6/reference/reference_lua/fio.rst:103
msgid "path name"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:72
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:81
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:85
msgid "suffix"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:87
msgid "file name"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:92
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:101
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:105
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:110
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:121
msgid "Common file manipulations"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:125
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type \"man 2 umask\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:128
msgid "mask bits."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:129
msgid "previous mask bits."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:134
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:144
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\""
" or \"man 2 stat\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:147
msgid "path name of file."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:148
msgid ""
"fields which describe the file's block size, creation time, size, and "
"other attributes."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:152
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include "
"methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:155
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:156
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:157
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:158
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:159
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:160
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:161
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:163
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:167
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:193
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2"
" rmdir\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:196
msgid "path of directory."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:197
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:200
#: ../doc/1.6/reference/reference_lua/fio.rst:296
#: ../doc/1.6/reference/reference_lua/fio.rst:338
#: ../doc/1.6/reference/reference_lua/fio.rst:354
#: ../doc/1.6/reference/reference_lua/fio.rst:482
#: ../doc/1.6/reference/reference_lua/fio.rst:556
msgid "true if success, false if failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:205
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:214
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:218
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:219
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:222
#: ../doc/1.6/reference/reference_lua/fio.rst:390
#: ../doc/1.6/reference/reference_lua/fio.rst:506
#: ../doc/1.6/reference/reference_lua/socket.rst:381
msgid "Possible errors: nil."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:226
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:237
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:241
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:250
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:254
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:266
msgid ""
"Functions to create and delete links. For details type \"man readlink\", "
"\"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:269
msgid "existing file name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:270
msgid "linked name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:272
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if "
"success, false if failure. ``fio.readlink`` returns the link value if "
"success, nil if failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:278
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:291
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:293
msgid "original name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:294
msgid "new name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:301
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:311
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:314
msgid "new user uid."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:315
msgid "new group uid."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:316
msgid "new permissions"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:320
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:333
msgid ""
"Reduce file size to a specified value. For details type \"man 2 "
"truncate\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:343
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:352
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:359
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:375
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:378
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:382
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREAT` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:387
msgid "file handle (later - fh)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:394
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:408
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 "
"close\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:410
#: ../doc/1.6/reference/reference_lua/fio.rst:430
#: ../doc/1.6/reference/reference_lua/fio.rst:461
#: ../doc/1.6/reference/reference_lua/fio.rst:481
#: ../doc/1.6/reference/reference_lua/fio.rst:499
#: ../doc/1.6/reference/reference_lua/fio.rst:522
#: ../doc/1.6/reference/reference_lua/fio.rst:555
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:411
msgid "true if success, false on failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:416
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:426
msgid ""
"Perform read/write random-access operation on a file, without affecting "
"the current seek position of the file. For details type \"man 2 pread\" "
"or \"man 2 pwrite\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:431
#: ../doc/1.6/reference/reference_lua/fio.rst:462
msgid "number of bytes to read"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:432
#: ../doc/1.6/reference/reference_lua/fio.rst:463
msgid "value to write"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:433
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:434
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:439
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:451
msgid ""
"Perform non-random-access read or write on a file. For details type \"man"
" 2 read\" or \"man 2 write\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:456
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:464
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:469
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:478
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:487
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:496
msgid ""
"Shift position in the file to the specified position. For details type "
"\"man 2 seek\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:500
msgid "position to seek to"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:501
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:503
msgid "the new position if success"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:510
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:519
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type \"man 2 "
"stat\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:523
msgid "details about the file."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:528
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:551
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type \"man 2 fsync\" or"
" \"man 2 fdatasync\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:560
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:571
msgid "FIO constants"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:575
msgid ""
"Table with constants which are the same as POSIX flag values on the "
"target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fio.rst:580
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fun.rst:39
msgid "Module `fun`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fun.rst:41
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the "
"module are \"sequence processors\" such as ``map``, ``filter``, "
"``reduce``, ``zip`` -- they take a user-written function as an argument "
"and run it against every element in a sequence, which can be faster or "
"more convenient than a user-written loop. Inside the module are "
"\"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they "
"return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or "
"Erlang."
msgstr ""

#: ../doc/1.6/reference/reference_lua/fun.rst:51
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual ``require`` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
"``require`` request. For example:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/fun.rst:57
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/index.rst:39
#, fuzzy
msgid "Built-in modules reference"
msgstr "Справочник по встроенной библиотеке"

#: ../doc/1.6/reference/reference_lua/index.rst:41
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/1.6/reference/reference_lua/index.rst:45
msgid ""
"Some functions in these modules are analogs to functions from `standard "
"Lua libraries <http://www.lua.org/manual/>`_. For better results, we "
"recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/1.6/reference/reference_lua/index.rst:49
msgid "List of Lua modules"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:39
msgid "Module `json`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:41
msgid ""
"The json module provides JSON manipulation routines. It is based on the "
"`Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON "
"please read `the official documentation`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:51
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:53
#: ../doc/1.6/reference/reference_lua/msgpack.rst:50
#: ../doc/1.6/reference/reference_lua/yaml.rst:50
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:54
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:59
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:89
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:91
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:92
#: ../doc/1.6/reference/reference_lua/yaml.rst:59
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:97
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:119
#: ../doc/1.6/reference/reference_lua/msgpack.rst:69
#: ../doc/1.6/reference/reference_lua/yaml.rst:66
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:124
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:146
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:148
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:149
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:151
#: ../doc/1.6/reference/reference_lua/yaml.rst:103
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:154
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:178
msgid "Configuration settings"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:180
msgid ""
"There are configuration settings which affect the way that Tarantool "
"encodes invalid numbers or types. They are all boolean ``true``/``false``"
" values"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:183
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:184
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:186
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use null for all "
"unrecognizable types"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:188
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:190
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a "
"number\") and 1/0 (which is \"infinity\") as special values rather than "
"nulls or errors:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:193
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:201
msgid "The result of the json.encode request will look like this:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:203
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/json.rst:210
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack "
"<msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:39
msgid "Module `log`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:43
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`log <cfg_logging-logger>` configuration parameter. "
"Diagnostic messages may be either system-generated by the server's "
"internal code, or user-generated with the :samp:`log.{log_level}` "
"function."
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:53
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-"
"logger>`, given log_level_function_name = ``error`` or ``warn`` or "
"``info`` or ``debug``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:57
#, python-format
msgid ""
"The actual output will be a line containing the current timestamp, a "
"module name, 'E' or 'W' or 'I' or 'D' or 'R' depending on "
"``log_level_function_name``, and ``message``. Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`. Messages may contain C-style format specifiers "
"%d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if x is "
"a number and y is a string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:79
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:88
#, fuzzy
msgid "$ less tarantool.txt"
msgstr "$ service tarantool start"

#: ../doc/1.6/reference/reference_lua/log.rst:95
msgid ""
"2...0 [5257] main/101/interactive C> version 1.6.9-1-g3a3f705\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:99
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../doc/1.6/reference/reference_lua/log.rst:101
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:39
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/1.6/reference/reference_lua/msgpack.rst:41
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them,"
" or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:48
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:51
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:56
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:58
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:60
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:61
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:63
msgid "lua object"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:76
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:101
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:103
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:104
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:106
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:110
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:130
msgid "**Result:**"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:135
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:138
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:143
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:145
msgid "and the second encoding means:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:150
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:152
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:160
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:166
msgid "{}"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:166
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:169
msgid "'a'"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:169
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:171
msgid "'false' = c2"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:173
msgid "'true' = c3"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:175
msgid "127"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:175
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:177
msgid "65535"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:177
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:179
msgid "4294967295"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:179
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:181
msgid "'nil' = c0"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:183
msgid "same as nil"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:185
msgid "[0] = 5"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:185
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:188
msgid "[0] = nil"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:188
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:191
msgid "1.5"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:191
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/1.6/reference/reference_lua/msgpack.rst:194
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in"
" the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:39
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/1.6/reference/reference_lua/net_box.rst:41
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS "
"modules <dbms_modules>` reference. In this section the subject is the "
"built-in variant, ``net.box``. This is for connecting to tarantool "
"servers via a network."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:47
msgid ""
"Call ``require('net.box')`` to get a ``net.box`` object, which will be "
"called ``net_box`` for examples in this section. Call ``net_box.new()`` "
"to connect and get a connection object, which will be called ``conn`` for"
" examples in this section. Call the other ``net.box()`` routines, passing"
" ``conn:``, to execute requests on the remote box. Call :ref:`conn:close "
"<socket-close>` to disconnect."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:53
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example when "
"it's necessary to prioritize requests or to use different authentication "
"ids."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:66
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It is re-established automatically after a "
"disconnect. The returned ``conn`` object supports methods for making "
"remote requests, such as select, update or delete."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:71
msgid ""
"For the local tarantool server there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any"
" request can yield, and database state may have changed by the time it "
"regains control."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:81
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:82
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:83
msgid "conn object"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:88
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:97
msgid "Execute a PING command."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:99
msgid "true on success, false on error"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:104
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:110
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:113
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:118
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:124
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:126
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:131
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:138
msgid "Close a connection."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:140
msgid ""
"Connection objects are garbage collected just like any other objects in "
"Lua, so an explicit destruction is not mandatory. However, since close() "
"is a system call, it is good programming practice to close a connection "
"explicitly when it is no longer needed, to avoid lengthy stalls of the "
"garbage collector."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:147
msgid "conn:close()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:153
msgid ""
":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:158
msgid ""
"due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:167
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:172
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:177
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:182
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:187
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:192
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:199
msgid ""
"``conn:call('func', '1', '2', '3')`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:205
msgid "conn:call('function5')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:213
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:221
msgid "conn:eval('return 5+5')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:227
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:232
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:236
msgid ""
"All remote calls support execution timeouts. Using a wrapper object makes"
" the remote connection API compatible with the local one, removing the "
"need for a separate ``timeout`` argument, which the local version would "
"ignore. Once a request is sent, it cannot be revoked from the remote "
"server even if a timeout expires: the timeout expiration only aborts the "
"wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:245
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:247
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. Assume that the database is nearly empty. Assume that the tarantool "
"server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/net_box.rst:252
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:39
msgid "Module `os`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:43
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`, :ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-"
"difftime>`. Most of these functions are described in the Lua manual "
"Chapter 22 `The Operating System Library "
"<https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:58
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:60
msgid "what to execute."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:64
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:80
msgid "Rename a file or directory."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:82
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:83
msgid "changed name of file or directory."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:87
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:100
msgid "Get environment variable."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:102
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:106
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:117
msgid "Remove file or directory."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:119
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:123
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:134
msgid "Return a formatted date."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:136
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:141
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:152
msgid ""
"Exit the program. If this is done on a server instance, then the instance"
" stops."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:156
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:165
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:169
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:180
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:184
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:195
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:199
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:210
msgid ""
"Change the locale. If new-locale-string is not specified, return the "
"current locale."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:215
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:226
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/1.6/reference/reference_lua/osmodule.rst:230
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:37
msgid "Miscellaneous"
msgstr "Разное"

#: ../doc/1.6/reference/reference_lua/other.rst:43
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can"
" be expressed in decimal, binary (for example 0b1010), or hexadecimal "
"(for example -0xffff). The result can be used in arithmetic, and the "
"arithmetic will be 64-bit integer arithmetic rather than floating-point "
"arithmetic. (Operations on an unconverted Lua number use floating-point "
"arithmetic.) The ``tonumber64()`` function is added by Tarantool; the "
"name is global."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:53
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:76
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:80
msgid "Lua code"
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:81
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:84
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:86
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/other.rst:91
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:37
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/1.6/reference/reference_lua/pickle.rst:43
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:49
msgid "**Format specifiers**"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:54
msgid "b, B"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:54
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:57
msgid "s, S"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:57
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:61
msgid "i, I"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:61
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:65
msgid "l, L"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:65
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, low byte first"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:69
msgid "n"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:69
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:73
msgid "N"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:73
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:76
msgid "q, Q"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:76
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, big endian,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:80
msgid "f"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:80
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:83
msgid "d"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:83
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the "
"resulting string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:86
msgid "a, A"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:86
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in "
"the resulting string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:90
msgid "string containing format specifiers"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:91
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:92
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:96
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:100
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:134
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:140
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/1.6/reference/reference_lua/pickle.rst:145
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:39
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/1.6/reference/reference_lua/socket.rst:41
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:47
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:58
msgid "**Socket functions**"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:63
msgid "Purposes"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:63
msgid "Names"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:65
msgid "setup"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:65
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:67
#: ../doc/1.6/reference/reference_lua/socket.rst:69
#: ../doc/1.6/reference/reference_lua/socket.rst:71
#: ../doc/1.6/reference/reference_lua/socket.rst:73
#: ../doc/1.6/reference/reference_lua/socket.rst:77
#: ../doc/1.6/reference/reference_lua/socket.rst:79
#: ../doc/1.6/reference/reference_lua/socket.rst:83
#: ../doc/1.6/reference/reference_lua/socket.rst:85
#: ../doc/1.6/reference/reference_lua/socket.rst:89
#: ../doc/1.6/reference/reference_lua/socket.rst:91
#: ../doc/1.6/reference/reference_lua/socket.rst:95
#: ../doc/1.6/reference/reference_lua/socket.rst:99
#: ../doc/1.6/reference/reference_lua/socket.rst:103
#: ../doc/1.6/reference/reference_lua/socket.rst:107
#: ../doc/1.6/reference/reference_lua/socket.rst:109
#: ../doc/1.6/reference/reference_lua/socket.rst:111
#: ../doc/1.6/reference/reference_lua/socket.rst:115
#: ../doc/1.6/reference/reference_lua/socket.rst:117
#: ../doc/1.6/reference/reference_lua/socket.rst:119
msgid "\"\""
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:67
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:69
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:73
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:75
msgid "sending"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:75
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:79
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:81
msgid "receiving"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:81
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:87
msgid "flag setting"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:87
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:89
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:93
msgid "client/server"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:93
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:95
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:97
msgid "teardown"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:97
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:99
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:101
msgid "error checking"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:101
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:103
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:105
msgid "information"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:105
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:107
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:109
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:113
msgid "state checking"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:113
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:115
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:117
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:119
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:123
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:132
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:141
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:144
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:149
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:157
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:159
msgid "URL or IP address"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:160
msgid "port number"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:161
msgid "timeout"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:162
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:167
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:175
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:179
#: ../doc/1.6/reference/reference_lua/socket.rst:553
#: ../doc/1.6/reference/reference_lua/socket.rst:565
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:184
msgid ""
"``socket.getaddrinfo('tarantool.org', 'http')`` will return variable "
"information such as"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:187
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:206
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:210
msgid "host name or IP"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:211
msgid "host port, may be 0"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:212
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:214
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:217
msgid ""
"The handler-function parameter may be a function name (for example "
"``function_55``), a function declaration (for example ``function () "
"print('!') end``), or a table including handler = function (for example "
"``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:222
msgid "Example:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:224
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:232
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:249
msgid "Parameters:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:239
msgid "Either:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:238
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:240
msgid "port - a number."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:242
#: ../doc/1.6/reference/reference_lua/socket.rst:249
msgid "Or:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:242
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:243
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:245
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:247
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:251
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:256
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:267
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:270
#: ../doc/1.6/reference/reference_lua/socket.rst:393
msgid "the number of bytes sent."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:273
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:279
msgid ""
"Write as much as possible data to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:286
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:290
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:293
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:306
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:311
#: ../doc/1.6/reference/reference_lua/socket.rst:333
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:313
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:315
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:318
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:328
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:336
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:344
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:352
msgid "a socket object on success"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:355
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:361
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:363
msgid ""
"On Linux the listen ``backlog`` backlog may be from "
"/proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:367
msgid "true for success, false for error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:368
msgid "boolean."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:374
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:378
msgid "new socket if success."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:387
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:396
#: ../doc/1.6/reference/reference_lua/socket.rst:408
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:402
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:405
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:406
msgid "string, table"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:412
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:416
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:426
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:428
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:430
#: ../doc/1.6/reference/reference_lua/tap.rst:82
#: ../doc/1.6/reference/reference_lua/tap.rst:101
#: ../doc/1.6/reference/reference_lua/tap.rst:133
#: ../doc/1.6/reference/reference_lua/tap.rst:164
#: ../doc/1.6/reference/reference_lua/tap.rst:175
#: ../doc/1.6/reference/reference_lua/tap.rst:192
#: ../doc/1.6/reference/reference_lua/tap.rst:200
msgid "true or false."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:437
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when its userdata is garbage collected by "
"Lua."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:440
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:449
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:452
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:454
msgid "number, string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:460
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:464
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:465
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:466
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:467
msgid "SO_DEBUG"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:468
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:469
msgid "SO_ERROR"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:470
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:471
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:472
msgid "SO_MARK"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:473
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:474
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:475
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:476
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:477
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:478
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:479
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:480
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:481
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:482
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:483
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:484
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:485
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:486
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:487
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:488
msgid "SO_TYPE"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:490
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:496
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:502
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:507
msgid "new active and timeout values."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:513
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:514
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:515
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:517
msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:524
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:526
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:532
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:534
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:540
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:542
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:548
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:560
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:572
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:575
msgid "file descriptor"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:576
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:577
msgid "number of seconds to wait"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:579
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:582
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:586
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:594
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:596
msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:602
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:633
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:635
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:641
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:678
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:680
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:685
msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:688
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:690
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:705
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:712
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:717
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:720
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/1.6/reference/reference_lua/socket.rst:724
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/strict.rst:39
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/1.6/reference/reference_lua/strict.rst:43
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or"
" off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""

#: ../doc/1.6/reference/reference_lua/strict.rst:48
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/1.6/reference/reference_lua/strict.rst:54
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:37
msgid "Module `tap`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:39
msgid ""
"The tap module streamlines the testing of other modules. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:49
msgid "Initialize."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:51
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:55
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:56
msgid "taptest"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:59
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:68
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:75
msgid ""
"Checks the number of tests performed. This check should only be done "
"after all planned tests are complete, so ordinarily ``taptest:check()`` "
"will only appear at the end of a script."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:79
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not "
"equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:87
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:89
msgid "the message to be displayed."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:94
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:98
msgid "an expression which is true or false"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:99
#: ../doc/1.6/reference/reference_lua/tap.rst:131
#: ../doc/1.6/reference/reference_lua/tap.rst:142
#: ../doc/1.6/reference/reference_lua/tap.rst:163
#: ../doc/1.6/reference/reference_lua/tap.rst:173
#: ../doc/1.6/reference/reference_lua/tap.rst:190
#: ../doc/1.6/reference/reference_lua/tap.rst:205
msgid "name of test"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:106
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:128
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:138
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:148
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:158
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:161
#: ../doc/1.6/reference/reference_lua/tap.rst:171
#: ../doc/1.6/reference/reference_lua/tap.rst:203
msgid "actual result"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:162
#: ../doc/1.6/reference/reference_lua/tap.rst:172
#: ../doc/1.6/reference/reference_lua/tap.rst:204
msgid "expected result"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:169
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:186
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:197
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:215
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:219
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:233
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tap.rst:235
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/1.6/reference/reference_lua/tarantool.rst:37
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/1.6/reference/reference_lua/tarantool.rst:41
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tarantool.rst:47
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info() <box_introspection-box_info>` but use of the tarantool "
"module is recommended."
msgstr ""

#: ../doc/1.6/reference/reference_lua/tarantool.rst:54
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.6.9-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uri.rst:37
#, fuzzy
msgid "Module `uri`"
msgstr "Модуль `strict`"

#: ../doc/1.6/reference/reference_lua/uri.rst:39
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard "
"<https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like "
"this: |br| [scheme:]scheme-specific-part[#fragment] |br| A common type, a"
" hierarchical URI, looks like this: |br| "
"[scheme:][//authority][path][?query][#fragment] |br| For example the "
"string `'https://tarantool.org/x.html#y'` has three components: https is "
"the scheme, tarantool.org/x.html is the path, and y is the fragment. "
"Tarantool's URI module provides a routine which converts URI strings into"
" their components."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uri.rst:56
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uri.rst
msgid "returns"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uri.rst:57
msgid ""
"URI-components-table. Possible components are fragment, host, login, "
"password, path, query, scheme, service."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uri.rst:58
#, fuzzy
msgid "Table"
msgstr "Lua table"

#: ../doc/1.6/reference/reference_lua/uri.rst:62
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:37
msgid "Module `uuid`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:39
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:45
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:47
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:48
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:49
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:51
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:53
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:54
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:55
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:56
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:58
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:60
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:66
msgid "A nil object"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:72
#: ../doc/1.6/reference/reference_lua/uuid.rst:79
#: ../doc/1.6/reference/reference_lua/uuid.rst:86
msgid "a UUID"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:73
#: ../doc/1.6/reference/reference_lua/uuid.rst:95
#: ../doc/1.6/reference/reference_lua/uuid.rst:103
msgid "cdata"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:80
msgid "16-byte string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:87
msgid "36-byte binary string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:93
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:94
#: ../doc/1.6/reference/reference_lua/uuid.rst:102
msgid "converted UUID"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:101
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:111
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:113
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:114
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:115
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:116
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:118
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:120
#: ../doc/1.6/reference/reference_lua/uuid.rst:127
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:121
msgid "16-byte binary string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:128
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:134
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:139
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/1.6/reference/reference_lua/uuid.rst:146
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:39
msgid "Module `yaml`"
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:41
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:48
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:51
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:56
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:58
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:72
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:95
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:98
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:99
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:100
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:101
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:106
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_lua/yaml.rst:142
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:39
#, fuzzy
msgid "SQL DBMS Modules"
msgstr ""
"#-#-#-#-#  reference.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL DBMS\n"
"#-#-#-#-#  reference_rock.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL СУБД"

#: ../doc/1.6/reference/reference_rock/dbms.rst:41
msgid ""
"The discussion here in the reference is about incorporating and using two"
" modules that have already been created: the \"SQL DBMS rocks\" for MySQL"
" and PostgreSQL."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:45
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: "
"another DBMS, and Tarantool. The module which connects Tarantool to "
"another DBMS may be called a \"connector\". Within the module there is a "
"shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:50
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for "
"Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:53
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL"
" statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a "
"\"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be "
"useful even if that was all Tarantool could do. But of course Tarantool "
"is also a DBMS, so the module also is useful for any operations, such as "
"database copying and accelerating, which work best when the application "
"can work on both SQL and Tarantool inside the same Lua routine. The "
"methods for connect/select/insert/etc. are similar to the ones in the "
":ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:64
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very "
"similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL "
"Example\" -- contain some redundancy."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:72
msgid "MySQL Example"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:74
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C "
"connector is used. The package that matters most is the MySQL client "
"developer package, typically named something like libmysqlclient-dev. The"
" file that matters most from this package is libmysqlclient.so or a "
"similar name. One can use ``find`` or ``whereis`` to see what directories"
" these files are installed in."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:81
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server instance. After that, "
"one can pass any MySQL statement to the server instance and receive "
"results, including multiple result sets."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:87
#: ../doc/1.6/reference/reference_rock/dbms.rst:440
msgid "Installation"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:89
#: ../doc/1.6/reference/reference_rock/dbms.rst:442
msgid ""
"Check the instructions for `downloading and installing a binary package "
"<http://tarantool.org/download.html>`_ that apply for the environment "
"where Tarantool was installed. In addition to installing ``tarantool``, "
"install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:95
#: ../doc/1.6/reference/reference_rock/dbms.rst:448
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:99
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:103
#: ../doc/1.6/reference/reference_rock/dbms.rst:456
msgid "With LuaRocks"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:105
#: ../doc/1.6/reference/reference_rock/dbms.rst:458
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:112
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:118
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:124
#: ../doc/1.6/reference/reference_rock/dbms.rst:477
msgid "With GitHub"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:126
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there,"
" saying:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:128
msgid ""
"git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:135
#: ../doc/1.6/reference/reference_rock/dbms.rst:488
msgid ""
"At this point it is a good idea to check that the installation produced a"
" file named ``driver.so``, and to check that this file is on a directory "
"that is searched by the ``require`` request."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:141
#: ../doc/1.6/reference/reference_rock/dbms.rst:494
msgid "Connecting"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:143
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will "
"assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:146
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:150
#: ../doc/1.6/reference/reference_rock/dbms.rst:503
msgid "Now, say:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:155
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:157
#: ../doc/1.6/reference/reference_rock/dbms.rst:510
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:159
#: ../doc/1.6/reference/reference_rock/dbms.rst:512
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:160
#: ../doc/1.6/reference/reference_rock/dbms.rst:513
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:161
#: ../doc/1.6/reference/reference_rock/dbms.rst:514
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system "
"user name"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:162
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:163
#: ../doc/1.6/reference/reference_rock/dbms.rst:516
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:164
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:166
msgid ""
"The option names, except for `raise`, are similar to the names that "
"MySQL's mysql client uses, for details see the MySQL manual at "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option "
"should be set to :codenormal:`true` if errors should be raised when "
"encountered. To connect with a Unix socket rather than with TCP, specify "
"``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:173
#: ../doc/1.6/reference/reference_rock/dbms.rst:520
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:175
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:191
#: ../doc/1.6/reference/reference_rock/dbms.rst:532
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:193
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:209
#: ../doc/1.6/reference/reference_rock/dbms.rst:551
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:213
#: ../doc/1.6/reference/reference_rock/dbms.rst:555
msgid "How to ping"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:215
#: ../doc/1.6/reference/reference_rock/dbms.rst:557
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:220
#: ../doc/1.6/reference/reference_rock/dbms.rst:562
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:224
#: ../doc/1.6/reference/reference_rock/dbms.rst:567
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:233
#: ../doc/1.6/reference/reference_rock/dbms.rst:576
msgid "Executing a statement"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:235
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:240
#: ../doc/1.6/reference/reference_rock/dbms.rst:583
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:242
#: ../doc/1.6/reference/reference_rock/dbms.rst:585
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks "
"(\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:248
msgid ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:261
#: ../doc/1.6/reference/reference_rock/dbms.rst:603
msgid "Closing connection"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:263
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:268
#: ../doc/1.6/reference/reference_rock/dbms.rst:610
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:272
#: ../doc/1.6/reference/reference_rock/dbms.rst:614
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:278
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:285
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of MySQL "
"had been installed on ~/mysql-5.5. The mysqld server instance is already "
"running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:289
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.6/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.6/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.6.9-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:370
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool "
"doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:373
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:381
msgid ""
"Create a Lua function that will connect to the MySQL server instance, "
"(using some factory default values for the port and user and password), "
"retrieve one row, and display the row. For explanations of the statement "
"types used here, read the Lua tutorial earlier in the Tarantool user "
"manual."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:386
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:410
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that "
"was inserted into the MySQL database. And now it's been selected with the"
" Tarantool client."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:417
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:419
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been "
"installed. More recent versions should also work. The package that "
"matters most is the PostgreSQL developer package, typically named "
"something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:424
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:428
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL "
"files are present and must explicitly state where they are when building "
"the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to "
"see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:434
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server instance. "
"After that, one can pass any PostgreSQL statement to the server instance "
"and receive results."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:452
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to "
"install:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:465
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:471
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:479
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:481
msgid ""
"git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:496
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume "
"that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:499
msgid "pg = require('pg')"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:508
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:515
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, "
"default value is blank"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:518
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:522
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:534
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:578
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:591
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:605
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:620
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:627
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of "
"PostgreSQL had been installed on /usr. The PostgreSQL server instance is "
"already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:631
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master"
"\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.6/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.6/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.9.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears "
"here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.6.9-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:705
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:708
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:716
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve"
" one row, and display the row. For explanations of the statement types "
"used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:721
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/dbms.rst:746
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row "
"that was inserted into the PostgreSQL database. And now it's been "
"selected with the Tarantool client."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:39
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/1.6/reference/reference_rock/expirationd.rst:41
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, "
"let us look at expirationd, which Tarantool supplies on GitHub_ with an "
"Artistic license. The expirationd.lua program is lengthy (about 500 "
"lines), so here we will only highlight the matters that will be enhanced "
"by studying the full source later."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:46
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:54
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being"
" done with a :doc:`fiber<../reference_lua/fiber>`. The program is making "
"a fiber and turning control over to it so it runs occasionally, goes to "
"sleep, then comes back for more."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:59
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:68
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index "
"of the space that is being scanned\", and within it, if the tuple is "
"\"expired\" (for example, if the tuple has a timestamp field which is "
"less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:73
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:84
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` "
"which does a \"delete\" of a tuple from its original space. First the fun"
" :ref:`fun <fun-module>` module is used, specifically fun.map_. "
"Remembering that :codenormal:`index[0]` is always the space's primary "
"key, and "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is "
"always the field number for key part :codeitalic:`N`, fun.map() is "
"creating a table from the primary-key values of the tuple. The result of "
"fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:94
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:99
msgid ""
"At this point, if the above explanation is worthwhile, it's clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other "
"fibers can operate at the same time, and - whenever it finds a tuple that"
" has expired - deletes it from this space. Now the "
"\"``expirationd_run_task()``\" function can be used in a test which "
"creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:108
msgid ""
"For those who like to see things run, here are the exact steps to get "
"expirationd through the test."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:111
msgid ""
"Get ``expirationd.lua``. There are standard ways - it is after all part "
"of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_"
"  - but for this purpose just copy the contents of expirationd.lua_ to a "
"default directory."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:114
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:115
msgid "Execute these requests:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:117
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'num'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:140
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should "
"already be familiar."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:145
msgid ""
"The function which will be supplied to expirationd is "
":codenormal:`is_tuple_expired`, which is saying \"if the second field of "
"the tuple is less than the :ref:`current time <fiber-time>`  , then "
"return true, otherwise return false\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:150
msgid ""
"The key for getting the rock rolling is ``expd = "
"require('expirationd')``. The \"``require``\" function is what reads in "
"the program; it will appear in many later examples in this manual, when "
"it's necessary to get a module that's not part of the Tarantool kernel. "
"After the Lua variable expd has been assigned the value of the "
"expirationd module, it's possible to invoke the module's ``run_task()`` "
"function."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:157
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has "
"had time to do its iterations through the spaces, ``expd.task_stats()`` "
"will print out a report showing how many tuples have expired -- "
"\"expired_count: 0\". After sleeping for two more seconds, "
"``expd.task_stats()`` will print out a report showing how many tuples "
"have expired -- \"expired_count: 1\". This shows that the "
"is_tuple_expired() function eventually returned \"true\" for one of the "
"tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/1.6/reference/reference_rock/expirationd.rst:167
msgid ""
"Of course, expirationd can be customized to do different things by "
"passing different parameters, which will be evident after looking in more"
" detail at the source code."
msgstr ""

#: ../doc/1.6/reference/reference_rock/index.rst:37
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/1.6/reference/reference_rock/index.rst:39
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:39
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/1.6/reference/reference_rock/shard.rst:43
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple "
"nodes, with a Tarantool database server instance on each node. With this "
"arrangement, each instance is handling only a subset of the total data, "
"so larger loads can be handled by simply adding more computers to a "
"network."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:48
msgid ""
"The Tarantool shard module has facilities for creating shards, as well as"
" analogues for the data-manipulation functions of the box library "
"(select, insert, replace, update, delete)."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:52
msgid "First some terminology:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:55
msgid "**Consistent Hash**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:57
msgid ""
"The shard module distributes according to a hash algorithm, that is, it "
"applies a hash function to a tuple's primary-key value in order to decide"
" which shard the tuple belongs to. The hash function is `consistent`_ so "
"that changing the number of servers will not affect results for many "
"keys. The specific hash function that the shard module uses is "
":ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:63
msgid "**Instance**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:65
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes "
"called a \"server instance\". Usually each shard is associated with one "
"instance, or, if both sharding and replicating are going on, each shard "
"is associated with one replica set."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:69
msgid "**Queue**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:71
msgid ""
"A temporary list of recent update requests. Sometimes called "
"\"batching\". Since updates to a sharded database can be slow, it may "
"speed up throughput to send requests to a queue rather than wait for the "
"update to finish on every node. The shard module has functions for adding"
" requests to the queue, which it will process without further "
"intervention. Queuing is optional."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:77
msgid "**Redundancy**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:79
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:80
msgid "**Replica**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:82
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:83
msgid "**Replica set**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:85
msgid ""
"Often a single shard is associated with a single instance; however, often"
" the shard is replicated. When a shard is replicated, the multiple "
"instances (\"replicas\"), which handle the shard's replicated data, are a"
" \"replica set\"."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:89
msgid "**Replicated data**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:91
msgid ""
"A complete copy of the data. The shard module handles both sharding and "
"replication. One shard can contain one or more replicated data copies. "
"When a write occurs, the write is attempted on every replicated data copy"
" in turn. The shard module does not use the built-in replication feature."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:95
msgid "**Shard**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:97
msgid ""
"A subset of the tuples in the database partitioned according to the value"
" returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:101
msgid "**Zone**"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:103
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is "
"a single computer with a single Tarantool-server instance. A shard's "
"replicated data copies should be in different zones."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:108
msgid ""
"The shard package is distributed separately from the main tarantool "
"package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:111
#, fuzzy
msgid "sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.6/reference/reference_rock/shard.rst:115
msgid ""
"Or, download from github tarantool/shard and tarantool/connpool and use "
"the Lua files as described in the README. Then, before using the module, "
"say ``shard = require('shard')``"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:119
msgid "The most important function is:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:124
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:126
msgid ""
"This must be called for every shard. The shard-configuration is a table "
"with these fields:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:129
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:130
msgid "login (the user name which applies for accessing via the shard module)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:131
msgid "password (the password for the login)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:132
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:133
msgid ""
"binary (a port number that this host is listening on, on the current "
"host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:136
msgid ""
"Possible Errors: Redundancy should not be greater than the number of "
"servers; the servers must be alive; two replicated data copies of the "
"same shard should not be in the same zone."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:142
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:144
msgid ""
"The number of replicated data copies per shard (redundancy) is 3. The "
"number of instances is 3. The shard module will conclude that there is "
"only one shard."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:148
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:169
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:171
msgid ""
"This describes three shards. Each shard has two replicated data copies. "
"Since the number of servers is 7, and the number of replicated data "
"copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of"
" the servers will not be used. This is not necessarily an error, because "
"perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:176
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:202
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:209
msgid ""
"Every data-access function in the box module has an analogue in the shard"
" module, so (for example) to insert in table T in a sharded database one "
"simply says ``shard.T:insert{...}`` instead of "
"``box.space.T:insert{...}``. A ``shard.T:select{}`` request without a "
"primary key will search all shards."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:217
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:224
msgid ""
"Every queued data-access function has an analogue in the shard module. "
"The user must add an operation_id. The details of queued data-access "
"functions, and of maintenance-related functions, are on `the shard "
"section of github`_."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:230
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:232
msgid ""
"There is only one shard, and that shard contains only one replicated data"
" copy. So this isn't illustrating the features of either replication or "
"sharding, it's only illustrating what the syntax is, and what the "
"messages look like, that anyone could duplicate in a minute or two with "
"the magic of cut-and-paste."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:237
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.6/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:263
msgid ""
"If one cuts and pastes the above, then the result, showing only the "
"requests and responses for shard.init and shard.tester, should look "
"approximately like this:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:267
msgid ""
"tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:296
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:298
msgid ""
"There are two shards, and each shard contains one replicated data copy. "
"This requires two nodes. In real life the two nodes would be two "
"computers, but for this illustration the requirement is merely: start two"
" shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:305
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.6/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:333
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:335
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.6/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:363
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It "
"will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:367
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:369
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:376
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by "
"Terminal #2, via the shard module."
msgstr ""

#: ../doc/1.6/reference/reference_rock/shard.rst:379
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:37
msgid "Module `tdb`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:39
msgid ""
"The Tarantool Debugger (abbreviation = tdb) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining"
" variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding "
"hints."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:45
msgid ""
"It is not supplied as part of the Tarantool repository; it must be "
"installed separately. Here is the usual way:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:48
msgid ""
"git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:55
msgid ""
"To initiate tdb within a Lua program and set a breakpoint, edit the "
"program to include these lines:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:58
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:63
msgid ""
"To start the debugging session, execute the Lua program. Execution will "
"stop at the breakpoint, and it will be possible to enter debugging "
"commands."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:68
msgid "Debugger Commands"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:72
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:71
msgid ""
"Backtrace -- show the stack (in red), with program/function names and "
"line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:75
msgid ":codebold:`c`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:75
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:82
msgid ":codebold:`e`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:78
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This "
"is particularly useful for displaying the values of the program's "
"variables. Other debugger commands will not work until one exits "
"evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:85
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:85
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:89
msgid ":codebold:`f`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:88
msgid ""
"Display the fiber id, the program name, and the percentage of memory "
"used, as a table."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:92
msgid ":codebold:`n`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:92
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:95
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:95
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:98
msgid ":codebold:`h`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:98
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:102
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:101
msgid ""
"Display names and values of variables, for example the control variables "
"of a Lua \"for\" statement."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:105
msgid ":codebold:`q`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:105
msgid "Quit immediately."
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:109
msgid "Example Session"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:111
msgid ""
"Put the following program in a default directory and call it "
"\"example.lua\":"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:113
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:121
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:126
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:128
#: ../doc/1.6/reference/reference_rock/tdb.rst:153
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:133
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:140
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and "
"the current line -- line 3 of example.lua -- is the default color. Now "
"enter six debugger commands:"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:144
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:158
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/1.6/reference/reference_rock/tdb.rst:175
msgid "Another debugger example can be found here_."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:39
#, fuzzy
msgid "Utility `tarantoolctl`"
msgstr "Утилита tarantoolctl"

#: ../doc/1.6/reference/tarantoolctl.rst:41
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool instances. It "
"is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:44
msgid "The command format is:"
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:46
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:50
msgid ""
"COMMAND is one of the following: start, stop, logrotate, status, enter, "
"restart, eval, check, connect, cat, play."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:53
msgid "NAME is the name of an :ref:`instance file <admin-instance_file>`."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:55
msgid "FILE is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:57
msgid "URI is the URI of some Tarantool instance."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:59
msgid "OPTIONS are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:61
msgid "See also:"
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:63
msgid "Detailed reference upon ``man tarantoolctl`` or ``tarantoolctl --help``."
msgstr ""

#: ../doc/1.6/reference/tarantoolctl.rst:64
msgid "Usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:37
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/1.6/tutorials/c_tutorial.rst:39
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:46
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/1.6/tutorials/c_tutorial.rst:48
msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or "
"with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This "
"tutorial only is about the third option, C stored procedures. In fact the"
" routines are always \"C functions\" but the phrase \"stored procedure\" "
"is commonly used for historical reasons."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:55
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are three tasks. The first --"
" :code:`easy.c` -- prints \"hello world\". The second -- :code:`harder.c`"
" -- decodes a passed parameter value. The third -- :code:`hardest.c` -- "
"uses the C API to do DBMS work."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:61
msgid ""
"After following the instructions, and seeing that the results are what is"
" described here, users should feel confident about writing their own "
"stored procedures."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:65
msgid "**Preparation**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:67
msgid ""
"Check that these items exist on the computer: |br| * Tarantool 1.6 |br| *"
" A gcc compiler, any modern version should work |br| * \"module.h\" and "
"files #included in it |br| * \"msgpuck.h\" |br|"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:73
msgid ""
"The \"module.h\" file will exist if Tarantool 1.6 was installed from "
"source. Otherwise Tarantool's \"developer\" package must be installed. "
"For example on Ubuntu say |br| :code:`sudo apt-get install tarantool-dev`"
" |br| or on Fedora say |br| :code:`dnf -y install tarantool-devel`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:80
msgid ""
"The \"msgpuck.h\" file will exist if Tarantool 1.6 was installed from "
"source. Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:84
msgid ""
"Both module.h and msgpuck.h must be on the include path for the C "
"compiler to see them. For example, if module.h address is "
"/usr/local/include/tarantool/module.h, and msgpuck.h address is "
"/usr/local/include/msgpuck/msgpuck.h, and they are not currently on the "
"include path, say |br| :code:`export "
"CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:90
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:94
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:102
msgid ""
"In plainer language: create a space named capi_test, and make a "
"connection to self named capi_connection."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:105
msgid ""
"Leave the client running. It will be necessary to enter more requests "
"later."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:107
msgid "**easy.c**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:109
msgid ""
"Start another shell. Change directory (cd) so that it is the same as the "
"directory that the client is running on."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:112
msgid "Create a file. Name it easy.c. Put these six lines in it."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:114
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:123
msgid ""
"Compile the program, producing a library file named easy.so: |br| "
":code:`gcc -shared -o easy.so -fPIC easy.c`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:126
#: ../doc/1.6/tutorials/c_tutorial.rst:195
#: ../doc/1.6/tutorials/c_tutorial.rst:278
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:128
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:134
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":ref:`box.schema.func.create <box_schema-func_create>` and "
":ref:`box.schema.user.grant <box_schema-user_grant>` and :ref:`conn:call "
"<net_box-call>`."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:140
msgid "The function that matters is capi_connection:call('easy')."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:142
msgid ""
"Its first job is to find the 'easy' function, which should be easy "
"because by default Tarantool looks on the current directory for a file "
"named easy.so."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:146
msgid ""
"Its second job is to call the 'easy' function. Since the easy() function "
"in easy.c begins with :code:`printf(\"hello world\\n\")`, the words "
"\"hello world\" will appear on the screen."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:150
msgid ""
"Its third job is to check that the call was successful. Since the easy() "
"function in easy.c ends with :code:`return 0`, there is no error message "
"to display and the request is over."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:154
#: ../doc/1.6/tutorials/c_tutorial.rst:296
msgid "The result should look like this:"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:156
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:164
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:166
msgid "**harder.c**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:168
msgid "Go back to the shell where the easy.c program was created."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:170
msgid "Create a file. Name it harder.c. Put these 17 lines in it:"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:172
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:192
msgid ""
"Compile the program, producing a library file named harder.so: |br| "
":code:`gcc -shared -o harder.so -fPIC harder.c`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:197
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:207
msgid ""
"This time the call is passing a Lua table (passable_table) to the "
"harder() function. The harder() function will see it, it's in the "
":code:`char *args` parameter."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:211
msgid ""
"At this point the harder() function will start using functions defined in"
" msgpuck.h, which are documented in `http://rtsisyk.github.io/msgpuck "
"<http://rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\""
" are msgpuck functions that handle data formatted according to the "
"MsgPack_ specification. Passes and returns are always done with this "
"format so one must become acquainted with msgpuck to become proficient "
"with the C API."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:220
msgid ""
"For now, though, it's enough to know that mp_decode_array() returns the "
"number of elements in an array, and mp_decode_uint returns an unsigned "
"integer, from :code:`args`. And there's a side effect: when the decoding "
"finishes, :code:`args` has changed and is now pointing to the next "
"element."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:226
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because "
"there was only one item passed: passable_table. |br| The second displayed"
" line will be \"field_count = 3\" because there are three items in the "
"table. |br| The next three lines will be \"1\" and \"2\" and \"3\" "
"because those are the values in the items in the table."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:233
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:235
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:247
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy "
"at first, but there are routines to do the job, and they're documented, "
"and there aren't very many of them."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:252
msgid "**hardest.c**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:254
msgid ""
"Go back to the shell where the easy.c and the harder.c programs were "
"created."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:257
msgid "Create a file. Name it hardest.c. Put these 13 lines in it:"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:259
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024];\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:275
msgid ""
"Compile the program, producing a library file named hardest.so: |br| "
":code:`gcc -shared -o hardest.so -fPIC hardest.c`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:280
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:287
msgid ""
"This time the C function is doing three things: (1) finding the numeric "
"identifier of the \"capi_test\" space by calling box_space_id_by_name(); "
"|br| (2) formatting a tuple using more msgpuck.h functions; |br| (3) "
"inserting a row using box_insert."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:293
msgid ""
"Now, still on the client, execute this request: |br| "
":code:`box.space.capi_test:select()`"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:298
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:305
msgid ""
"This proves that the hardest() function succeeded, but where did "
"box_space_id_by_name() and box_insert() come from? Answer: the C API. The"
" whole C API is documented :ref:`here <index-c_api_reference>`. The "
"function box_space_id_by_name() is documented :ref:`here <box-"
"box_space_id_by_name>`. The function box_insert() is documented "
":ref:`here <box-box_insert>`."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:311
msgid ""
"Conclusion: the long description of the C API is there for a good reason."
" All of the functions in it can be called from C functions which are "
"called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:317
msgid "**Cleaning up**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:319
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`, and get rid of the capi_test space with "
":ref:`box.schema.capi_test:drop() <box_space-drop>`, and remove the .c "
"and .so files that were created for this tutorial."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:324
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:326
msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named "
":code:`tuple_bench.c`. Examine the Lua file and observe that it is "
"calling a function in the C file, using the same techniques that this "
"tutorial has shown."
msgstr ""

#: ../doc/1.6/tutorials/c_tutorial.rst:333
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and"
" they must work, because releases don't happen if Tarantool doesn't pass "
"the tests."
msgstr ""

#: ../doc/1.6/tutorials/index.rst:39
msgid "Tutorials"
msgstr "Практикум"

#: ../doc/1.6/tutorials/lua_tutorials.rst:39
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/1.6/tutorials/lua_tutorials.rst:41
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:43
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure "
"<c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:44
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:45
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:51
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/1.6/tutorials/lua_tutorials.rst:53
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple "
"should have a constantly-increasing numeric primary-key field and a "
"random alphabetic 10-character string field.”"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:57
msgid ""
"The purpose of the exercise is to show what Lua functions look like "
"inside Tarantool. It will be necessary to employ the Lua math library, "
"the Lua string library, the Tarantool box library, the Tarantool "
"box.tuple library, loops, and concatenations. It should be easy to follow"
" even for a person who has not used either Lua or Tarantool before. The "
"only requirement is a knowledge of how other programming languages work "
"and a memory of the first two chapters of this manual. But for better "
"understanding, follow the comments and the links, which point to the Lua "
"manual or to elsewhere in this Tarantool manual. To further enhance "
"learning, type the statements in with the tarantool client while reading "
"along."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:69
msgid "Configure"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:71
msgid ""
"We are going to use the Tarantool sandbox that was created our "
":ref:`\"Getting started\" exercises <getting_started>`. So there is a "
"single space, and a numeric primary key, and a running Tarantool server "
"instance which also serves as a client."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:78
msgid "Delimiter"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:80
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed"
" within \"delimiters\". They are no longer necessary, and so they will "
"not be used in this tutorial. However, they are still supported. Users "
"who wish to use delimiters, or users of older versions of Tarantool, "
"should check the syntax description for :ref:`declaring a delimiter "
"<console-delimiter>` before proceeding."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:89
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:91
msgid ""
"We will start by making a function that returns a fixed string, “Hello "
"world”."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:93
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:99
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua."
" The function name is string_function. The function has one executable "
"statement, ``return \"hello world\"``. The string \"hello world\" is "
"enclosed in double quotes here, although Lua doesn't care -- one could "
"use single quotes instead. The word \"``end``\" means “this is the end of"
" the Lua function declaration.” To confirm that the function works, we "
"can say"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:106
msgid "string_function()"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:110
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect "
"is that the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:113
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . "
"For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:121
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:136
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:138
msgid ""
"Now that ``string_function`` exists, we can invoke it from another "
"function."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:141
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:149
msgid ""
"We begin by declaring a variable \"``string_value``\". The word "
"\"``local``\" means that string_value appears only in ``main_function``. "
"If we didn't use \"``local``\" then ``string_value`` would be visible "
"everywhere - even by other users using other clients connected to this "
"server instance! Sometimes that's a very desirable feature for inter-"
"client communication, but not this time."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:155
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check "
"that it got the value."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:159
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local "
"Variables and Blocks\"`_ ."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:165
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:182
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:184
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal "
"\"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:188
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:198
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, "
"they're simply overwritten. The first assignment invokes a random-number "
"function in Lua's math library; the parameters mean “the number must be "
"an integer between 65 and 90.” The second assignment invokes an integer-"
"to-character function in Lua's string library; the parameter is the code "
"point of the character. Luckily the ASCII value of 'A' is 65 and the "
"ASCII value of 'Z' is 90 so the result will always be a letter between A "
"and Z."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:206
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:212
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() "
"which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:217
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:234
msgid ""
"... Well, actually it won't always look like this because "
"``math.random()`` produces random numbers. But for the illustration "
"purposes it won't matter what the random string values are."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:240
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:242
msgid ""
"Now that it's clear how to produce one-letter random strings, we can "
"reach our goal of producing a ten-letter string by concatenating ten one-"
"letter strings, in a loop."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:246
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:259
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x "
"equals 10, increment x by 1 for each iteration.” The symbol \"..\" means "
"\"concatenate\", that is, add the string on the right of the \"..\" sign "
"to the string on the left of the \"..\" sign. Since we start by saying "
"that random_string is \"\" (a blank string), the end result is that "
"random_string has 10 random letters. Once again the ``string_function()``"
" can be invoked from ``main_function()`` which can be invoked with "
"``main_function()``."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:267
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:273
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:295
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:297
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible "
"to make a tuple that contains a number and a 10-letter random string, by "
"invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:301
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:310
msgid ""
"Once this is done, t will be the value of a new tuple which has two "
"fields. The first field is numeric: 1. The second field is a random "
"string. Once again the ``string_function()`` can be invoked from "
"``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:315
msgid ""
"For more about Tarantool tuples see Tarantool manual section "
":ref:`Submodule box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:319
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:337
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:339
msgid ""
"Now that it's clear how to make a tuple that contains a number and a "
"10-letter random string, the only trick remaining is putting that tuple "
"into tester. Remember that tester is the first space that was defined in "
"the sandbox, so it's like a database table."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:344
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:353
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second "
"parameter is the tuple value. To be perfectly correct we could have said "
"``box.space.tester:insert(t)`` here, rather than "
"``box.space.tester:replace(t)``, but \"replace\" means “insert even if "
"there is already a tuple whose primary-key value is a duplicate”, and "
"that makes it easier to re-run the exercise even if the sandbox database "
"isn't empty. Once this is done, tester will contain a tuple with two "
"fields. The first field will be 1. The second field will be a random "
"10-letter string. Once again the ``string_function(``) can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``. "
"But ``main_function()`` won't tell the whole story, because it does not "
"return t, it only puts t into the database. To confirm that something got"
" inserted, we'll use a SELECT request."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:367
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:372
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:377
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:398
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:400
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no "
"big deal to figure out how to scale up: instead of inserting with a "
"literal value = 1 for the primary key, insert with a variable value = "
"between 1 and 1 million, in a loop. Since we already saw how to loop, "
"that's a simple thing. The only extra wrinkle that we add here is a "
"timing function."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:406
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:421
msgid ""
"The standard Lua function `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return "
"the number of CPU seconds since the start. Therefore, by getting "
"start_time = number of seconds just before the inserting, and then "
"getting end_time = number of seconds just after the inserting, we can "
"calculate (end_time - start_time) = elapsed time in seconds. We will "
"display that value by putting it in a request without any assignments, "
"which causes Tarantool to send the value to the client, which prints it. "
"(Lua's answer to the C ``printf()`` function, which is ``print()``, will "
"also work.)"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:431
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and "
"Time\"`_. For more on Lua print() see Lua manual `chapter 5 "
"\"Functions\"`_."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:437
msgid ""
"Since this is the grand finale, we will redo the final versions of all "
"the necessary requests: the request that created ``string_function()``, "
"the request that created ``main_function()``, and the request that "
"invokes ``main_function()``."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:442
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:470
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:509
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact "
"one can do more with Tarantool's Lua stored procedures than one can do "
"with stored procedures in some SQL DBMSs), and that it's straightforward "
"to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:514
msgid ""
"What has also been shown is that inserting a million tuples took 37 "
"seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode"
" <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the "
"test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:522
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/1.6/tutorials/lua_tutorials.rst:524
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is "
"a string formatted as JSON. Inside that string there is a JSON numeric "
"field. For each tuple, find the numeric field's value and add it to a "
"'sum' variable. At end, return the 'sum' variable.” The purpose of the "
"exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:530
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:547
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will"
" be used in the function. Actually it's not necessary to declare all "
"variables at the start, and in a long function it would be better to "
"declare variables just before using them. In fact it's not even necessary"
" to declare variables at all, but an undeclared variable is \"global\". "
"That's not desirable for any of the variables that are declared in line "
"1, because all of them are for use only within the function."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:554
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and "
"there are two ways to do it: with :ref:`box.space.space_object:pairs() "
"<box_space-pairs>` or with ``variable = select(...)`` followed by "
":samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred "
"``pairs()`` for this example."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:559
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop "
"will be repeated as long as there is another index key. A tuple is "
"fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:563
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = "
"json.decode(t[2]))``, then the function would abort with an error if it "
"encountered something wrong with the JSON string - a missing colon, for "
"example. By putting the function inside \"``pcall``\" (`protected "
"call`_), we're saying: we want to intercept that sort of error, so if "
"there's a problem just set ``is_valid_json = false`` and we will know "
"what to do about it later."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:570
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` "
"which means decode a JSON string, and the parameter is t[2] which is a "
"reference to a JSON string. There's a bit of hard coding here, we're "
"assuming that the second field in the tuple is where the JSON string was "
"inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:580
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:583
msgid ""
"meaning that the tuple's first field, the primary key field, is a number "
"while the tuple's second field, the JSON string, is a string. Thus the "
"entire statement means \"decode ``t[2]`` (the tuple's second field) as a "
"JSON string; if there's an error set ``is_valid_json = false``; if "
"there's no error set ``is_valid_json = true`` and set ``lua_table =`` a "
"Lua table which has the decoded string\"."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:589
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua"
" table that came from the JSON string. The value in field_name, which is "
"the parameter for the whole function, must be a name of a JSON field. For"
" example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": "
"15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the "
"whole function is invoked with ``sum_json_field(\"Quantity\")``, then "
"``field_value = lua_table[field_name]`` is effectively the same as "
"``field_value = lua_table[\"Quantity\"]`` or even ``field_value = "
"lua_table.Quantity``. Those are just three different ways of saying: for "
"the Quantity field in the Lua table, get the value and put it in variable"
" :code:`field_value`."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:599
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but "
"the JSON field is not a number, or is missing. In that case, the function"
" would be aborted when there was an attempt to add it to the sum. By "
"first checking ``type(field_value) == \"number\"``, we avoid that "
"abortion. Anyone who knows that the database is in perfect shape can skip"
" this kind of thing."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:605
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database in our "
":ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:609
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'num'}})"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:616
msgid ""
"then add some tuples where the first field is a number and the second "
"field is a string."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:619
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:626
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and "
"the \"waffle iron\" do not have numeric Quantity fields, so must be "
"ignored. Therefore the real sum of the Quantity field in the JSON strings"
" should be: 15 + 7 = 22."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:631
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:633
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:640
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that "
"there might have to be an overflow check if some field values are huge, "
"and that the function should contain a \"yield\" instruction if the count"
" of tuples is huge."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:649
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/1.6/tutorials/lua_tutorials.rst:651
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the "
"first field of a TREE index. |br| * The function will use `Lua pattern "
"matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which "
"allows \"magic characters\" in regular expressions. |br| * The initial "
"characters in the pattern, as far as the first magic character, will be "
"used as an index search key. For each tuple that is found via the index, "
"there will be a match of the whole pattern. |br| * To be "
":ref:`cooperative <atomic-cooperative_multitasking>`, the function should"
" yield after every 10 tuples, unless there is a reason to delay yielding."
" |br| With this function, we can take advantage of Tarantool's indexes "
"for speed, and take advantage of Lua's pattern matching for flexibility. "
"It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:668
msgid ""
"Read the following Lua code to see how it works. The comments that begin "
"with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:672
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and box.space[space_name].index[i].parts[1].type == \"STR\") then"
"\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\""
"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\""
"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:762
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed "
"space_name (a string) and field_no (a number). The requirements are: |br|"
" (a) index type must be \"TREE\" because for other index types (HASH, "
"BITSET, RTREE) a search with iterator=GE will not return strings in order"
" by string value; |br| (b) field_no must be the first index part; |br| "
"(c) the field must contain strings, because for other data types (such as"
" \"num\") pattern searches are not possible; |br| If these requirements "
"are not met by any index, then print an error message and return nil."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:774
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has "
"passed pattern (a string). The index search key will be the characters in"
" the pattern as far as the first magic character. Lua's magic characters "
"are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", "
"the period is a magic character and therefore the index search key will "
"be \"ABC\". But there is a complication ... If we see \"%\" followed by a"
" punctuation character, that punctuation character is \"escaped\" so "
"remove the \"%\" when making the index search key. For example, if the "
"pattern is \"AB%$E\", the dollar sign is escaped and therefore the index "
"search key will be \"AB$E\". Finally there is a check that the index "
"search key length must be at least three -- this is an arbitrary number, "
"and in fact zero would be okay, but short index search keys will cause "
"long search times."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:791
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return "
"a result set, just as box.space.select would. We will fill it within an "
"outer loop that contains an inner loop. The outer loop's job is to "
"execute the inner loop, and possibly yield, until the search ends. The "
"inner loop's job is to find tuples via the index, and put them in the "
"result set if they match the pattern."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:800
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(),"
" see the :ref:`explanation of what index iterators are <box_index-"
"index_pairs>`. Within the inner loop, there will be a local variable "
"named \"tuple\" which contains the latest tuple found via the index "
"search key."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:807
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator"
" is GE (Greater or Equal), and we must be more specific: if the search "
"index key has N characters, then the leftmost N characters of the "
"result's index field must not be greater than the search index key. For "
"example, if the search index key is 'ABC', then 'ABCDE' is a potential "
"match, but 'ABD' is a signal that no more matches are possible."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:816
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This "
"chunk of code is for cooperative multitasking. The number 10 is "
"arbitrary, and usually a larger number would be okay. The simple rule "
"would be \"after checking 10 tuples, yield, and then resume the search "
"(that is, do the inner loop again) starting after the last value that was"
" found\". However, if the index is non-unique or if there is more than "
"one field in the index, then we might have duplicates -- for example "
"{\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to"
" decide which \"ABC\" tuple to resume with. Therefore, if the result's "
"index field is the same as the previous result's index field, there is no"
" break."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:829
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare"
" the result's index field to the entire pattern. For example, suppose "
"that the caller passed pattern \"ABC.E\" and there is an indexed field "
"containing \"ABCDE\". Therefore the initial index search key is \"ABC\". "
"Therefore a tuple containing an indexed field with \"ABCDE\" will be "
"found by the iterator, because \"ABCDE\" > \"ABC\". In that case "
"string.match will return a value which is not nil. Therefore this tuple "
"can be added to the result set."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:839
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three"
" conditions which will cause a break from the inner loop: (1) the for "
"loop ends naturally because there are no more index keys which are "
"greater than or equal to the index search key, (2) the index key is too "
"great as described in NOTE #5, (3) it is time for a yield as described in"
" NOTE #6. If condition (1) or condition (2) is true, then there is "
"nothing more to do, the outer loop ends too. If and only if condition (3)"
" is true, the outer loop must yield and then continue. If it does "
"continue, then the inner loop -- the iterator search -- will happen again"
" with a new value for the index search key."
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:852
msgid "EXAMPLE:"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:854
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search``, and try the following:"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:860
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'str',3,'str'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/1.6/tutorials/lua_tutorials.rst:879
msgid ""
"tarantool> **indexed_pattern_search(\"t\", 2, \"ABC.E.\")**\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../doc/1.6/whats_new.rst:39
msgid "Release Notes"
msgstr ""

#: ../doc/1.6/whats_new.rst:41
msgid ""
"The Release Notes are summaries of significant changes introduced in "
"Tarantool :ref:`1.6.9 <whats_new_169>`, :ref:`1.6.8 <whats_new_168>`, and"
" :ref:`1.6.6 <whats_new_166>`."
msgstr ""

#: ../doc/1.6/whats_new.rst:46
msgid ""
"For smaller feature changes and bug fixes, see closed `milestones "
"<https://github.com/tarantool/tarantool/milestones?state=closed>`_ at "
"GitHub."
msgstr ""
"Более мелкие изменения и исправления дефектов указаны в отчетах о "
"`выпущенных стабильных релизах (milestone = closed) "
"<https://github.com/tarantool/tarantool/milestones?state=closed>`_ на "
"GitHub."

#: ../doc/1.6/whats_new.rst:54
msgid "Version 1.6"
msgstr ""

#: ../doc/1.6/whats_new.rst:58
msgid "**Release 1.6.9**"
msgstr ""

#: ../doc/1.6/whats_new.rst:60
msgid ""
"Release type: maintenance. Release date: 2016-09-27. Release tag: "
"1.6.9-4-gcc9ddd7."
msgstr ""

#: ../doc/1.6/whats_new.rst:62
msgid ""
"Since February 15, 2017, due to Tarantool issue#2040 `Remove sophia "
"engine from 1.6 <https://github.com/tarantool/tarantool/issues/2040>`_ "
"there no longer is a storage engine named `sophia`. It will be superseded"
" in version 1.7 by the `vinyl` storage engine."
msgstr ""

#: ../doc/1.6/whats_new.rst:67 ../doc/1.6/whats_new.rst:110
#: ../doc/1.6/whats_new.rst:222 ../doc/1.6/whats_new.rst:264
msgid "Incompatible changes:"
msgstr ""

#: ../doc/1.6/whats_new.rst:69
msgid "Support for SHA-0 (``digest.sha()``) was removed due to OpenSSL upgrade."
msgstr ""

#: ../doc/1.6/whats_new.rst:70
msgid ""
"Tarantool binary now dynamically links with libssl.so during compile time"
" instead of loading it at the run time."
msgstr ""

#: ../doc/1.6/whats_new.rst:72
msgid "Fedora 22 packages were deprecated (EOL)."
msgstr ""

#: ../doc/1.6/whats_new.rst:74 ../doc/1.6/whats_new.rst:136
#: ../doc/1.6/whats_new.rst:234 ../doc/1.6/whats_new.rst:274
msgid "Functionality added or changed:"
msgstr ""

#: ../doc/1.6/whats_new.rst:76
#, fuzzy
msgid ""
"Tab-based autocompletion in the interactive console. Issue `86 "
"<https://github.com/tarantool/tarantool/issues/86>`_"
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый "
"функционал можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.6/whats_new.rst:78
msgid ""
"LUA_PATH and LUA_CPATH environment variables taken into account, like in "
"PUC-RIO Lua. Issue `1428 "
"<https://github.com/tarantool/tarantool/issues/1428>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:80
msgid ""
"Search for ``.dylib`` as well as for ``.so`` libraries in OS X. Issue "
"`810 <https://github.com/tarantool/tarantool/issues/810>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:82
msgid ""
"A new ``box.cfg { read_only = true }`` option to emulate master-slave "
"behavior. Issue `246 "
"<https://github.com/tarantool/tarantool/issues/246>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:84
msgid ""
"``if_not_exists = true`` option added to box.schema.user.grant. Issue "
"`1683 <https://github.com/tarantool/tarantool/issues/1683>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:86
msgid ""
"``clock_realtime()``/``monotonic()`` functions added to the public C API."
" Issue `1455 <https://github.com/tarantool/tarantool/issues/1455>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:88
msgid ""
"``space:count(key, opts)`` introduced as an alias for "
"``space.index.primary:count(key, opts)``. Issue `1391 "
"<https://github.com/tarantool/tarantool/issues/13918>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:91
msgid ""
"Upgrade script for 1.6.4 -> 1.6.8 -> 1.6.9. Issue `1281 "
"<https://github.com/tarantool/tarantool/issues/1281>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:93
#, fuzzy
msgid ""
"Support for OpenSSL 1.1. Issue `1722 "
"<https://github.com/tarantool/tarantool/issues/1722>`_"
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый "
"функционал можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.6/whats_new.rst:96 ../doc/1.6/whats_new.rst:197
msgid "New rocks and packages:"
msgstr ""

#: ../doc/1.6/whats_new.rst:98
msgid ""
"`curl <https://github.com/tarantool/tarantool-curl>`_ - non-blocking "
"bindings for libcurl"
msgstr ""

#: ../doc/1.6/whats_new.rst:99
msgid ""
"`prometheus <https://github.com/tarantool/prometheus>`_ - Prometheus "
"metric collector for Tarantool"
msgstr ""

#: ../doc/1.6/whats_new.rst:100
msgid ""
"`gis <https://github.com/tarantool/gis>`_ - full-featured geospatial "
"extension for Tarantool."
msgstr ""

#: ../doc/1.6/whats_new.rst:101
msgid ""
"`mqtt <https://github.com/tarantool/mqtt>`_ - MQTT protocol client for "
"Tarantool"
msgstr ""

#: ../doc/1.6/whats_new.rst:102
msgid ""
"`luaossl <https://github.com/tarantool/luaossl>`_ - the most "
"comprehensive OpenSSL module in the Lua universe"
msgstr ""

#: ../doc/1.6/whats_new.rst:106
msgid "**Release 1.6.8**"
msgstr ""

#: ../doc/1.6/whats_new.rst:108
msgid ""
"Release type: maintenance. Release date: 2016-02-25. Release tag: "
"1.6.8-525-ga571ac0."
msgstr ""

#: ../doc/1.6/whats_new.rst:112
msgid ""
"RPM packages for CentOS 7 / RHEL 7 and Fedora 22+ now use native systemd "
"configuration without legacy sysvinit shell scripts. Systemd provides its"
" own facilities for multi-instance management. To upgrade, perform the "
"following steps:"
msgstr ""

#: ../doc/1.6/whats_new.rst:117
msgid ""
"Ensure that ``INSTANCENAME.lua`` file is present in "
"``/etc/tarantool/instace.available``."
msgstr ""

#: ../doc/1.6/whats_new.rst:118
msgid "Stop INSTANCENAME using ``tarantoolctl stop INSTANCENAME``."
msgstr ""

#: ../doc/1.6/whats_new.rst:119
msgid "Start INSTANCENAME using ``systemctl start tarantool@INSTANCENAME``."
msgstr ""

#: ../doc/1.6/whats_new.rst:120
msgid ""
"Enable INSTANCENAME during system boot using ``systemctl enable "
"trantool@INTANCENAME``."
msgstr ""

#: ../doc/1.6/whats_new.rst:122
msgid ""
"``/etc/tarantool/instance.enabled`` directory is now deprecated for "
"systemd-enabled platforms."
msgstr ""

#: ../doc/1.6/whats_new.rst:124
msgid "See :ref:`the administration chapter <admin>` for additional information."
msgstr ""

#: ../doc/1.6/whats_new.rst:126
msgid ""
"Sophia was upgraded to v2.1 to fix upsert, memory corruption and other "
"bugs. Sophia v2.1 doesn't support old v1.1 data format. Please use "
"Tarantool replication to upgrade. Issue `1222 "
"<https://github.com/tarantool/tarantool/issues/1222>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:130
msgid "Ubuntu Vivid, Fedora 20, Fedora 21 were deprecated due to EOL."
msgstr ""

#: ../doc/1.6/whats_new.rst:131
msgid ""
"i686 packages were deprecated. Please use our RPM and DEB specs to build "
"these on your own infrastructure."
msgstr ""

#: ../doc/1.6/whats_new.rst:133
msgid ""
"Please update your ``yum.repos.d`` and/or apt ``sources.list.d`` "
"according to instructions at http://tarantool.org/download.html"
msgstr ""

#: ../doc/1.6/whats_new.rst:138
msgid ""
"Tarantool 1.6.8 fully supports ARMv7 and ARMv8 (aarch64) processors. Now "
"it is possible to use Tarantool on a wide range of consumer devices, "
"starting from popular Raspberry PI 2 to coin-size embedded boards and no-"
"name mini-micro-nano-PCs. Issue `1153 "
"<https://github.com/tarantool/tarantool/issues/1153>`_. (Also qemu works "
"well, but we don't have real hardware to check.)"
msgstr ""

#: ../doc/1.6/whats_new.rst:144
msgid ""
"Tuple comparator functions were optimized, providing up to 30% "
"performance boost when an index key consists of 2, 3 or more parts. Issue"
" `969 <https://github.com/tarantool/tarantool/issues/969>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:147
msgid ""
"Tuple allocator changes give another 15% performance improvement. Issue "
"`1298 <https://github.com/tarantool/tarantool/issues/1298>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:149
msgid ""
"Replication relay performance was improved by reducing the amount of data"
" directory re-scans. Issue `11150 "
"<https://github.com/tarantool/tarantool/issues/1150>`_"
msgstr ""

#: ../doc/1.6/whats_new.rst:152
msgid ""
"A random delay was introduced into snapshot daemon, reducing the chance "
"that multiple instances take a snapshot at the same time. Issue `732 "
"<https://github.com/tarantool/tarantool/issues/732>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:155
msgid "Sophia storage engine was upgraded to v2.1:"
msgstr ""

#: ../doc/1.6/whats_new.rst:157
msgid "serializable Snapshot Isolation (SSI),"
msgstr ""

#: ../doc/1.6/whats_new.rst:158
msgid "RAM storage mode,"
msgstr ""

#: ../doc/1.6/whats_new.rst:159
msgid "anti-cache storage mode,"
msgstr ""

#: ../doc/1.6/whats_new.rst:160
msgid "persistent caching storage mode,"
msgstr ""

#: ../doc/1.6/whats_new.rst:161
msgid "implemented AMQ Filter,"
msgstr ""

#: ../doc/1.6/whats_new.rst:162
msgid "LRU mode,"
msgstr ""

#: ../doc/1.6/whats_new.rst:163
msgid "separate compression for hot and cold data,"
msgstr ""

#: ../doc/1.6/whats_new.rst:164
msgid "snapshot implementation for Faster Recovery,"
msgstr ""

#: ../doc/1.6/whats_new.rst:165
msgid "upsert reorganizations and fixes,"
msgstr ""

#: ../doc/1.6/whats_new.rst:166
msgid "new performance metrics."
msgstr ""

#: ../doc/1.6/whats_new.rst:168
msgid "Please note \"Incompatible changes\" above."
msgstr ""

#: ../doc/1.6/whats_new.rst:170
msgid ""
"Allow to remove servers with non-zero LSN from ``_cluster`` space. Issue "
"`1219 <https://github.com/tarantool/tarantool/issues/1219>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:172
msgid ""
"``net.box`` now automatically reloads space and index definitions. Issue "
"`1183 <https://github.com/tarantool/tarantool/issues/1183>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:174
msgid ""
"The maximal number of indexes in space was increased to 128. Issue `1311 "
"<https://github.com/tarantool/tarantool/issues/1311>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:176
msgid ""
"New native ``systemd`` configuration with support of instance management "
"and daemon supervision (CentOS 7 and Fedora 22+ only). Please note "
"\"Incompatible changes\" above. Issue `1264 "
"<https://github.com/tarantool/tarantool/issues/1264>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:180
msgid ""
"Tarantool package was accepted to the official Fedora repositories "
"(https://apps.fedoraproject.org/packages/tarantool)."
msgstr ""

#: ../doc/1.6/whats_new.rst:182
msgid ""
"Tarantool brew formula (OS X) was accepted to the official Homebrew "
"repository (http://brewformulas.org/tarantool)."
msgstr ""

#: ../doc/1.6/whats_new.rst:184
msgid ""
"Clang compiler support was added on FreeBSD. Issue `786 "
"<https://github.com/tarantool/tarantool/issues/786>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:186
msgid ""
"Support for musl libc, used by Alpine Linux and Docker images, was added."
" Issue `1249 <https://github.com/tarantool/tarantool/issues/1249>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:188
msgid "Added support for GCC 6.0."
msgstr ""

#: ../doc/1.6/whats_new.rst:189
msgid ""
"Ubuntu Wily, Xenial and Fedora 22, 23 and 24 are now supported "
"distributions for which we build official packages."
msgstr ""

#: ../doc/1.6/whats_new.rst:191
msgid ""
"box.info.cluster.uuid can be used to retrieve cluster UUID. Issue `1117 "
"<https://github.com/tarantool/tarantool/issues/1117>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:193
msgid ""
"Numerous improvements in the documentation, added documentation for "
"``syslog``, ``clock``, ``fiber.storage`` packages, updated the built-in "
"tutorial."
msgstr ""

#: ../doc/1.6/whats_new.rst:199
msgid ""
"Tarantool switched to a new Docker-based cloud build infrastructure The "
"new buildbot significantly decreases commit-to-package time. The official"
" repositories at http://tarantool.org now contain the latest version of "
"the server, rocks and connectors. See http://github.com/tarantool/build"
msgstr ""

#: ../doc/1.6/whats_new.rst:204
msgid ""
"The repositories at http://tarantool.org/download.html were moved to "
"http://packagecloud.io cloud hosting (backed by Amazon AWS). Thanks to "
"packagecloud.io for their support of open source!"
msgstr ""

#: ../doc/1.6/whats_new.rst:207
msgid ""
"``memcached`` - memcached text and binary protocol implementation for "
"Tarantool. Turns Tarantool into a persistent memcached with master-master"
" replication. See https://github.com/tarantool/memcached"
msgstr ""

#: ../doc/1.6/whats_new.rst:210
msgid ""
"``migrate`` - a Tarantool rock for migration from Tarantool 1.5 to 1.6. "
"See https://github.com/bigbes/migrate"
msgstr ""

#: ../doc/1.6/whats_new.rst:212
msgid ""
"``cqueues`` - a Lua asynchronous networking, threading, and notification "
"framework (contributed by @daurnimator). PR `1204 "
"<https://github.com/tarantool/tarantool/pull/1204>`_."
msgstr ""

#: ../doc/1.6/whats_new.rst:218
msgid "**Release 1.6.7**"
msgstr ""

#: ../doc/1.6/whats_new.rst:220
msgid "Release type: maintenance. Release date: 2015-11-17."
msgstr ""

#: ../doc/1.6/whats_new.rst:224
msgid ""
"The syntax of ``upsert`` command has been changed and an extra ``key`` "
"argument was removed from it. The primary key for look up is now always "
"taken from the tuple, which is the second argument of upsert. "
"``upsert()`` was added fairly late at a release cycle and the design had "
"an obvious bug which we had to fix. Sorry for this."
msgstr ""

#: ../doc/1.6/whats_new.rst:230
msgid ""
"``fiber.channel.broadcast()`` was removed since it wasn't used by anyone "
"and didn't work properly."
msgstr ""

#: ../doc/1.6/whats_new.rst:232
msgid "tarantoolctl ``reload`` command renamed to ``eval``."
msgstr ""

#: ../doc/1.6/whats_new.rst:236
msgid ""
"``logger`` option now accepts a syntax for syslog output. Use uri-style "
"syntax for file, pipe or syslog log destination."
msgstr ""

#: ../doc/1.6/whats_new.rst:238
msgid ""
"``replication_source`` now accepts an array of URIs, so each replica can "
"have up to 30 peers."
msgstr ""

#: ../doc/1.6/whats_new.rst:240
msgid ""
"RTREE index now accept two types of ``distance`` functions: ``euclid`` "
"and ``manhattan``."
msgstr ""

#: ../doc/1.6/whats_new.rst:242
msgid ""
"``fio.abspath()`` - a new function in ``fio`` rock to convert a relative "
"path to absolute."
msgstr ""

#: ../doc/1.6/whats_new.rst:244
msgid "The process title now can be set with an on-board ``title`` rock."
msgstr ""

#: ../doc/1.6/whats_new.rst:245
msgid "This release uses LuaJIT 2.1."
msgstr ""

#: ../doc/1.6/whats_new.rst:247 ../doc/1.6/whats_new.rst:327
msgid "New rocks:"
msgstr ""

#: ../doc/1.6/whats_new.rst:249
msgid ""
"``memcached`` - makes Tarantool understand Memcached binary protocol. "
"Text protocol support is in progress and will be added to the rock "
"itself, without changes to the server core."
msgstr ""

#: ../doc/1.6/whats_new.rst:255
msgid "**Release 1.6.6**"
msgstr ""

#: ../doc/1.6/whats_new.rst:257
msgid "Release type: maintenance. Release date: 2015-08-28."
msgstr ""

#: ../doc/1.6/whats_new.rst:260
msgid ""
"Tarantool 1.6 is no longer getting major new features, although it will "
"be maintained. The developers are concentrating on Tarantool version 1.9."
msgstr ""

#: ../doc/1.6/whats_new.rst:266
msgid ""
"A new schema of ``_index`` system space which accommodates multi-"
"dimensional RTREE indexes. Tarantool 1.6.6 works fine with an old "
"snapshot and system spaces, but you will not be able to start Tarantool "
"1.6.5 with a data directory created by Tarantool 1.6.6, neither will you "
"be able to query Tarantool 1.6.6 schema with 1.6.5 net.box."
msgstr ""

#: ../doc/1.6/whats_new.rst:272
msgid "``box.info.snapshot_pid`` is renamed to ``box.info.snapshot_in_progress``"
msgstr ""

#: ../doc/1.6/whats_new.rst:276
msgid ""
"Threaded architecture for network. Network I/O has finally been moved to "
"a separate thread, increasing single instance performance by up to 50%."
msgstr ""

#: ../doc/1.6/whats_new.rst:279
msgid ""
"Threaded architecture for checkpointing. Tarantool no longer forks to "
"create a snapshot, but uses a separate thread, accessing data via a "
"consistent read view. This eliminates all known latency spikes caused by "
"snapshotting."
msgstr ""

#: ../doc/1.6/whats_new.rst:284
msgid ""
"Stored procedures in C/C++. Stored procedures in C/C++ provide speed (3-4"
" times, compared to a Lua version in our measurements), as well as "
"unlimited extensibility power. Since C/C++ procedures run in the same "
"memory space as the database, they are also an easy tool to corrupt "
"database memory. See :ref:`The C API description <index-"
"c_api_reference>`."
msgstr ""

#: ../doc/1.6/whats_new.rst:291
msgid ""
"Multidimensional RTREE index. RTREE index type now support a large (up to"
" 32) number of dimensions. RTREE data structure has been optimized to "
"actually use `R\\*-TREE <https://en.wikipedia.org/wiki/R*_tree>`_. We're "
"working on further improvements of the index, in particular, configurable"
" distance function. See https://github.com/tarantool/tarantool/wiki/R"
"-tree-index-quick-start-and-usage"
msgstr ""

#: ../doc/1.6/whats_new.rst:298
msgid ""
"Sophia 2.1.1, with support of compression and multipart primary keys. See"
" https://groups.google.com/forum/#!topic/sophia-database/GfcbEC7ksRg"
msgstr ""

#: ../doc/1.6/whats_new.rst:301
msgid ""
"New ``upsert`` command available in the binary protocol and in stored "
"functions. The key advantage of upsert is that it's much faster with "
"write-optimized storage (sophia storage engine), but some caveats exists "
"as well. See Issue `905 "
"<https://github.com/tarantool/tarantool/issues/905>`_ for details. Even "
"though upsert performance advantage is most prominent with sophia engine,"
" it works with all storage engines."
msgstr ""

#: ../doc/1.6/whats_new.rst:308
msgid ""
"Better memory diagnostics information for fibers, tuple and index arena "
"Try a new command ``box.slab.stats()``, for detailed information about "
"tuple/index slabs, ``fiber.info()`` now displays information about memory"
" used by the fiber."
msgstr ""

#: ../doc/1.6/whats_new.rst:312
msgid ""
"Update and delete now work using a secondary index, if the index is "
"unique."
msgstr ""

#: ../doc/1.6/whats_new.rst:314
msgid ""
"Authentication triggers. Set ``box.session.on_auth`` triggers to catch "
"authentication events. Trigger API is improved to display all defined "
"triggers, easily remove old triggers."
msgstr ""

#: ../doc/1.6/whats_new.rst:317
msgid "Manifold performance improvements of ``net.box`` built-in package."
msgstr ""

#: ../doc/1.6/whats_new.rst:318
msgid "Performance optimizations of BITSET index."
msgstr ""

#: ../doc/1.6/whats_new.rst:319
msgid "``panic_on_wal_error`` is a dynamic configuration option now."
msgstr ""

#: ../doc/1.6/whats_new.rst:320
msgid "iproto ``sync`` field is available in Lua as ``session.sync()``."
msgstr ""

#: ../doc/1.6/whats_new.rst:321
msgid ""
"``box.once()`` - a new method to invoke code once in an instance and "
"replica set lifetime. Use ``once()`` to set up spaces and uses, as well "
"as do schema upgrade in production."
msgstr ""

#: ../doc/1.6/whats_new.rst:325
msgid "``box.error.last()`` to return the last error in a session."
msgstr ""

#: ../doc/1.6/whats_new.rst:329
msgid ""
"``jit.*``, ``jit.dump``, ``jit.util``, ``jit.vmdef`` modules of LuaJIT "
"2.0 are now available as built-ins. See http://luajit.org/ext_jit.html"
msgstr ""

#: ../doc/1.6/whats_new.rst:332
msgid ""
"``strict`` built-in package, banning use of undeclared variables in Lua. "
"Strict mode is on when Tarantool is compiled with debug. Turn on/off with"
" ``require('strict').on()``/``require('strict').off()``."
msgstr ""

#: ../doc/1.6/whats_new.rst:335
msgid "``pg`` and ``mysql`` rocks, available at http://rocks.tarantool.org"
msgstr ""

#: ../doc/1.6/whats_new.rst:336
msgid "working with MySQL and PostgreSQL from Tarantool."
msgstr ""

#: ../doc/1.6/whats_new.rst:337
msgid ""
"``gperftools`` rock, availble at http://rocks.tarantool.org - getting "
"perfromance data using Google's gperf from Tarantool."
msgstr ""

#: ../doc/1.6/whats_new.rst:340
msgid "``csv`` built-in rock, to parse and load CSV (comma-separated"
msgstr ""

#: ../doc/1.6/whats_new.rst:340
msgid "values) data."
msgstr ""

#: ../doc/1.6/whats_new.rst:342
msgid "New supported platforms:"
msgstr ""

#: ../doc/1.6/whats_new.rst:344
msgid "Fedora 22, Ubuntu Vivid"
msgstr ""

#~ msgid ""
#~ "**Tarantool's disk-based storage engine** "
#~ "is a fusion of ideas from modern"
#~ " filesystems, log-structured merge trees"
#~ " and classical B-trees. All data is"
#~ " organized into **runs**. Each run is"
#~ " represented by a file on disk. "
#~ "Run size is a configuration option "
#~ "and normally is around 64MB. Each "
#~ "run is a collection of pages, "
#~ "serving different purposes. Pages in a"
#~ " fully merged run contain non-"
#~ "overlapping ranges of keys. A run "
#~ "can be partially merged if there "
#~ "were a lot of changes in its "
#~ "key range recently. In that case "
#~ "some pages represent new keys and "
#~ "values in the run. The disk-based"
#~ " storage engine is append only: new"
#~ " data never overwrites old data. The"
#~ " disk-based storage engine is named"
#~ " :ref:`vinyl <index-vinyl>`."
#~ msgstr ""
#~ "**Дисковый движок** (:ref:`vinyl <index-"
#~ "vinyl>`) совмещает в себе подходы, "
#~ "заимствованные из современных файловых систем,"
#~ " журналируемых merge-деверьев (log-structured "
#~ "merge trees) и классических B-деревьев. "
#~ "Все данные в этом движке разбиты "
#~ "по забегам (runs), где каждый забег "
#~ "представляет собой файл на диске. "
#~ "Максимальный размер забега обычно равен "
#~ "64МБ, и его можно настраивать. Каждый"
#~ " забег — это набор страниц, которые"
#~ " нужны для каких-то целей. Если забег"
#~ " полностью смержен, то диапазоны ключей "
#~ "на его страницах не пересекаются. Если"
#~ " же диапазоны ключей в забеге в "
#~ "какой-то момент сильно изменялись, то мы"
#~ " имеем дело с частично смерженным "
#~ "забегом. В этом случае на некоторых "
#~ "страницах появились новые ключи и "
#~ "значения, которых ранее не было в "
#~ "данном забеге. Дисковый движок обновляет "
#~ "данные по принципу дописывания в конец:"
#~ " новые данные никогда не затирают "
#~ "старые."

#~ msgid ""
#~ "The two ordinary index types are "
#~ "'tree' which is the default, and "
#~ "'hash' which must be unique and "
#~ "which may be faster or smaller. "
#~ "The third type is 'bitset' which "
#~ "is not unique and which works best"
#~ " for combinations of binary values. "
#~ "The fourth type is 'rtree' which "
#~ "is not unique and which works with"
#~ " arrays, instead of 'string' or "
#~ "'unsigned' values."
#~ msgstr ""
#~ "Чаще всего индекс — это дерево (по"
#~ " умолчанию) или хеш (в этом случае"
#~ " индекс должен быть уникальным; в "
#~ "определенных случаях такой индекс занимает "
#~ "меньше места и поиск по нему "
#~ "работает быстрее). Третий тип индекса —"
#~ " это набор битов (bitset); это "
#~ "неуникальный индекс, предназначенный для "
#~ "работы с различными бинарными значениями. "
#~ "Четвертый тип индекса — это R-дерево;"
#~ " это тоже неуникальный индекс, "
#~ "предназначенный для работы с массивами, "
#~ "а не со строками или беззнаковыми "
#~ "числами."

#~ msgid ""
#~ "**To review...** If you followed all "
#~ "the instructions in this chapter, then"
#~ " so far you have: installed Tarantool"
#~ " from either a binary or a "
#~ "source repository, started up the "
#~ "Tarantool server, inserted and selected "
#~ "tuples."
#~ msgstr ""
#~ "Если вы выполнили все инструкции из "
#~ "этой главы, то к данному моменту "
#~ "вы уже установили Tarantool (из "
#~ "бинарного пакета, либо из исходных "
#~ "файлов), запустили Tarantool-сервер, а также"
#~ " выполнили вставку и выборку кортежей."

#~ msgid ""
#~ "Here is a complete Tarantool manual. "
#~ "It embraces all aspects of using "
#~ "Tarantool: from introductory information and"
#~ " excercises for beginners -- to "
#~ "advanced instructions and detailed references"
#~ " for power users and contributors.A "
#~ "single-page version of this manual is"
#~ " available here."
#~ msgstr ""

#~ msgid ""
#~ "Here is a **complete Tarantool manual**."
#~ " It embraces all aspects of using "
#~ "Tarantool: from introductory information and"
#~ " excercises for beginners -- to "
#~ "advanced instructions and detailed references"
#~ " for power users and contributors."
#~ msgstr ""

#~ msgid "A single-page version of this manual is available `here`_."
#~ msgstr ""

#~ msgid "What's new?"
#~ msgstr "Что нового?"

#~ msgid "`What's new in Tarantool 1.7?`_"
#~ msgstr ""

#~ msgid "`An application server together with a database manager`_"
#~ msgstr ""

#~ msgid "`Database features`_"
#~ msgstr ""

#~ msgid "`Lua tutorials`_"
#~ msgstr ""

#~ msgid "`C tutorial`_"
#~ msgstr ""

#~ msgid "`Preface`_"
#~ msgstr ""

#~ msgid "`Database`_"
#~ msgstr ""

#~ msgid "`Application server`_"
#~ msgstr ""

#~ msgid "`Server administration`_"
#~ msgstr ""

#~ msgid "`Connectors`_"
#~ msgstr ""

#~ msgid "`FAQ`_"
#~ msgstr ""

#~ msgid "`Built-in library reference`_"
#~ msgstr ""

#~ msgid "`Rocks reference`_"
#~ msgstr ""

#~ msgid "`Configuration reference`_"
#~ msgstr ""

#~ msgid "`C API reference`_"
#~ msgstr ""

#~ msgid "`Internals`_"
#~ msgstr ""

#~ msgid "`Build and contribute`_"
#~ msgstr ""

#~ msgid "`Guidelines`_"
#~ msgstr ""

#~ msgid ""
#~ "Here are other sources -- besides "
#~ "the manual -- where you can get"
#~ " more information about Tarantool."
#~ msgstr ""

#~ msgid "Discussion boards"
#~ msgstr ""

#~ msgid "tl;dr? ;-) Feel free to ask your question in our `telegram chat`_."
#~ msgstr ""

#~ msgid ""
#~ "Typical server administration tasks include"
#~ " starting and stopping the server, "
#~ "reloading configuration, taking snapshots, log"
#~ " rotation."
#~ msgstr ""
#~ "Типичные задачи администрирования серверной "
#~ "части включают в себя запуск и "
#~ "остановку сервера, перезагрузку настроек, "
#~ "создание снимков, ротацию логов."

#~ msgid ""
#~ "If :program:`tarantool` is started without "
#~ "an :ref:`initialization file <index-"
#~ "init_label>`, or if the initialization "
#~ "file contains :ref:`console.start() <console-"
#~ "start>`, then :program:`tarantool` enters "
#~ "interactive mode. There will be a "
#~ "prompt (\"``tarantool>``\") and it will "
#~ "be possible to enter requests. When "
#~ "used this way, :program:`tarantool` can "
#~ "be a client for a remote server."
#~ msgstr ""
#~ "Если :program:`tarantool` запущен без "
#~ ":ref:`файла инициализации <index-init_label>`, "
#~ "или же в файле инициализации указана "
#~ "функция :ref:`console.start() <console-start>`, "
#~ "то :program:`tarantool` стартует в "
#~ "интерактивном режиме: он выводит приглашение"
#~ " командной строки (\"``tarantool>``\"), и "
#~ "запросы можно вводить прямо в консоли."
#~ " В таком режиме :program:`tarantool` можно"
#~ " использовать в качестве клиента для "
#~ "удаленного сервера."

#~ msgid ""
#~ "This section shows all legal syntax "
#~ "for the :program:`tarantool` program, with "
#~ "short notes and examples. Other client"
#~ " programs may have similar options "
#~ "and request syntaxes. Some of the "
#~ "information in this section is "
#~ "duplicated in the chapter :ref:`Configuration"
#~ " reference <index-book_cfg>`."
#~ msgstr ""
#~ "В этом разделе описаны синтаксические "
#~ "правила для ввода запросов в консоли "
#~ "Tarantool'а, с примечаниями и примерами. "
#~ "Другие клиентские программы могут иметь "
#~ "схожие параметры и синтаксис запросов. "
#~ "Некоторые сведения из этого раздела "
#~ "дублируются в главе :ref:`Справочник по "
#~ "конфигурированию <index-book_cfg>`."

#~ msgid ""
#~ "Tokens are character sequences which are"
#~ " treated as syntactic units within "
#~ "requests. Square brackets [ and ] "
#~ "enclose optional syntax. Three dots in"
#~ " a row ... mean the preceding "
#~ "tokens may be repeated. A vertical "
#~ "bar | means the preceding and "
#~ "following tokens are mutually exclusive "
#~ "alternatives."
#~ msgstr ""
#~ "Токены — это последовательности символов, "
#~ "которые рассматриваются как синтаксические "
#~ "единицы в рамках запроса. Квадратные "
#~ "скобки [ и ] используются для "
#~ "обозначения необязательных токенов. Три точки"
#~ " в строке ... означают, что "
#~ "предыдущие токены могут повторяться. "
#~ "Вертикальная черта | означает, что "
#~ "предыдущие и последующие токены являются "
#~ "взаимоисключающими альтернативами."

#~ msgid "Options when starting client from the command line"
#~ msgstr "Параметры запуска клиента из командной строки"

#~ msgid "General form:"
#~ msgstr "Общий вид:"

#~ msgid ""
#~ "$ **tarantool**\n"
#~ "OR\n"
#~ "$ **tarantool** *options*\n"
#~ "OR\n"
#~ "$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "ИЛИ\n"
#~ "$ tarantool опции\n"
#~ "ИЛИ\n"
#~ "$ tarantool файл-инициализации-на-lua [ аргументы ]"

#~ msgid ""
#~ "Here *lua-initialization-file* can be"
#~ " any script containing code for "
#~ "initializing. Effect: The code in the"
#~ " file is executed during startup. "
#~ "Example: :samp:`init.lua`. |br| Notes: If "
#~ "a script is used, there will be"
#~ " no prompt. The script should contain"
#~ " configuration information including "
#~ ":samp:`box.cfg{...listen=...}` or :samp:`box.listen(...)`"
#~ " so that a separate program can "
#~ "connect to the server via one of"
#~ " the ports."
#~ msgstr ""
#~ "*файл-инициализации-на-lua* — это любой "
#~ "скрипт, содержащий логику инициализации. Код"
#~ " из этого файла выполняется при "
#~ "запуске Tarantool'а.  Например: :samp:`init.lua`."
#~ " |br| Примечания: При использовании "
#~ "скрипта, Tarantool не выводит приглашение "
#~ "командной строки. Скрипт должен содержать "
#~ "конфигурационные настройки, в т.ч. "
#~ ":samp:`box.cfg{...listen=...}` или "
#~ ":samp:`box.listen(...)`, чтобы внешние программы "
#~ "могли установить соединение с "
#~ "Tarantool-сервером на одном из указанных "
#~ "портов."

#~ msgid ""
#~ "*Option* is one of the following "
#~ "(in alphabetical order by the long "
#~ "form of the option):"
#~ msgstr ""
#~ "*Опция* — это одно из следующих "
#~ "значений (указаны в алфавитном порядке, "
#~ "по полному имени опции):"

#~ msgid ""
#~ "Client displays a help message including"
#~ " a list of options. Example: "
#~ ":samp:`tarantool --help` The program stops "
#~ "after displaying the help."
#~ msgstr ""
#~ "Tarantool-клиент выводит краткую справку, "
#~ "включая список всех параметров. Например: "
#~ ":samp:`tarantool --help`. Вывод останавливается "
#~ "после показа справки."

#~ msgid ""
#~ "Client displays version information. Example:"
#~ " :samp:`tarantool --version`. The program "
#~ "stops after displaying the version."
#~ msgstr ""
#~ "Tarantool-клиент выводит свой номер версии."
#~ " Например: :samp:`tarantool --version`. Вывод "
#~ "останавливается после показа номера версии."

#~ msgid "Tokens, requests, and special key combinations"
#~ msgstr "Токены, запросы и специальные комбинации клавиш"

#~ msgid ""
#~ "Procedure identifiers are: Any sequence "
#~ "of letters, digits, or underscores which"
#~ " is legal according to the rules "
#~ "for Lua identifiers. Procedure identifiers "
#~ "are also called function names. |br| "
#~ "Note: function names are case sensitive"
#~ " so ``insert`` and ``Insert`` are not"
#~ " the same thing."
#~ msgstr ""
#~ "Идентификатором процедуры может быть любая "
#~ "последовательность букв, цифр и/или "
#~ "подчеркиваний, которая отвечает правилам "
#~ "именования идентификаторов в Lua. Термин "
#~ "\"идентификаторы процедур\" также применяют к"
#~ " именам функций. |br| Примечание: в "
#~ "случае с именами функций регистр имеет"
#~ " значение, поэтому ``insert`` и ``Insert``"
#~ " — это не одно и то же."

#~ msgid ""
#~ "String literals are: Any sequence of "
#~ "zero or more characters enclosed in "
#~ "single quotes. Double quotes are legal"
#~ " but single quotes are preferred. "
#~ "Enclosing in double square brackets is"
#~ " good for multi-line strings as "
#~ "described in `Lua documentation "
#~ "<http://www.lua.org/pil/2.4.html>`_. |br| Examples: "
#~ "'Hello, world', 'A', [[A\\\\B!]]."
#~ msgstr ""
#~ "Строковым литералом может быть любая "
#~ "последовательность из нуля и более "
#~ "символов, которая заключена в *одинарные "
#~ "кавычки*. *Двойные кавычки* также допустимы,"
#~ " но предпочтительным вариантом являются "
#~ "одинарные кавычки. А *двойные квадратные "
#~ "скобки* нужны для многострочных литералов "
#~ "(см. `документацию по языку Lua "
#~ "<http://www.lua.org/pil/2.4.html>`_). |br| Например: "
#~ "'Hello, world', 'A', [[A\\\\B!]]."

#~ msgid ""
#~ "Numeric literals are: Any sequence of"
#~ " one or more digits, not enclosed "
#~ "in quotes, optionally preceded by - "
#~ "(minus sign). Large or floating-point"
#~ " numeric literals may include decimal "
#~ "points, exponential notation, or suffixes.|br|"
#~ " Examples: 500, -500, 5e2, 500.1, "
#~ "5LL, 5ULL."
#~ msgstr ""
#~ "Числовым литералом может быть любая "
#~ "последовательность символов, состоящая из "
#~ "одной и более цифр с необязательным "
#~ "знаком + или - в начале. В "
#~ "состав больших числовых литералов, а "
#~ "также числовых литералов с плавающей "
#~ "точкой может входить десятичный разделитель"
#~ " (запятая или точка), символы для "
#~ "экспоненциального представления и суффиксы. "
#~ "|br| Например: 500, -500, 5e2, 500.1,"
#~ " 5LL, 5ULL."

#~ msgid ""
#~ "Single-byte tokens are: , or ( "
#~ "or ) or arithmetic operators. |br| "
#~ "Examples: * , ( )."
#~ msgstr ""
#~ "Однобайтовым символом может быть запятая, "
#~ "открывающая или закрывающая круглая скобка,"
#~ " а также арифметический оператор. |br| "
#~ "Например: * , ( )."

#~ msgid ""
#~ "Tokens must be separated from each "
#~ "other by one or more spaces, "
#~ "except that spaces are not necessary "
#~ "around single-byte tokens or string "
#~ "literals."
#~ msgstr ""
#~ "Токены должны разделяться одним или "
#~ "бОльшим количеством пробелов. Исключением "
#~ "являются однобайтовые токены и строковые "
#~ "литералы — вокруг них пробелы не "
#~ "нужны."

#~ msgid ""
#~ "Generally requests are entered following "
#~ "the prompt in interactive mode while "
#~ ":program:`tarantool` is running. (A prompt "
#~ "will be the word 'tarantool' and a"
#~ " greater-than sign, for example "
#~ ":samp:`tarantool>`). The end-of-request "
#~ "marker is by default a newline "
#~ "(line feed)."
#~ msgstr ""
#~ "Запросы вводятся после приглашения командной"
#~ " строки, когда Tarantool работает в "
#~ "интерактивном режиме. (Приглашение — это "
#~ "слово tarantool и знак \"больше\", вот"
#~ " так: :samp:`tarantool>`). Маркером конца "
#~ "запроса по умолчанию является перевод "
#~ "строки."

#~ msgid ""
#~ "For multi-line requests, it is "
#~ "possible to change the end-of-"
#~ "request marker. Syntax: :samp:`console = "
#~ "require('console'); console.delimiter({string-literal})`."
#~ " The string-literal must be a "
#~ "value in single quotes. Effect: string"
#~ " becomes end-of-request delimiter, so"
#~ " newline alone is not treated as "
#~ "end of request. To go back to "
#~ "normal mode: :samp:`console.delimiter(''){string-"
#~ "literal}`. Delimiters are usually not "
#~ "necessary because Tarantool can tell "
#~ "when a multi-line request has not"
#~ " ended (for example, if it sees "
#~ "that a function declaration does not "
#~ "have an :samp:`end` keyword). Example:"
#~ msgstr ""
#~ "Для ввода многострочных запросов можно "
#~ "задать другой маркер конца запроса. Для"
#~ " этого введите команду следующего вида: "
#~ ":samp:`console = require('console'); "
#~ "console.delimiter({новый-маркер})`. В качестве "
#~ "нового маркера укажите строковый литерал "
#~ "в одинарных кавычках. После этого вам"
#~ " нужно будет вводить указанный маркер "
#~ "в конце каждого запроса, потому что "
#~ "Tarantool перестанет интерпретировать перевод "
#~ "строки как конец запроса. Чтобы "
#~ "вернуться к обычному режиму, введите: "
#~ ":samp:`console.delimiter(''){string-literal}`. Как "
#~ "правило, задавать свой маркер нет "
#~ "необходимости, поскольку Tarantool сам "
#~ "распознает, что запрос введен не "
#~ "полностью (скажем, когда Tarantool не "
#~ "встречает слова :samp:`end` в объявлении "
#~ "функции). Например:"

#~ msgid ""
#~ "See :ref:`here <box_protocol-iproto_protocol>` "
#~ "a condensed Backus-Naur Form [BNF] "
#~ "description of the suggested form of "
#~ "client requests."
#~ msgstr ""
#~ "См. также :ref:`описание формата клиентских"
#~ " запросов <box_protocol-iproto_protocol>` в "
#~ "виде аннотированных BNF-диаграмм (Backus-Naur"
#~ " Form)."

#~ msgid ""
#~ "In *interactive* mode, one types "
#~ "requests and gets results. Typically the"
#~ " requests are typed in by the "
#~ "user following prompts. Here is an "
#~ "example of an interactive-mode Tarantool"
#~ " client session:"
#~ msgstr ""
#~ "Работая в  *интерактивном* режиме, "
#~ "Tarantool-сервер принимает введенные запросы и"
#~ " выводит результаты. Запросы, как правило,"
#~ " вводит пользователь. Вот пример "
#~ "интерактивной пользовательской сессии:"

#~ msgid ""
#~ "$ tarantool\n"
#~ "[ tarantool will display an introductory message\n"
#~ "  including version number here ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ tarantool will display configuration information here ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ tarantool may display an in-progress message here ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = "
#~ "'hash', parts = {1, 'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner "
#~ "I> Exiting: master shutdown\n"
#~ "$"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "[ здесь tarantool выводит приветствие и номер версии ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ здесь tarantool выводит свои текущие настройки ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ здесь tarantool может вывести сообщение о том,\n"
#~ "  что идет обработка запроса ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = "
#~ "'hash', parts = {1, 'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner "
#~ "I> Exiting: master shutdown\n"
#~ "$"

#~ msgid "Explanatory notes about what Tarantool displayed in the above example:"
#~ msgstr "Пояснения к приведенному выше примеру:"

#~ msgid ""
#~ "Many requests return typed objects. In"
#~ " the case of :samp:`box.cfg{listen=3301}`, "
#~ "this result is displayed on the "
#~ "screen. If the request had assigned "
#~ "the result to a variable, for "
#~ "example :samp:`c = box.cfg{listen=3301}`, then"
#~ " the result would not have been "
#~ "displayed on the screen."
#~ msgstr ""
#~ "На многие запросы Tarantool возвращает "
#~ "типизированные объекты. В ответ на "
#~ "запрос :samp:`box.cfg{listen=3301}` Tarantool "
#~ "выведет результат на экран. Если в "
#~ "запросе задано, что его результат должен"
#~ " быть записан в некоторую переменную, "
#~ "например :samp:`c = box.cfg{listen=3301}`, то"
#~ " в таком случае вывода результата на"
#~ " экран не происходит."

#~ msgid ""
#~ "A display of an object always "
#~ "begins with \"``---``\" and ends with"
#~ " \"``...``\"."
#~ msgstr ""
#~ "Вывод объекта в Tarantool'е всегда "
#~ "начинается со строки \"``---``\" и "
#~ "заканчивается строкой \"``...``\"."

#~ msgid ""
#~ "The insert request returns an object "
#~ "of type = tuple, so the object "
#~ "display line begins with a single "
#~ "dash ('``-``'). However, the select "
#~ "request returns an object of type "
#~ "= table of tuples, so the object"
#~ " display line begins with two dashes"
#~ " ('``- -``')."
#~ msgstr ""
#~ "По запросу на вставку данных "
#~ "возвращается объект типа кортеж (tuple), "
#~ "и в этом случае перед выводом "
#~ "будет стоять одиночное тире ('``-``'). А"
#~ " по запросу на выборку данных "
#~ "возвращается объект типа таблица кортежей "
#~ "(table of tuples), и в этом случае"
#~ " перед выводом будут стоять два тире"
#~ " ('``- -``')."

#~ msgid ""
#~ "With :program:`tarantoolctl`, you can say: "
#~ "\"start an instance of the Tarantool "
#~ "server which runs a single user-"
#~ "written Lua program, allocating disk "
#~ "resources specifically for that program, "
#~ "via a standardized deployment method.\""
#~ msgstr ""

#~ msgid ""
#~ "If Tarantool was installed with Debian"
#~ " or Red Hat installation packages, "
#~ "the script is in :file:`/usr/bin/tarantoolctl`"
#~ " or :file:`/usr/local/bin/tarantoolctl`. The "
#~ "script handles such things as: starting,"
#~ " stopping, rotating logs, logging in "
#~ "to the application's console, and "
#~ "checking status."
#~ msgstr ""

#~ msgid ""
#~ "Also, you can use :program:`tarantoolctl` "
#~ ":ref:`as a client <administration-"
#~ "tarantoolctl_connect>` to connect to another"
#~ " instance of Tarantool server and "
#~ "pass requests."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Данная команда означает \"использовать утилиту"
#~ " :ref:`tarantoolctl <administration-"
#~ "tarantoolctl_connect>` для соединения с "
#~ "Tarantool-сервером, который слушает на "
#~ "``localhost:3301``.\""

#~ msgid "Configuration for tarantoolctl"
#~ msgstr "Конфигурирование tarantoolctl"

#~ msgid ""
#~ "The :program:`tarantoolctl` script will look"
#~ " for a configuration file in the "
#~ "current directory (:file:`$PWD/.tarantoolctl`). If"
#~ " that fails, it looks in the "
#~ "current user's home directory "
#~ "(:file:`$HOME/.config/tarantool/tarantool`). If that "
#~ "fails, it looks in the SYSCONFDIR "
#~ "directory (usually :file:`/etc/sysconfig/tarantool`, "
#~ "but it may be different on some"
#~ " platforms). Most of the settings are"
#~ " similar to the settings used by "
#~ ":samp:`box.cfg{...}`; however, :program:`tarantoolctl` "
#~ "adjusts some of them by adding an"
#~ " application name. A copy of "
#~ ":file:`usr/local/etc/default/tarantool`, with defaults "
#~ "for all settings, would look like "
#~ "this:"
#~ msgstr ""
#~ "Скрипт :program:`tarantoolctl` сначала проверяет "
#~ "наличие файла конфигурации в текущей "
#~ "директории (:file:`$PWD/.tarantoolctl`). Если не "
#~ "находит, то проверяет домашнюю директорию "
#~ "текущего пользователя "
#~ "(:file:`$HOME/.config/tarantool/tarantool`). Если опять"
#~ " не находит, то проверяет директорию, "
#~ "указанную в переменной SYSCONFDIR (обычно "
#~ "это :file:`/etc/sysconfig/tarantool`, но на "
#~ "разных платформах этот путь может "
#~ "различаться). Большинство параметров "
#~ ":program:`tarantoolctl` аналогичны тем, что "
#~ "задаются в запросе :samp:`box.cfg{...}`; "
#~ "однако :program:`tarantoolctl` меняет значение "
#~ "некоторых параметров, дописывая к ним "
#~ "имя приложения. Далее приводится копия "
#~ "файла :file:`usr/local/etc/default/tarantool`, где "
#~ "для всех параметров указаны их значения"
#~ " по умолчанию:"

#~ msgid ""
#~ "default_cfg = {\n"
#~ "    pid_file   = \"/var/run/tarantool\",\n"
#~ "    wal_dir    = \"/var/lib/tarantool\",\n"
#~ "    snap_dir   = \"/var/lib/tarantool\",\n"
#~ "    vinyl_dir = \"/var/lib/tarantool\",\n"
#~ "    logger     = \"/var/log/tarantool\",\n"
#~ "    username   = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/etc/tarantool/instances.enabled\""
#~ msgstr ""
#~ "default_cfg = {\n"
#~ "    pid_file   = \"/var/run/tarantool\",\n"
#~ "    wal_dir    = \"/var/lib/tarantool\",\n"
#~ "    snap_dir   = \"/var/lib/tarantool\",\n"
#~ "    vinyl_dir = \"/var/lib/tarantool\",\n"
#~ "    logger     = \"/var/log/tarantool\",\n"
#~ "    username   = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/etc/tarantool/instances.enabled\""

#~ msgid "The settings in the above script are:"
#~ msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#~ msgid "``vinyl_dir``"
#~ msgstr "``vinyl_dir``"

#~ msgid ""
#~ "The directory for the vinyl-storage-"
#~ "engine files. The script will add "
#~ "\":samp:`/vinyl/{instance-name}`\" to the "
#~ "directory-name."
#~ msgstr ""
#~ "Директория, где хранятся файлы движка "
#~ "vinyl. Скрипт :program:`tarantoolctl` добавляет "
#~ "\":samp:`/{instance-name}`\" к имени "
#~ "директории."

#~ msgid ""
#~ "The user that runs the Tarantool "
#~ "server. This is the operating-system "
#~ "user name rather than the Tarantool-"
#~ "client user name."
#~ msgstr ""
#~ "Имя пользователя, из-под которого запущен "
#~ "Tarantool-сервер. Это имя пользователя в "
#~ "операционной системе, а не в "
#~ "Tarantool-клиенте."

#~ msgid ""
#~ "The directory where all applications for"
#~ " this host are stored. The user "
#~ "who writes an application for "
#~ ":program:`tarantoolctl` must put the "
#~ "application's source code in this "
#~ "directory, or a symbolic link. For "
#~ "examples in this section the application"
#~ " name ``my_app`` will be used, and"
#~ " its source will have to be in"
#~ " :samp:`{instance_dir}/my_app.lua`."
#~ msgstr ""
#~ "Имя директории, где хранятся исходные "
#~ "файлы всех Tarantool-приложений для данного"
#~ " хоста. Пользователю, который пишет "
#~ "приложение для :program:`tarantoolctl`, нужно "
#~ "положить исходный код своего приложения "
#~ "в эту директорию или настроить симлинк."
#~ " Далее для примеров в этом разделе"
#~ " мы используем Tarantool-приложение с "
#~ "именем ``my_app``, и его исходный код"
#~ " должен лежать в файле "
#~ ":samp:`{instance_dir}/my_app.lua`."

#~ msgid "Commands for tarantoolctl"
#~ msgstr "Команды для tarantoolctl"

#~ msgid ""
#~ "The command format is :samp:`tarantoolctl "
#~ "{operation} {application_name}`, where operation "
#~ "is one of: start, stop, enter, "
#~ "logrotate, status, eval. Thus ..."
#~ msgstr ""
#~ "Команды для :program:`tarantoolctl` имеют вид"
#~ " :samp:`tarantoolctl {операция} {имя_приложения}`. "
#~ "В качестве *операции* можно указать одно"
#~ " из следующих значений: start, stop, "
#~ "enter, logrotate, status, eval."

#~ msgid "Start application *<application>*"
#~ msgstr "Запустить приложение с именем *<application>*"

#~ msgid "Show application's admin console"
#~ msgstr "Вывести консоль для управления приложением"

#~ msgid "Check application's status"
#~ msgstr "Проверить статус приложения"

#~ msgid "Execute code from *<scriptname>* on an instance of application"
#~ msgstr ""
#~ "Выполнить код из файла *<scriptname>* от"
#~ " имени запущенного экземпляра приложения "
#~ "*<application>*"

#~ msgid ""
#~ "Connect to a Tarantool server running"
#~ " at the specified :ref:`URI <index-"
#~ "uri>`"
#~ msgstr ""

#~ msgid "Typical code snippets for tarantoolctl"
#~ msgstr "Примеры кода для tarantoolctl"

#~ msgid "A user can check whether ``my_app`` is running with these lines:"
#~ msgstr "Проверить, запущено ли приложение ``my_app``:"

#~ msgid ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"
#~ msgstr ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"

#~ msgid ""
#~ "A user can initiate, for boot "
#~ "time, an :file:`init.d` set of "
#~ "instructions:"
#~ msgstr ""
#~ "Выполнить инструкции из файла :file:`init.d`"
#~ " во время запуска приложения:"

#~ msgid ""
#~ "for (each file mentioned in the instance_dir directory):\n"
#~ "    tarantoolctl start `basename $ file .lua`"
#~ msgstr ""
#~ "for (каждый файл в директории instance_dir):\n"
#~ "    tarantoolctl start `basename $ file .lua`"

#~ msgid ""
#~ "A user can set up a further "
#~ "configuration file for log rotation, "
#~ "like this:"
#~ msgstr "Указать файл конфигурации для ротации журнала, например:"

#~ msgid "A detailed example for tarantoolctl"
#~ msgstr "Подробный пример для tarantoolctl"

#~ msgid ""
#~ "The example's objective is to make "
#~ "a temporary directory where "
#~ ":program:`tarantoolctl` can start a long-"
#~ "running application and monitor it."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "В этом примере мы создадим временную "
#~ "директорию, в которой :program:`tarantoolctl` "
#~ "сможет запускать и мониторить некое "
#~ "долго работающее приложение."

#~ msgid ""
#~ "The assumptions are: the root password"
#~ " is known, the computer is only "
#~ "being used for tests, the Tarantool "
#~ "server is ready to run but is "
#~ "not currently running, tarantoolctl is "
#~ "installed along the user's path, and "
#~ "there currently is no directory named"
#~ " :file:`tarantool_test`."
#~ msgstr ""
#~ "Итак, наши исходные условия: нам "
#~ "известен пароль root-пользователя; компьютер "
#~ "используется только для тестирования; "
#~ "Tarantool-сервер настроен и готов к "
#~ "запуску, но пока еще не запущен "
#~ ";программа :program:`tarantoolctl` установлена в "
#~ "пользовательском окружении; пока не существует"
#~ " директории с именем :file:`tarantool_test`."

#~ msgid "Create a directory named :file:`/tarantool_test`:"
#~ msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#~ msgid ""
#~ "Edit :file:`/usr/local/etc/default/tarantool`. It "
#~ "might be necessary to say :samp:`sudo"
#~ " mkdir /usr/local/etc/default` first. Let "
#~ "the new file contents be:"
#~ msgstr ""
#~ "Отредактируем файл "
#~ ":file:`/usr/local/etc/default/tarantool`. Для этого "
#~ "нам сначала может понадобиться выполнить "
#~ "команду :samp:`sudo mkdir /usr/local/etc/default`."
#~ " Указанный файл будет содержать следующие"
#~ " настройки:"

#~ msgid ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""
#~ msgstr ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""

#~ msgid ""
#~ "Clean up. Restore the original contents"
#~ " of :file:`/usr/local/etc/default/tarantool`, and "
#~ "..."
#~ msgstr ""
#~ "Почистим систему после тестирования. Приведем"
#~ " содержимое файла "
#~ ":file:`/usr/local/etc/default/tarantool` к исходному "
#~ "виду и удалим нашу тестовую директорию:"

#~ msgid ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"
#~ msgstr ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"

#~ msgid "An example for tarantoolctl connect"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Подробный пример для tarantoolctl"

#~ msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
#~ msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#~ msgid ""
#~ "There are alternatives to "
#~ ":program:`tarantoolctl connect` -- you can "
#~ "use the :ref:`console module <console-"
#~ "module>` or the :ref:`net.box module "
#~ "<net_box-module>` from a Tarantool server."
#~ " Also, you can write your client "
#~ "programs with any of the Connectors. "
#~ "However, most of the examples in "
#~ "this manual illustrate usage with either"
#~ " :program:`tarantoolctl connect` or with "
#~ ":ref:`using the Tarantool server as a"
#~ " client <administration-using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Вместо :program:`tarantoolctl connect` вы "
#~ "можете использовать модули :ref:`console "
#~ "<console-module>` или :ref:`net.box <net_box-"
#~ "module>` из библиотеки Tarantool'а. Еще "
#~ "одна альтернатива — это написать "
#~ "клиентскую программу под любой из "
#~ "существующих Tarantool-коннекторов. Но для "
#~ "большинства примеров в текущей документации"
#~ " мы используем :program:`tarantoolctl connect`"
#~ " или :ref:`Tarantool-сервер в качестве "
#~ "клиента <administration-using_tarantool_as_a_client>`."

#~ msgid "Administrative ports"
#~ msgstr "Служебные порты"

#~ msgid ""
#~ "\"Admin port\", \"admin console\", and "
#~ "\"text protocol\" all refer to the "
#~ "same thing: a connection which is "
#~ "set up with :ref:`console.listen(...) "
#~ "<console-listen>` for entry of requests "
#~ "by administrators."
#~ msgstr ""
#~ "Термины \"порт для администрирования\", "
#~ "\"консоль для администрирования\", \"текстовый "
#~ "протокол\" относятся к установке соединения"
#~ " с помощью :ref:`console.listen(...) <console-"
#~ "listen>` для ввода запросов от "
#~ "администраторов."

#~ msgid ""
#~ "\"Binary port\", \"binary protocol\", and "
#~ "\"primary port\" all refer to a "
#~ "different thing: a connection which is"
#~ " set up with :ref:`box.cfg{listen=...} "
#~ "<cfg_basic-listen>` for entry of requests"
#~ " by anyone."
#~ msgstr ""
#~ "Термины \"бинарный порт\", \"бинарный "
#~ "протокол\", \"первичный порт\" относятся к "
#~ "другому виду соединения — тому, что "
#~ "устанавливается с помощью параметра "
#~ ":ref:`box.cfg{listen=...} <cfg_basic-listen>` и "
#~ "предназначено для ввода запросов от "
#~ "любых пользователей."

#~ msgid ""
#~ "Ordinary connections to the Tarantool "
#~ "server should go via a binary "
#~ "port. But admin ports are useful "
#~ "for special cases involving security."
#~ msgstr ""
#~ "Для обычных соединений с Tarantool-сервером"
#~ " должен использоваться бинарный протокол. А"
#~ " порты для администрирования нужны для "
#~ "особых случаев, когда повышены требования "
#~ "к безопасности."

#~ msgid ""
#~ "if the listener has the privilege "
#~ "to write on :file:`/var/lib/tarantool` and "
#~ "the connector has the privilege to "
#~ "read on :file:`/var/lib/tarantool`. Alternatively"
#~ " both setup and connection can be "
#~ "done with :ref:`tarantoolctl <administration-"
#~ "tarantoolctl>`."
#~ msgstr ""
#~ "Это в том случае, если у сервера"
#~ " (listener'а) есть привилегии на запись "
#~ "в файл :file:`/var/lib/tarantool`, а на "
#~ "стороне клиента (connector'а) есть привилегии"
#~ " на чтение из того же файла. "
#~ "Аналогично можно установить соединение и "
#~ "задать настройки с помощью :ref:`tarantoolctl"
#~ " <administration-tarantoolctl>`."

#~ msgid ""
#~ "If no administrator password exists "
#~ "which could be given out to users,"
#~ " and admin ports are restricted or"
#~ " are sockets, then requests which "
#~ "require 'admin' privileges can only "
#~ "occur locally, and are subject to "
#~ "Unix security and monitoring."
#~ msgstr ""
#~ "Если не задан пароль администратора, "
#~ "который можно сообщить пользователям, а "
#~ "порты для администрирования настроены с "
#~ "ограничением доступа по IP либо через"
#~ " сокеты, то запросы, требующие привилегий"
#~ " администратора, можно делать только "
#~ "локально, где вопросы безопасности и "
#~ "мониторинга регулируются с помощью средств "
#~ "Unix-системы."

#~ msgid ""
#~ "For additional security, some requests "
#~ "are illegal. For example, :ref:`\"conn:eval\""
#~ " <net_box-eval>`  will result in the"
#~ " error message \"- error: console "
#~ "does not support this request type\" "
#~ "because ``conn:eval`` requires the binary "
#~ "protocol."
#~ msgstr ""
#~ "В целях дополнительной безопасности некоторые"
#~ " запросы на портах для администрирования"
#~ " запрещены. Например, :ref:`conn:eval "
#~ "<net_box-eval>` вернет сообщение об ошибке"
#~ " ``- error: console does not support"
#~ " this request type``, поскольку запрос "
#~ "``conn:eval`` должен осуществляться в рамках"
#~ " бинарного протокола."

#~ msgid ""
#~ "If security via admin ports is not"
#~ " necessary, it is still possible to"
#~ " be an admin user by :ref:`using "
#~ "the tarantool server as a client "
#~ "<administration-using_tarantool_as_a_client>`, or by"
#~ " connecting to a binary port with "
#~ "a valid password."
#~ msgstr ""
#~ "Если вопросы безопасности на портах для"
#~ " администрирования неактуальны, то стать "
#~ "пользователем с правами администратора можно,"
#~ " :ref:`используя Tarantool-сервер в качестве "
#~ "клиента <administration-using_tarantool_as_a_client>` "
#~ "или указав администраторский пароль при "
#~ "установке соединения по бинарному протоколу."

#~ msgid ""
#~ "$ telnet 0 3303\n"
#~ "Trying 0.0.0.0...\n"
#~ "Connected to 0.\n"
#~ "Escape character is '^]'.\n"
#~ "Tarantool 1.7.2-70-gbc479ad (Lua console)\n"
#~ "type 'help' for interactive help"
#~ msgstr ""

#~ msgid "Administrative requests"
#~ msgstr "Служебные запросы"

#~ msgid ""
#~ "To learn which functions are considered"
#~ " to be administrative, type ``help()``. "
#~ "A reference description also follows "
#~ "below:"
#~ msgstr ""

#~ msgid ""
#~ "Since a snapshot is written "
#~ "sequentially, one can expect a very "
#~ "high write performance (averaging to "
#~ "80MB/second on modern disks), which "
#~ "means an average database instance gets"
#~ " saved in a matter of minutes. "
#~ "Note: as long as there are any "
#~ "changes to the parent index memory "
#~ "through concurrent updates, there are "
#~ "going to be page splits, and "
#~ "therefore one needs to have some "
#~ "extra free memory to run this "
#~ "command. 10% of :ref:`slab_alloc_arena "
#~ "<cfg_storage-slab_alloc_arena>` is, on average,"
#~ " sufficient. This statement waits until "
#~ "a snapshot is taken and returns "
#~ "operation result."
#~ msgstr ""

#~ msgid ""
#~ "Change Notice: prior to Tarantool "
#~ "version 1.6.6, the snapshot process "
#~ "caused a fork, which could cause "
#~ "occasional latency spikes. Starting with "
#~ "Tarantool version 1.6.6, the snapshot "
#~ "process creates a consistent read view"
#~ " and writes this view to the "
#~ "snapshot file from a separate thread."
#~ msgstr ""

#~ msgid ""
#~ "Although box.snapshot() does not cause a"
#~ " fork, there is a separate fiber "
#~ "which may produce snapshots at regular"
#~ " intervals -- see the discussion of"
#~ " the :ref:`snapshot daemon "
#~ "<book_cfg_snapshot_daemon>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.info.version\n"
#~ "---\n"
#~ "- 1.7.0-1216-g73f7154\n"
#~ "...\n"
#~ "tarantool> box.snapshot()\n"
#~ "---\n"
#~ "- ok\n"
#~ "...\n"
#~ "tarantool> box.snapshot()\n"
#~ "---\n"
#~ "- error: can't save snapshot, errno 17 (File exists)\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Taking a snapshot does not cause "
#~ "the server to start a new "
#~ "write-ahead log. Once a snapshot is"
#~ " taken, old WALs can be deleted "
#~ "as long as all replicas are up "
#~ "to date. But the WAL which was "
#~ "current at the time ``box.snapshot()`` "
#~ "started must be kept for recovery, "
#~ "since it still contains log records "
#~ "written after the start of "
#~ "``box.snapshot()``."
#~ msgstr ""

#~ msgid ""
#~ "An alternative way to save a "
#~ "snapshot is to send the server "
#~ "SIGUSR1 UNIX signal. While this approach"
#~ " could be handy, it is not "
#~ "recommended for use in automation: a "
#~ "signal provides no way to find out"
#~ " whether the snapshot was taken "
#~ "successfully or not."
#~ msgstr ""

#~ msgid ""
#~ "Fork and dump a core. Since "
#~ "Tarantool stores all tuples in memory,"
#~ " it can take some time. Mainly "
#~ "useful for debugging."
#~ msgstr ""

#~ msgid ""
#~ "For server introspection, use the "
#~ "reports provided by functions in the "
#~ "following submodules:"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`box.info <box_introspection-box_info>` "
#~ "submodule (introspect Tarantool's server "
#~ "variables)"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`box.stat <box_introspection-box_stat>` "
#~ "submodule (introspect Tarantool's request and"
#~ " network statistics)"
#~ msgstr ""

#~ msgid ""
#~ "To set up replication, it's necessary"
#~ " to set up the master servers "
#~ "which make the original data-change "
#~ "requests, set up the replica servers "
#~ "which copy data-change requests from "
#~ "masters, and establish procedures for "
#~ "recovery from a degraded state."
#~ msgstr ""
#~ "Чтобы настроить репликацию, необходимо "
#~ "настроить главные сервера (master), которые"
#~ " первыми обрабатывают запросы на изменение"
#~ " данных, затем настроить сервера-реплики "
#~ "(replica), которые копируют к себе "
#~ "запросы на изменение данных с главных"
#~ " серверов, и прописать процедуры для "
#~ "восстановления после сбоя."

#~ msgid ""
#~ "A server requires a valid snapshot "
#~ "(.snap) file. A snapshot file is "
#~ "created for a server the first "
#~ "time that ``box.cfg`` occurs for it. "
#~ "If this first ``box.cfg`` request occurs"
#~ " without a \"replication source\" clause,"
#~ " then the server is a master "
#~ "and starts its own new cluster "
#~ "with a new unique UUID. If this"
#~ " first ``box.cfg`` request occurs with "
#~ "a \"replication source\" clause, then "
#~ "the server is a replica and its"
#~ " snapshot file, along with the "
#~ "cluster information, is constructed from "
#~ "the write-ahead logs of the "
#~ "master. Therefore, to start replication, "
#~ "specify :ref:`replication_source <cfg_replication-"
#~ "replication_source>` in a ``box.cfg`` request."
#~ " When a replica contacts a master "
#~ "for the first time, it becomes "
#~ "part of a cluster. On subsequent "
#~ "occasions, it should always contact a"
#~ " master in the same cluster."
#~ msgstr ""
#~ "Каждому Tarantool-серверу необходим корректный "
#~ "файл со статическим снимком данных "
#~ "(.snap-файл). Файл-снимок создается на сервере"
#~ " при первом запросе ``box.cfg``. Если "
#~ "при первом таком запросе на сервере "
#~ "не определен источник репликации (replication"
#~ " source), то сервер стартует в режиме"
#~ " главного сервера и создает для себя"
#~ " новый кластер с новым уникальными "
#~ "UUID. Если же источник репликации при"
#~ " первом ``box.cfg``-запросе определен, то "
#~ "сервер стартует в режиме реплики, а "
#~ "файл-снимок и информация о кластере "
#~ "берутся из WAL-файлов на главном "
#~ "сервере. Поэтому при настройке репликации "
#~ "нужно указать параметр :ref:`replication_source "
#~ "<cfg_replication-replication_source>` в запросе "
#~ "``box.cfg``. При первом соединении с "
#~ "главным сервером сервер-реплика включается в"
#~ " состав кластера. В дальнейшем такая "
#~ "реплика общается только с главным "
#~ "сервером из данного кластера."

#~ msgid ""
#~ "However, once a master failure is "
#~ "detected, the recovery is simple: "
#~ "declare that the replica is now "
#~ "the new master, by saying "
#~ ":codenormal:`box.cfg{... "
#~ "listen=`:codeitalic:`URI`:codenormal:`}`. Then, if "
#~ "there are updates on the old "
#~ "master that were not propagated before"
#~ " the old master went down, they "
#~ "would have to be re-applied "
#~ "manually."
#~ msgstr ""

#~ msgid ""
#~ "Q: What if there are more than "
#~ "two servers with master-master? |br| "
#~ "A: On each server, specify the "
#~ ":ref:`replication_source <cfg_replication-"
#~ "replication_source>` for all the others. "
#~ "For example, server #3 would have "
#~ "a request: |br| :codenormal:`box.cfg{` |br|"
#~ " |nbsp| |nbsp| |nbsp| "
#~ ":codenormal:`replication_source = {`:codeitalic:`uri#1,"
#~ " uri#2`:codenormal:`}` |br| :codenormal:`}`"
#~ msgstr ""
#~ "Вопрос: Что если в кластере вида "
#~ "master-master более двух серверов? |br| "
#~ "Ответ: На каждом сервере нужно задать"
#~ " параметр :ref:`replication_source <cfg_replication-"
#~ "replication_source>` и указать в нем все"
#~ " остальные сервера. Например, для сервера"
#~ " #3 настройки будут следующими: |br| "
#~ ":codenormal:`box.cfg{` |br| |nbsp| |nbsp| "
#~ "|nbsp| :codenormal:`replication_source = "
#~ "{`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| "
#~ ":codenormal:`}`"

#~ msgid ""
#~ "Q: What if it's necessary to know"
#~ " what cluster a server is in? "
#~ "|br| A: The identification of the "
#~ "cluster is a UUID which is "
#~ "generated when the first master starts"
#~ " for the first time. This UUID "
#~ "is stored in a tuple of the "
#~ ":ref:`box.space._schema <box_space-schema>` system"
#~ " space. So to see it, say: "
#~ "``box.space._schema:select{'cluster'}``"
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, к "
#~ "какому кластеру принадлежит данный сервер? "
#~ "|br| Ответ: Идентификатором кластера является"
#~ " UUID, который генерируется при первом "
#~ "запуске главного сервера. Данный UUID "
#~ "хранится в системном пространстве "
#~ ":ref:`box.space._schema <box_space-schema>`. Чтобы"
#~ " посмотреть UUID кластера, введите запрос"
#~ " ``box.space._schema:select{'cluster'}``"

#~ msgid ""
#~ "Q: What if it's necessary to know"
#~ " what other servers belong in the "
#~ "cluster? |br| A: The universal "
#~ "identification of a server is a "
#~ "UUID in ``box.info.server.uuid``. The ordinal"
#~ " identification of a server within a"
#~ " cluster is a number in "
#~ "``box.info.server.id``. To see all the "
#~ "servers in the cluster, say: "
#~ "``box.space._cluster:select{}``. This will return"
#~ " a table with all {server.id, "
#~ "server.uuid} tuples for every server "
#~ "that has ever joined the cluster."
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, какие"
#~ " сервера входят в кластер? |br| "
#~ "Ответ: У каждого сервера есть "
#~ "универсальный идентификатор — это его "
#~ "UUID в поле ``box.info.server.uuid``. Также"
#~ " у сервера есть его порядковый "
#~ "идентификатор в кластере — это номер "
#~ "в поле ``box.info.server.id``. Чтобы увидеть"
#~ " номера всех серверов в кластере, "
#~ "введите запрос: ``box.space._cluster:select{}``. "
#~ "Данный запрос возвращает таблицу со "
#~ "всеми кортежами вида {server.id, server.uuid}"
#~ " для всех серверов, что когда-либо "
#~ "входили в данный кластер."

#~ msgid ""
#~ "Q: What if advanced users want to"
#~ " understand better how it all works?"
#~ " |br| A: See the description of "
#~ "server startup with replication in the"
#~ " :ref:`Internals <internals-replication>` "
#~ "section."
#~ msgstr ""

#~ msgid ""
#~ "The exact procedure for backing up "
#~ "a database depends on: how up-"
#~ "to-date the database must be, how "
#~ "frequently backups must be taken, "
#~ "whether it is okay to disrupt "
#~ "other users, and whether the procedure"
#~ " should be optimized for size (saving"
#~ " disk space) or for speed (saving "
#~ "time). So there is a spectrum of"
#~ " possible policies, ranging from cold-"
#~ "and-simple to hot-and-difficult."
#~ msgstr ""
#~ "При выборе конкретной процедуры для "
#~ "резервного копирования базы данных нужно "
#~ "учитывать следующие требования: насколько "
#~ "актуальной должна быть копия, можно ли"
#~ " временно отключать других пользователей, а"
#~ " также нужна ли оптимизация размера "
#~ "копии (чтобы копия занимала меньше места"
#~ " на диске) или скорости самой "
#~ "процедуры (чтобы процедура занимала меньше "
#~ "времени). Выбирать можно из нескольких "
#~ "вариантов в диапазоне от \"простого и"
#~ " холодного\" до \"трудного и горячего\"."

#~ msgid "Cold backup"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "**\"Холодное\" резервирование**"

#~ msgid ""
#~ "Prevent all users from writing to "
#~ "the database. This can be done by"
#~ " shutting down the server, or by "
#~ "saying ``box.cfg{read_only=true}`` and then "
#~ "ensuring that all earlier writes are "
#~ "complete (:program:`fsync` can be used "
#~ "for this purpose)."
#~ msgstr ""
#~ "Временно запретите всем пользователям делать"
#~ " записи в базе. Для этого можно "
#~ "остановить Tarantool-сервер, либо ввести "
#~ "запрос ``box.cfg{read_only=true}`` и убедиться, "
#~ "что все обращения на запись завершились"
#~ " (для этого можно использовать "
#~ ":program:`fsync`)."

#~ msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
#~ msgstr ""
#~ "Если вы хотите создать резеврную копию"
#~ " для всей базы целиком, введите "
#~ "запрос :samp:`box.snapshot()`."

#~ msgid ""
#~ "In essence: :ref:`replication <index-"
#~ "box_replication>` is useful for backup "
#~ "as well as for load balancing. "
#~ "Therefore taking a backup is a "
#~ "matter of ensuring that any given "
#~ "replica is up to date, and doing"
#~ " a cold backup on it. Since all"
#~ " the other replicas continue to "
#~ "operate, this is not a cold backup"
#~ " from the end user's point of "
#~ "view. This could be done on a "
#~ "regular basis, with a cron job or"
#~ " with a Tarantool fiber."
#~ msgstr ""
#~ "Суть процедуры: для резервирования (а "
#~ "также для балансирования нагрузки) можно "
#~ "использовать :ref:`репликацию <index-"
#~ "box_replication>`. Процедура резервирования в "
#~ "рамках репликационного кластера сводится к "
#~ "тому, чтобы держать все реплики в "
#~ "актуальном состоянии и периодически делать "
#~ "с них \"холодные\" копии. Поскольку во"
#~ " время снятия копии с какой-либо "
#~ "одной реплики все остальные реплики "
#~ "продолжают синхронизироваться с главным "
#~ "сервером, то эта процедура несколько "
#~ "отличается от описанной выше процедуры "
#~ "\"холодного\" резервирования. Регулярное "
#~ "резервирование в кластере можно настроить "
#~ "с помощью планировщика :program:`cron` или "
#~ "Tarantool-файбера."

#~ msgid "Note re storage engine: vinyl databases require additional steps."
#~ msgstr ""
#~ "Примечание про движок: при организации "
#~ "резервирования для баз данных на движке"
#~ " vinyl понадобятся дополнительные действия."

#~ msgid ""
#~ "First, put your application's business "
#~ "logic in a Tarantool-Lua module "
#~ "that exports its functions for CALL."
#~ msgstr ""
#~ "Во-первых, вынесите всю бизнес-логику своего"
#~ " приложения в отдельный Tarantool-модуль на"
#~ " языке Lua так, чтобы все нужные "
#~ "функции были доступны для вызова извне"
#~ " (CALL)."

#~ msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
#~ msgstr "Вот пример такого модуля, файл :file:`/usr/share/tarantool/myapp.lua`:"

#~ msgid ""
#~ "local function start()\n"
#~ "  -- Initial version\n"
#~ "  box.once(\"myapp:.1.0\", function()\n"
#~ "  box.schema.space.create(\"somedata\")\n"
#~ "  box.space.somedata:create_index(\"primary\")\n"
#~ "  ...\n"
#~ "\n"
#~ "  -- migration code from 1.0 to 1.1\n"
#~ "  box.once(\"myapp:.v1.1\", function()\n"
#~ "  box.space.somedata.index.primary:alter(...)\n"
#~ "  ...\n"
#~ "\n"
#~ "  -- migration code from 1.1 to 1.2\n"
#~ "  box.once(\"myapp:.v1.2\", function()\n"
#~ "  box.space.somedata.space:alter(...)\n"
#~ "  box.space.somedata:insert(...)\n"
#~ "  ...\n"
#~ "end\n"
#~ "\n"
#~ "-- start some background fibers if you need\n"
#~ "\n"
#~ "local function stop()\n"
#~ "  -- stop all background fibers and cleanup resources\n"
#~ "end\n"
#~ "\n"
#~ "local function api_for_call(xxx)\n"
#~ "  -- do some business\n"
#~ "end\n"
#~ "\n"
#~ "return {\n"
#~ "  start = start;\n"
#~ "  stop = stop;\n"
#~ "  api_for_call = api_for_call;\n"
#~ "}"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "local function start()\n"
#~ "-- Первоначальная версия\n"
#~ "box.once(\"myapp:.1.0\", function()\n"
#~ "box.schema.space.create(\"somedata\")\n"
#~ "box.space.somedata:create_index(\"primary\")\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Код для миграции с 1.0 на 1.1\n"
#~ "box.once(\"myapp:.v1.1\", function()\n"
#~ "box.space.somedata.index.primary:alter(...)\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Код для миграции с 1.1 на 1.2\n"
#~ "box.once(\"myapp:.v1.2\", function()\n"
#~ "box.space.somedata.space:alter(...)\n"
#~ "box.space.somedata:insert(...)\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Если нужно, запустить файберы в фоновом режиме\n"
#~ "\n"
#~ "local function stop()\n"
#~ "-- Остановить все фоновые файберы и освободить ресурсы\n"
#~ "end\n"
#~ "\n"
#~ "local function api_for_call(xxx)\n"
#~ "-- Сделать что-то полезное\n"
#~ "end\n"
#~ "\n"
#~ "return {\n"
#~ "start = start;\n"
#~ "stop = stop;\n"
#~ "api_for_call = api_for_call;\n"
#~ "}"

#~ msgid ""
#~ "This file is maintained by the "
#~ "application's developers. On its side, "
#~ "Tarantool Team provides templates for "
#~ "you to `assemble deb/rpm packages "
#~ "<https://github.com/tarantool/modulekit>`_ and utilities"
#~ " to quickly `assemble packages for "
#~ "specific platforms <https://github.com/tarantool/build>`_."
#~ " If needed, you can split "
#~ "applications into standalone files and/or "
#~ "modules."
#~ msgstr ""
#~ "Поддержка этого файла лежит на стороне"
#~ " разработчиков приложения. А команда "
#~ "разработки Tarantool'а со своей стороны "
#~ "предлагает шаблоны, для того чтобы вы"
#~ " могли `создать у себя deb/rpm-сборку "
#~ "<https://github.com/tarantool/modulekit>`_, а также "
#~ "утилиты для быстрого `создания сборок "
#~ "под разные платформы "
#~ "<https://github.com/tarantool/build>`_. Если понадобится,"
#~ " вы можете разбить приложения на "
#~ "отдельные файлы и/или модули."

#~ msgid ""
#~ "Second, put an initialization script to"
#~ " the :file:`/etc/tarantool/instances.available` "
#~ "directory."
#~ msgstr ""
#~ "Во вторых, положите скрипт инициализации "
#~ "в директорию :file:`/etc/tarantool/instances.available`."

#~ msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
#~ msgstr ""
#~ "Вот пример такого скрипта, файл "
#~ ":file:`/etc/tarantool/instances.available/myappcfg.lua`:"

#~ msgid ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "  listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "  -- hot code reload using tarantoolctl or dofile()\n"
#~ "\n"
#~ "  -- unload old application\n"
#~ "  myapp.stop()\n"
#~ "  -- clear cache for loaded modules and dependencies\n"
#~ "  package.loaded['myapp'] = nil\n"
#~ "  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- load a new version of app and all dependencies\n"
#~ "myapp = require('myapp').start({some app "
#~ "options controlled by sysadmins})"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
#~ "\n"
#~ "-- Выгрузка старого приложения\n"
#~ "myapp.stop()\n"
#~ "-- Очистка кеша от загруженных модулей и зависимостей\n"
#~ "package.loaded['myapp'] = nil\n"
#~ "package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- Загрузка новой версии приложения и всех зависимостей\n"
#~ "myapp = require('myapp').start({some app "
#~ "options controlled by sysadmins})"

#~ msgid ""
#~ "As a more detailed example, you "
#~ "can take the :file:`example.lua` script "
#~ "that ships with Tarantool and defines"
#~ " all configuration options."
#~ msgstr ""
#~ "Более детальный пример (со всеми "
#~ "настройками) содержится в файле "
#~ ":file:`example.lua`, который входит в состав"
#~ " дистрибутива Tarantool'а."

#~ msgid ""
#~ "This initialization script is actually a"
#~ " configuration file and should be "
#~ "maintained by system administrators, while "
#~ "developers only provide a template."
#~ msgstr ""
#~ "Этот скрипт инициализации по сути "
#~ "является конфигурационным файлом. Его "
#~ "поддержкой должны заниматься системные "
#~ "администраторы, в то время как "
#~ "разработчики только предоставляют им шаблон."

#~ msgid ""
#~ "Now update your app file in "
#~ ":file:`/usr/share/tarantool`. Replace your "
#~ "application file (for example, "
#~ ":file:`/usr/share/tarantool/myapp.lua`) and manually "
#~ "reload the :file:`myappcfg.lua` initialization "
#~ "script using :program:`tarantoolctl`:"
#~ msgstr ""
#~ "Теперь обновите файл с вашим приложением"
#~ " в директории :file:`/usr/share/tarantool`. "
#~ "Замените старую версию файла (например, "
#~ ":file:`/usr/share/tarantool/myapp.lua`) и вручную "
#~ "загрузите скрипт инициализации :file:`myappcfg.lua`"
#~ " с помощью утилиты :program:`tarantoolctl`:"

#~ msgid ""
#~ "After that, you need to manually "
#~ "flush the cache of ``package.loaded`` "
#~ "modules."
#~ msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#~ msgid ""
#~ "For deb/rpm packages, you can add "
#~ "the ``tarantoolctl eval`` instruction directly"
#~ " into Tarantool's specification in "
#~ ":file:`RPM.spec` and the :file:`/debian` "
#~ "directory."
#~ msgstr ""
#~ "Чтобы создать deb/rpm-сборку, вы можете "
#~ "добавить инструкцию ``tarantoolctl eval`` "
#~ "прямо в спецификацию Tarantool'а в файле"
#~ " :file:`RPM.spec` и в директории "
#~ ":file:`/debian`."

#~ msgid ""
#~ "Finally, clients make a CALL to "
#~ "``myapp.api_for_call`` and other API "
#~ "functions."
#~ msgstr ""
#~ "В итоге клиенты делают вызов (CALL) "
#~ "функции ``myapp.api_for_call`` и других "
#~ "функций из API."

#~ msgid ""
#~ "In the case of ``tarantool-http``, "
#~ "there is no need to start the "
#~ "binary protocol at all."
#~ msgstr ""
#~ "Если вы используете ``tarantool-http``, "
#~ "то запускать бинарный протокол не нужно."

#~ msgid ""
#~ "This information applies for users who"
#~ " created databases with older versions "
#~ "of the Tarantool server, and have "
#~ "now installed a newer version. The "
#~ "request to make in this case is:"
#~ " :samp:`box.schema.upgrade()`."
#~ msgstr ""
#~ "Эта информация полезна в том случае, "
#~ "если у вас есть база данных, "
#~ "работающая на какой-либо старой версии "
#~ "Tarantool'а, а теперь вы установили "
#~ "Tarantool новой версии. В этом случае"
#~ " выполните запрос :samp:`box.schema.upgrade()`."

#~ msgid "SIGINT"
#~ msgstr "SIGINT"

#~ msgid ""
#~ "Other signals will result in behavior"
#~ " defined by the operating system. "
#~ "Signals other than SIGKILL may be "
#~ "ignored, especially if the server is "
#~ "executing a long-running procedure which"
#~ " prevents return to the main thread"
#~ " event loop."
#~ msgstr ""
#~ "Действие других сигналов определяется "
#~ "операционной системой. Все сигналы, кроме "
#~ "SIGKILL, могут быть проигнорированы, особенно"
#~ " если Tarantool-сервер выполняет длительную "
#~ "процедуру, которая позволяет вернуться к "
#~ "главному циклу."

#~ msgid "Process title"
#~ msgstr "Название процесса"

#~ msgid ""
#~ "Linux and FreeBSD operating systems "
#~ "allow a running process to modify "
#~ "its title, which otherwise contains the"
#~ " program name. Tarantool uses this "
#~ "feature to help meet the needs of"
#~ " system administration, such as figuring"
#~ " out what services are running on "
#~ "a host, their status, and so on."
#~ msgstr ""
#~ "Операционные системы Linux и FreeBSD "
#~ "позволяют запущенному процессу менять его "
#~ "название (title), в котором изначально "
#~ "содержится имя программы (name). Tarantool "
#~ "использует эту возможность, чтобы упростить"
#~ " работу системного администратора, например "
#~ "посмотреть, какие службы запущены на "
#~ "хосте, их статус и т.д."

#~ msgid "A Tarantool server's process title has these components:"
#~ msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#~ msgid ""
#~ ":extsamp:`{**{program_name}**} "
#~ "[{**{initialization_file_name}**}] {**{<role_name>}**} "
#~ "[{**{custom_proc_title}**}]`"
#~ msgstr ""
#~ ":extsamp:`{**{имя_программы}**} "
#~ "[{**{имя_файла_инициализации}**}] {**{<имя_роли>}**} "
#~ "[{**{название_процесса}**}]`"

#~ msgid "**program_name** is typically \"tarantool\"."
#~ msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#~ msgid ""
#~ "**initialization_file_name** is the name of"
#~ " an :ref:`initialization file <index-"
#~ "init_label>`, if one was specified."
#~ msgstr ""
#~ "**имя_файла_инициализации** — это имя  "
#~ ":ref:`файла инициализации на Lua <index-"
#~ "init_label>`, если этот файл был указан"
#~ " при запуске."

#~ msgid "**role_name** is:"
#~ msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#~ msgid "\"running\" (ordinary node \"ready to accept requests\"),"
#~ msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#~ msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
#~ msgstr ""
#~ "\"loading\" (узел, который загружает данные"
#~ " из ранее сохраненного снимка и "
#~ "WAL-файла),"

#~ msgid "\"orphan\" (not in a cluster),"
#~ msgstr "\"orphan\" (узел не входит в состав кластера),"

#~ msgid "\"hot_standby\", or"
#~ msgstr ""

#~ msgid "\"dumper\" + process-id (saving a snapshot)."
#~ msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#~ msgid ""
#~ "**custom_proc_title** is taken from the "
#~ ":ref:`custom_proc_title <cfg_basic-custom_proc_title>` "
#~ "configuration parameter, if one was "
#~ "specified."
#~ msgstr ""
#~ "**название_процесса** — это необязательное "
#~ "название Tarantool-процесса в системе, которое"
#~ " берется из конфигурационного параметра "
#~ ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`,"
#~ " если он указан."

#~ msgid ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916"
#~ "   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"
#~ msgstr ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916"
#~ "   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"

#~ msgid "System-specific administration notes"
#~ msgstr "Заметки по администрированию для разных платформ"

#~ msgid ""
#~ "This section will contain information "
#~ "about issues or features which exist "
#~ "on some platforms but not others -"
#~ " for example, on certain versions of"
#~ " a particular Linux distribution."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "В этом разделе приводится информация по"
#~ " проблемам и особенностям, которые "
#~ "относятся только к конкретным платформам. "
#~ "Например, к определенным версиям Linux-систем."

#~ msgid "Debian GNU/Linux and Ubuntu"
#~ msgstr "Debian GNU/Linux and Ubuntu"

#~ msgid ""
#~ "$ ln -s /etc/tarantool/instances.available"
#~ "/*instance-name.cfg* /etc/tarantool/instances.enabled/"
#~ msgstr ""
#~ "$ ln -s /etc/tarantool/instances.available"
#~ "/*instance-name.cfg* /etc/tarantool/instances.enabled/"

#~ msgid "Starting all instances:"
#~ msgstr "Запуск всех экземпляров:"

#~ msgid "$ service tarantool stop"
#~ msgstr "$ service tarantool stop"

#~ msgid "$ service tarantool-instance-name start/stop"
#~ msgstr "$ service tarantool-instance-name start/stop"

#~ msgid "Fedora, RHEL, CentOS"
#~ msgstr "Fedora, RHEL, CentOS"

#~ msgid ""
#~ "There are no known permanent issues. "
#~ "For transient issues, go to "
#~ "http://github.com/tarantool/tarantool/issues and enter "
#~ "\"RHEL\" or \"CentOS\" or \"Fedora\" or"
#~ " \"Red Hat\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для "
#~ "данных платформ нет. Если вы столкнулись"
#~ " с плавающим дефектом, посмотрите описания"
#~ " проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в "
#~ "строке поиска слово \"RHEL\", \"CentOS\", "
#~ "\"Fedora\" или \"Red Hat\"."

#~ msgid ""
#~ "There are no known permanent issues. "
#~ "For transient issues, go to "
#~ "http://github.com/tarantool/tarantool/issues and enter "
#~ "\"FreeBSD\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для "
#~ "данной платформы нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите"
#~ " описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в "
#~ "строке поиска слово \"FreeBSD\"."

#~ msgid "Mac OS X"
#~ msgstr "Mac OS X"

#~ msgid ""
#~ "There are no known permanent issues. "
#~ "For transient issues, go to "
#~ "http://github.com/tarantool/tarantool/issues and enter "
#~ "\"OS X\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для "
#~ "данных платформ нет. Если вы столкнулись"
#~ " с плавающим дефектом, посмотрите описания"
#~ " проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в "
#~ "строке поиска слово \"OS X\"."

#~ msgid ""
#~ "Tarantool fully supports :program:`systemd` "
#~ "for managing instances and supervising "
#~ "database daemons."
#~ msgstr ""
#~ "Tarantool полностью поддерживает работу с "
#~ ":program:`systemd` как со средством для "
#~ "управления экземплярами и контроля за "
#~ "фоновыми программами базы данных."

#~ msgid ""
#~ "Tarantool was designed to have multiple"
#~ " running instances of Tarantool on "
#~ "the same machine. Use :samp:`systemctl "
#~ "{start|stop|restart|status} tarantool@${MYAPP}` to "
#~ "manage your databases and Lua "
#~ "applications."
#~ msgstr ""
#~ "В архитектуре Tarantool'а заложена возможность"
#~ " запуска сразу многих экземпляров "
#~ "Tarantool-сервера на одной машине. С "
#~ "помощью :samp:`systemctl {start|stop|restart|status} "
#~ "tarantool@${MYAPP}` можно управлять базами "
#~ "данных и Lua-приложениями."

#~ msgid "Creating instances"
#~ msgstr "Создание экземпляров"

#~ msgid ""
#~ "Simply put your Lua configuration to "
#~ ":file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"
#~ msgstr ""
#~ "Задайте все настройки в виде Lua-скрипта"
#~ " и поместите их в файл "
#~ ":file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"

#~ msgid ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"
#~ msgstr ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"

#~ msgid "(this minimal example is sufficient)."
#~ msgstr "(это пример минимально достаточной конфигурации)."

#~ msgid ""
#~ "Another starting point could be the "
#~ ":file:`example.lua` script that ships with "
#~ "Tarantool and defines all options."
#~ msgstr ""
#~ "Также вы можете посмотреть пример "
#~ "Lua-скрипт в файле :file:`example.lua`, "
#~ "который входит в состав дистрибутива "
#~ "Tarantool'а и содержит значения всех "
#~ "опций."

#~ msgid ""
#~ "Use :samp:`systemctl start tarantool@${MYAPP}` "
#~ "to start ``${MYAPP}`` instance:"
#~ msgstr ""
#~ "Для запуска экземпляра ``${MYAPP}`` выполните"
#~ " команду :samp:`systemctl start "
#~ "tarantool@${MYAPP}`:"

#~ msgid "Monitoring instances"
#~ msgstr "Мониторинг экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl status tarantool@${MYAPP}` "
#~ "to check information about ``${MYAPP}`` "
#~ "instance:"
#~ msgstr ""
#~ "Для проверки информации об экземпляре "
#~ "``${MYAPP}`` выполните команду :samp:`systemctl "
#~ "status tarantool@${MYAPP}`:"

#~ msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
#~ msgstr ""
#~ "Для проверки журнала загрузки выполните "
#~ "команду :samp:`journalctl -u tarantool@${MYAPP}`:"

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"

#~ msgid "Checking logs"
#~ msgstr "Проверка журнала"

#~ msgid ""
#~ "Tarantool logs important events to "
#~ ":file:`/var/log/tarantool/${MYAPP}.log`."
#~ msgstr ""
#~ "Tarantool ведет записи о важных событиях"
#~ " в файле :file:`/var/log/tarantool/${MYAPP}.log`."

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> "
#~ "require('log').info(\"Hello for README.systemd "
#~ "readers\")\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> "
#~ "require('log').info(\"Hello for README.systemd "
#~ "readers\")\n"
#~ "---\n"
#~ "..."

#~ msgid ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> "
#~ "binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl"
#~ " I> ready to accept requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example "
#~ "I> Run console at "
#~ "/var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example "
#~ "I> tcp_server: remove dead UNIX socket:"
#~ " /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] "
#~ "main/104/console/unix/:/var/run/tarant I> started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] "
#~ "main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] "
#~ "main/105/console/unix/: I> Hello for "
#~ "README.systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] "
#~ "main/105/console/unix/: I> client unix/: "
#~ "disconnected"
#~ msgstr ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> "
#~ "binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl"
#~ " I> ready to accept requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example "
#~ "I> Run console at "
#~ "/var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example "
#~ "I> tcp_server: remove dead UNIX socket:"
#~ " /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] "
#~ "main/104/console/unix/:/var/run/tarant I> started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] "
#~ "main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] "
#~ "main/105/console/unix/: I> Hello for "
#~ "README.systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] "
#~ "main/105/console/unix/: I> client unix/: "
#~ "disconnected"

#~ msgid ""
#~ "Log rotation is enabled by default "
#~ "if you have :program:`logrotate` installed."
#~ " Please configure :file:`/etc/logrotate.d/tarantool`"
#~ " to change the default behavior."
#~ msgstr ""
#~ "Для ротации журнала нужно установить "
#~ "программу :program:`logrotate`. Настройки для "
#~ "ротации можно задать в файле "
#~ ":file:`/etc/logrotate.d/tarantool`."

#~ msgid "Stopping instances"
#~ msgstr "Остановка экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl stop tarantool@${MYAPP}` "
#~ "to see information about the running "
#~ "``${MYAPP}`` instance."
#~ msgstr ""
#~ "Для просмотра информации о запущенном "
#~ "экземпляре ``${MYAPP}`` выполните команду "
#~ ":samp:`systemctl stop tarantool@${MYAPP}`."

#~ msgid ""
#~ "All instances are automatically restarted "
#~ "by :program:`systemd` in case of "
#~ "failure."
#~ msgstr ""
#~ "Если какой-либо экземпляр Tarantool-сервера "
#~ "выходит из строя, :program:`systemd` "
#~ "автоматически перезапускает его."

#~ msgid "Let's try to destroy an instance:"
#~ msgstr "Давайте попробуем вывести из строя один экземпляр:"

#~ msgid ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: "
#~ "Remote host closed connection"
#~ msgstr ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: "
#~ "Remote host closed connection"

#~ msgid "Customizing the service file"
#~ msgstr "Правка настроек сервисного файла"

#~ msgid ""
#~ "Please don't modify the "
#~ ":file:`tarantool@.service` file in-place, "
#~ "because it will be overwritten during"
#~ " package upgrades. It is recommended "
#~ "to copy this file to "
#~ ":file:`/etc/systemd/system` and then modify "
#~ "the required settings. Alternatively, you "
#~ "can create a directory named "
#~ ":file:`unit.d/` within :file:`/etc/systemd/system` "
#~ "and put there a drop-in file "
#~ ":file:`name.conf` that only changes the "
#~ "required settings. Please see "
#~ "``systemd.unit(5)`` manual page for additional"
#~ " information."
#~ msgstr ""
#~ "Пожалуйста, не редактируйте файл "
#~ ":file:`tarantool@.service` по месту, поскольку "
#~ "все ваши изменения будут перезаписаны "
#~ "при последующих обновлениях Tarantool'а. Мы"
#~ " рекомендуем скопировать этот файл в "
#~ ":file:`/etc/systemd/system` и править настройки "
#~ "уже в копии. Либо вы можете "
#~ "создать поддиректорию с именем :file:`unit.d/`"
#~ " в директории :file:`/etc/systemd/system` и "
#~ "положить туда drop-in файл с "
#~ "именем :file:`name.conf`, в котором будут "
#~ "указаны только те настройки, которые "
#~ "нужно поменять. См. подробности в "
#~ "``systemd.unit(5)``."

#~ msgid "Debugging"
#~ msgstr "Отладка"

#~ msgid ""
#~ "$ # !!! please never do this on the production system !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> "
#~ "require('ffi').cast('char *', 0)[0] = 48\n"
#~ ""
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: "
#~ "Remote host closed connection"
#~ msgstr ""
#~ "$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
#~ "  # в условиях промышленной эксплуатации !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in "
#~ "/etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to "
#~ "unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> "
#~ "require('ffi').cast('char *', 0)[0] = 48\n"
#~ ""
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: "
#~ "Remote host closed connection"

#~ msgid ""
#~ ":samp:`coredumpctl list /usr/bin/tarantool` displays"
#~ " the latest crashes of the Tarantool"
#~ " daemon:"
#~ msgstr ""
#~ "Введем :samp:`coredumpctl list /usr/bin/tarantool`,"
#~ " чтобы получить отчет о последних "
#~ "аварийных завершениях Tarantool-демона:"

#~ msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
#~ msgstr ""
#~ "Далее с помощью команды :samp:`coredumpctl "
#~ "gdb <pid>` запустим отладчик :program:`gdb`"
#~ " и подадим сохраненный дамп памяти "
#~ "ему на вход."

#~ msgid ""
#~ "For additional information, please refer "
#~ "to the documentation provided with your"
#~ " Linux distribution."
#~ msgstr "Дополнительно см. документацию по вашей Linux-системе."

#~ msgid "Precautions"
#~ msgstr "Особые указания"

#~ msgid ""
#~ "Please don't use ``tarantoolctl "
#~ "{start,stop,restart}`` to control instances "
#~ "started by :program:`systemd`. It is "
#~ "still possible to use :program:`tarantoolctl`"
#~ " to start and stop instances from "
#~ "your local directories (e.g. :file:`${HOME}`)"
#~ " without obtaining ``ROOT`` access."
#~ msgstr ""
#~ "Пожалуйста, не используйте ``tarantoolctl "
#~ "{start,stop,restart}`` для управления экземплярами,"
#~ " которые были запущены с помощью "
#~ ":program:`systemd`. Но вы можете использовать"
#~ " :program:`tarantoolctl` для запуска/остановки "
#~ "экземпляров в ваших локальных директориях "
#~ "(например, :file:`${HOME}`), что не требует"
#~ " пользовательских прав уровня ``ROOT``."

#~ msgid ""
#~ ":program:`tarantoolctl` is configured to work"
#~ " properly with :program:`systemd`. Please "
#~ "don't modify system-wide settings of "
#~ ":program:`tarantoolctl`, such as paths, "
#~ "directory permissions and usernames. "
#~ "Otherwise, you have a chance to "
#~ "shoot yourself in the foot."
#~ msgstr ""
#~ "Утилита :program:`tarantoolctl` уже настроена "
#~ "так, чтобы корректно работать с "
#~ ":program:`systemd`. Пожалуйста, не меняйте "
#~ "общесистемные настройки для :program:`tarantoolctl`,"
#~ " такие как пути, настройки прав для"
#~ " директорий и имена пользователей, т.к. "
#~ "это может привести к неожиданным "
#~ "проблемам."

#~ msgid ""
#~ ":program:`systemd` scripts are maintained by"
#~ " the Tarantool Team (http://tarantool.org). "
#~ "Please file tickets directly to the "
#~ "upstream's bug tracker "
#~ "(https://github.com/tarantool/tarantool/issues/) rather "
#~ "than to your Linux distribution."
#~ msgstr ""
#~ "Поддержкой скриптов для :program:`systemd` "
#~ "занимается команда разработки Tarantool'а "
#~ "(http://tarantool.org). Если у вас возникли"
#~ " проблемы при работе Tarantool'а с "
#~ ":program:`systemd`, то мы просим сообщать "
#~ "об этом нашей команде "
#~ "(https://github.com/tarantool/tarantool/issues/), а не "
#~ "разработчикам вашего Linux-дистрибутива."

#~ msgid ""
#~ "These limitations exist due to decisions"
#~ " by packagers to support systemd "
#~ "alongside sysvinit."
#~ msgstr ""

#~ msgid ""
#~ "``/etc/init.d/tarantool start`` under systemd, "
#~ "or ``systemctl start tarantool`` (without "
#~ "an @instance argument), will start only"
#~ " those instances which were enabled "
#~ "before reboot or before the last "
#~ "time that systemd was reloaded with "
#~ "``systemctl daemon-reload``."
#~ msgstr ""

#~ msgid ""
#~ "(``systemctl start tarantool``, without an "
#~ "@instance argument, is provided only for"
#~ " interoperability with sysvinit scripts. "
#~ "Please use ``systemctl start "
#~ "tarantool@instance`` instead.)"
#~ msgstr ""

#~ msgid ""
#~ "``/etc/init.d/tarantool stop`` under systemd, "
#~ "or ``systemctl tarantool stop`` (without "
#~ "an @instance argument), will do nothing."
#~ msgstr ""

#~ msgid ""
#~ "Starting with Tarantool version 1.7.1.42, "
#~ "a new version of tarantool-common "
#~ "is required. (tarantool-common is a "
#~ "downloadable package which provides scripts"
#~ " to work with tarantool configuration "
#~ "and log files.) An attempt to "
#~ "upgrade tarantool-common will cause "
#~ "restart of all instances."
#~ msgstr ""

#~ msgid "sysvinit -> systemd conversion"
#~ msgstr ""

#~ msgid ""
#~ "These instructions apply only for "
#~ "Debian/Ubuntu distros where both sysvinit "
#~ "and systemd exist."
#~ msgstr ""

#~ msgid "Install new systemd-enabled packages."
#~ msgstr ""

#~ msgid ""
#~ "#For each instancename in "
#~ "/etc/tarantool/instances.enabled/: |br| #To enable"
#~ " the instance to be automatically "
#~ "loaded by systemd: |br| ``systemctl "
#~ "enable tarantool@instancename``"
#~ msgstr ""

#~ msgid ""
#~ "#The following command does nothing but"
#~ " is recommended for consistency: |br| "
#~ "``/etc/init.d/tarantool stop``"
#~ msgstr ""

#~ msgid ""
#~ "#Disable sysvinit-compatible wrappers: |br|"
#~ " ``systemctl disable tarantool; update-rc.d"
#~ " tarantool remove``"
#~ msgstr ""

#~ msgid "About modules/rocks"
#~ msgstr "Про модули/rocks"

#~ msgid ""
#~ "Alongside with using Tarantool as a "
#~ "database manager, you can also use "
#~ "it as an application server. This "
#~ "means that you can write your own"
#~ " logic, install it as a module "
#~ "in Tarantool — and see Tarantool "
#~ "perform your logic. So, a module "
#~ "is an optional library which enhances"
#~ " Tarantool functionality."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool's native language for writing "
#~ "modules is Lua. Modules in Lua are"
#~ " also called \"rocks\". If you are"
#~ " new to Lua, we recommend following"
#~ " this `Lua modules tutorial <http://lua-"
#~ "users.org/wiki/ModulesTutorial>`_ before reading "
#~ "this section."
#~ msgstr ""

#~ msgid ""
#~ "Modules that come from Tarantool "
#~ "developers and community contributors are "
#~ "available at `rocks.tarantool.org "
#~ "<http://rocks.tarantool.org>`_. Some of them "
#~ "-- :ref:`expirationd <expirationd-module>`, "
#~ ":ref:`mysql <dbms_modules-mysql-example>`, "
#~ ":ref:`postgresql <dbms_modules-postgresql-example>`,"
#~ " :ref:`shard <shard-module>` -- are "
#~ "discussed elsewhere in this manual."
#~ msgstr ""
#~ "Модули, созданные командой Tarantool'а и "
#~ "членами сообщества разработчиков, выложены на"
#~ " `rocks.tarantool.org <http://rocks.tarantool.org>`_. "
#~ "Про некоторые из этих модулей — "
#~ ":ref:`expirationd <expirationd-module>`, :ref:`mysql"
#~ " <dbms_modules-mysql-example>`, :ref:`postgresql"
#~ " <dbms_modules-postgresql-example>`, :ref:`shard"
#~ " <shard-module>` -- подробнее говорится "
#~ "в других разделах текущей документации."

#~ msgid ""
#~ "**Step 1:** Install LuaRocks. A general"
#~ " description of installing LuaRocks on "
#~ "a Unix system is given in the "
#~ "`LuaRocks Quick Start Guide "
#~ "<http://luarocks.org/#quick-start>`_. For example,"
#~ " on Ubuntu you could say:"
#~ msgstr ""
#~ "**Шаг 1:** Установите LuaRocks. Общее "
#~ "описание того, как установить LuaRocks в"
#~ " Unix-системе, приводится в `кратком "
#~ "руководстве по LuaRocks <http://luarocks.org"
#~ "/#quick-start>`_. Например, установить LuaRocks"
#~ " в Ubuntu можно следующей командой:"

#~ msgid ""
#~ "**Step 2:** Add the Tarantool repository"
#~ " to the list of rocks servers. "
#~ "This is done by putting "
#~ "`rocks.tarantool.org <http://rocks.tarantool.org>`_ in "
#~ "the :file:`.luarocks/config.lua` file:"
#~ msgstr ""
#~ "**Шаг 2:** Добавьте репозиторий Tarantool'а"
#~ " в список rocks-серверов. Для этого "
#~ "добавьте `rocks.tarantool.org "
#~ "<http://rocks.tarantool.org>`_ в файл "
#~ ":file:`.luarocks/config.lua`:"

#~ msgid ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = "
#~ "{[[http://rocks.tarantool.org/]]}\" >> "
#~ "~/.luarocks/config.lua"
#~ msgstr ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = "
#~ "{[[http://rocks.tarantool.org/]]}\" >> "
#~ "~/.luarocks/config.lua"

#~ msgid "search the repositories with"
#~ msgstr "искать существующие модули в общем репозитории"

#~ msgid "add new modules to the local repository with"
#~ msgstr "добавлять новые модули в свой локальный репозиторий"

#~ msgid ""
#~ "... and that is why examples in"
#~ " this manual often begin with "
#~ "``require`` requests."
#~ msgstr ""
#~ "(вот почему многие примеры в этой "
#~ "документации начинаются с вызова ``require``.)"

#~ msgid ""
#~ "For developers, we provide :ref:`instructions"
#~ " on creating their own Tarantool "
#~ "modules in Lua, C/C++ and Lua+C "
#~ "<develop_modules>`."
#~ msgstr ""

#~ msgid "Creating a new Lua module locally"
#~ msgstr "Создание нового модуля на языке Lua"

#~ msgid ""
#~ "As an example, let's create a new"
#~ " Lua file named :file:`mymodule.lua`, "
#~ "containing a named function which will"
#~ " be exported. Then, in Tarantool: "
#~ "load, examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый Lua-файл с"
#~ " именем :file:`mymodule.lua`, в котором "
#~ "опишем экспортируемую функцию с некоторым "
#~ "именем, а затем с помощью Tarantool'а"
#~ " загрузим и просмотрим наш новый "
#~ "модуль и вызовем описанную в нем "
#~ "функцию."

#~ msgid "The Lua file should look like this:"
#~ msgstr "Lua-файл в нашем примере будет таким:"

#~ msgid "The requests to load, examine and call look like this:"
#~ msgstr ""
#~ "Для загрузки и просмотра модуля, а "
#~ "также вызова описанной в нем функции,"
#~ " выполним следующие команды:"

#~ msgid ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."

#~ msgid "Creating a new C/C++ module locally"
#~ msgstr "Создание нового модуля на языке C/C++"

#~ msgid ""
#~ "As an example, let's create a new"
#~ " C file named :file:`mycmodule.c`, "
#~ "containing a named function which will"
#~ " be exported. Then, in Tarantool: "
#~ "load, examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый C-файл с "
#~ "именем :file:`mymodule.c`, в котором опишем"
#~ " экспортируемую функцию с некоторым именем,"
#~ " а затем с помощью Tarantool'а "
#~ "загрузим и просмотрим наш новый модуль"
#~ " и вызовем описанную в нем функцию."

#~ msgid "Prerequisite: install ``tarantool-dev`` first."
#~ msgstr ""
#~ "Обратите внимание, что для корректной "
#~ "работы требуется заранее установить модуль "
#~ "``tarantool-dev``."

#~ msgid ""
#~ "/* mycmodule - a simple Tarantool module */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"
#~ msgstr ""
#~ "/* mycmodule - простейший C-модуль для Tarantool'а */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"

#~ msgid ""
#~ "Use :program:`gcc` to compile the code"
#~ " for a shared library (without a "
#~ "\"lib\" prefix), then use :program:`ls` "
#~ "to examine it:"
#~ msgstr ""
#~ "С помощью :program:`gcc` скомпилируем наш "
#~ "код в виде shared-библиотеки (без "
#~ "префикса \"lib\"), а затем просмотрим ее"
#~ " содержимое с помощью :program:`ls`:"

#~ msgid ""
#~ "$ **gcc mycmodule.c -shared -fPIC "
#~ "-I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
#~ msgstr ""
#~ "$ **gcc mycmodule.c -shared -fPIC "
#~ "-I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#~ msgid ""
#~ "Tarantool's developers recommend using "
#~ "Tarantool's `CMake scripts "
#~ "<https://github.com/tarantool/modulekit>`_ which will "
#~ "handle some of the build steps "
#~ "automatically."
#~ msgstr ""
#~ "Для автоматизации сборки рекомендуется "
#~ "использовать `CMake-скрипты для Tarantool'а "
#~ "<https://github.com/tarantool/modulekit>`_."

#~ msgid ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."

#~ msgid "Creating a mixed Lua/C module locally"
#~ msgstr "Создание нового модуля на смеси языков Lua/C"

#~ msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
#~ msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#~ msgid ""
#~ "Create a C module (submodule) and "
#~ "name it ``myfunmodule.internal`` or something"
#~ " like that."
#~ msgstr ""
#~ "Создайте (вложенный) модуль на C и "
#~ "назовите его, например, ``myfunmodule.internal``."

#~ msgid ""
#~ "Load the C module from your Lua"
#~ " code using :samp:`require('myfunmodule.internal')` "
#~ "and then wrap or use it."
#~ msgstr ""
#~ "Загрузите новый C-модуль из Lua-кода с"
#~ " помощью :samp:`require('myfunmodule.internal')`, а "
#~ "затем сделайте для него обертку или "
#~ "вызывайте его функции напрямую."

#~ msgid ""
#~ "For a sample of a mixed Lua/C "
#~ "module, see `\"tarantool/http\" repository at"
#~ " GitHub <https://github.com/tarantool/http>`_."
#~ msgstr ""
#~ "Примеры модулей на смеси языков Lua/C"
#~ " можно посмотреть в `репозитории "
#~ "\"tarantool/http\" на GitHub "
#~ "<https://github.com/tarantool/http>`_."

#~ msgid "Tips for special situations"
#~ msgstr "Примечания для особых случаев"

#~ msgid ""
#~ "Lua caches all loaded modules in "
#~ "the ``package.loaded`` table. To reload "
#~ "a module from disk, set its key"
#~ " to `nil`:"
#~ msgstr ""
#~ "В среде Lua все загруженные модули "
#~ "кешируются в таблице ``package.loaded``. Чтобы"
#~ " перегрузить какой-либо модуль с диска, "
#~ "укажите для его ключа значение `nil`:"

#~ msgid ""
#~ "Use ``package.path`` to search for "
#~ ":file:`.lua` modules, and use "
#~ "``package.cpath`` to search for C binary"
#~ " modules."
#~ msgstr ""
#~ "Для поиска :file:`.lua`-модулей используйте "
#~ "команду ``package.path``, а для поиска "
#~ "бинарных модулей на C используйте "
#~ "команду ``package.cpath``."

#~ msgid ""
#~ "To see the internal state from "
#~ "within a Lua module, use :samp:`state`"
#~ " and create a local variable inside"
#~ " the scope of the file:"
#~ msgstr ""
#~ "Для просмотра внутреннего состояния прямо "
#~ "изнутри Lua-модуля используйте :samp:`state` и"
#~ " соответствующую локальную переменную в "
#~ "рамках модуля:"

#~ msgid ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- use state\n"
#~ "end\n"
#~ "return exports"
#~ msgstr ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- используем state\n"
#~ "end\n"
#~ "return exports"

#~ msgid ""
#~ "Any of the programs can be "
#~ "executed by copying the code into "
#~ "a .lua file, and then entering "
#~ ":samp:`chmod +x ./{program-name}.lua` and "
#~ ":samp:`./{program-name}.lua` on the terminal."
#~ " As is usual for Tarantool/Lua "
#~ "programs, the first line is a "
#~ "\"hashbang\" |br| #!/usr/bin/env tarantool "
#~ "|br| This runs the Tarantool Lua "
#~ "application server, which should be on"
#~ " the execution path."
#~ msgstr ""

#~ msgid ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "-- Configure database\n"
#~ "box.cfg {\n"
#~ "    listen = 3313\n"
#~ "}\n"
#~ "\n"
#~ "box.once(\"bootstrap\", function()\n"
#~ "    box.schema.space.create('tweedledum')\n"
#~ "    box.space.tweedledum:create_index('primary',\n"
#~ "        { type = 'TREE', parts = {1, 'unsigned'}})\n"
#~ "end)\n"
#~ "\n"
#~ "require('console').start()"
#~ msgstr ""

#~ msgid "uri.lua"
#~ msgstr ""

#~ msgid ""
#~ "Use built-in function :code:`uri_parse` "
#~ "to see what is in a `URI "
#~ "<configuration-uri>`:"
#~ msgstr ""

#~ msgid ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "local uri = require('uri')\n"
#~ "local r= "
#~ "uri.parse(\"scheme://login:password@host:service:/path1/path2/path3?q1=v1&q2=v2#fragment\")"
#~ "\n"
#~ "print('r.password=',r.password)\n"
#~ "print('r.path=',r.path)\n"
#~ "print('r.scheme',r.scheme)\n"
#~ "print('r.login=',r.login)\n"
#~ "print('r.query=',r.query)\n"
#~ "print('r.service=',r.service)\n"
#~ "print('r.fragment=',r.fragment)\n"
#~ "print('r.host=',r.host)"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{index_object}` = an :ref:`object "
#~ "reference <index-object_reference>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.space.tester.index.primary\n"
#~ "---\n"
#~ "- unique: true\n"
#~ "  parts:\n"
#~ "  - type: unsigned\n"
#~ "    fieldno: 1\n"
#~ "  id: 0\n"
#~ "  space_id: 513\n"
#~ "  name: primary\n"
#~ "  type: TREE\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The :codeitalic:`search-key-value` parameter"
#~ " specifies what must match within the"
#~ " index. The :codeitalic:`iterator-type` "
#~ "parameter specifies the rule for "
#~ "matching and ordering. Different index "
#~ "types support different iterators. For "
#~ "example, a TREE index maintains a "
#~ "strict order of keys and can "
#~ "return all tuples in ascending or "
#~ "descending order, starting from the "
#~ "specified key. Other index types, "
#~ "however, do not support ordering."
#~ msgstr ""

#~ msgid ""
#~ "To understand consistency of tuples "
#~ "returned by an iterator, it's essential"
#~ " to know the principles of the "
#~ "Tarantool transaction processing subsystem. An"
#~ " iterator in Tarantool does not own"
#~ " a consistent read view. Instead, "
#~ "each procedure is granted exclusive "
#~ "access to all tuples and spaces "
#~ "until there is a \"context switch\": "
#~ "which may happen due to :ref:`the-"
#~ "implicit-yield-rules <atomic-"
#~ "the_implicit_yield_rules>`, or by an explicit"
#~ " call to :ref:`fiber.yield <fiber-yield>`."
#~ " When the execution flow returns to"
#~ " the yielded procedure, the data set"
#~ " could have changed significantly. "
#~ "Iteration, resumed after a yield point,"
#~ " does not preserve the read view, "
#~ "but continues with the new content "
#~ "of the database. The tutorial "
#~ ":ref:`Indexed pattern search <c_lua_tutorial-"
#~ "indexed_pattern_search>` shows one way that"
#~ " iterators and yields can be used "
#~ "together."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :samp:`search-key-value` (type = Lua"
#~ " table or scalar) = value to be"
#~ " matched against the index key, which"
#~ " may be multi-part; :samp:`{iterator-"
#~ "type}` = as defined in tables "
#~ "below. The default iterator type is "
#~ "'EQ'."
#~ msgstr ""

#~ msgid ""
#~ "Return: `iterator <https://www.lua.org/pil/7.1.html>`_ "
#~ "which can be used in a for/end "
#~ "loop or with `totable() "
#~ "<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: No such space; wrong"
#~ " type; Selected iteration type is not"
#~ " supported for the index type; or "
#~ "search-key-value is not supported "
#~ "for the iteration type."
#~ msgstr ""

#~ msgid "Complexity Factors: Index size, Index type; Number of tuples accessed."
#~ msgstr ""

#~ msgid ""
#~ "A search-key-value can be a "
#~ "number (for example ``1234``), a string"
#~ " (for example ``'abcd'``), or a table"
#~ " of numbers and strings (for example"
#~ " ``{1234, 'abcd'}``). Each part of a"
#~ " search-key-value will be compared"
#~ " to each part of an index key."
#~ msgstr ""

#~ msgid ""
#~ "Formally the logic for TREE index "
#~ "searches is: |br| comparison-operator is"
#~ " = or >= or > or <= or"
#~ " < depending on iterator-type"
#~ msgstr ""

#~ msgid ""
#~ "if all comparison-results are true, "
#~ "then search-value \"matches\" index key."
#~ msgstr ""

#~ msgid ""
#~ "Notice how, according to this logic, "
#~ "regardless what the index-key-part "
#~ "contains, the comparison-result for "
#~ "equality is always true when a "
#~ "search-value-part is ``nil`` or is"
#~ " missing. This behavior of searches "
#~ "with nil is subject to change."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('space17')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {\n"
#~ "         >   parts = {1, 'string', 2, 'string'}\n"
#~ "         > })\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:insert{'C', 'C'}\n"
#~ "---\n"
#~ "- ['C', 'C']\n"
#~ "...\n"
#~ "tarantool> s:insert{'B', 'A'}\n"
#~ "---\n"
#~ "- ['B', 'A']\n"
#~ "...\n"
#~ "tarantool> s:insert{'C', '!'}\n"
#~ "---\n"
#~ "- ['C', '!']\n"
#~ "...\n"
#~ "tarantool> s:insert{'A', 'C'}\n"
#~ "---\n"
#~ "- ['A', 'C']\n"
#~ "...\n"
#~ "tarantool> function example()\n"
#~ "         >   for _, tuple in\n"
#~ "         >     s.index.primary:pairs(nil, {\n"
#~ "         >         iterator = box.index.ALL}) do\n"
#~ "         >       print(tuple)\n"
#~ "         >   end\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> example()\n"
#~ "['A', 'C']\n"
#~ "['B', 'A']\n"
#~ "['C', '!']\n"
#~ "['C', 'C']\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:drop()\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "for tuple in\n"
#~ "box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
#~ "  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
#~ "  print(tuple)\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "for tuple in\n"
#~ "box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
#~ "  if (tuple[1] > 1999) then break end\n"
#~ "  print(tuple)\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{index_object}` = an :ref:`object "
#~ "reference <index-object_reference>`;"
#~ msgstr ""

#~ msgid ":samp:`search-key` = values to be matched against the index key;"
#~ msgstr ""

#~ msgid ":samp:`option(s)` any or all of"
#~ msgstr ""

#~ msgid ":samp:`iterator = {iterator-type}`,"
#~ msgstr ""

#~ msgid ":samp:`limit = {maximum-number-of-tuples}`,"
#~ msgstr ""

#~ msgid ":samp:`offset = {start-tuple-number}`."
#~ msgstr ""

#~ msgid ""
#~ "-- Create a space named tester.\n"
#~ "tarantool> sp = box.schema.space.create('tester')\n"
#~ "-- Create a unique index 'primary'\n"
#~ "-- which won't be needed for this example.\n"
#~ "tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
#~ "-- Create a non-unique index 'secondary'\n"
#~ "-- with an index on the second field.\n"
#~ "tarantool> sp:create_index('secondary', {\n"
#~ "         >   type = 'tree',\n"
#~ "         >   unique = false,\n"
#~ "         >   parts = {2, 'string'}\n"
#~ "         > })\n"
#~ "-- Insert three tuples, values in field[2]\n"
#~ "-- equal to 'X', 'Y', and 'Z'.\n"
#~ "tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
#~ "tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
#~ "tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
#~ "-- Select all tuples where the secondary index\n"
#~ "-- keys are greater than 'X'.`\n"
#~ "tarantool> sp.index.secondary:select({'X'}, {\n"
#~ "         >   iterator = 'GT',\n"
#~ "         >   limit = 1000\n"
#~ "         > })"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('space_with_bitset')\n"
#~ "tarantool> s:create_index('primary_index', {\n"
#~ "         >   parts = {1, 'string'},\n"
#~ "         >   unique = true,\n"
#~ "         >   type = 'TREE'\n"
#~ "         > })\n"
#~ "tarantool> s:create_index('bitset_index', {\n"
#~ "         >   parts = {2, 'unsigned'},\n"
#~ "         >   unique = false,\n"
#~ "         >   type = 'BITSET'\n"
#~ "         > })\n"
#~ "tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
#~ "tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
#~ "tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
#~ "tarantool> s.index.bitset_index:select(0x02, {\n"
#~ "         >   iterator = box.index.EQ\n"
#~ "         > })\n"
#~ "---\n"
#~ "- - ['Tuple with bit value = 10', 2]\n"
#~ "...\n"
#~ "tarantool> s.index.bitset_index:select(0x02, {\n"
#~ "         >   iterator = box.index.BITS_ANY_SET\n"
#~ "         > })\n"
#~ "---\n"
#~ "- - ['Tuple with bit value = 10', 2]\n"
#~ "  - ['Tuple with bit value = 11', 3]\n"
#~ "...\n"
#~ "tarantool> s.index.bitset_index:select(0x02, {\n"
#~ "         >   iterator = box.index.BITS_ALL_SET\n"
#~ "         > })\n"
#~ "---\n"
#~ "- - ['Tuple with bit value = 10', 2]\n"
#~ "  - ['Tuple with bit value = 11', 3]\n"
#~ "...\n"
#~ "tarantool> s.index.bitset_index:select(0x02, {\n"
#~ "         >   iterator = box.index.BITS_ALL_NOT_SET\n"
#~ "         > })\n"
#~ "---\n"
#~ "- - ['Tuple with bit value = 01', 1]\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`key` (type = Lua table "
#~ "or scalar) = key to be matched "
#~ "against the index key, which may "
#~ "be multi-part."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: No such index; wrong"
#~ " type; more than one tuple matches."
#~ msgstr ""

#~ msgid ""
#~ "Complexity Factors: Index size, Index "
#~ "type. See also :ref:`space_object:get() "
#~ "<box_space-get>`."
#~ msgstr ""

#~ msgid ":samp:`key-value`."
#~ msgstr ""

#~ msgid "Possible errors: index is not of type 'TREE'."
#~ msgstr ""

#~ msgid "Complexity Factors: Index size, Index type."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`random-value` (type = number) ="
#~ " an arbitrary non-negative integer."
#~ msgstr ""

#~ msgid "Note re storage engine: vinyl does not support ``random()``."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{key-value}` (type = Lua table"
#~ " or scalar) = the value which "
#~ "must match the key(s) in the "
#~ "specified index. The type may be a"
#~ " list of field-values, or a "
#~ "tuple containing only the field-values;"
#~ "  :codeitalic:`iterator` = comparison method."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{key}` (type = Lua table or "
#~ "scalar) = key to be matched "
#~ "against the index key;"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{operator, field_no, value}` (type ="
#~ " Lua table) = update operations (see:"
#~ " :ref:`box.space...update() <box_space-update>`)."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`key` (type = Lua table or "
#~ "scalar) = key to be matched "
#~ "against the index key."
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl will "
#~ "return nil, rather than the deleted "
#~ "tuple."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{options}` = options list, same "
#~ "as the options list for "
#~ ":ref:`create_index <box_space-create_index>`."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: Index does not exist,"
#~ " or the first index cannot be "
#~ "changed to {unique = false}, or "
#~ "the alter function is only applicable"
#~ " for the memtx storage engine."
#~ msgstr ""

#~ msgid "Note re storage engine: vinyl does not support ``alter()``."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: Index does not exist,"
#~ " or a primary-key index cannot "
#~ "be dropped while a secondary-key "
#~ "index exists."
#~ msgstr ""

#~ msgid ":samp:`{index-name}` (type = string) = new name for index."
#~ msgstr ""

#~ msgid ""
#~ "Here is an example that shows how"
#~ " to build one's own iterator. The "
#~ "``paged_iter`` function is an \"iterator "
#~ "function\", which will only be "
#~ "understood by programmers who have read"
#~ " the Lua manual section `Iterators "
#~ "and Closures <https://www.lua.org/pil/7.1.html>`_. "
#~ "It does paginated retrievals, that is,"
#~ " it returns 10 tuples at a time"
#~ " from a table named \"t\", whose "
#~ "primary key was defined with "
#~ ":codenormal:`create_index('primary',{parts={1,'string'}})`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('rectangles')\n"
#~ "tarantool> i = s:create_index('primary', {\n"
#~ "         >   type = 'HASH',\n"
#~ "         >   parts = {1, 'unsigned'}\n"
#~ "         > })\n"
#~ "tarantool> r = s:create_index('rtree', {\n"
#~ "         >   type = 'RTREE',\n"
#~ "         >   unique = false,\n"
#~ "         >   parts = {2, 'ARRAY'}\n"
#~ "         > })"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('R')\n"
#~ "tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
#~ "tarantool> r = s:create_index('S', {\n"
#~ "         >   type = 'RTREE',\n"
#~ "         >   unique = false,\n"
#~ "         >   dimension = 3,\n"
#~ "         >   parts = {2, 'ARRAY'}\n"
#~ "         > })"
#~ msgstr ""

#~ msgid ""
#~ "The additional field here is "
#~ "``dimension=3``. The default dimension is "
#~ "2, which is why it didn't need "
#~ "to be specified for the examples "
#~ "of rectangle. The maximum dimension is"
#~ " 20. Now for insertions and "
#~ "selections there will usually be 6 "
#~ "coordinates. For example:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('R')\n"
#~ "tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
#~ "tarantool> r = s:create_index('S', {\n"
#~ "         >   type = 'RTREE',\n"
#~ "         >   unique = false,\n"
#~ "         >   distance = 'manhattan',\n"
#~ "         >   parts = {2, 'ARRAY'}\n"
#~ "         > })"
#~ msgstr ""

#~ msgid ""
#~ "The additional field here is "
#~ "``distance='manhattan'``. The default distance "
#~ "calculator is 'euclid', which is the "
#~ "straightforward as-the-crow-flies "
#~ "method. The optional distance calculator "
#~ "is 'manhattan', which can be a "
#~ "more appropriate method if one is "
#~ "following the lines of a grid "
#~ "rather than traveling in a straight "
#~ "line."
#~ msgstr ""

#~ msgid ""
#~ "The ``box.info`` submodule provides access "
#~ "to information about server variables."
#~ msgstr ""

#~ msgid ""
#~ "**server.ro**  True if the server is "
#~ "in \"read_only\" mode (same as "
#~ ":ref:`read_only <cfg_basic-read_only>` in "
#~ "box.cfg)."
#~ msgstr ""

#~ msgid ""
#~ "**server.uuid** The unique identifier of "
#~ "this server, as stored in the "
#~ "database. This value is also in "
#~ "the :ref:`box.space._cluster <box_space-cluster>`"
#~ " system space."
#~ msgstr ""

#~ msgid "**server.id** The number of this server within a cluster."
#~ msgstr ""

#~ msgid ""
#~ "**cluster.uuid** UUID of the cluster. "
#~ "Every server in a cluster will "
#~ "have the same cluster.uuid value. This"
#~ " value is also in the "
#~ ":ref:`box.space._schema <box_space-schema>` system"
#~ " space."
#~ msgstr ""

#~ msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
#~ msgstr ""

#~ msgid "**replication.idle** Number of seconds that the server has been idle."
#~ msgstr ""

#~ msgid ""
#~ "**replication.uuid** The unique identifier of"
#~ " a master to which this server "
#~ "is connected."
#~ msgstr ""

#~ msgid ""
#~ "**replication.uptime** Number of seconds since"
#~ " the server started. This value can"
#~ " also be retrieved with "
#~ ":ref:`tarantool.uptime() <tarantool-build>`."
#~ msgstr ""

#~ msgid ""
#~ "The replication fields are blank unless"
#~ " the server is a :ref:`replica "
#~ "<index-box_replication>`. The replication fields"
#~ " are in an array if the server"
#~ " is a replica for more than one"
#~ " master."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.info()\n"
#~ "---\n"
#~ "- server:\n"
#~ "    lsn: 158\n"
#~ "    ro: false\n"
#~ "    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
#~ "    id: 1\n"
#~ "  version: 1.7.2-435-g6ba8500\n"
#~ "  pid: 12932\n"
#~ "  status: running\n"
#~ "  vclock:\n"
#~ "  - 158\n"
#~ "  replication:\n"
#~ "    status: off\n"
#~ "  uptime: 908\n"
#~ "...\n"
#~ "tarantool> box.info.pid\n"
#~ "---\n"
#~ "- 12932\n"
#~ "...\n"
#~ "tarantool> box.info.status\n"
#~ "---\n"
#~ "- running\n"
#~ "...\n"
#~ "tarantool> box.info.uptime\n"
#~ "---\n"
#~ "- 1065\n"
#~ "...\n"
#~ "tarantool> box.info.version\n"
#~ "---\n"
#~ "- 1.7.2-435-g6ba8500\n"
#~ "..."
#~ msgstr ""

#~ msgid "space is temporary"
#~ msgstr ""

#~ msgid "fixed field count"
#~ msgstr ""

#~ msgid "storage engine = :ref:`'memtx' or 'vinyl' <index-two_storage_engines>`"
#~ msgstr ""

#~ msgid "user name"
#~ msgstr ""

#~ msgid "field names+types"
#~ msgstr ""

#~ msgid ""
#~ "There are five :ref:`syntax variations "
#~ "<index-object_reference>` for object references"
#~ " targeting space objects, for example "
#~ ":samp:`box.schema.space.drop({space-id})` will drop"
#~ " a space. However, the common "
#~ "approach is to use functions attached"
#~ " to the space objects, for example"
#~ " :ref:`space_object:drop() <box_space-drop>`."
#~ msgstr ""

#~ msgid "Note re storage engine: vinyl does not support temporary spaces."
#~ msgstr ""

#~ msgid ""
#~ "For an illustration with the ``format``"
#~ " clause, see :ref:`box.space._space "
#~ "<box_space-space>` example."
#~ msgstr ""

#~ msgid ""
#~ "Create a user. For explanation of "
#~ "how Tarantool maintains user data, see"
#~ " section :ref:`Users and the _user "
#~ "space <authentication-users>`."
#~ msgstr ""

#~ msgid ""
#~ "Drop a user. For explanation of "
#~ "how Tarantool maintains user data, see"
#~ " section :ref:`Users and the _user "
#~ "space <authentication-users>`."
#~ msgstr ""

#~ msgid "``if_exists``"
#~ msgstr ""

#~ msgid "Return true if a user exists; return false if a user does not exist."
#~ msgstr ""

#~ msgid "Grant :ref:`privileges <authentication-privileges>` to a user."
#~ msgstr ""

#~ msgid "``grantor``, ``if_not_exists``"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
#~ "box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
#~ "box.schema.user.grant('Lena', 'read,write', 'universe')\n"
#~ "box.schema.user.grant('Lena', 'Accountant')\n"
#~ "box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
#~ "box.schema.user.grant('X', 'read', 'universe', nil,"
#~ " {if_not_exists=true}))"
#~ msgstr ""

#~ msgid "Revoke :ref:`privileges <authentication-privileges>` from a user."
#~ msgstr ""

#~ msgid "Return a hash of a password."
#~ msgstr ""

#~ msgid ""
#~ "Associate a password with the user "
#~ "who is currently logged in. or "
#~ "with another user. Users who wish "
#~ "to change their own passwords should "
#~ "use box.schema.user.passwd(password). Administrators "
#~ "who wish to change passwords of "
#~ "other users should use box.schema.user.passwd"
#~ "(user-name, password)."
#~ msgstr ""

#~ msgid "Return a description of a user's privileges."
#~ msgstr ""

#~ msgid "``if_not_exists``"
#~ msgstr ""

#~ msgid "Return true if a role exists; return false if a role does not exist."
#~ msgstr ""

#~ msgid "Grant :ref:`privileges <authentication-privileges>` to a role."
#~ msgstr ""

#~ msgid "{if_not_exists=true} or {if_not_exists=false}"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
#~ "box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
#~ "box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
#~ "box.schema.role.grant('public', 'Accountant')\n"
#~ "box.schema.role.grant('role1', 'role2', nil, nil,"
#~ " {if_not_exists=false})"
#~ msgstr ""

#~ msgid "Revoke :ref:`privileges <authentication-privileges>` from a role."
#~ msgstr ""

#~ msgid ""
#~ "Create a function tuple. This does "
#~ "not create the function itself -- "
#~ "that is done with Lua -- but "
#~ "if it is necessary to grant "
#~ "privileges for a function, "
#~ "box.schema.func.create must be done first. "
#~ "For explanation of how Tarantool "
#~ "maintains function data, see section "
#~ ":ref:`Functions and the _func space "
#~ "<authentication-funcs>`."
#~ msgstr ""

#~ msgid ""
#~ "Drop a function tuple. For explanation"
#~ " of how Tarantool maintains function "
#~ "data, see section :ref:`Functions and "
#~ "the _func space <authentication-funcs>`."
#~ msgstr ""

#~ msgid ""
#~ "This function works only if there "
#~ "is a peer, that is, if a "
#~ "connection has been made to a "
#~ "separate server."
#~ msgstr ""

#~ msgid ""
#~ "The host address and port of the"
#~ " session peer, for example "
#~ "\"127.0.0.1:55457\". If the session exists "
#~ "but there is no connection to a"
#~ " separate server, the return is null."
#~ " The command is executed on the "
#~ "server, so the \"local name\" is "
#~ "the server's host and port, and "
#~ "the \"peer name\" is the client's "
#~ "host and port."
#~ msgstr ""

#~ msgid ""
#~ "the value of the :code:`sync` integer"
#~ " constant used in the `binary "
#~ "protocol "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
#~ msgstr ""

#~ msgid ""
#~ "A Lua table that can hold "
#~ "arbitrary unordered session-specific names "
#~ "and values, which will last until "
#~ "the session ends."
#~ msgstr ""

#~ msgid ""
#~ "See the section :ref:`Triggers <triggers-"
#~ "box_triggers>` for instructions about defining"
#~ " triggers for connect and disconnect "
#~ "events with ``box.session.on_connect()`` and "
#~ "``box.session.on_disconnect()``. See the section "
#~ ":ref:`Access control <authentication>` for "
#~ "instructions about ``box.session`` functions "
#~ "that affect user identification and "
#~ "security."
#~ msgstr ""

#~ msgid ""
#~ "``items_size`` is the *total* amount of"
#~ " memory (including allocated, but currently"
#~ " free slabs) used only for tuples,"
#~ " no indexes;"
#~ msgstr ""

#~ msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
#~ msgstr ""

#~ msgid ""
#~ "``items_used`` is the *efficient* amount "
#~ "of memory (omitting allocated, but "
#~ "currently free slabs) used only for "
#~ "tuples, no indexes;"
#~ msgstr ""

#~ msgid ""
#~ "``quota_used`` is the percentage of "
#~ ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` "
#~ "that is already distributed to the "
#~ "slab allocator;"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.slab.info()\n"
#~ "---\n"
#~ "- items_size: 228128\n"
#~ "  items_used_ratio: 1.8%\n"
#~ "  quota_size: 1073741824\n"
#~ "  quota_used_ratio: 0.8%\n"
#~ "  arena_used_ratio: 43.2%\n"
#~ "  items_used: 4208\n"
#~ "  quota_used: 8388608\n"
#~ "  arena_size: 2325176\n"
#~ "  arena_used: 1003632\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> box.slab.info().arena_used\n"
#~ "---\n"
#~ "- 1003632\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The ``box.space`` submodule has the "
#~ "data-manipulation functions ``select``, "
#~ "``insert``, ``replace``, ``update``, ``upsert``, "
#~ "``delete``, ``get``, ``put``. It also "
#~ "has members, such as id, and "
#~ "whether or not a space is enabled."
#~ " Submodule source code is available "
#~ "in file `src/box/lua/schema.lua "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
#~ msgstr ""

#~ msgid ".Numeric identifier of space"
#~ msgstr ""

#~ msgid ".Flag, true if space is enabled"
#~ msgstr ""

#~ msgid ".Required number of fields"
#~ msgstr ""

#~ msgid ".Container of space's indexes"
#~ msgstr ""

#~ msgid ".(Metadata) List of schemas"
#~ msgstr ""

#~ msgid ".(Metadata) List of spaces"
#~ msgstr ""

#~ msgid ".(Metadata) List of indexes"
#~ msgstr ""

#~ msgid ".(Metadata) List of users"
#~ msgstr ""

#~ msgid ".(Metadata) List of privileges"
#~ msgstr ""

#~ msgid ".(Metadata) List of clusters"
#~ msgstr ""

#~ msgid ".(Metadata) List of function tuples"
#~ msgstr ""

#~ msgid ""
#~ "Create an index. It is mandatory "
#~ "to create an index for a tuple "
#~ "set before trying to insert tuples "
#~ "into it, or select tuples from it."
#~ " The first created index, which will"
#~ " be used as the primary-key "
#~ "index, must be unique."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`index_name` (type = string) ="
#~ " name of index, which should not "
#~ "be a number and should not contain"
#~ " special characters; :codeitalic:`options`."
#~ msgstr ""

#~ msgid ""
#~ "{field_no, 'unsigned' or 'string' or "
#~ "'integer' or 'number' or 'array' or "
#~ "'scalar'}"
#~ msgstr ""

#~ msgid "``{1, 'unsigned'}``"
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: too many parts. Index"
#~ " '...' already exists. Primary key "
#~ "must be unique."
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl supports"
#~ " only the TREE index type, and "
#~ "vinyl secondary indexes must be created"
#~ " before tuples are inserted."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.space.space55\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {unique = "
#~ "true, parts = {1, 'unsigned', 2, "
#~ "'string'}})\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Details about index field types: |br|"
#~ " The six index field types (unsigned"
#~ " | string | integer | number |"
#~ " array | scalar) differ depending on"
#~ " what values are allowed, and what"
#~ " index types are allowed. |br| "
#~ "**unsigned**: unsigned integers between 0 "
#~ "and 18446744073709551615, about 18 "
#~ "quintillion. May also be called 'uint'"
#~ " or 'num', but 'num' is deprecated."
#~ " Legal in memtx TREE or HASH "
#~ "indexes, and in vinyl TREE indexes. "
#~ "|br| **string**: any set of octets, "
#~ "up to the :ref:`maximum length "
#~ "<limitations_bytes_in_index_key>`. May also be "
#~ "called 'str'. Legal in memtx TREE "
#~ "or HASH or BITSET indexes, and in"
#~ " vinyl TREE indexes. |br| **integer**: "
#~ "integers between -9223372036854775808 and "
#~ "18446744073709551615. May also be called "
#~ "'int'. Legal in memtx TREE or HASH"
#~ " indexes, and in vinyl TREE indexes."
#~ " |br| **number**: integers between "
#~ "-9223372036854775808 and 18446744073709551615, "
#~ "single-precision floating point numbers, or"
#~ " double-precision floating point numbers."
#~ " Legal in memtx TREE or HASH "
#~ "indexes, and in vinyl TREE indexes. "
#~ "|br| **array**: array of integers "
#~ "between -9223372036854775808 and "
#~ "9223372036854775807. Legal in memtx RTREE "
#~ "indexes. |br| **scalar**: booleans (true "
#~ "or false), or integers between "
#~ "-9223372036854775808 and 18446744073709551615, or"
#~ " single-precision floating point numbers,"
#~ " or double-precison floating-point "
#~ "numbers, or strings. When there is "
#~ "a mix of types, the key order "
#~ "is: booleans, then numbers, then "
#~ "strings. Legal in memtx TREE or "
#~ "HASH indexes, and in vinyl TREE "
#~ "indexes."
#~ msgstr ""

#~ msgid "**unsigned**"
#~ msgstr ""

#~ msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
#~ msgstr ""

#~ msgid "**string**"
#~ msgstr ""

#~ msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
#~ msgstr ""

#~ msgid "**integer**"
#~ msgstr ""

#~ msgid "integers between -9223372036854775808 and 18446744073709551615"
#~ msgstr ""

#~ msgid "-2^63 |br|"
#~ msgstr ""

#~ msgid "**number**"
#~ msgstr ""

#~ msgid ""
#~ "integers between -9223372036854775808 and "
#~ "18446744073709551615, single-precision floating "
#~ "point numbers, double-precision floating "
#~ "point numbers"
#~ msgstr ""

#~ msgid "1.234 |br| -44 |br| 1.447e+44"
#~ msgstr ""

#~ msgid ""
#~ "booleans (true or false), integers "
#~ "between -9223372036854775808 and "
#~ "18446744073709551615, single-precision floating "
#~ "point numbers, double-precision floating "
#~ "point numbers, strings"
#~ msgstr ""

#~ msgid "true |br| -1 |br| 1.234 |br| '' |br| '俄國'"
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`tuple` (type = Lua table "
#~ "or tuple) = tuple to be inserted."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: If a tuple with "
#~ "the same unique-key value already "
#~ "exists, returns :errcode:`ER_TUPLE_FOUND`."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`search-key-value` (type = "
#~ "Lua table or scalar) = value to"
#~ " be matched against the index key,"
#~ " which may be multi-part."
#~ msgstr ""

#~ msgid ""
#~ "the tuples whose primary-key fields "
#~ "are equal to the fields of the "
#~ "passed search-key-value. If the "
#~ "number of passed fields is less "
#~ "than the number of fields in the"
#~ " primary key, then only the passed"
#~ " fields are compared, so ``select{1,2}``"
#~ " will match a tuple whose primary "
#~ "key is ``{1,2,3}``."
#~ msgstr ""

#~ msgid "Possible errors: No such space; wrong type."
#~ msgstr ""

#~ msgid "**Complexity Factors:** Index size, Index type."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary',{parts = "
#~ "{1,'unsigned', 2, 'string'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:insert{1,'A'}\n"
#~ "---\n"
#~ "- [1, 'A']\n"
#~ "...\n"
#~ "tarantool> s:insert{1,'B'}\n"
#~ "---\n"
#~ "- [1, 'B']\n"
#~ "...\n"
#~ "tarantool> s:insert{1,'C'}\n"
#~ "---\n"
#~ "- [1, 'C']\n"
#~ "...\n"
#~ "tarantool> s:insert{2,'D'}\n"
#~ "---\n"
#~ "- [2, 'D']\n"
#~ "...\n"
#~ "tarantool> -- must equal both primary-key fields\n"
#~ "tarantool> s:select{1,'B'}\n"
#~ "---\n"
#~ "- - [1, 'B']\n"
#~ "...\n"
#~ "tarantool> -- must equal only one primary-key field\n"
#~ "tarantool> s:select{1}\n"
#~ "---\n"
#~ "- - [1, 'A']\n"
#~ "  - [1, 'B']\n"
#~ "  - [1, 'C']\n"
#~ "...\n"
#~ "tarantool> -- must equal 0 fields, so returns all tuples\n"
#~ "tarantool> s:select{}\n"
#~ "---\n"
#~ "- - [1, 'A']\n"
#~ "  - [1, 'B']\n"
#~ "  - [1, 'C']\n"
#~ "  - [2, 'D']\n"
#~ "..."
#~ msgstr ""

#~ msgid "the tuple whose index key matches :codeitalic:`key`, or null."
#~ msgstr ""

#~ msgid "Possible errors: If space_object does not exist."
#~ msgstr ""

#~ msgid ""
#~ "**Complexity Factors:** Index size, Index "
#~ "type, Number of indexes accessed, WAL"
#~ " settings."
#~ msgstr ""

#~ msgid ""
#~ "The ``box.space...select`` function returns a"
#~ " set of tuples as a Lua table;"
#~ " the ``box.space...get`` function returns "
#~ "at most a single tuple. And it "
#~ "is possible to get the first tuple"
#~ " in a tuple set by appending "
#~ "``[1]``. Therefore ``box.space.tester:get{1}`` has"
#~ " the same effect as "
#~ "``box.space.tester:select{1}[1]``, if exactly one"
#~ " tuple is found."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`."
#~ msgstr ""

#~ msgid ""
#~ "Parameters::samp:`{space_object}` = an :ref:`object"
#~ " reference <index-object_reference>`; :codeitalic"
#~ ":`space-name` (type = string) = new"
#~ " name for space."
#~ msgstr ""

#~ msgid "Possible errors: space_object does not exist."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: If a different tuple"
#~ " with the same unique-key value "
#~ "already exists, returns :errcode:`ER_TUPLE_FOUND`."
#~ " (This will only happen if there "
#~ "is a unique secondary index.)"
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`key` (type = Lua table "
#~ "or scalar) = primary-key field "
#~ "values, must be passed as a Lua"
#~ " table if key is multi-part; "
#~ ":codeitalic:`{operator, field_no, value}` (type "
#~ "= table): a group of arguments for"
#~ " each operation, indicating what the "
#~ "operation is, what field the operation"
#~ " will apply to, and what value "
#~ "will be applied. The field number "
#~ "can be negative, meaning the position"
#~ " from the end of tuple (#tuple "
#~ "+ negative field number + 1)."
#~ msgstr ""

#~ msgid "Possible errors: it is illegal to modify a primary-key field."
#~ msgstr ""

#~ msgid ""
#~ "**Complexity Factors:** Index size, Index "
#~ "type, number of indexes accessed, WAL"
#~ " settings."
#~ msgstr ""

#~ msgid ""
#~ "Assume that initially there is a "
#~ "space named ``tester`` with a "
#~ "primary-key index whose type is "
#~ "``unsigned``. There is one tuple, with"
#~ " ``field[1]`` = ``999`` and ``field[2]``"
#~ " = ``'A'``."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :samp:`{tuple_value}` (type = Lua table"
#~ " or scalar) = field values, must "
#~ "be passed as a Lua table; "
#~ ":codeitalic:`{operator, field_no, value}` (type "
#~ "= Lua table) = a group of "
#~ "arguments for each operation, indicating "
#~ "what the operation is, what field "
#~ "the operation will apply to, and "
#~ "what value will be applied. The "
#~ "field number can be negative, meaning"
#~ " the position from the end of "
#~ "the tuple (#tuple + negative field "
#~ "number + 1)."
#~ msgstr ""

#~ msgid "null."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: it is illegal to "
#~ "modify a primary-key field. It is"
#~ " illegal to use upsert with a "
#~ "space that has a unique secondary "
#~ "index."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>` "
#~ ":codeitalic:`key` (type = Lua table or"
#~ " scalar) = key to be matched "
#~ "against the index key, which may "
#~ "be multi-part."
#~ msgstr ""

#~ msgid "**Complexity Factors:** Index size, Index type"
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl will "
#~ "return ``nil``, rather than the deleted"
#~ " tuple."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.space.tester:delete(1)\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:delete(1)\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:delete('a')\n"
#~ "---\n"
#~ "- error: 'Supplied key type of part 0 does not match index part type:\n"
#~ "  expected unsigned'\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`key` (type = Lua table "
#~ "or scalar) = key to be matched "
#~ "against the primary index key, which "
#~ "may be multi-part; :codeitalic:`iterator` "
#~ "= comparison method."
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl does "
#~ "not support ``len()``.  One possible "
#~ "workaround is to say ``#select(...)``."
#~ msgstr ""

#~ msgid ""
#~ "**Complexity Factors:** Index size, Index "
#~ "type, Number of tuples accessed."
#~ msgstr ""

#~ msgid ""
#~ "Note that ``truncate`` must be called"
#~ " only by the user who created "
#~ "the space OR under a `setuid` "
#~ "function created by that user. Read "
#~ "more about `setuid` functions :ref:`here "
#~ "<authentication-funcs>`"
#~ msgstr ""

#~ msgid ""
#~ "Insert a new tuple using an "
#~ "auto-increment primary key. The space "
#~ "specified by space_object must have an"
#~ " ``unsigned`` or ``integer`` or ``numeric``"
#~ " primary key index of type ``TREE``."
#~ " The primary-key field will be "
#~ "incremented before the insert."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`field-value(s)` (type = Lua"
#~ " table or scalar) = tuple's fields,"
#~ " other than the primary-key field."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: index has wrong type"
#~ " or primary-key indexed field is "
#~ "not a number."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: :samp:`{space_object}` = an "
#~ ":ref:`object reference <index-object_reference>`;"
#~ " :codeitalic:`search-key-value` (type = "
#~ "Lua table or scalar) = value to"
#~ " be matched against the index key,"
#~ " which may be multi-part; :samp"
#~ ":`{iterator-type}` = see :ref:`index_object:pairs"
#~ " <box_index-index_pairs>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('space33')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
#~ "tarantool> s:create_index('X', {})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
#~ "---\n"
#~ "- [0, 'Hello my ']\n"
#~ "- [1, 'Lua world']\n"
#~ "...\n"
#~ "tarantool> tmp = ''\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> for k, v in s:pairs() do\n"
#~ "         >   tmp = tmp .. v[2]\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> tmp\n"
#~ "---\n"
#~ "- Hello my Lua world\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "``_schema`` is a system tuple set. "
#~ "Its single tuple contains these fields:"
#~ " ``'version', major-version-number, "
#~ "minor-version-number``."
#~ msgstr ""

#~ msgid ""
#~ "The following function will display all"
#~ " fields in all tuples of ``_schema``:"
#~ msgstr ""

#~ msgid ""
#~ "function example()\n"
#~ "  local ta = {}\n"
#~ "  local i, line\n"
#~ "  for k, v in box.space._schema:pairs() do\n"
#~ "    i = 1\n"
#~ "    line = ''\n"
#~ "    while i <= #v do\n"
#~ "      line = line .. v[i] .. ' '\n"
#~ "      i = i + 1\n"
#~ "    end\n"
#~ "    table.insert(ta, line)\n"
#~ "  end\n"
#~ "  return ta\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> example()\n"
#~ "---\n"
#~ "- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
#~ "  - 'max_id 520 '\n"
#~ "  - 'version 1 7 0 '\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "``_space`` is a system tuple set. "
#~ "Its tuples contain these fields: ``id``,"
#~ " ``owner`` (= id of user who "
#~ "owns the space), ``name``, ``engine``, "
#~ "``field_count``, ``flags`` (e.g. temporary), "
#~ "``format``. These fields are established "
#~ "by :ref:`space.create() <box_schema-space_create>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> example()\n"
#~ "---\n"
#~ "- - '272 1 _schema memtx 0  '\n"
#~ "  - '280 1 _space memtx 0  '\n"
#~ "  - '281 1 _vspace sysview 0  '\n"
#~ "  - '288 1 _index memtx 0  '\n"
#~ "  - '296 1 _func memtx 0  '\n"
#~ "  - '304 1 _user memtx 0  '\n"
#~ "  - '305 1 _vuser sysview 0  '\n"
#~ "  - '312 1 _priv memtx 0  '\n"
#~ "  - '313 1 _vpriv sysview 0  '\n"
#~ "  - '320 1 _cluster memtx 0  '\n"
#~ "  - '512 1 tester memtx 0  '\n"
#~ "  - '513 1 origin vinyl 0  '\n"
#~ "  - '514 1 archive memtx 0  '\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The following requests will create a "
#~ "space using ``box.schema.space.create`` with a"
#~ " ``format`` clause. Then it retrieves "
#~ "the _space tuple for the new "
#~ "space. This illustrates the typical use"
#~ " of the ``format`` clause, it shows"
#~ " the recommended names and data types"
#~ " for the fields."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.schema.space.create('TM', {\n"
#~ "         >   id = 12345,\n"
#~ "         >   format = {\n"
#~ "         >     [1] = {[\"name\"] = \"field_1\"},\n"
#~ "         >     [2] = {[\"type\"] = \"unsigned\"}\n"
#~ "         >   }\n"
#~ "         > })\n"
#~ "---\n"
#~ "- index: []\n"
#~ "  on_replace: 'function: 0x41c67338'\n"
#~ "  temporary: false\n"
#~ "  id: 12345\n"
#~ "  engine: memtx\n"
#~ "  enabled: false\n"
#~ "  name: TM\n"
#~ "  field_count: 0\n"
#~ "- created\n"
#~ "...\n"
#~ "tarantool> box.space._space:select(12345)\n"
#~ "---\n"
#~ "- - [12345, 1, 'TM', 'memtx', 0,"
#~ " {}, [{'name': 'field_1'}, {'type': "
#~ "'unsigned'}]]\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "``_index`` is a system tuple set. "
#~ "Its tuples contain these fields: ``id``"
#~ " (= id of space), ``iid`` (= "
#~ "index number within space), ``name``, "
#~ "``type``, ``opts`` (e.g. unique option), "
#~ "[``tuple-field-no``, ``tuple-field-"
#~ "type`` ...]."
#~ msgstr ""

#~ msgid ""
#~ "The following function will display all"
#~ " fields in all tuples of ``_index``:"
#~ " (notice that the fifth field gets"
#~ " special treatment as a map value "
#~ "and the sixth or later fields get"
#~ " special treatment as arrays):"
#~ msgstr ""

#~ msgid ""
#~ "function example()\n"
#~ "  local ta = {}\n"
#~ "  local i, line, value\n"
#~ "  for k, v in box.space._index:pairs() do\n"
#~ "    i = 1\n"
#~ "    line = ''\n"
#~ "     while v[i] ~= nil do\n"
#~ "      if i < 5 then\n"
#~ "        value = v[i]\n"
#~ "        end\n"
#~ "      if i == 5 then\n"
#~ "        if v[i].unique == true then\n"
#~ "          value = 'true'\n"
#~ "          end\n"
#~ "        end\n"
#~ "      if i > 5 then\n"
#~ "        value = v[i][1][1] .. ' ' .. v[i][1][2]\n"
#~ "        end\n"
#~ "      line = line .. value .. ' '\n"
#~ "      i = i + 1\n"
#~ "    end\n"
#~ "    table.insert(ta, line)\n"
#~ "    end\n"
#~ "  return ta\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> example()\n"
#~ "---\n"
#~ "- - '272 0 primary tree true 0 str '\n"
#~ "  - '280 0 primary tree true 0 num '\n"
#~ "  - '280 1 owner tree tree 1 num '\n"
#~ "  - '280 2 name tree true 2 str '\n"
#~ "  - '281 0 primary tree true 0 num '\n"
#~ "  - '281 1 owner tree tree 1 num '\n"
#~ "  - '281 2 name tree true 2 str '\n"
#~ "  - '288 0 primary tree true 0 num '\n"
#~ "  - '288 2 name tree true 0 num '\n"
#~ "  - '289 0 primary tree true 0 num '\n"
#~ "  - '289 2 name tree true 0 num '\n"
#~ "  - '296 0 primary tree true 0 num '\n"
#~ "  - '296 1 owner tree tree 1 num '\n"
#~ "  - '296 2 name tree true 2 str '\n"
#~ "  - '297 0 primary tree true 0 num '\n"
#~ "  - '297 1 owner tree tree 1 num '\n"
#~ "  - '297 2 name tree true 2 str '\n"
#~ "  - '304 0 primary tree true 0 num '\n"
#~ "  - '304 1 owner tree tree 1 num '\n"
#~ "  - '304 2 name tree true 2 str '\n"
#~ "  - '305 0 primary tree true 0 num '\n"
#~ "  - '305 1 owner tree tree 1 num '\n"
#~ "  - '305 2 name tree true 2 str '\n"
#~ "  - '312 0 primary tree true 1 num '\n"
#~ "  - '312 1 owner tree tree 0 num '\n"
#~ "  - '312 2 object tree tree 2 str '\n"
#~ "  - '313 0 primary tree true 1 num '\n"
#~ "  - '313 1 owner tree tree 0 num '\n"
#~ "  - '313 2 object tree tree 2 str '\n"
#~ "  - '320 0 primary tree true 0 num '\n"
#~ "  - '320 1 uuid tree true 1 str '\n"
#~ "  - '512 0 primary tree true 0 num '\n"
#~ "  - '513 0 primary tree true 0 num '\n"
#~ "  - '516 0 primary tree true 0 STR '\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "``_user`` is a system tuple set "
#~ "for support of the :ref:`authorization "
#~ "feature <authentication>`."
#~ msgstr ""

#~ msgid ""
#~ "``_priv`` is a system tuple set "
#~ "for support of the :ref:`authorization "
#~ "feature <authentication>`."
#~ msgstr ""

#~ msgid ""
#~ "``_cluster`` is a system tuple set "
#~ "for support of the :ref:`replication "
#~ "feature <index-box_replication>`."
#~ msgstr ""

#~ msgid ""
#~ "``_func`` is a system tuple set "
#~ "with function tuples made by "
#~ ":ref:`box.schema.func.create <box_schema-func_create>`."
#~ msgstr ""

#~ msgid ""
#~ "This function will illustrate how to "
#~ "look at all the spaces, and for"
#~ " each display: approximately how many "
#~ "tuples it contains, and the first "
#~ "field of its first tuple. The "
#~ "function uses Tarantool ``box.space`` "
#~ "functions ``len()`` and ``pairs()``. The "
#~ "iteration through the spaces is coded"
#~ " as a scan of the ``_space`` "
#~ "system tuple set, which contains "
#~ "metadata. The third field in ``_space``"
#~ " contains the space name, so the "
#~ "key instruction ``space_name = v[3]`` "
#~ "means ``space_name`` is the ``space_name`` "
#~ "field in the tuple of ``_space`` "
#~ "that we've just fetched with "
#~ "``pairs()``. The function returns a "
#~ "table:"
#~ msgstr ""

#~ msgid ""
#~ "A simple way is to look at "
#~ "the constants in box.schema, which tell"
#~ " us that there is an item named"
#~ " SPACE_ID == 288, so these statements"
#~ " will retrieve the correct tuple: "
#~ "|br| :codenormal:`box.space._space:select{288}` |br| "
#~ "or |br| "
#~ ":codenormal:`box.space._space:select{box.schema.SPACE_ID}` |br|"
#~ msgstr ""

#~ msgid ""
#~ "Another way is to look at the "
#~ "tuples in box.space._index, which tell "
#~ "us that there is a secondary index"
#~ " named 'name' for space number 288,"
#~ " so this statement also will retrieve"
#~ " the correct tuple: |br| "
#~ ":codenormal:`box.space._space.index.name:select{'_space'}`"
#~ msgstr ""

#~ msgid ""
#~ "However, the retrieved tuple is not "
#~ "easy to read: |br| :codenormal:`tarantool>`"
#~ " :codebold:`box.space._space.index.name:select{'_space'}` "
#~ "|br| :codenormal:`---` |br| :codenormal:`- -"
#~ " [280, 1, '_space', 'memtx', 0, '',"
#~ " [{'name': 'id',` |br| |nbsp| |nbsp| "
#~ "|nbsp| :codenormal:`'type': 'num'}, {'name': "
#~ "'owner','type': 'num'},` |br| |nbsp| |nbsp|"
#~ " |nbsp| :codenormal:`{'name': 'name','type': "
#~ "'str'}, {'name': 'engine',` |br| |nbsp| "
#~ "|nbsp| |nbsp| :codenormal:`'type': 'str'},{'name':"
#~ " 'field_count', 'type': 'num'},` |br| "
#~ "|nbsp| |nbsp| |nbsp| :codenormal:`{'name': "
#~ "'flags','type': 'str'}, {'name': 'format',` "
#~ "|br| |nbsp| |nbsp| |nbsp| :codenormal:`'type':"
#~ " '*'}]]` |br| |nbsp| |nbsp| |nbsp| "
#~ ":codenormal:`...`"
#~ msgstr ""

#~ msgid ""
#~ "It looks disorganized because field "
#~ "number 7 has been formatted with "
#~ "recommended names and data types. How"
#~ " can one get those specific sub-"
#~ "fields? Since it's visible that field"
#~ " number 7 is an array of maps,"
#~ " this `for` loop will do the "
#~ "organizing: |br| :codenormal:`local tuple_of_space,"
#~ " field_name, field_type` |br| "
#~ ":codenormal:`tuple_of_space = "
#~ "box.space._space.index.name:select{'_space'}[1]` |br| "
#~ ":codenormal:`for i = 1, #tuple_of_space[7],"
#~ " 1` |br| :codenormal:`do` |br| |nbsp| "
#~ "|nbsp| |nbsp| :codenormal:`field_name = "
#~ "tuple_of_space[7][i]['name']` |br| |nbsp| |nbsp| "
#~ "|nbsp| :codenormal:`field_type = "
#~ "tuple_of_space[7][i]['type']` |br| |nbsp| |nbsp| "
#~ "|nbsp| :codenormal:`print(field_name .. ',' "
#~ "..field_type)` |br| :codenormal:`end`"
#~ msgstr ""

#~ msgid ""
#~ "And here is what happens when one"
#~ " executes the `for` loop: |br| "
#~ ":codenormal:`id,num` |br| :codenormal:`owner,num` "
#~ "|br| :codenormal:`name,str` |br| "
#~ ":codenormal:`engine,str` |br| "
#~ ":codenormal:`field_count,num` |br| :codenormal:`flags,str`"
#~ " |br| :codenormal:`format,*`"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
#~ "---\n"
#~ "- table\n"
#~ "- table\n"
#~ "...\n"
#~ "tarantool> box.stat, box.stat.net\n"
#~ "---\n"
#~ "- net: []\n"
#~ "- []\n"
#~ "...\n"
#~ "tarantool> box.stat()\n"
#~ "---\n"
#~ "- DELETE:\n"
#~ "    total: 1873949\n"
#~ "    rps: 123\n"
#~ "  SELECT:\n"
#~ "    total: 1237723\n"
#~ "    rps: 4099\n"
#~ "  INSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVAL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  CALL:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  REPLACE:\n"
#~ "    total: 1239123\n"
#~ "    rps: 7849\n"
#~ "  UPSERT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  AUTH:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  ERROR:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  UPDATE:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat().DELETE -- a selected item of the table\n"
#~ "---\n"
#~ "- total: 0\n"
#~ "  rps: 0\n"
#~ "...\n"
#~ "tarantool> box.stat.net()\n"
#~ "---\n"
#~ "- SENT:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "  EVENTS:\n"
#~ "    total: 2\n"
#~ "    rps: 0\n"
#~ "  LOCKS:\n"
#~ "    total: 6\n"
#~ "    rps: 0\n"
#~ "  RECEIVED:\n"
#~ "    total: 0\n"
#~ "    rps: 0\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "If ``t`` is a tuple instance, "
#~ "``t:bsize()`` will return the number of"
#~ " bytes in the tuple. It is "
#~ "useful to check this number when "
#~ "making changes to data, because there"
#~ " is a fixed maximum: one megabyte."
#~ " Every field has one or more "
#~ "\"length\" bytes preceding the actual "
#~ "contents, so ``bsize()`` returns a value"
#~ " which is slightly greater than the"
#~ " sum of the lengths of the "
#~ "contents."
#~ msgstr ""

#~ msgid ""
#~ "This function updates a tuple which "
#~ "is not in a space. Compare the "
#~ "function :code:`box.space.`:samp:`{space-"
#~ "name}`:code:`:update{`:samp:`{key}, {format},` "
#~ ":code:`{`:samp:`{field_number}, {value}`:code:`}...)`, "
#~ "which updates a tuple in a space."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: briefly: ``format`` indicates the"
#~ " type of update operation such as "
#~ "'``=``' for 'assign new value', "
#~ "``field_number`` indicates the field number"
#~ " to change such as 2 for field"
#~ " number 2, ``value`` indicates the "
#~ "string which operates on the field "
#~ "such as 'B' for a new assignable"
#~ " value = 'B'."
#~ msgstr ""

#~ msgid ""
#~ "For details: see the description for "
#~ "``format``, ``field_number``, and ``value`` in"
#~ " the section :ref:`box.space.space-"
#~ "name:update{key, format, {field_number, value}...)"
#~ " <box_space-update>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2',"
#~ " 'Fld#3', 'Fld#4', 'Fld#5'}\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> t:update({{'=',2,'B'}})\n"
#~ "---\n"
#~ "- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "tuple = box.tuple.new({scalar1, scalar2, ..."
#~ " scalar_n}) -- scalars to tuple\n"
#~ "lua_table = {tuple:unpack()}"
#~ "                            -- tuple to Lua "
#~ "table\n"
#~ "scalar1, scalar2, ... scalar_n = "
#~ "tuple:unpack()         -- tuple to scalars"
#~ "\n"
#~ "tuple = box.tuple.new(lua_table)"
#~ "                        -- Lua table to "
#~ "tuple"
#~ msgstr ""

#~ msgid ""
#~ "function example()\n"
#~ "  local tuple1, tuple2, lua_table_1, "
#~ "scalar1, scalar2, scalar3, field_number\n"
#~ "  local luatable1 = {}\n"
#~ "  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
#~ "  luatable1 = {tuple1:unpack()}\n"
#~ "  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
#~ "  tuple2 = box.tuple.new(luatable1)\n"
#~ "  field_number = tuple2:find('b')\n"
#~ "  tuple2 = tuple2:transform(field_number, 1)\n"
#~ "  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "If you tried out the :ref:`Starting "
#~ "Tarantool and making your first database"
#~ " <user_guide_getting_started-first_database>` exercise"
#~ " from the last chapter, then your "
#~ "database looks like this:"
#~ msgstr ""
#~ "Если вы уже выполнили тестовое задание"
#~ " из раздела :ref:`Первичный запуск "
#~ "Tarantool'а и создание базы данных "
#~ "<user_guide_getting_started-first_database>` в "
#~ "предыдущей главе, то ваша база данных"
#~ " имеет следующий вид:"

#~ msgid "Here follow the descriptions of basic concepts."
#~ msgstr ""

#~ msgid ""
#~ "When Tarantool is being used to "
#~ "store data, there is always at "
#~ "least one space. There can be many"
#~ " spaces. Each space has a unique "
#~ "name specified by the user. Each "
#~ "space has a unique numeric identifier"
#~ " which can be specified by the "
#~ "user but usually is assigned "
#~ "automatically by Tarantool. Spaces always "
#~ "contain one tuple set and one or"
#~ " more indexes."
#~ msgstr ""
#~ "Когда Tarantool используется для хранения "
#~ "данных, то он создает по меньшей "
#~ "мере одно пространство (space). В общем"
#~ " же случае пространств может быть "
#~ "много. Каждое пространство имеет уникальное"
#~ " имя, заданное пользователем, а также "
#~ "уникальный числовой идентификатор, который "
#~ "тоже может быть задан пользователем, но"
#~ " обычно назначается автоматически самим "
#~ "Tarantool'ом. Пространство всегда содержит "
#~ "один набор кортежей и один или "
#~ "более индексов."

#~ msgid "Tuple set"
#~ msgstr "Набор кортежей"

#~ msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
#~ msgstr ""
#~ "*Набор кортежей* — в нашем примере "
#~ "он назван 'tester' — это группа "
#~ "кортежей."

#~ msgid ""
#~ "There is always one tuple set in"
#~ " a space. The identifier of a "
#~ "tuple set is the same as the "
#~ "space name -- 'tester' in the "
#~ "example."
#~ msgstr ""
#~ "Каждое пространство всегда содержит один "
#~ "набор кортежей. Идентификатор набора кортежей"
#~ " совпадает с именем самого пространства,"
#~ " в нашем примере — `tester`."

#~ msgid ""
#~ "A tuple fills the same role as "
#~ "a “row” or a “record”, and the "
#~ "components of a tuple (which we "
#~ "call “fields”) fill the same role "
#~ "as a “row column” or “record "
#~ "field”, except that: the fields of "
#~ "a tuple can be composite structures, "
#~ "such as arrays or maps and don't"
#~ " need to have names. That's why "
#~ "there was no need to pre-define"
#~ " the tuple set when creating the "
#~ "space, and that's why each tuple "
#~ "can have a different number of "
#~ "elements. Tuples are stored as "
#~ "`MsgPack`_ arrays."
#~ msgstr ""
#~ "Кортеж (tuple) выполняет ту же роль, "
#~ "что \"строка\" или \"запись\", а "
#~ "компоненты кортежа (его \"полЯ\") выполняют"
#~ " ту же роль, что \"поле столбца, "
#~ "соответствующее данной строке\" или \"поле "
#~ "в записи\" за тем исключением, что "
#~ "поля кортежа могут быть составными "
#~ "(например, они могут быть массивами или"
#~ " отображениями) и им не нужны имена."
#~ " Поэтому нет необходимости предварительно "
#~ "определять набор кортежей при создании "
#~ "пространства, а каждый кортеж может "
#~ "иметь различное количество элементов. Кортежи"
#~ " хранятся в виде `MsgPack`_-массивов."

#~ msgid ""
#~ "When Tarantool returns a tuple value,"
#~ " it surrounds strings with single "
#~ "quotes, separates fields with commas, "
#~ "and encloses the tuple inside square "
#~ "brackets. For example: ``[3, 'length', "
#~ "93]``."
#~ msgstr ""
#~ "Когда Tarantool возвращает значение кортежа,"
#~ " он берет строки в одинарные кавычки,"
#~ " отделяет поля с запятыми и заключает"
#~ " кортеж в квадратные скобки. Например, "
#~ "``[ 3, 'length', 93 ]``."

#~ msgid ""
#~ "In order for a tuple set to "
#~ "be useful, there must always be at"
#~ " least one index in a space. "
#~ "There can be many indexes. As with"
#~ " spaces, the user can and should "
#~ "specify the index name, and let "
#~ "Tarantool come up with a unique "
#~ "numeric identifier (the \"index id\"). "
#~ "In our example there is one index"
#~ " and its name is “primary”."
#~ msgstr ""
#~ "Чтобы набором кортежей было можно "
#~ "пользоваться, в пространстве необходим по "
#~ "крайней мере один индекс. Вообще же "
#~ "индексов в пространстве может быть "
#~ "много. Как и в случае с "
#~ "пространствами, пользователь может — и "
#~ "должен — указать имя индекса, а "
#~ "Tarantool подставляет уникальный числовой "
#~ "идентификатор (\"идентификатор индекса\"). В "
#~ "нашем примере всего один индекс с "
#~ "именем “primary”."

#~ msgid ""
#~ "An index may be *multi-part*, that"
#~ " is, the user can declare that "
#~ "an index key value is taken from"
#~ " two or more fields in the "
#~ "tuple, in any order. An index may"
#~ " be *unique*, that is, the user "
#~ "can declare that it would be "
#~ "illegal to have the same key value"
#~ " twice. An index may have *one "
#~ "of four types*: HASH which is fast"
#~ " and is best for exact-equality "
#~ "searches with unique keys, TREE which"
#~ " allows partial-key searching and "
#~ "ordered results, BITSET which can be "
#~ "good for searches that contain '=' "
#~ "and multiple ANDed conditions, and RTREE"
#~ " for spatial coordinates. The first "
#~ "index is called the “*primary key*” "
#~ "index and it must be unique; all"
#~ " other indexes are called “secondary” "
#~ "indexes."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Индекс может быть *составным*. Значение "
#~ "ключа в таком индексе составляется из"
#~ " значений двух или более полей "
#~ "кортежа, причем они могут браться в "
#~ "любом порядке. Индекс может быть "
#~ "*уникальным*. В этом случае один и "
#~ "тот же ключ не может встречаться в"
#~ " индексе более одного раза. Также "
#~ "индекс может быть одного из следующих"
#~ " *четырех типов*: HASH (он самый "
#~ "быстрый и самый экономный в плане "
#~ "использования памяти, но он должен быть"
#~ " уникальным), TREE (он позволяет делать "
#~ "поиск по части ключа и получать "
#~ "отсортированные результаты), BITSET (он хорош"
#~ " для поиска с '=' и больших "
#~ "количеством AND-условий) или RTREE (для "
#~ "пространственных координат). Первый индекс "
#~ "называется “*первичным*” (primary) и должен"
#~ " быть уникальным. Все остальные индексы "
#~ "называются “вторичными” (secondary)."

#~ msgid ""
#~ "``unsigned`` (unsigned integer between 0 "
#~ "and 18,446,744,073,709,551,615)"
#~ msgstr ""
#~ "``unsigned`` (беззнаковое целое число в "
#~ "диапазоне от 0 до 18,446,744,073,709,551,615)"

#~ msgid "``number`` (unsigned integer or signed integer or floating-point value)"
#~ msgstr ""
#~ "``number`` (беззнаковое целое число, либо "
#~ "знаковое целое число, либо число с "
#~ "плавающей точкой)"

#~ msgid "``string`` (string, any sequence of octets)"
#~ msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#~ msgid "``scalar`` (boolean or number or string)"
#~ msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#~ msgid ""
#~ "``array`` (a series of numbers for "
#~ "use with :ref:`RTREE indexes <box_index-"
#~ "rtree>`)"
#~ msgstr ""
#~ "``array`` (последовательность чисел для "
#~ ":ref:`RTREE-индексов <box_index-rtree>`)"

#~ msgid "Take our example, which has the request:"
#~ msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#~ msgid ""
#~ "The effect is that, for all tuples"
#~ " in tester, field number 1 must "
#~ "exist and must contain an unsigned "
#~ "integer."
#~ msgstr ""
#~ "В результате у всех кортежей в "
#~ "пространстве `tester` должно быть поле с"
#~ " номером 1, содержащее беззнаковое целое"
#~ " число."

#~ msgid ""
#~ "Space definitions and index definitions "
#~ "are stored permanently in system spaces."
#~ " It is possible to add, drop, "
#~ "or alter the definitions at runtime, "
#~ "with some restrictions. See syntax "
#~ "details for defining spaces and indexes"
#~ " in :ref:`reference on Tarantool's \"box\""
#~ " module <index-box_library>`."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Определения пространств и индексов хранятся"
#~ " в системных пространствах. Можно (с "
#~ "некоторыми ограничениями) на ходу добавлять,"
#~ " удалять и менять эти определения. "
#~ "Правила синтаксиса в определениях пространств"
#~ " и индексов даны в разделе "
#~ ":ref:`Библиотека \"box\" <index-box_library>`."

#~ msgid ""
#~ "Tarantool can work with numbers, "
#~ "strings, booleans, tables, and userdata."
#~ msgstr ""
#~ "Tarantool работает с числами (numbers), "
#~ "строками (strings), логическими значениями "
#~ "(booleans), таблицами (tables) и "
#~ "пользовательскими типами данных (userdata)."

#~ msgid "Specific type"
#~ msgstr "Особый тип"

#~ msgid "What Lua ``type()`` would return"
#~ msgstr "Результат Lua type()"

#~ msgid "\"`table`_\""
#~ msgstr "\"`table`_\""

#~ msgid "\"`Userdata`_\""
#~ msgstr "\"`Userdata`_\""

#~ msgid ""
#~ "For database storage, Tarantool uses "
#~ "MsgPack rules. Storage is variable-"
#~ "length, so the smallest number requires"
#~ " only one byte but the largest "
#~ "number requires nine bytes. When a "
#~ "field has an 'unsigned' index, all "
#~ "values must be unsigned integers between"
#~ " 0 and 18,446,744,073,709,551,615."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Для хранения данных в базе Tarantool "
#~ "использует формат MsgPack. Данные при "
#~ "хранении имеют переменную длину, поэтому "
#~ "для самого маленького числа потребуется "
#~ "только один байт, а самое большее "
#~ "число потребует девять байтов. Если поле"
#~ " имеет индекс 'unsigned', то оно "
#~ "может содержать только целые беззнаковые "
#~ "числа со значениями в диапазоне от "
#~ "0 до 18,446,744,073,709,551,615."

#~ msgid ""
#~ "A *string* is a variable-length "
#~ "sequence of bytes, usually represented "
#~ "with alphanumeric characters inside single "
#~ "quotes."
#~ msgstr ""
#~ "Тип *string* (строка) — это "
#~ "последовательность байтов, имеющая переменную "
#~ "длину. Как правило, строки представлены "
#~ "в виде алфавитно-числовых символы, заключенных"
#~ " в одинарные кавычки."

#~ msgid ""
#~ "A *tuple* is returned in YAML "
#~ "format like ``- [120, 'a', 'b', "
#~ "'c']``. A few functions may return "
#~ "tables with multiple tuples. A scalar"
#~ " may be converted to a tuple "
#~ "with only one field. A Lua table"
#~ " may contain all of a tuple's "
#~ "fields, but not nil."
#~ msgstr ""
#~ "Тип *tuple* возвращается в формате YAML,"
#~ " например ``- [120, 'a', 'b', 'c']``."
#~ " Некоторые функции могут возвращать таблицы"
#~ " с несколькими кортежами. Скалярная "
#~ "величина может быть конвертирована в "
#~ "кортеж с 1 полем. Lua-таблица может "
#~ "содержать все типы полей, допустимые для"
#~ " кортежей, кроме нулевого типа (nil)."

#~ msgid ""
#~ "Some of the data types may be "
#~ "used in :ref:`indexed fields "
#~ "<details_about_index_field_types>`."
#~ msgstr ""
#~ "Некоторые из этих типов данных подходят"
#~ " для :ref:`индексируемых полей "
#~ "<details_about_index_field_types>`."

#~ msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
#~ msgstr ""
#~ "См. также примеры кортежей в разделе "
#~ "про модуль :ref:`box.tuple <box_tuple>`."

#~ msgid ""
#~ "The basic operations are: the five "
#~ "data-change operations (``insert``, "
#~ "``update``, ``upsert``, ``delete``, ``replace``),"
#~ " and the data-retrieval operation "
#~ "(``select``). There are also minor "
#~ "operations like “ping” which can only"
#~ " be used with the binary protocol."
#~ " Also, there are :ref:`index iterator "
#~ "<box_index-index_pairs>` operations, which can"
#~ " only be used with Lua code. "
#~ "(Index iterators are for traversing "
#~ "indexes one key at a time, taking"
#~ " advantage of features that are "
#~ "specific to an index type, for "
#~ "example evaluating Boolean expressions when"
#~ " traversing BITSET indexes, or going "
#~ "in descending order when traversing TREE"
#~ " indexes.)"
#~ msgstr ""
#~ "Основные операции — это пять операций"
#~ " для изменения данных (INSERT, UPDATE, "
#~ "UPSERT, DELETE, REPLACE) и одна операция"
#~ " для возвращения данных (SELECT). Также "
#~ "в Tarantool'е поддерживаются второстепенные "
#~ "операции типа PING, которые можно "
#~ "использовать только в рамках бинарного "
#~ "протокола. Кроме того, в Tarantool'е "
#~ "есть операции для :ref:`индекс-итераторов "
#~ "<box_index-index_pairs>`, которые можно "
#~ "использовать только в коде на языке "
#~ "Lua. (Индекс-итераторы нужны для обхода "
#~ "индексов от одного ключа к другому "
#~ "и дают возможность пользоваться преимуществами"
#~ " разных типов индексов, например вычислять"
#~ " значение выражений логического типа при"
#~ " обходе BITSET-индексов или двигаться в "
#~ "порядке убывания значений при обходе "
#~ "TREE-индексов.)"

#~ msgid "Six examples of basic operations:"
#~ msgstr "Шесть примеров основных операций:"

#~ msgid ""
#~ "-- Add a new tuple to tuple set tester.\n"
#~ "-- The first field, field[1], will be 999 (type is unsigned).\n"
#~ "-- The second field, field[2], will be 'Taranto' (type is string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Update the tuple, changing field field[2].\n"
#~ "-- The clause \"{999}\", which has the value to look up in\n"
#~ "-- the index of the tuple's primary-key field, is mandatory\n"
#~ "-- because update() requests must always have a clause that\n"
#~ "-- specifies the primary key, which in this case is field[1].\n"
#~ "-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
#~ "-- will happen to field[2] with the new value.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Upsert the tuple, changing field field[2] again.\n"
#~ "-- The syntax of upsert is similar to the syntax of update,\n"
#~ "-- but the return value will be different.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Replace the tuple, adding a new field.\n"
#~ "-- This is also possible with the update() request but\n"
#~ "-- the update() request is usually more complicated.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Retrieve the tuple.\n"
#~ "-- The clause \"{999}\" is still "
#~ "mandatory, although it does not have "
#~ "to\n"
#~ "-- mention the primary key.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Delete the tuple.\n"
#~ "-- Once again the clause to "
#~ "identify the primary-key field is "
#~ "mandatory.\n"
#~ "tarantool> box.space.tester:delete{999}"
#~ msgstr ""
#~ "-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
#~ "-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
#~ "-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Обновляем кортеж, меняем значение поля field[2].\n"
#~ "-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
#~ "-- искать в первичном индексе, построенном по первому полю\n"
#~ "-- кортежа, является обязательным, поскольку запросам update()\n"
#~ "-- всегда требуется условие, определяющее значение первичного\n"
#~ "-- ключа, в данном случае field[1].\n"
#~ "-- Условие \"{{'=', 2, 'Tarantino'}}\" "
#~ "определяет, что полю field[2] нужно \n"
#~ "-- присвоить новое значение.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Выполняем операцию upsert() для кортежа и снова меняем\n"
#~ "-- значение поля field[2].\n"
#~ "-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
#~ "-- но возвращаемые значения у этих запросов разные.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Производим замену кортежа с помощью"
#~ " replace(), добавляем новое поле.\n"
#~ "-- Это можно сделать и с помощью запроса update(),\n"
#~ "-- но такой вариант часто оказывается более сложным.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Возвращаем значение кортежа.\n"
#~ "-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
#~ "-- содержать значение первичного ключа.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Удаляем кортеж.\n"
#~ "-- Условие, определяющее значение первичного ключа,\n"
#~ "-- снова является обязательным.\n"
#~ "tarantool> box.space.tester:delete{999}"

#~ msgid ""
#~ "If this is happening on a remote"
#~ " client, then the client parses the"
#~ " statement and changes it to a "
#~ "binary-protocol instruction which has "
#~ "already been checked, and which the "
#~ "server can understand without needing to"
#~ " parse everything again. The client "
#~ "ships a packet to the server."
#~ msgstr ""
#~ "Если запрос делается с удаленного "
#~ "клиента, то клиент разбирает введенное "
#~ "выражение, проверяет на корректность и "
#~ "переводит его в формат инструкций "
#~ "бинарного протокола, которые Tarantool-сервер "
#~ "сможет понять без повторного разбора. "
#~ "Затем клиент отправляет всё в виде "
#~ "пакета на сторону сервера."

#~ msgid ""
#~ "The transaction processor thread sends a"
#~ " message to the write-ahead logging"
#~ " (WAL) thread."
#~ msgstr ""
#~ "Поток обработки транзакций посылает сообщение"
#~ " другому потоку, который занимается записью"
#~ " в WAL."

#~ msgid ""
#~ "At this point, a *yield* takes "
#~ "place. To know the significance of "
#~ "that -- and it's quite significant "
#~ "-- you have to know a few "
#~ "facts and a few new words."
#~ msgstr ""
#~ "В этот момент происходит *передача "
#~ "управления* (yield). Чтобы понять важность "
#~ "этого события — а оно действительно "
#~ "важно, — нужно пояснить несколько фактов"
#~ " и ввести ряд новых терминов."

#~ msgid "FACT 1:"
#~ msgstr "ФАКТ #1:"

#~ msgid "FACT 2:"
#~ msgstr "ФАКТ #2:"

#~ msgid "FACT 3:"
#~ msgstr "ФАКТ #3:"

#~ msgid ""
#~ "Yields must happen, otherwise the "
#~ "transaction processor thread would stick "
#~ "permanently on the same fiber. There "
#~ "are :ref:`implicit yields <atomic-"
#~ "the_implicit_yield_rules>`: every data-change "
#~ "operation or network-access causes an"
#~ " implicit yield, and every statement "
#~ "that goes through the tarantool client"
#~ " causes an implicit yield. And there"
#~ " are explicit yields: in a Lua "
#~ "function one can and should add "
#~ "“yield” statements to prevent hogging. "
#~ "This is called *cooperative multitasking*."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Без передачи управления не обойтись, "
#~ "т.к. иначе поток обработки транзакций "
#~ "сможет выполнять инструкции только для "
#~ "одного файбера. Передача управления может "
#~ "осуществляться один их двух способов. "
#~ "Первый — это :ref:`неявная передача "
#~ "<atomic-the_implicit_yield_rules>`. Она делается "
#~ "при каждой операции, связанной с "
#~ "изменением данных, при каждом обращении "
#~ "к сетевому соединению, а также при "
#~ "каждом запросе, который передается через "
#~ "Tarantool-клиент. Второй способ передачи "
#~ "управления — это явная передача. Ее "
#~ "можно — и нужно — вызывать внутри"
#~ " Lua-функций с помощью инструкции “yield”,"
#~ " чтобы не допустить захвата процессора "
#~ "одним файбером. Это называется *взаимная "
#~ "многозадачность*."

#~ msgid ""
#~ "Since all data-change operations end "
#~ "with an implicit yield and an "
#~ "implicit commit, and since no data-"
#~ "change operation can change more than"
#~ " one tuple, there is no need "
#~ "for any locking. Consider, for example,"
#~ " a Lua function that does three "
#~ "Tarantool operations:"
#~ msgstr ""
#~ "Поскольку все операции, связанные с "
#~ "изменением данных, заканчиваются неявной "
#~ "передачей управления и неявным коммитом, "
#~ "и поскольку каждая такая операция может"
#~ " затрагивать не более одного кортежа, "
#~ "то не возникает нужды в блокировках. "
#~ "Для примера рассмотрим следующую Lua-функцию,"
#~ " которая осуществляет три операции в "
#~ "Tarantool'е:"

#~ msgid ""
#~ "s:select{999}             -- this does not yield and does not commit\n"
#~ "s:update({...},{{...}})   -- this yields and commits\n"
#~ "s:select{999}             -- this does not yield and does not commit"
#~ msgstr ""
#~ "s:select{999}             -- не происходит ни"
#~ " передачи управления, ни коммита\n"
#~ "s:update({...},{{...}})   -- происходит и "
#~ "передача управления, и коммит\n"
#~ "s:select{999}             -- не происходит ни"
#~ " передачи управления, ни коммита"

#~ msgid ""
#~ "The combination “SELECT plus UPDATE” is"
#~ " an atomic transaction: the function "
#~ "holds a consistent view of the "
#~ "database until the UPDATE ends. For "
#~ "the combination “UPDATE plus SELECT” the"
#~ " view is not consistent, because "
#~ "after the UPDATE the transaction "
#~ "processor thread can switch to another"
#~ " fiber, and delete the tuple that "
#~ "was just updated."
#~ msgstr ""
#~ "Последовательность операций “SELECT + UPDATE”"
#~ " является атомарной транзакцией: функция "
#~ "сохраняет базу данных в согласованном "
#~ "виде, пока не отработает UPDATE. А "
#~ "в случае “UPDATE + SELECT” "
#~ "согласованности нет, поскольку после операции"
#~ " UPDATE поток обработки транзакций может"
#~ " переключится на другой файбер и "
#~ "удалить тот кортеж, что был обновлен "
#~ "в рамках предыдущей операции UPDATE."

#~ msgid ""
#~ "Note re storage engine: vinyl handles"
#~ " yields differently, see :ref:`differences "
#~ "between memtx and vinyl <vinyl_diff>`."
#~ msgstr ""
#~ "Примечание про движок: в движке vinyl"
#~ " передача управления происходит по-другому, "
#~ "см. раздел про :ref:`различия между "
#~ "движками memtx и vinyl <vinyl_diff>`."

#~ msgid "Note re multi-request transactions"
#~ msgstr "Примечание про составные транзакции:"

#~ msgid ""
#~ "There is a way to delay yields."
#~ " Read about execution atomicity in "
#~ "section :ref:`Transaction control "
#~ "<transaction_control>`."
#~ msgstr ""

#~ msgid ""
#~ "Since locks don't exist, and disk "
#~ "writes only involve the write-ahead "
#~ "log, transactions are usually fast. Also"
#~ " the Tarantool server may not be "
#~ "using up all the threads of a "
#~ "powerful multi-core processor, so "
#~ "advanced users may be able to "
#~ "start a second Tarantool server on "
#~ "the same processor without ill effects."
#~ msgstr ""
#~ "Посколько блокировки не используются, а "
#~ "запись на диск производится только при"
#~ " работе с WAL-файлом, то транзакции в"
#~ " Tarantool'е обычно совершаются быстро. "
#~ "Кроме того, если мы имеем дело с"
#~ " мощным многоядерным процессором, то "
#~ "Tarantool-сервер может задействовать для "
#~ "работы не все потоки такого процессора,"
#~ " и продвинутые пользователи могут "
#~ "безболезненно запускать второй Tarantool-сервер "
#~ "на том же процессоре."

#~ msgid ""
#~ "Additional examples of requests can be"
#~ " found in the Tarantool regression "
#~ "test suite "
#~ "(https://github.com/tarantool/tarantool/tree/1.7/test/box). A"
#~ " complete grammar of supported data-"
#~ "manipulation functions will come later "
#~ "in this chapter."
#~ msgstr ""
#~ "См. также примеры с запросами в "
#~ "регрессионных тестах для Tarantool'а "
#~ "(https://github.com/tarantool/tarantool/tree/1.7/test/box). "
#~ "Полное описание грамматики поддерживаемых в"
#~ " Tarantool'е функций для манипулирования "
#~ "данными см. далее в этой главе."

#~ msgid ""
#~ "Since not all Tarantool operations can"
#~ " be expressed with the data-"
#~ "manipulation functions, or with Lua, to"
#~ " gain complete access to data "
#~ "manipulation functionality one must use "
#~ "a :ref:`Perl, PHP, Python or other "
#~ "programming language connector <index-"
#~ "box_connectors>`. The client/server protocol "
#~ "is open and documented. See this "
#~ ":ref:`annotated BNF <box_protocol-iproto_protocol>`."
#~ msgstr ""
#~ "Не все операции в Tarantool'е можно "
#~ "выразить с помощью функций по "
#~ "манипулированию данными или с помощью "
#~ "языка Lua. Чтобы получить доступ ко "
#~ "всем возможностями манипулирования данными, "
#~ "вам понадобится :ref:`коннектор для Perl, "
#~ "PHP, Python или другого языка "
#~ "программирования <index-box_connectors>`. Бинарный"
#~ " клиент-серверный протокол для коннекторов "
#~ "является открытым. Документация по нему "
#~ "доступна в виде аннотированных "
#~ ":ref:`BNF-диаграмм <box_protocol-iproto_protocol>`."

#~ msgid ""
#~ "Tarantool maintains a set of write-"
#~ "ahead log (WAL) files. There is a"
#~ " separate thread -- the WAL writer"
#~ " -- which catches all requests that"
#~ " can change a database, such as "
#~ "``box.schema.create`` or ``box.space.insert``. "
#~ "Ordinarily the WAL writer writes the "
#~ "request, along with administrative fields "
#~ "and flags, to a WAL file "
#~ "immediately. This ensures data persistence,"
#~ " because, even if an in-memory "
#~ "database is lost when the power "
#~ "goes off, Tarantool recovers it "
#~ "automatically when it starts up again,"
#~ " by reading the WAL files and "
#~ "redoing the requests (this is called "
#~ "the \"recovery process\"). Users can "
#~ "change the timing of the WAL "
#~ "writer, or turn it off, by setting"
#~ " :ref:`wal_mode <cfg_binary_logging_snapshots-"
#~ "wal_mode>`."
#~ msgstr ""
#~ "Tarantool сохраняет данные и информацию "
#~ "об изменениях в нескольких WAL-файлах "
#~ "(write-ahead log). Записью в WAL "
#~ "занимается отдельный поток. Он ловит все"
#~ " запросы, которые могут привести к "
#~ "изменению данных в базе, например "
#~ "``box.schema.create`` или ``box.space.insert``. Как"
#~ " правило, запись о запросе, включая "
#~ "служебные поля и флаги, делается в "
#~ "WAL-файл немедленно. Это обеспечивает "
#~ "сохранность данных, поскольку, даже если "
#~ "данные из памяти утеряны вследствие "
#~ "перебоя в электроснабжении, Tarantool "
#~ "восстановит их автоматически при следующем "
#~ "старте: он загрузит данные из "
#~ "WAL-файлов, а затем применит все "
#~ "записанные в WAL-файлах запросы (это "
#~ "называется \"процесс восстановления\"). Пользователи"
#~ " могут менять частоту записи или "
#~ "вовсе отключать запись в WAL с "
#~ "помощью параметра :ref:`wal_mode "
#~ "<cfg_binary_logging_snapshots-wal_mode>`."

#~ msgid ""
#~ "Details about the WAL writer and "
#~ "the recovery process are in the "
#~ ":ref:`Internals <internals>` section."
#~ msgstr ""

#~ msgid "Data manipulation"
#~ msgstr "Манипулирование данными"

#~ msgid ""
#~ "The basic *data-manipulation* requests "
#~ "are: ``insert``, ``replace``, ``update``, "
#~ "``upsert``, ``delete``, ``select``. All of "
#~ "them are part of the ``box`` "
#~ "library. Most of them may return "
#~ "data. Usually both inputs and outputs"
#~ " are Lua tables."
#~ msgstr ""
#~ "Основные запросы для *манипулирования данными*"
#~ " — это ``insert``, ``replace``, ``update``,"
#~ " ``upsert``, ``delete``, ``select``. Все "
#~ "они реализованы в библиотеке ``box``. "
#~ "Многие из этих запросов могут возвращать"
#~ " данные. Как правило, и вводимые, и"
#~ " возвращаемые значения являются Lua-таблицами."

#~ msgid ""
#~ "-- #1 module . submodule . name\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 replace name with a literal in square brackets\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 replace name with a numeric id in square brackets\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 use a variable instead of a literal for the name\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 use a variable for the entire object reference\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"
#~ msgstr ""
#~ "-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 вместо имени объекта указываем "
#~ "числовой идентификатор в квадратных скобках"
#~ "\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 вместо литерала, обозначающего имя"
#~ " объекта, указываем переменную\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 указываем переменную вместо ссылки на весь объект\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"

#~ msgid ""
#~ "The primary-key value is enclosed "
#~ "in braces, and if it was a "
#~ "multi-part primary key then the value"
#~ " would be multi-part, for example "
#~ "``...select{1,2,3}``. The braces can be "
#~ "enclosed inside parentheses — "
#~ "``...select({...})`` — which are optional "
#~ "unless it is necessary to pass "
#~ "something besides the primary-key value,"
#~ " as in example #5. Literal values "
#~ "such as 1 (a scalar value) or "
#~ "{1} (a Lua table value) may be "
#~ "replaced by variable names, as in "
#~ "examples #6 and #7. Although there "
#~ "are special cases where braces can "
#~ "be omitted, they are preferable because"
#~ " they signal \"Lua table\". Examples "
#~ "and descriptions in this manual have "
#~ "the \"{1}\" form; however, this too "
#~ "is a matter of user preference and"
#~ " all the variations exist in the "
#~ "wild."
#~ msgstr ""
#~ "Значение первичного ключа заключается в "
#~ "фигурные скобки. Если же этот первичный"
#~ " ключ является составным, то и "
#~ "значение будет составным, например "
#~ "``...select{1,2,3}``. Фигурные скобки в свою"
#~ " очередь могут заключаться в круглые "
#~ "скобки — например, ``...select({...})``. Это"
#~ " опциональный вариант синтаксиса, и он "
#~ "необходим только в том случае, если "
#~ "нужно передать что-то помимо первичного "
#~ "ключа, как в примере #5. Вместо "
#~ "значений-литералов — например, 1 (скалярное"
#~ " значение) или {1} (Lua-таблица) — "
#~ "можно использовать имена переменных, как "
#~ "в примерах #6 и #7. Хотя в "
#~ "некоторых случаях фигурные скобки можно "
#~ "опускать, мы рекомендуем всегда их "
#~ "использовать. Так вы явно обозначите, "
#~ "что значение имеет тип \"Lua-таблица\". "
#~ "В примерах и описаниях в документации"
#~ " мы везде используем фигурные скобки, "
#~ "например \"{1}\".  Но как и в "
#~ "случае со ссылками на объект, вы "
#~ "можете пользоваться любым допустимым вариантом"
#~ " синтаксиса."

#~ msgid ""
#~ "All the data-manipulation functions "
#~ "operate on tuple sets but, since "
#~ "primary keys are unique, the number "
#~ "of tuples in the tuple set is "
#~ "always 0 or 1. The only exception"
#~ " is ``box.space...select``, which may "
#~ "accept either a primary-key value "
#~ "or a secondary-key value."
#~ msgstr ""
#~ "Все функции для манипулирования данными "
#~ "оперируют наборами кортежей. Однако, поскольку"
#~ " первичные ключи всегда уникальны, "
#~ "количество кортежей в таком наборе "
#~ "всегда равно 0 или 1. Единственным "
#~ "исключением является функция ``box.space...select``,"
#~ " которая может брать на вход как "
#~ "первичный, так и вторичный ключ."

#~ msgid "**Complexity factors that may affect data-manipulation functions**"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "**Факторы, которые могут влиять на "
#~ "быстродействие функций для манипулирования "
#~ "данными из библиотеки box**"

#~ msgid ""
#~ "In the discussion of each data-"
#~ "manipulation function, there will be a"
#~ " note about which complexity factors "
#~ "might affect the function's resource "
#~ "usage."
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Далее в описании каждой функции для "
#~ "манипулирования данными будет дано примечание,"
#~ " какие из перечисленных выше факторов "
#~ "могут влиять на ее быстродействие."

#~ msgid "An indexed field may be a string rather than a number."
#~ msgstr "Индексируемое поле может быть строкой, а не числом."

#~ msgid ""
#~ "For an ordinary index, the most "
#~ "common data types are 'unsigned' = "
#~ "any non-negative integer, or 'string'"
#~ " = any series of bytes. Numbers "
#~ "are ordered according to their point "
#~ "on the number line -- so 2345 "
#~ "is greater than 500 -- while "
#~ "strings are ordered according to the "
#~ "encoding of the first byte then "
#~ "the encoding of the second byte "
#~ "then the encoding of the third "
#~ "byte and so on -- so '2345' "
#~ "is less than '500'."
#~ msgstr ""
#~ "Обычный индекс, как правило, строится по"
#~ " полям одного из двух типов: 'NUM'"
#~ " = числовой (numeric) = любое "
#~ "неотрицательное целое число, либо 'STR' "
#~ "= строка (string) = любая "
#~ "последовательность байтов. Числа в индексе "
#~ "упорядочены по числовой прямой (например, "
#~ "число 2345 больше, чем число 500), "
#~ "а строки — по коду первого байта,"
#~ " затем по коду второго, третьего и"
#~ " т.д. (и теперь строка '2345' будет"
#~ " меньше, чем строка '500')."

#~ msgid "There may be more than one field."
#~ msgstr "Индекс может строиться по нескольким полям."

#~ msgid ""
#~ "For an ordinary index, the maximum "
#~ "number of parts is 255. The "
#~ "specification of each part consists of"
#~ " a field number and a type."
#~ msgstr ""
#~ "В обычном индексе может быть максимум"
#~ " 255 частей. Каждая часть характеризуется"
#~ " номером поля и его типом."

#~ msgid "The index does not have to be unique."
#~ msgstr "Индекс может быть неуникальным."

#~ msgid "The index does not have to be a tree."
#~ msgstr "Индекс может представлять собой не только дерево."

#~ msgid ""
#~ "The two ordinary index types are "
#~ "'tree' which is the default, and "
#~ "'hash' which must be unique and "
#~ "which may be faster. The third "
#~ "type is 'bitset' which is not "
#~ "unique and which works best for "
#~ "combinations of binary values. The "
#~ "fourth type is 'rtree' which is "
#~ "not unique and which works with "
#~ "arrays, instead of 'string' or "
#~ "'unsigned' values."
#~ msgstr ""

#~ msgid ""
#~ "The existence of indexes does not "
#~ "affect the syntax of data-change "
#~ "requests, but does cause select requests"
#~ " to have more variety."
#~ msgstr ""
#~ "Наличие индексов никак не влияет на "
#~ "синтаксис запросов на изменение данных. "
#~ "А вот SELECT-запросы, благодаря индексам, "
#~ "становятся более разнообразными."

#~ msgid ""
#~ "Searches on BITSET indexes can be "
#~ "for BITS_ANY_SET, BITS_ALL_SET, BITS_ALL_NOT_SET,"
#~ " EQ, or ALL."
#~ msgstr ""
#~ "При поиске по BITSET-индексам можно "
#~ "использовать операторы BITS_ANY_SET, BITS_ALL_SET,"
#~ " BITS_ALL_NOT_SET, EQ и ALL."

#~ msgid ""
#~ "Searches on RTREE indexes can be "
#~ "for GT, GE, LT, LE, OVERLAPS, or"
#~ " NEIGHBOR."
#~ msgstr ""
#~ "При поиске по RTREE-индексам можно "
#~ "использовать операторы GT, GE, LT, LE,"
#~ " OVERLAPS и NEIGHBOR."

#~ msgid ""
#~ "In several places in this manual, "
#~ "it's been noted that Lua processes "
#~ "occur in fibers on a single "
#~ "thread. That is why there can be"
#~ " a guarantee of execution atomicity. "
#~ "That requires emphasis."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool uses cooperative multitasking: "
#~ "unless a running fiber deliberately "
#~ "yields control, it is not preempted "
#~ "by some other fiber. But a running"
#~ " fiber will deliberately yield when "
#~ "it encounters a \"yield point\": an "
#~ "explicit `yield()` request, or an "
#~ "implicit yield due to an operating-"
#~ "system call. Any system call which "
#~ "can block will be performed "
#~ "asynchronously, and any running fiber "
#~ "which must wait for a system call"
#~ " will be preempted so that another"
#~ " ready-to-run fiber takes its "
#~ "place and becomes the new running "
#~ "fiber. This model makes all programmatic"
#~ " locks unnecessary: cooperative multitasking "
#~ "ensures that there will be no "
#~ "concurrency around a resource, no race"
#~ " conditions, and no memory consistency "
#~ "issues."
#~ msgstr ""

#~ msgid ""
#~ "However, a function might perform "
#~ "complex computations or might be written"
#~ " in such a way that yields do"
#~ " not occur for a long time. "
#~ "This can lead to unfair scheduling, "
#~ "when a single client throttles the "
#~ "rest of the system, or to apparent"
#~ " stalls in request processing. Avoiding "
#~ "this situation is the responsibility of"
#~ " the function's author. For the "
#~ "default memtx storage engine some of "
#~ "the box calls, including the data-"
#~ "change requests :ref:`box.space...insert "
#~ "<box_space-insert>` or :ref:`box.space...update "
#~ "<box_space-update>` or :ref:`box.space...delete "
#~ "<box_space-delete>`, will usually cause "
#~ "yielding; however, :ref:`box.space...select "
#~ "<box_space-select>` will not. A fuller "
#~ "description will appear in section "
#~ ":ref:`Implicit yields <atomic-"
#~ "the_implicit_yield_rules>`."
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl has "
#~ "different rules: insert or update or "
#~ "delete will very rarely cause a "
#~ "yield, but select can cause a "
#~ "yield."
#~ msgstr ""

#~ msgid ""
#~ "In the absence of transactions, any "
#~ "function that contains yield points may"
#~ " see changes in the database state"
#~ " caused by fibers that preempt. Then"
#~ " the only safe atomic functions for"
#~ " memtx databases would be functions "
#~ "which contain only one database request,"
#~ " or functions which contain a select"
#~ " request followed by a data-change"
#~ " request."
#~ msgstr ""

#~ msgid ""
#~ "At this point an objection could "
#~ "arise: \"It's good that a single "
#~ "data-change request will commit and "
#~ "yield, but surely there are times "
#~ "when multiple data-change requests must"
#~ " happen without yielding.\" The standard"
#~ " example is the money-transfer, where"
#~ " $1 is withdrawn from account #1 "
#~ "and deposited into account #2. If "
#~ "something interrupted after the withdrawal,"
#~ " then the institution would be out"
#~ " of balance. For such cases, the "
#~ "``begin ... commit|rollback`` block was "
#~ "designed."
#~ msgstr ""

#~ msgid ""
#~ "End the transaction, but cancel all "
#~ "its data-change operations. An explicit"
#~ " call to functions outside ``box.space``"
#~ " that always yield, such as "
#~ "``fiber.yield`` or ``fiber.sleep``, will have"
#~ " the same effect."
#~ msgstr ""

#~ msgid ""
#~ "The **requests in a transaction must "
#~ "be sent to the server as a "
#~ "single block**. It is not enough "
#~ "to enclose them between ``begin`` and"
#~ " ``commit`` or ``rollback``. To ensure "
#~ "they are sent as a single block:"
#~ " put them in a function, or put"
#~ " them all on one line, or use"
#~ " a delimiter so that multi-line "
#~ "requests are handled together."
#~ msgstr ""

#~ msgid ""
#~ "**All database operations in a "
#~ "transaction should use the same storage"
#~ " engine**. It is not safe to "
#~ "access tuple sets that are defined "
#~ "with ``{engine='vinyl'}`` and also access "
#~ "tuple sets that are defined with "
#~ "``{engine='memtx'}``, in the same transaction."
#~ msgstr ""

#~ msgid ""
#~ "Assuming that in tuple set 'tester' "
#~ "there are tuples in which the "
#~ "third field represents a positive dollar"
#~ " amount ... Start a transaction, "
#~ "withdraw from tuple#1, deposit in "
#~ "tuple#2, and end the transaction, making"
#~ " its effects permanent."
#~ msgstr ""

#~ msgid ""
#~ "The only explicit yield requests are "
#~ ":ref:`fiber.sleep() <fiber-sleep>` and "
#~ ":ref:`fiber.yield() <fiber-yield>`, but many"
#~ " other requests \"imply\" yields because"
#~ " Tarantool is designed to avoid "
#~ "blocking."
#~ msgstr ""

#~ msgid ""
#~ "The implicit yield requests are: "
#~ ":ref:`insert <box_space-insert>` :ref:`replace "
#~ "<box_space-replace>` :ref:`update <box_space-"
#~ "update>` :ref:`upsert <box_space-upsert>` "
#~ ":ref:`delete <box_space-delete>` (the "
#~ "\"data-change\" requests), and functions in"
#~ " module :ref:`fio <fio-section>`, "
#~ ":ref:`net_box <net_box-module>`, :ref:`console "
#~ "<console-module>`, or :ref:`socket <socket-"
#~ "module>` (the \"os\" and \"network\" "
#~ "requests)."
#~ msgstr ""

#~ msgid ""
#~ "Note re storage engine: vinyl causes "
#~ ":ref:`select <box_space-select>` to be "
#~ "an implicit yield request, but data-"
#~ "change requests may not be."
#~ msgstr ""

#~ msgid ""
#~ "The yield occurs just before a "
#~ "blocking syscall, such as a write "
#~ "to the Write-Ahead Log (WAL) or"
#~ " a network message reception."
#~ msgstr ""

#~ msgid ""
#~ "Implicit yield requests are disabled by"
#~ " :ref:`box.begin <atomic-box_begin>`, and "
#~ "enabled again by :ref:`commit <atomic-"
#~ "box_commit>`. Therefore the sequence"
#~ msgstr ""

#~ msgid ""
#~ "begin\n"
#~ "implicit yield request #1\n"
#~ "implicit yield request #2\n"
#~ "implicit yield request #3\n"
#~ "commit"
#~ msgstr ""

#~ msgid ""
#~ "will not cause implicit yield until "
#~ "the commit occurs (specifically: just "
#~ "before the writes to the WAL, "
#~ "which are delayed until commit time)."
#~ " The commit request is not itself "
#~ "an implicit yield request, it only "
#~ "enables yields caused by earlier "
#~ "implicit yield requests."
#~ msgstr ""

#~ msgid ""
#~ "Despite their resemblance to implicit "
#~ "yield requests, :ref:`truncate <box_space-"
#~ "truncate>` and :ref:`drop <box_space-drop>`"
#~ " do not cause implicit yield. Despite"
#~ " their resemblance to functions of "
#~ "the fio module, functions of the "
#~ "standard Lua module `os "
#~ "<http://www.lua.org/manual/5.1/manual.html#5.8>`_ do not"
#~ " cause implicit yield. Despite its "
#~ "resemblance to commit, :ref:`rollback "
#~ "<atomic-box_rollback>` does not enable "
#~ "yields."
#~ msgstr ""

#~ msgid ""
#~ "If :ref:`wal_mode <cfg_binary_logging_snapshots-"
#~ "wal_mode>` = 'none', then implicit "
#~ "yielding is disabled, because there are"
#~ " no writes to the WAL."
#~ msgstr ""

#~ msgid ""
#~ "If a task is interactive -- "
#~ "sending requests to the server and "
#~ "receiving responses -- then it involves"
#~ " network IO, and therefore there is"
#~ " an implicit yield, even if the "
#~ "request that is sent to the server"
#~ " is not itself an implicit yield "
#~ "request. Therefore the sequence"
#~ msgstr ""

#~ msgid ""
#~ "causes blocking if it is inside a"
#~ " function or Lua program being "
#~ "executed on the server, but causes "
#~ "yielding if it is done as a "
#~ "series of transmissions from a client,"
#~ " including a client which operates "
#~ "via telnet, via one of the "
#~ "connectors, or via the MySQL and "
#~ "PostgreSQL rocks, or via the interactive"
#~ " mode when :ref:`\"Using tarantool as "
#~ "a client\" <administration-"
#~ "using_tarantool_as_a_client>`."
#~ msgstr ""

#~ msgid ""
#~ "Understanding the details of security is"
#~ " primarily an issue for administrators, "
#~ "but ordinary users should at least "
#~ "skim this section so that they "
#~ "will have an idea of how Tarantool"
#~ " makes it possible for administrators "
#~ "to prevent unauthorized access to the"
#~ " database and to certain functions."
#~ msgstr ""

#~ msgid ""
#~ "Briefly: there is a method to "
#~ "guarantee with password checks that "
#~ "users really are who they say they"
#~ " are (\"authentication\"). There is a "
#~ "_user space where user names and "
#~ "password-hashes are stored. There are "
#~ "functions for saying that certain users"
#~ " are allowed to do certain things "
#~ "(\"privileges\"). There is a _priv space"
#~ " where privileges are stored. Whenever "
#~ "a user tries to do an operation,"
#~ " there is a check whether the "
#~ "user has the privilege to do the"
#~ " operation (\"access control\")."
#~ msgstr ""

#~ msgid ""
#~ "Each user may have a password. The"
#~ " password is any alphanumeric string. "
#~ "Administrators should advise users to "
#~ "choose long unobvious passwords, but it"
#~ " is ultimately up to the users "
#~ "to choose or change their own "
#~ "passwords."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool passwords are stored in the"
#~ " _user space with a `Cryptographic "
#~ "hash function`_ so that, if the "
#~ "password is 'x', the stored hashed-"
#~ "password is a long string like "
#~ "'``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client"
#~ " connects to a Tarantool server, the"
#~ " server sends a random `Salt Value`_"
#~ " which the client must mix with "
#~ "the hashed-password before sending to"
#~ " the server. Thus the original value"
#~ " 'x' is never stored anywhere except"
#~ " in the user's head, and the "
#~ "hashed value is never passed down "
#~ "a network wire except when mixed "
#~ "with a random salt. This system "
#~ "prevents malicious onlookers from finding "
#~ "passwords by snooping in the log "
#~ "files or snooping on the wire. It"
#~ " is the same system that `MySQL "
#~ "introduced several years ago`_ which has"
#~ " proved adequate for medium-security "
#~ "installations. Nevertheless administrators should"
#~ " warn users that no system is "
#~ "foolproof against determined long-term "
#~ "attacks, so passwords should be guarded"
#~ " and changed occasionally."
#~ msgstr ""

#~ msgid ""
#~ "To get the hash-password of a "
#~ "string 'X', say ``box.schema.user.password('X')``."
#~ " To see more about the details "
#~ "of the algorithm for the purpose "
#~ "of writing a new client application, "
#~ "read the `scramble.h`_ header file."
#~ msgstr ""

#~ msgid "Users and the _user space"
#~ msgstr ""

#~ msgid "The fields in the _user space are:"
#~ msgstr ""

#~ msgid "the numeric id of the tuple"
#~ msgstr ""

#~ msgid "the numeric id of the tuple's creator"
#~ msgstr ""

#~ msgid "the user name"
#~ msgstr ""

#~ msgid "the type"
#~ msgstr ""

#~ msgid "optional password"
#~ msgstr ""

#~ msgid ""
#~ "There are four special tuples in "
#~ "the _user space: 'guest', 'admin', "
#~ "'public', and 'replication'."
#~ msgstr ""

#~ msgid ""
#~ "Default when connecting remotely. Usually "
#~ "an untrusted user with few privileges."
#~ msgstr ""

#~ msgid ""
#~ "Default when using ``tarantool`` as a"
#~ " console. Usually an administrative user"
#~ " with all privileges."
#~ msgstr ""

#~ msgid "Not a user in the usual sense. Described later in section `Roles`_."
#~ msgstr ""

#~ msgid ""
#~ "To select a row from the _user "
#~ "space, use ``box.space._user:select``. For "
#~ "example, here is what happens with "
#~ "a select for user id = 0, "
#~ "which is the 'guest' user, which "
#~ "by default has no password:"
#~ msgstr ""

#~ msgid ""
#~ "To change tuples in the _user "
#~ "space, do not use ordinary ``box.space``"
#~ " functions for insert or update or"
#~ " delete - the _user space is "
#~ "special so there are special functions"
#~ " which have appropriate error checking."
#~ msgstr ""

#~ msgid "To create a new user, say:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.user.create(*user-name*)\n"
#~ "box.schema.user.create(*user-name*, {if_not_exists = true})\n"
#~ "box.schema.user.create(*user-name*, {password = *password*})."
#~ msgstr ""

#~ msgid ""
#~ "The :samp:`password={password}` specification is "
#~ "good because in a :ref:`URI <index-"
#~ "uri>` (Uniform Resource Identifier) it "
#~ "is usually illegal to include a "
#~ "user-name without a password."
#~ msgstr ""

#~ msgid "To change the user's password, say:"
#~ msgstr ""

#~ msgid ""
#~ "-- To change the current user's password\n"
#~ "box.schema.user.passwd(*password*)\n"
#~ "\n"
#~ "-- To change a different user's password\n"
#~ "box.schema.user.passwd(*user-name*, *password*)"
#~ msgstr ""

#~ msgid ""
#~ "(Usually it is only the admin user"
#~ " who can change a different user's"
#~ " password.)"
#~ msgstr ""

#~ msgid "To drop a user, say:"
#~ msgstr ""

#~ msgid "box.schema.user.drop(*user-name*)."
#~ msgstr ""

#~ msgid "To check whether a user exists, say:"
#~ msgstr ""

#~ msgid "which returns true or false."
#~ msgstr ""

#~ msgid "To find what privileges a user has, say:"
#~ msgstr ""

#~ msgid ""
#~ "Here is a session which creates a"
#~ " new user with a strong password, "
#~ "selects a tuple in the _user "
#~ "space, and then drops the user."
#~ msgstr ""

#~ msgid "Privileges and the _priv space"
#~ msgstr ""

#~ msgid "The fields in the _priv space are:"
#~ msgstr ""

#~ msgid "the type of object - \"space\" or \"function\" or \"universe\","
#~ msgstr ""

#~ msgid ""
#~ "the type of operation - \"read\" ="
#~ " 1, or \"write\" = 2, or "
#~ "\"execute\" = 4, or a combination "
#~ "such as \"read,write,execute\"."
#~ msgstr ""

#~ msgid "The function for granting a privilege is:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.user.grant(*grantee*, *operation*, *object-"
#~ "type*, *object-name*[, *options*])\n"
#~ "-- OR\n"
#~ "box.schema.user.grant(*grantee*, *operation*, 'universe'"
#~ " [, nil, *options*])"
#~ msgstr ""

#~ msgid ""
#~ "where 'universe' means 'all objects', "
#~ "and the optional grant-option can "
#~ "be:"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`grantor={grantor_name_or_id}` - string or "
#~ "number, for custom grantor"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`if_not_exists=true|false` - bool, do "
#~ "not throw error if user already "
#~ "has the privilege"
#~ msgstr ""

#~ msgid "The function for revoking a privilege is:"
#~ msgstr ""

#~ msgid ""
#~ "box.schema.user.revoke(*grantee*, *operation*, *object-"
#~ "type*, *object-name*[, *options*])\n"
#~ "box.schema.user.revoke(*grantee*, *operation*, "
#~ "'universe'[, nil, *options*])"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`if_not_exists=true|false` - bool, do "
#~ "not throw error if user already "
#~ "lacks the privilege"
#~ msgstr ""

#~ msgid ""
#~ "For example, here is a session "
#~ "where the admin user gave the "
#~ "guest user the privilege to read "
#~ "from a space named ``space55``, and "
#~ "then took the privilege away:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.user.revoke('guest', 'read', "
#~ "'space', 'space55')\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Generally privileges are granted or "
#~ "revoked by the owner of the object"
#~ " (the user who created it), or "
#~ "by the 'admin' user. Before dropping "
#~ "any objects or users, steps should "
#~ "be taken to ensure that all their"
#~ " associated privileges have been revoked."
#~ msgstr ""

#~ msgid ""
#~ "Only the creator of a space can"
#~ " drop, alter, or truncate the space."
#~ " Only the creator of a user can"
#~ " change a different user's password."
#~ msgstr ""

#~ msgid "Functions and the _func space"
#~ msgstr ""

#~ msgid "The fields in the _func space are:"
#~ msgstr ""

#~ msgid "the function name"
#~ msgstr ""

#~ msgid "flag"
#~ msgstr ""

#~ msgid "possibly a language name."
#~ msgstr ""

#~ msgid ""
#~ "The _func space does not include "
#~ "the function's body. One continues to"
#~ " create Lua functions in the usual"
#~ " way, by saying \":samp:`function "
#~ "{function_name} () ... end`\", without "
#~ "adding anything in the _func space. "
#~ "The _func space only exists for "
#~ "storing function tuples so that their"
#~ " names can be used within "
#~ "grant/revoke functions."
#~ msgstr ""

#~ msgid "The function for creating a _func tuple is:"
#~ msgstr ""

#~ msgid "box.schema.func.create(*function-name* [, *options*])"
#~ msgstr ""

#~ msgid ":samp:`if_not_exists = {true|false}` - default = false,"
#~ msgstr ""

#~ msgid ":samp:`setuid = {true|false}` - default = false,"
#~ msgstr ""

#~ msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
#~ msgstr ""

#~ msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
#~ msgstr ""

#~ msgid ""
#~ "Specifying :code:`if_not_exists=false` would cause"
#~ " ``error: Function '...' already exists``"
#~ " if the _func tuple already exists."
#~ msgstr ""

#~ msgid ""
#~ "Specifying :code:`setuid=true` would cause the"
#~ " setuid flag (the fourth field in "
#~ "the _func tuple) to have a value"
#~ " meaning \"true\", and the effect of"
#~ " that is that the function's caller"
#~ " is treated as the function's "
#~ "creator, with full privileges. The "
#~ "setuid behavior does not apply for "
#~ "users who connect via :code:`console.connect`."
#~ msgstr ""

#~ msgid ""
#~ "Specifying :code:`language='C'` would cause "
#~ "the language field (the fifth field "
#~ "in the _func tuple) to have a "
#~ "value 'C', which means the function "
#~ "was written in C. Tarantool functions"
#~ " are normally written in Lua but "
#~ "can be written in C as well."
#~ msgstr ""

#~ msgid "The function for dropping a _func tuple is:"
#~ msgstr ""

#~ msgid "box.schema.func.drop(*function-name*)"
#~ msgstr ""

#~ msgid "The function for checking whether a _func tuple exists is:"
#~ msgstr ""

#~ msgid "box.schema.func.exists(*function-name*)"
#~ msgstr ""

#~ msgid ""
#~ "In the following example, a function "
#~ "named 'f7' is created, then it is"
#~ " put in the _func space, then "
#~ "it is used in a "
#~ "``box.schema.user.grant`` function, then it is"
#~ " dropped:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> function f7()\n"
#~ "         >   box.session.uid()\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.func.create('f7')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.user.grant('guest', 'execute', "
#~ "'function', 'f7')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.user.revoke('guest', 'execute', "
#~ "'function', 'f7')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.schema.func.drop('f7')\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid "box.session and security"
#~ msgstr ""

#~ msgid ""
#~ "After a connection has taken place, "
#~ "the user has access to a "
#~ "\"session\" object which has several "
#~ "functions. The ones which are of "
#~ "interest for security purposes are:"
#~ msgstr ""

#~ msgid ""
#~ "box.session.uid()         -- returns the id of the current user\n"
#~ "box.session.user()        -- returns the name of the current user\n"
#~ "box.session.su(*user-name*) -- allows changing"
#~ " current user to 'user-name'"
#~ msgstr ""

#~ msgid ""
#~ "If a user types requests directly "
#~ "on the Tarantool server in its "
#~ ":ref:`interactive mode <administration-"
#~ "using_tarantool_as_a_client>`, or if a user"
#~ " connects to the :ref:`admin port "
#~ "<administration-admin_ports>`, then the user "
#~ "by default is 'admin' and has many"
#~ " privileges. If a user connects from"
#~ " an application program via one of"
#~ " the :ref:`connectors <index-box_connectors>`,"
#~ " then the user by default is "
#~ "'guest' and has few privileges. "
#~ "Typically an admin user will set "
#~ "up and configure objects, then grant "
#~ "privileges to appropriate non-admin "
#~ "users. Typically a guest user will "
#~ "use ``box.session.su()`` to change into "
#~ "a non-generic user to whom admin"
#~ " has granted more than the default"
#~ " privileges. For example, admin might "
#~ "say:"
#~ msgstr ""

#~ msgid ""
#~ "box.space._user:insert{123456,0,'manager','user'}\n"
#~ "box.schema.user.grant('manager', 'read', 'space', '_space')\n"
#~ "box.schema.user.grant('manager', 'read', 'space', 'payroll')"
#~ msgstr ""

#~ msgid "and later a guest user, who wishes to see the payroll, might say:"
#~ msgstr ""

#~ msgid ""
#~ "box.session.su('manager')\n"
#~ "box.space.payroll:select{'Jones'}"
#~ msgstr ""

#~ msgid ""
#~ "A role is a container for "
#~ "privileges which can be granted to "
#~ "regular users. Instead of granting and"
#~ " revoking individual privileges, one can"
#~ " put all the privileges in a "
#~ "role and then grant or revoke the"
#~ " role. Role information is in the "
#~ "_user space but the third field -"
#~ " the type field - is 'role' "
#~ "rather than 'user'."
#~ msgstr ""

#~ msgid ""
#~ "If a role R1 is granted a "
#~ "privilege X, and user U1 is "
#~ "granted a privilege \"role R1\", then"
#~ " user U1 in effect has privilege "
#~ "X. Then if a role R2 is "
#~ "granted a privilege Y, and role R1"
#~ " is granted a privilege \"role R2\","
#~ " then user U1 in effect has "
#~ "both privilege X and privilege Y. "
#~ "In other words, a user gets all"
#~ " the privileges that are granted to"
#~ " a user's roles, directly or "
#~ "indirectly."
#~ msgstr ""

#~ msgid "Create a new role."
#~ msgstr ""

#~ msgid "Put a privilege in a role."
#~ msgstr ""

#~ msgid "Take a privilege out of a role."
#~ msgstr ""

#~ msgid "Drop a role."
#~ msgstr ""

#~ msgid "Grant a role to a role."
#~ msgstr ""

#~ msgid "Revoke a role from a role."
#~ msgstr ""

#~ msgid ""
#~ "Check whether a role exists. Returns "
#~ "(type = boolean) true if role-name"
#~ " identifies a role, otherwise false."
#~ msgstr ""

#~ msgid "Grant a role to a user."
#~ msgstr ""

#~ msgid "Revoke a role from a user."
#~ msgstr ""

#~ msgid ""
#~ "There are two predefined roles. The "
#~ "first predefined role, named 'public', "
#~ "is automatically assigned to new users"
#~ " when they are created with "
#~ ":samp:`box.schema.user.create({user-name})` - "
#~ "Therefore a convenient way to grant "
#~ "'read' on space 't' to every user"
#~ " that will ever exist is: "
#~ ":code:`box.schema.role.grant('public','read','space','t')`. The"
#~ " second predefined role, named "
#~ "'replication', can be assigned by the"
#~ " 'admin' user to users who need "
#~ "to use replication features."
#~ msgstr ""

#~ msgid "Example showing a role within a role"
#~ msgstr ""

#~ msgid ""
#~ "In this example, a new user named"
#~ " U1 will insert a new tuple "
#~ "into a new space named T, and "
#~ "will succeed even though user U1 "
#~ "has no direct privilege to do such"
#~ " an insert -- that privilege is "
#~ "inherited from role R1, which in "
#~ "turn inherits from role R2."
#~ msgstr ""

#~ msgid ""
#~ "-- This example will work for a"
#~ " user with many privileges, such as"
#~ " 'admin'\n"
#~ "box.schema.space.create('T')\n"
#~ "box.space.T:create_index('primary', {})\n"
#~ "-- Create a user U1 so that "
#~ "later it's possible to say "
#~ "box.session.su('U1')\n"
#~ "box.schema.user.create('U1')\n"
#~ "-- Create two roles, R1 and R2\n"
#~ "box.schema.role.create('R1')\n"
#~ "box.schema.role.create('R2')\n"
#~ "-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
#~ "box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
#~ "box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
#~ "-- Grant read and execute privileges "
#~ "to R2 (but not to R1 and not"
#~ " to U1)\n"
#~ "box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
#~ "box.schema.role.grant('R2', 'execute', 'universe')\n"
#~ "-- Use box.session.su to say \"now become user U1\"\n"
#~ "box.session.su('U1')\n"
#~ "-- Next insert succeeds because U1 in effect has write privilege on T\n"
#~ "box.space.T:insert{1}"
#~ msgstr ""

#~ msgid ""
#~ "*Triggers*, also known as *callbacks*, "
#~ "are functions which the server executes"
#~ " when certain events happen. Currently "
#~ "the main types of triggers are "
#~ ":ref:`connection triggers <triggers-"
#~ "connection_triggers>`, which are executed when"
#~ " a session begins or ends, and "
#~ ":ref:`replace triggers <triggers-replace_triggers>`,"
#~ " which are for database events."
#~ msgstr ""

#~ msgid ""
#~ "They associate a `function` with an "
#~ "`event`. The request to \"define a "
#~ "trigger\" consists of passing the name"
#~ " of the trigger's function to one "
#~ "of the \":samp:`on_{event-name}()`\" "
#~ "functions: :code:`on_connect()`, :code:`on_auth()`, "
#~ ":code:`on_disconnect()`, or :code:`on_replace()`."
#~ msgstr ""

#~ msgid ""
#~ "They are `defined by any user`. "
#~ "There are no privilege requirements for"
#~ " defining triggers."
#~ msgstr ""

#~ msgid ""
#~ "They are called `after` the event. "
#~ "They are not called if the event"
#~ " ends prematurely due to an error."
#~ " (Exception: :code:`on_auth()` is called "
#~ "before the event.)"
#~ msgstr ""

#~ msgid ""
#~ "They are in `server memory`. They "
#~ "are not stored in the database. "
#~ "Triggers disappear when the server is"
#~ " shut down. If there is a "
#~ "requirement to make them permanent, then"
#~ " the function definitions and trigger "
#~ "settings should be part of an "
#~ "initialization script."
#~ msgstr ""

#~ msgid ""
#~ "They have `low overhead`. If a "
#~ "trigger is not defined, then the "
#~ "overhead is minimal: merely a pointer"
#~ " dereference and check. If a trigger"
#~ " is defined, then its overhead is "
#~ "equivalent to the overhead of calling"
#~ " a stored procedure."
#~ msgstr ""

#~ msgid ""
#~ "They can be `multiple` for one "
#~ "event. Triggers are executed in the "
#~ "reverse order that they were defined "
#~ "in."
#~ msgstr ""

#~ msgid ""
#~ "They must work `within the event "
#~ "context`. If the function contains "
#~ "requests which normally could not occur"
#~ " immediately after the event but "
#~ "before the return from the event, "
#~ "effects are undefined. For example, "
#~ "putting ``os.exit()`` or ``box.rollback()`` in"
#~ " a trigger function would be bringing"
#~ " in requests outside the event "
#~ "context."
#~ msgstr ""

#~ msgid ""
#~ "They are `replaceable`. The request to"
#~ " \"redefine a trigger\" consists of "
#~ "passing the names of a new trigger"
#~ " function and an old trigger function"
#~ " to one of the \"on `event-"
#~ "name` ...\" functions."
#~ msgstr ""

#~ msgid "Connection triggers"
#~ msgstr ""

#~ msgid ""
#~ "Define a trigger for execution when "
#~ "a new session is created due to"
#~ " an event such as :ref:`console.connect "
#~ "<console-connect>`. The trigger function "
#~ "will be the first thing executed "
#~ "after a new session is created. If"
#~ " the trigger fails by raising an "
#~ "error, the error is sent to the"
#~ " client and the connection is closed."
#~ msgstr ""

#~ msgid "nil or function list"
#~ msgstr ""

#~ msgid ""
#~ "If the parameters are (nil, old-"
#~ "trigger-function-name), then the old "
#~ "trigger is deleted."
#~ msgstr ""

#~ msgid ""
#~ "If a trigger always results in an"
#~ " error, it may become impossible to"
#~ " connect to the server to reset "
#~ "it."
#~ msgstr ""

#~ msgid ""
#~ "After the following series of requests,"
#~ " the server will write a message "
#~ "using the :ref:`log <log>` module "
#~ "whenever any user connects or "
#~ "disconnects."
#~ msgstr ""

#~ msgid ""
#~ "function log_connect ()\n"
#~ "  local log = require('log')\n"
#~ "  local m = 'Connection. user=' .."
#~ " box.session.user() .. ' id=' .. "
#~ "box.session.id()\n"
#~ "  log.info(m)\n"
#~ "end\n"
#~ "function log_disconnect ()\n"
#~ "  local log = require('log')\n"
#~ "  local m = 'Disconnection. user=' "
#~ ".. box.session.user() .. ' id=' .. "
#~ "box.session.id()\n"
#~ "  log.info(m)\n"
#~ "end\n"
#~ "box.session.on_connect(log_connect)\n"
#~ "box.session.on_disconnect(log_disconnect)"
#~ msgstr ""

#~ msgid "Authentication triggers"
#~ msgstr ""

#~ msgid ""
#~ "The on_auth trigger function is invoked"
#~ " in these circumstances: (1) The "
#~ ":ref:`console.connect <console-connect>` function"
#~ " includes an authentication check for "
#~ "all users except 'guest'; for this "
#~ "case the on_auth trigger function is "
#~ "invoked after the on_connect trigger "
#~ "function, if and only if the "
#~ "connection has succeeded so far. (2) "
#~ "The binary protocol has a separate "
#~ ":ref:`authentication packet <box_protocol-"
#~ "authentication>` -- for this case, "
#~ "connection and authentication are considered"
#~ " to be separate steps."
#~ msgstr ""

#~ msgid ""
#~ "Unlike other trigger types, on_auth "
#~ "trigger functions are invoked `before` "
#~ "the event. Therefore a trigger function"
#~ " like :code:`function auth_function () v"
#~ " = box.session.user(); end` will set "
#~ ":code:`v` to \"guest\", the user name"
#~ " before the authentication is done. "
#~ "To get the user name after the "
#~ "authentication is done, use the special"
#~ " syntax: :code:`function auth_function "
#~ "(user_name) v = user_name; end`"
#~ msgstr ""

#~ msgid "Replace triggers"
#~ msgstr ""

#~ msgid ""
#~ "Create a \"``replace trigger``\". The "
#~ "``function-name`` will be executed whenever"
#~ " a ``replace()`` or ``insert()`` or "
#~ "``update()`` or ``upsert()`` or ``delete()``"
#~ " happens to a tuple in ``<space-"
#~ "name>``."
#~ msgstr ""

#~ msgid "tarantool> box.space.X:run_triggers(false)"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('space53')\n"
#~ "tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
#~ "tarantool> function replace_trigger()\n"
#~ "         >   replace_counter = replace_counter + 1\n"
#~ "         > end\n"
#~ "tarantool> s:on_replace(replace_trigger)\n"
#~ "tarantool> replace_counter = 0\n"
#~ "tarantool> t = s:insert{1, 'First replace'}\n"
#~ "tarantool> t = s:insert{2, 'Second replace'}\n"
#~ "tarantool> s:drop()\n"
#~ "tarantool> replace_counter"
#~ msgstr ""

#~ msgid "Another example"
#~ msgstr ""
#~ "#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
#~ "Например:"

#~ msgid "Getting a list of triggers"
#~ msgstr ""

#~ msgid "You can use:"
#~ msgstr ""

#~ msgid ""
#~ ":code:`on_connect()` -- with no arguments "
#~ "-- to return a table of all "
#~ "connect-trigger functions;"
#~ msgstr ""

#~ msgid ":code:`on_auth()` to return all authentication-trigger functions;"
#~ msgstr ""

#~ msgid ":code:`on_disconnect()` to return all disconnect-trigger functions;"
#~ msgstr ""

#~ msgid ":code:`on_replace()` to return all replace-trigger functions."
#~ msgstr ""

#~ msgid ""
#~ "In the following example, we find "
#~ "that there are three functions "
#~ "associated with :code:`on_connect` triggers, "
#~ "and execute the third function, which"
#~ " happens to contain the line "
#~ "\"print('function #3')\". Then we delete "
#~ "the third trigger."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.session.on_connect()\n"
#~ "---\n"
#~ "- - 'function: 0x416ab6f8'\n"
#~ "  - 'function: 0x416ab6f8'\n"
#~ "  - 'function: 0x416ad800'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> box.session.on_connect()[3]()\n"
#~ "function #3\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "For TREE or HASH indexes, the "
#~ "maximum is 255 (``box.schema.INDEX_PART_MAX``). "
#~ "For RTREE indexes, the maximum is "
#~ "1 but the field is an ARRAY. "
#~ "For BITSET indexes, the maximum is "
#~ "1."
#~ msgstr ""

#~ msgid ""
#~ "The theoretical maximum is 2147483647 "
#~ "(``box.schema.FIELD_MAX``). The practical maximum"
#~ " is whatever is specified by the "
#~ "space's :ref:`field_count <box_space-field_count>`"
#~ " member, or the maximum tuple length."
#~ msgstr ""

#~ msgid ""
#~ "By default the value of "
#~ ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal>`"
#~ " is 1048576, and the maximum tuple"
#~ " length is approximately one quarter "
#~ "of that: approximately 262,000 bytes. To"
#~ " increase it, when starting the "
#~ "server, specify a larger value. For "
#~ "example :code:`box.cfg{slab_alloc_maximal=2*1048576}`."
#~ msgstr ""

#~ msgid "**Number of replicas in a cluster**"
#~ msgstr ""

#~ msgid ""
#~ "For additional limitations which apply "
#~ "only to the vinyl storage engine, "
#~ "see section :ref:`Differences between memtx"
#~ " and vinyl <vinyl_diff>`."
#~ msgstr ""

#~ msgid ""
#~ "A storage engine is a set of "
#~ "very-low-level routines which actually"
#~ " store and retrieve tuple values. "
#~ "Tarantool offers a choice of two "
#~ "storage engines:"
#~ msgstr ""

#~ msgid ""
#~ "memtx (the in-memory storage engine) "
#~ "is the default and was the first"
#~ " to arrive."
#~ msgstr ""

#~ msgid ""
#~ "vinyl (the on-disk storage engine) "
#~ "is a working key-value engine and"
#~ " will especially appeal to users who"
#~ " like to see data go directly "
#~ "to disk, so that recovery time "
#~ "might be shorter and database size "
#~ "might be larger. On the other "
#~ "hand, vinyl lacks some functions and "
#~ "options that are available with memtx."
#~ " Where that is the case, the "
#~ "relevant description in this manual will"
#~ " contain a note beginning with the"
#~ " words \"Note re storage engine\". "
#~ "See also a coverage for all "
#~ ":ref:`the differences between memtx and "
#~ "vinyl <vinyl_diff>` further on this "
#~ "page."
#~ msgstr ""

#~ msgid ""
#~ "To specify that the engine should "
#~ "be vinyl, add the clause ``engine "
#~ "= 'vinyl'`` when creating a space, "
#~ "for example: ``space = "
#~ "box.schema.space.create('name', {engine='vinyl'})``."
#~ msgstr ""

#~ msgid "Differences between memtx and vinyl storage engines"
#~ msgstr "Различия между движками memtx и vinyl"

#~ msgid ""
#~ "The primary difference between memtx and"
#~ " vinyl is that memtx is an "
#~ "\"in-memory\" engine while vinyl is "
#~ "an \"on-disk\" engine. An in-"
#~ "memory storage engine is generally "
#~ "faster, and the memtx engine is "
#~ "justifiably the default for Tarantool, "
#~ "but there are two situations where "
#~ "an on-disk engine such as vinyl"
#~ " would be preferable:"
#~ msgstr ""

#~ msgid ""
#~ "when the database is larger than "
#~ "the available memory and adding more "
#~ "memory is not a realistic option;"
#~ msgstr ""

#~ msgid ""
#~ "when the server frequently goes down "
#~ "due to errors or a simple desire"
#~ " to save power -- bringing the "
#~ "server back up and restoring a "
#~ "memtx database into memory takes time."
#~ msgstr ""

#~ msgid ""
#~ "Here are behavior differences which "
#~ "affect programmers. All of these "
#~ "differences have been noted elsewhere in"
#~ " sentences that begin with the words"
#~ " \"Note re storage engine: vinyl\"."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, the index type can be"
#~ " TREE or HASH or RTREE or "
#~ "BITSET. |br| With vinyl, the only "
#~ "index type is TREE."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, :ref:`create_index <box_space-"
#~ "create_index>` can be done at any "
#~ "time. |br| With vinyl, secondary indexes"
#~ " must be created before tuples are"
#~ " inserted."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, for index searches, ``nil``"
#~ " may be allowed within a search "
#~ "key. |br| With vinyl, ``nil`` is "
#~ "only allowed at the end of a "
#~ "search key."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, temporary spaces are "
#~ "supported. |br| With vinyl, they are "
#~ "not."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, the :ref:`alter() <box_index-"
#~ "alter>` and :ref:`len() <box_space-len>` "
#~ "and :ref:`random() <box_index-random>` "
#~ "functions are supported. |br| With "
#~ "vinyl, they are not."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, the :ref:`count() <box_index-"
#~ "count>` function takes a constant amount"
#~ " of time. |br| With vinyl, it "
#~ "takes a variable amount of time "
#~ "depending on index size."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, delete will return deleted"
#~ " tuple, if any. |br| With vinyl, "
#~ "delete will always return nil."
#~ msgstr ""

#~ msgid ""
#~ "It was explained :ref:`earlier <index-"
#~ "yields_must_happen>` that memtx does not "
#~ "\"yield\" on a select request, it "
#~ "yields only on data-change requests. "
#~ "However, vinyl does yield on a "
#~ "select request, or on an equivalent "
#~ "such as ``get()`` or ``pairs()``. This"
#~ " has significance for :ref:`cooperative "
#~ "multitasking <atomic-cooperative_multitasking>`."
#~ msgstr ""

#~ msgid "Vinyl features"
#~ msgstr ""

#~ msgid "Full ACID compliance"
#~ msgstr ""

#~ msgid "Multi-Version Concurrency Control (MVCC)"
#~ msgstr ""

#~ msgid "Pure Append-Only"
#~ msgstr ""

#~ msgid "Multi-threaded (Client access and Engine scalability)"
#~ msgstr ""

#~ msgid "Multi-databases support (Single environment and WAL)"
#~ msgstr ""

#~ msgid ""
#~ "Multi-Statement and Single-Statement "
#~ "Transactions (Snapshot Isolation (SI), "
#~ "multi-databases)"
#~ msgstr ""

#~ msgid ""
#~ "Asynchronous or synchronous transaction "
#~ "execution (Callback triggered versus blocking)"
#~ msgstr ""

#~ msgid ""
#~ "Separate storage formats: key-value "
#~ "(Default), or document (Keys are part"
#~ " of value)"
#~ msgstr ""

#~ msgid "Update without read"
#~ msgstr ""

#~ msgid "Consistent Cursors"
#~ msgstr ""

#~ msgid "Prefix search"
#~ msgstr ""

#~ msgid "Point-in-Time Snapshots"
#~ msgstr ""

#~ msgid "Versional database creation and asynchronous shutdown/drop"
#~ msgstr ""

#~ msgid "Asynchronous Online/Hot Backup"
#~ msgstr ""

#~ msgid "Compression (Per region, both lz4 and zstd are supported)"
#~ msgstr ""

#~ msgid "Metadata Compression (By default)"
#~ msgstr ""

#~ msgid "Key Compression (Compress key duplicates, including suffixes)"
#~ msgstr ""

#~ msgid "Easy to use (Minimalist API)"
#~ msgstr ""

#~ msgid "Easy to integrate (Native support of using as storage engine)"
#~ msgstr ""

#~ msgid ""
#~ "Easy to write bindings (Very FFI-"
#~ "friendly, API designed to be stable "
#~ "in future)"
#~ msgstr ""

#~ msgid "Easy to build in (Amalgamated, compiles into two C files)"
#~ msgstr ""

#~ msgid "Event loop friendly"
#~ msgstr ""

#~ msgid "Zero-Configuration (Tuned by default)"
#~ msgstr ""

#~ msgid "Implemented as a small library **written in C** with zero dependencies"
#~ msgstr ""

#~ msgid "BSD Licensed"
#~ msgstr ""

#~ msgid ""
#~ "It is appropriate for databases that "
#~ "cannot fit in memory, where access "
#~ "via secondary keys is not required."
#~ msgstr ""

#~ msgid "In vinyl terminology:"
#~ msgstr ""

#~ msgid "There is one **Environment**."
#~ msgstr ""

#~ msgid ""
#~ "An Environment has N **Databases** - "
#~ "a vinyl database is like a "
#~ "Tarantool `space`."
#~ msgstr ""

#~ msgid "A Database has N **Ranges**."
#~ msgstr ""

#~ msgid "A Range has one **Range File**."
#~ msgstr ""

#~ msgid "A Range File has N **Runs**."
#~ msgstr ""

#~ msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
#~ msgstr ""

#~ msgid ""
#~ "A Region has **keys** and **values** "
#~ "- a vinyl key-value is like "
#~ "a Tarantool `tuple`."
#~ msgstr ""

#~ msgid ""
#~ "A key and its associated value are"
#~ " together, so when one accesses a "
#~ "key one gets the whole tuple. In"
#~ " other words, in vinyl the data "
#~ "is stored in the index. There are"
#~ " up to two in-memory copies of"
#~ " an index, as well as the copy"
#~ " in the Range File."
#~ msgstr ""

#~ msgid ""
#~ "For operations that insert or update "
#~ "tuples - called Set operations in "
#~ "vinyl - vinyl makes changes to "
#~ "in-memory copies of the index, and"
#~ " writes to Tarantool's Write-ahead "
#~ "Log. A scheduler assigns tasks to "
#~ "multiple background threads for transferring"
#~ " index data from memory to disk, "
#~ "and for reorganizing Runs. To support"
#~ " transactions, Set operations can be "
#~ "delayed until an explicit commit. If "
#~ "multiple users access the same tuples"
#~ " simultaneously, the concurrency control "
#~ "method is `MVCC`_ and the isolation "
#~ "level is `Snapshot`_."
#~ msgstr ""

#~ msgid ""
#~ "Formally, in terms of disk accesses, "
#~ "vinyl has the following algorithmic "
#~ "complexity:"
#~ msgstr ""

#~ msgid ""
#~ "**Set** - the worst case is O(*1*)"
#~ " append-only key writes to the "
#~ "Write-Ahead Log + in-memory Range "
#~ "index searches + in-memory index "
#~ "inserts"
#~ msgstr ""

#~ msgid ""
#~ "**Delete** - the worst case is "
#~ "O(*1*) key writes and in-memory "
#~ "index inserts (the same as **Set**)"
#~ msgstr ""

#~ msgid ""
#~ "**Get** - the worst case is "
#~ "`amortized`_ O(*max\\_run\\_count\\_per\\_node*) random"
#~ " Region reads from a single Range "
#~ "file, which itself does in-memory "
#~ "index search + in-memory Region "
#~ "search"
#~ msgstr ""

#~ msgid ""
#~ "**Range** - queries, the worst case "
#~ "of full Database scan is amortized "
#~ "O(*total\\_Region\\_count*) + in-memory "
#~ "key-index searches for each Range"
#~ msgstr ""

#~ msgid "Under the hood"
#~ msgstr "А что там \"под капотом\"?"

#~ msgid "In this section, to illustrate internals, we will discuss this example:"
#~ msgstr ""

#~ msgid ""
#~ "filling an empty database with one "
#~ "million tuples (we'll call them \"keys\""
#~ " to emphasize the indexed nature)"
#~ msgstr ""

#~ msgid "reading all stored tuples in the original order."
#~ msgstr ""

#~ msgid "Inserting the first 200.000 keys"
#~ msgstr ""

#~ msgid ""
#~ "During the first 200,000 Set operations,"
#~ " inserted keys first go to the "
#~ "in-memory index. To maintain persistence,"
#~ " information about each Set operation "
#~ "is written to Tarantool's Write-ahead"
#~ " Log."
#~ msgstr ""

#~ msgid ""
#~ "At this point, we have keys in "
#~ "an in-memory index and records in"
#~ " the Write-ahead Log."
#~ msgstr ""

#~ msgid "Inserting the next 300.000 keys"
#~ msgstr ""

#~ msgid ""
#~ "As the in-memory index becomes too"
#~ " large for available memory, the "
#~ "index must be copied from memory "
#~ "to disk. The on-disk copy of "
#~ "the in-memory index is called a"
#~ " Run. To save the Run, a new"
#~ " file is created, the Range File. "
#~ "We will call it **db file** for"
#~ " this example."
#~ msgstr ""

#~ msgid ""
#~ "The scheduler wakes a worker thread "
#~ "in the background, a Run Creation "
#~ "Thread. The thread creates a second "
#~ "in-memory index. If there are Set"
#~ " operations taking place while the "
#~ "thread is working, their contention "
#~ "effect will be small because they "
#~ "will operate on the second in-"
#~ "memory index."
#~ msgstr ""

#~ msgid ""
#~ "When the Run Creation Thread finishes"
#~ " the task, the first in-memory "
#~ "index is freed."
#~ msgstr ""

#~ msgid "Inserting the next 200.000 keys"
#~ msgstr ""

#~ msgid ""
#~ "Several times, the in-memory index "
#~ "becomes too large and a Run "
#~ "Creation Thread transfers the keys to"
#~ " a Run. The Runs have been "
#~ "appended to the end of db file."
#~ " The number of created Runs becomes"
#~ " large."
#~ msgstr ""

#~ msgid ""
#~ "There is a user-settable maximum "
#~ "number of Runs per Range. When the"
#~ " number of Runs reaches this maximum,"
#~ " the vinyl scheduler wakes a "
#~ "**Compaction Thread** for the db file."
#~ " The Compaction Thread merges the "
#~ "keys in all the Runs, and creates"
#~ " one or more new db files."
#~ msgstr ""

#~ msgid ""
#~ "Now there are multiple pairs of "
#~ "in-memory indexes, and each pair has"
#~ " an associated db file. The "
#~ "combination of the in-memory indexes "
#~ "and the db file is called a "
#~ "**Range**, and the db file is "
#~ "called a **Range File**."
#~ msgstr ""

#~ msgid ""
#~ "Thus the contents of a Range are:"
#~ " a range of sorted key values, "
#~ "stored in Runs of a Range File "
#~ "and (when necessary) in memory. Since"
#~ " the ranges do not overlap, each "
#~ "Range can be handled independently. "
#~ "Therefore, while one of the background"
#~ " threads is working on Range 1, "
#~ "another background thread can be working"
#~ " on Range 2, without contention. That"
#~ " means that all the background "
#~ "operations (Run Creation, Compaction, Garbage"
#~ " Collection, and Backup) can take "
#~ "place in parallel on multiple threads."
#~ msgstr ""

#~ msgid "The foregoing explanation will now be repeated with different wording."
#~ msgstr ""

#~ msgid ""
#~ "Before the Compaction there was one "
#~ "Range, which was created automatically "
#~ "when the Database was initialized. The"
#~ " Range had:"
#~ msgstr ""

#~ msgid "an in-memory index with some keys in it,"
#~ msgstr ""

#~ msgid "a Range File with several Runs,"
#~ msgstr ""

#~ msgid ""
#~ "a Write-Ahead Log file recording "
#~ "the Set operations, in the order "
#~ "they happened."
#~ msgstr ""

#~ msgid ""
#~ "The number of Runs became too big,"
#~ " so the vinyl scheduler starts the"
#~ " Compaction Thread and creates two "
#~ "new Ranges."
#~ msgstr ""

#~ msgid ""
#~ "So, each of the two new Range "
#~ "Files contains half of the keys "
#~ "that were in the original Range. "
#~ "The Range's in-memory indexes are "
#~ "split in the same way."
#~ msgstr ""

#~ msgid ""
#~ "After the splitting, vinyl must take "
#~ "into account that: while the Compaction"
#~ " was going on in the background, "
#~ "there might have been more Set "
#~ "operations taking place in parallel. "
#~ "These Set operations would have changed"
#~ " one of the in-memory indexes, "
#~ "and these changes too will be "
#~ "merged."
#~ msgstr ""

#~ msgid ""
#~ "When the Compaction Thread finishes, the"
#~ " original Range is deleted, and "
#~ "information about the new Ranges is "
#~ "inserted into an in-memory **Range "
#~ "Index**."
#~ msgstr ""

#~ msgid ""
#~ "This Range Index is used for all"
#~ " Set operations and all searches. "
#~ "Since the Range Index has the "
#~ "minimum and maximum key values that "
#~ "are in each Range, it is "
#~ "straightforward to scan it to find "
#~ "what Range would contain a particular"
#~ " key value."
#~ msgstr ""

#~ msgid "Inserting the last 300.000 keys"
#~ msgstr ""

#~ msgid ""
#~ "The final 300,000 Set operations take"
#~ " place; the background threads continue "
#~ "to create new Runs and do more "
#~ "Compactions. After the millionth insertion,"
#~ " the Database has four Ranges."
#~ msgstr ""

#~ msgid ""
#~ "The inserting is done. Now, because "
#~ "the words \"memory\" and \"disk\" have"
#~ " appeared in this explanation several "
#~ "times, here are a few words about"
#~ " how vinyl is designed to use "
#~ "these resources most efficiently:"
#~ msgstr ""

#~ msgid ""
#~ "If there is more memory available, "
#~ "then Run Creation and Compaction will"
#~ " be less frequent, and there will "
#~ "be fewer disk accesses."
#~ msgstr ""

#~ msgid ""
#~ "The best vinyl performance will occur"
#~ " if there is no setting of a"
#~ " memory limit, but this must be "
#~ "balanced against other considerations, such"
#~ " as requirements for the memtx "
#~ "storage engine. If there is a "
#~ "setting of a memory limit, the "
#~ "vinyl scheduler will give priority to"
#~ " the Ranges that have the largest "
#~ "in-memory indexes, so that the "
#~ "largest memory blocks are freed first."
#~ msgstr ""

#~ msgid ""
#~ "To make the most of hard drives"
#~ " and Flash, vinyl will delay "
#~ "operations that require disk access "
#~ "(except the writing of the Write-"
#~ "ahead Log which is specially tunable),"
#~ " so that the accesses are done "
#~ "in large sequential blocks."
#~ msgstr ""

#~ msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
#~ msgstr ""

#~ msgid "Reading million keys"
#~ msgstr ""

#~ msgid ""
#~ "We will now start to read the "
#~ "million rows in the order that "
#~ "they were inserted, which was random."
#~ msgstr ""

#~ msgid ""
#~ "During the Get (search), vinyl first "
#~ "finds the correct Range by looking "
#~ "in the Range Index. Then it "
#~ "searches the Range's first in-memory "
#~ "index, and/or the Range's second in-"
#~ "memory index, and/or each Run of "
#~ "the Range, starting from the end "
#~ "of the Range File."
#~ msgstr ""

#~ msgid ""
#~ "Remember that a Run is divided "
#~ "into Regions, which are like what "
#~ "would be called \"pages\" or \"blocks\""
#~ " in a B-tree. For each Run, "
#~ "there is a list of the Regions "
#~ "and their minimum/maximum key values -"
#~ " the Region Index - as well as"
#~ " some metadata."
#~ msgstr ""

#~ msgid ""
#~ "Region Indexes are loaded into memory"
#~ " when the Database is opened. Since"
#~ " the Database's Range Index and the"
#~ " Region Indexes are normally in-"
#~ "memory, searching and retrieving a tuple"
#~ " might require only zero or one "
#~ "disk accesses. However, when memory is"
#~ " limited and there are many Runs, "
#~ "search time may rise. For each "
#~ "additional Run there is a possible "
#~ "additional disk access during a search."
#~ " Also, it is impossible to maintain"
#~ " memory limits without doing a Run"
#~ " Creation process, because new Set "
#~ "operations might occur more quickly than"
#~ " the Compaction process can run."
#~ msgstr ""

#~ msgid ""
#~ "Vinyl is read optimized. It is "
#~ "very likely that the most recently "
#~ "created Runs (hot data) will be in"
#~ " the file system cache. The scheduler"
#~ " will give priority to the Ranges "
#~ "which have the largest in-memory "
#~ "indexes and the most Runs."
#~ msgstr ""

#~ msgid ""
#~ "The scheduler may also try to "
#~ "arrange that a Range will have "
#~ "only one Run, which will ensure "
#~ "the average number of disk seeks "
#~ "for each search is O(*1*)."
#~ msgstr ""

#~ msgid ""
#~ "This chapter has examples that show "
#~ "how to connect to the Tarantool "
#~ "server via the Perl, PHP, Python, "
#~ "node.js, and C connectors. The examples"
#~ " contain hard code that will work "
#~ "if and only if the following "
#~ "conditions are met:"
#~ msgstr ""

#~ msgid ""
#~ "Here is a complete PHP program "
#~ "that inserts ``[99999,'BB']`` into a "
#~ "space named ``examples`` via the PHP "
#~ "API. Before trying to run, check "
#~ "that the server is listening at "
#~ "``localhost:3301`` and that the space "
#~ "``examples`` exists, as :ref:`described "
#~ "earlier <index-connector_setting>`. To run,"
#~ " paste the code into a file "
#~ "named :file:`example.php` and say ``php "
#~ "-d extension=~/tarantool-php/modules/tarantool.so "
#~ "example.php``. The program will open a"
#~ " socket connection with the Tarantool "
#~ "server at ``localhost:3301``, then send "
#~ "an INSERT request, then — if all"
#~ " is well — print \"Insert "
#~ "succeeded\". If the tuple already "
#~ "exists, the program will print "
#~ "“Duplicate key exists in unique index"
#~ " 'primary' in space 'examples'”."
#~ msgstr ""

#~ msgid "node.js"
#~ msgstr ""

#~ msgid "$ npm install tarantool-driver --global"
#~ msgstr ""

#~ msgid ""
#~ "Here is a complete node.js program "
#~ "that inserts ``[99999,'BB']`` into "
#~ "``space[999]`` via the node.js API. "
#~ "Before trying to run, check that "
#~ "the server is listening at "
#~ "``localhost:3301`` and that the space "
#~ "``examples`` exists, as :ref:`described "
#~ "earlier <index-connector_setting>`. To run,"
#~ " paste the code into a file "
#~ "named :file:`example.rs` and say :samp:`node"
#~ " example.rs`. The program will connect "
#~ "using an application-specific definition "
#~ "of the space. The program will "
#~ "open a socket connection with the "
#~ "Tarantool server at ``localhost:3301``, then"
#~ " send an INSERT request, then — "
#~ "if all is well — end after "
#~ "saying \"Insert succeeded\". If Tarantool "
#~ "is not running on ``localhost`` with "
#~ "listen port = 3301, the program "
#~ "will print “Connect failed”. If user "
#~ "``guest`` does not have authorization to"
#~ " connect, the program will print "
#~ "\"Auth failed\". If the insert request"
#~ " fails for any reason, for example"
#~ " because the tuple already exists, "
#~ "the program will print \"Insert "
#~ "failed\"."
#~ msgstr ""

#~ msgid ""
#~ "var TarantoolConnection = require('tarantool-driver');\n"
#~ "var conn = new TarantoolConnection({port: 3301});\n"
#~ "var insertTuple = [99999, \"BB\"];\n"
#~ "conn.connect().then(function(){\n"
#~ "    conn.auth(\"guest\", \"\").then(function(){\n"
#~ "        conn.insert(999, insertTuple).then(function(){\n"
#~ "            console.log(\"Insert succeeded\");\n"
#~ "            process.exit(0);\n"
#~ "    }, function(e){ console.log(\"Insert "
#~ "failed\"); process.exit(1); });\n"
#~ "    }, function(e){ console.log(\"Auth "
#~ "failed\"); process.exit(1); });\n"
#~ "    }, function(e){ console.log(\"Connect "
#~ "failed\"); process.exit(1); });"
#~ msgstr ""

#~ msgid ""
#~ "The example program only shows one "
#~ "request and does not show all "
#~ "that's necessary for good practice. For"
#~ " that, please see `The node.js driver"
#~ " repository <https://github.com/KlonD90/node-"
#~ "tarantool-driver>`_."
#~ msgstr ""

#~ msgid "Q: |br| A: |br|"
#~ msgstr "Вопрос: |br| Ответ: |br|"

#~ msgid ""
#~ "Why Tarantool? |br| Tarantool is the "
#~ "latest generation of a family of "
#~ "in-memory data servers developed for "
#~ "web applications. It is the result "
#~ "of practical experience and trials "
#~ "within Mail.Ru since development began "
#~ "in 2008."
#~ msgstr ""
#~ "Почему Tarantool? |br| Tarantool — это"
#~ " in-memory сервер баз данных "
#~ "последнего поколения, предназначенный для "
#~ "работы с веб-приложениями. Разработка ведется"
#~ " с учетом многолетнего опыта использования"
#~ " Tarantool'а в стенах Mail.Ru. Первый "
#~ "релиз состоялся в 2008 году."

#~ msgid ""
#~ "What's the key advantage of Tarantool?"
#~ " |br| Tarantool provides a rich "
#~ "database feature set (HASH, TREE, RTREE,"
#~ " BITSET indexes, secondary indexes, "
#~ "composite indexes, transactions, triggers, "
#~ "asynchronous replication) in a flexible "
#~ "environment of a Lua interpreter. |br|"
#~ " These two properties make it "
#~ "possible to be a fast, atomic and"
#~ " reliable in-memory data server which"
#~ " handles non-trivial application-specific"
#~ " logic. The advantage over traditional "
#~ "SQL servers is in performance: low-"
#~ "overhead, lock-free architecture means "
#~ "Tarantool can serve an order of "
#~ "magnitude more requests per second, on"
#~ " comparable hardware. The advantage over"
#~ " NoSQL alternatives is in flexibility: "
#~ "Lua allows flexible processing of data"
#~ " stored in a compact, denormalized "
#~ "format."
#~ msgstr ""
#~ "В чем состоит главное преимущество "
#~ "Tarantool'а? |br| Tarantool предоставляет "
#~ "богатый набор функций по работе с "
#~ "базами данных (HASH, TREE, RTREE, "
#~ "BitSet-индексы, вторичные индексы, составные "
#~ "индексы, транзакции, триггеры, асинхронная "
#~ "репликация), и всё это — в гибкой"
#~ " среде Lua-интерпретатора. |br| Эти два "
#~ "обстоятельства делают Tarantool быстрым и "
#~ "надежным in-memory сервером баз данных"
#~ " с атомарными операциями и сложной "
#~ "логикой на стороне сервера. Преимуществом "
#~ "Tarantool'а по сравнению с традиционными "
#~ "SQL СУБД является его высокая "
#~ "производительность: низкие накладные расходы и"
#~ " безблокировочная архитектура позволяют "
#~ "Tarantool'у обрабатывать на порядок больше "
#~ "запросов в секунду на аналогичном "
#~ "оборудовании. Преимущество же перед другими"
#~ " NoSQL СУБД заключается в большей "
#~ "гибкости Tarantool'а: язык Lua позволяет "
#~ "гибко обрабатывать данные, хранящиеся в "
#~ "компактном, ненормализованном формате."

#~ msgid ""
#~ "What are your development plans? |br|"
#~ " We continuously improve server "
#~ "performance. On the feature front, "
#~ "automatic sharding and synchronous "
#~ "replication, and a subset of SQL "
#~ "are the major goals for 2016-2018. "
#~ "We have an open roadmap to which"
#~ " we encourage anyone to add feature"
#~ " requests."
#~ msgstr ""
#~ "Каковы ваши планы по развитию? |br| "
#~ "Мы постоянно улучшаем производительность "
#~ "серверной части. Наши главные цели на"
#~ " 2016-2018 год — это автоматический "
#~ "шардинг и синхронная репликация, а также"
#~ " частичная поддержка SQL. План работ "
#~ "находится в открытом доступе, и все "
#~ "желающие могут оставлять запросы на "
#~ "добавление функционала."

#~ msgid ""
#~ "How serious is Mail.Ru about Tarantool?"
#~ " |br| Tarantool is an open source "
#~ "project, distributed under a BSD "
#~ "license, so it does not depend on"
#~ " any one sponsor. However, it is "
#~ "an integral part of the Mail.Ru "
#~ "backbone, so it gets a lot of "
#~ "support from Mail.Ru."
#~ msgstr ""
#~ "Насколько серьезны планы Mail.Ru в "
#~ "отношении Tarantool'а? |br| Tarantool — "
#~ "это проект с открытым кодом, "
#~ "распространяемый под лицензией BSD, поэтому"
#~ " он не зависит от внешних спонсоров."
#~ " В то же время, Tarantool — это"
#~ " часть технологического \"костяка\" Mail.Ru, "
#~ "и поэтому он пользуется сильной "
#~ "поддержкой со стороны Mail.Ru."

#~ msgid ""
#~ "To get started, you can either "
#~ "*download the whole Tarantool package* "
#~ "as described in the first part of"
#~ " :ref:`Chapter 2 \"Getting Started\" "
#~ "<user_guide_getting_started>`, or you can skip"
#~ " the download and *connect to the "
#~ "online Tarantool server* running on the"
#~ " web at http://try.tarantool.org. Either "
#~ "way, as the first tryout, you can"
#~ " follow the introductory example \"Starting"
#~ " Tarantool and making your first "
#~ "database\" from :ref:`the second part of"
#~ " Chapter 2 <user_guide_getting_started-"
#~ "first_database>`. If you want more "
#~ "hands-on experience, proceed to the "
#~ ":ref:`\"Tutorials\" <tutorials>` part after "
#~ "you are through with Chapter 2."
#~ msgstr ""
#~ "Знакомство с Tarantool'ом вы можете "
#~ "начать с того, что скачаете готовый "
#~ "установочный пакет (как описано в начале"
#~ " :ref:`главы 2 \"Начало работы\" "
#~ "<user_guide_getting_started>`) или воспользуетесь "
#~ "нашим онлайн-стендом на http://try.tarantool.org."
#~ " В любом случае для первого "
#~ "знакомства вы можете выполнить тренировочный"
#~ " пример \"Первичный запуск Tarantool'а и"
#~ " создание базы данных\" из второй "
#~ "части главы 2. После этого вы "
#~ "можете заглянуть в наш :ref:`\"Практикум\" "
#~ "<tutorials>`, где содержится еще больше "
#~ "практических заданий."

#~ msgid ""
#~ "This chapter shows how to download, "
#~ "how to install, and how to start"
#~ " Tarantool for the first time."
#~ msgstr ""
#~ "В этой главе рассказывается, как "
#~ "скачать, установить и начать работать с"
#~ " Tarantool'ом с нуля."

#~ msgid ""
#~ "For production, if possible, you should"
#~ " download a binary (executable) package."
#~ " This will ensure that you have "
#~ "the same build of the same version"
#~ " that the developers have. That makes"
#~ " analysis easier if later you need"
#~ " to report a problem, and avoids "
#~ "subtle problems that might happen if "
#~ "you used different tools or different"
#~ " parameters when building from source. "
#~ "The section about binaries is \":ref"
#~ ":`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`\"."
#~ msgstr ""
#~ "Для промышленной эксплуатации рекомендуется "
#~ "скачать бинарный (исполняемый) пакет. Тогда"
#~ " вы гарантированно получите сборку той "
#~ "же версии, что и у разработчиков. "
#~ "Это существенно упростит поиск ошибок, "
#~ "если вам в будущем понадобится помощь,"
#~ " а также позволит избежать проблем "
#~ "из-за того, что вы использовали "
#~ "инструменты или параметры отличные от "
#~ "тех, что использовали при сборке сами"
#~ " разработчики. См. раздел “:ref"
#~ ":`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`”."

#~ msgid ""
#~ "For development, you will want to "
#~ "download a source package and make "
#~ "the binary by yourself using a "
#~ "C/C++ compiler and common tools. "
#~ "Although this is a bit harder, it"
#~ " gives more control. And the source"
#~ " packages include additional files, for "
#~ "example the Tarantool test suite. The"
#~ " section about source is \":ref:`Building"
#~ " from source <building_from_source>`\" in "
#~ ":ref:`Contributor's Guide <contrib_guide>`."
#~ msgstr ""
#~ "Для разработческих целей вы можете "
#~ "скачать исходные файлы и собрать "
#~ "бинарный пакет самостоятельно с помощью "
#~ "компилятора C/C++ и обычных инструментов "
#~ "для сборки. Хотя это и более "
#~ "трудный способ получить бинарный пакет, "
#~ "но он дает вам больший контроль "
#~ "над результатом. Также в состав исходных"
#~ " файлов входят дополнительные пакеты, "
#~ "например набор тестов для Tarantool'а. "
#~ "См. раздел \":ref:`Сборка из исходных "
#~ "файлов <building_from_source>`\" в "
#~ "\":ref:`Руководстве участника проекта "
#~ "<contrib_guide>`\"."

#~ msgid ""
#~ "If the installation has already been "
#~ "done, then you should try it out."
#~ " So we've provided some instructions "
#~ "that you can use to make a "
#~ "temporary “sandbox”. In a few minutes"
#~ " you can start the server and "
#~ "type in some database-manipulation "
#~ "statements. The section about the "
#~ "sandbox is \":ref:`user_guide_getting_started-"
#~ "first_database`\"."
#~ msgstr ""
#~ "После установки вы можете сразу "
#~ "опробовать Tarantool в действии. Ниже вы"
#~ " найдете инструкции по созданию безопасной"
#~ " тестовой среды. Всего за несколько "
#~ "минут вы сможете запустить Tarantool-сервер"
#~ " и задать несколько инструкций по "
#~ "манипулированию данными. См. раздел \":ref"
#~ ":`user_guide_getting_started-first_database`”."

#~ msgid ""
#~ "Binary packages for two Tarantool "
#~ "versions -- for the stable 1.6 and"
#~ " the latest 1.7 -- are provided "
#~ "at http://tarantool.org/download.html. An automatic"
#~ " build system creates, tests and "
#~ "publishes packages for every push into"
#~ " the 1.7 branch."
#~ msgstr ""
#~ "Бинарные пакеты для двух версий "
#~ "Tarantool'а — стабильной 1.6 и самой "
#~ "свежей 1.7 — выложены на странице "
#~ "http://tarantool.org/download.html. При каждом "
#~ "изменении исходного кода на GitHub "
#~ "(репозиторий http://github.com/tarantool/tarantool, ветка"
#~ " \"1.7\") происходит сборка, автоматическое "
#~ "тестирование и выкладка бинарных пакетов "
#~ "на вышеуказанную страницу."

#~ msgid "Starting Tarantool and making your first database"
#~ msgstr "Первичный запуск Tarantool'а и создание базы данных"

#~ msgid "Start the server. The server name is tarantool."
#~ msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#~ msgid ""
#~ "The server starts in interactive mode"
#~ " and outputs a command prompt. To "
#~ "turn on the database, :ref:`configure "
#~ "<box_introspection-box_cfg>` it. This minimal "
#~ "example is sufficient:"
#~ msgstr ""
#~ "Tarantool-сервер запускается в интерактивном "
#~ "режиме и выводит приглашение командной "
#~ "строки. Чтобы создать базу данных, "
#~ "задайте ее настройки с помощью вызова"
#~ " :ref:`box.cfg <box_introspection-box_cfg>`. Вот"
#~ " пример минимальной конфигурации:"

#~ msgid ""
#~ "If all goes well, you will see "
#~ "the server displaying progress as it "
#~ "initializes, something like this:"
#~ msgstr ""
#~ "Если все в порядке, то Tarantool-сервер"
#~ " начнет в прогрессе отображать процесс "
#~ "инициализации, например:"

#~ msgid ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824"
#~ " bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating "
#~ "'./00000000000000000000.snap.inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot"
#~ " './00000000000000000000.snap.inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"
#~ msgstr ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824"
#~ " bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating "
#~ "'./00000000000000000000.snap.inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot"
#~ " './00000000000000000000.snap.inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"

#~ msgid ""
#~ "Now that the server is up, you "
#~ "could start up a different shell "
#~ "and connect to its primary port "
#~ "with:"
#~ msgstr ""
#~ "Поскольку Tarantool-сервер уже запущен, вы "
#~ "можете запустить новый терминал и "
#~ "присоединиться к основному порту "
#~ "Tarantool-сервера, введя следующую команду:"

#~ msgid "$ telnet 0 3301"
#~ msgstr "$ telnet 0 3301"

#~ msgid ""
#~ "but for example purposes it is "
#~ "simpler to just leave the server "
#~ "running in \"interactive mode\". On "
#~ "production machines the :ref:`interactive mode"
#~ " <administration-using_tarantool_as_a_client>` is "
#~ "just for administrators, but because "
#~ "it's convenient for learning it will "
#~ "be used for most examples in this"
#~ " manual. Tarantool is waiting for the"
#~ " user to type instructions."
#~ msgstr ""
#~ "но пока что будет лучше оставить "
#~ "Tarantool-сервер работать в интерактивном "
#~ "режиме. На промышленных серверах "
#~ ":ref:`интерактивный режим <administration-"
#~ "using_tarantool_as_a_client>` нужен лишь для "
#~ "администрирования, однако для наглядности "
#~ "большинство примеров в данном руководстве "
#~ "даны именно в интерактивном режиме. "
#~ "Итак, Tarantool ждет от вас ввода "
#~ "инструкций."

#~ msgid "Your terminal screen should now look like this:"
#~ msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#~ msgid ""
#~ "In the previous section the first "
#~ "request was with ``box.cfg{listen = "
#~ "3301}``. The ``listen`` value can be "
#~ "any form of URI (uniform resource "
#~ "identifier); in this case it's just "
#~ "a local port: port 3301. It's "
#~ "possible to send requests to the "
#~ "listen URI via:"
#~ msgstr ""
#~ "В предыдущем разделе ваш первый запрос"
#~ " был :samp:`box.cfg{listen = 3301}`. "
#~ "Значением ``listen`` может быть любой "
#~ "URI (универсальный код ресурса), в "
#~ "данном случае — просто номер локального"
#~ " порта (3301). Вы можете отправлять "
#~ "запросы на URI для прослушивания с "
#~ "помощью:"

#~ msgid ""
#~ "a connector (which will be the "
#~ "subject of the \":ref:`index-box_connectors`\""
#~ " chapter),"
#~ msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#~ msgid "Let's try (4)."
#~ msgstr ""

#~ msgid ""
#~ "This means \"use :ref:`tarantoolctl connect"
#~ " <administration-tarantoolctl_connect>` to "
#~ "connect to the Tarantool server that's"
#~ " listening on ``localhost:3301``\"."
#~ msgstr ""

#~ msgid "To drop the space: ``s:drop()``"
#~ msgstr ""

#~ msgid ""
#~ "**To review...** If you followed all "
#~ "the instructions in this chapter, then"
#~ " so far you have: installed Tarantool"
#~ " from a binary repository, started up"
#~ " the Tarantool server, inserted and "
#~ "selected tuples."
#~ msgstr ""

#~ msgid ""
#~ "This documentation is built using a "
#~ "simplified markup system named ``Sphinx`` "
#~ "(see http://sphinx-doc.org). You can "
#~ "build a local version of this "
#~ "documentation and contribute to it."
#~ msgstr ""

#~ msgid "You need to install:"
#~ msgstr ""

#~ msgid "Also, make sure to install the following Python modules:"
#~ msgstr ""

#~ msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4"
#~ msgstr ""

#~ msgid "`pelican <https://pypi.python.org/pypi/pelican>`_, any version"
#~ msgstr ""

#~ msgid ""
#~ "`BeautifulSoup <https://pypi.python.org/pypi/BeautifulSoup>`_,"
#~ " any version"
#~ msgstr ""

#~ msgid ""
#~ "See installation details in the :ref"
#~ ":`build-from-source <building_from_source>` "
#~ "section of this documentation. The "
#~ "procedure below implies that all the "
#~ "prerequisites are met."
#~ msgstr ""

#~ msgid ""
#~ "Use ``git`` to download the latest "
#~ "source code of this documentation from"
#~ " the GitHub repository ``tarantool/doc``, "
#~ "branch 1.7. For example, to a "
#~ "local directory named `~/tarantool-doc`:"
#~ msgstr ""

#~ msgid "git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/tarantool-doc\n"
#~ "make clean         # unnecessary, added for good luck\n"
#~ "rm CMakeCache.txt  # unnecessary, added for good luck\n"
#~ "cmake .            # start initiating"
#~ msgstr ""

#~ msgid "Build a local version of the existing documentation package."
#~ msgstr ""

#~ msgid ""
#~ "cd ~/tarantool-doc\n"
#~ "make all                # all versions\n"
#~ "make sphinx-html        # multi-page English version\n"
#~ "make sphinx-singlehtml  # one-page English version\n"
#~ "make sphinx-html-ru     # multi-page Russian version\n"
#~ "make sphinx-singlehtml  # one-page Russian version"
#~ msgstr ""

#~ msgid "Documentation is created and stored at `/www/output`:"
#~ msgstr ""

#~ msgid "`/www/output/doc` (English versions)"
#~ msgstr ""

#~ msgid "`/www/output/doc/ru` (Russian versions)"
#~ msgstr ""

#~ msgid ""
#~ "The entry point for each version "
#~ "is `index.html` file in the appropriate"
#~ " directory."
#~ msgstr ""

#~ msgid "Set up a web-server."
#~ msgstr ""

#~ msgid ""
#~ "Run the following command to set "
#~ "up a web-server (the example below"
#~ " is for Ubuntu, but the procedure "
#~ "is similar for other supported OS's)."
#~ " Make sure to run it from the"
#~ " documentation output folder, as specified"
#~ " below:"
#~ msgstr ""

#~ msgid ""
#~ "cd ~/tarantool-doc/www/output\n"
#~ "python -m SimpleHTTPServer 8000"
#~ msgstr ""

#~ msgid ""
#~ "Open your browser and enter "
#~ "``127.0.0.1:8000/doc`` into the address box."
#~ " If your local documentation build is"
#~ " valid, the default version (English "
#~ "multi-page) will be displayed in the"
#~ " browser."
#~ msgstr ""

#~ msgid ""
#~ "To contribute to documentation, use the"
#~ " ``.rst`` format for drafting and "
#~ "submit your updates as \"Pull Requests\""
#~ " via GitHub."
#~ msgstr ""

#~ msgid "Notes:"
#~ msgstr ""

#~ msgid ""
#~ "If you suggest creating a new "
#~ "documentation section (i.e., a whole new"
#~ " page), it has to be saved to"
#~ " the relevant section at GitHub."
#~ msgstr ""

#~ msgid ""
#~ "If you want to contribute to "
#~ "localizing this documentation (e.g. into "
#~ "Russian), add your translation strings "
#~ "to ``.po`` files stored in the "
#~ "corresponding locale directory (e.g. "
#~ "``/sphinx/locale/ru/LC_MESSAGES/`` for Russian). See"
#~ " more about localizing with Sphinx at"
#~ " http://www.sphinx-doc.org/en/stable/intl.html"
#~ msgstr ""

#~ msgid ""
#~ "Use ``git`` to download the latest "
#~ "Tarantool source code from the GitHub"
#~ " repository ``tarantool/tarantool``, branch 1.7."
#~ " For example, to a local directory"
#~ " named `~/tarantool`:"
#~ msgstr ""

#~ msgid ""
#~ "`README.FreeBSD "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/README.FreeBSD>`_ "
#~ "for FreeBSD 10.1"
#~ msgstr ""

#~ msgid ""
#~ "`README.MacOSX "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/README.MacOSX>`_ "
#~ "for Mac OS X `El Capitan`"
#~ msgstr ""

#~ msgid ""
#~ "`README.md "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/README.md>`_ "
#~ "for generic GNU/Linux"
#~ msgstr ""

#~ msgid ""
#~ "These example scripts assume that the"
#~ " intent is to download from the "
#~ "1.7 branch, build the server and "
#~ "run tests after build."
#~ msgstr ""

#~ msgid ""
#~ "The server begins the dialogue by "
#~ "sending a fixed-size (128-byte) text "
#~ "greeting to the client. The greeting "
#~ "always contains two 64-byte lines of "
#~ "ASCII text, each line ending with "
#~ "a newline character ('\\\\n'). The first"
#~ " line contains the server version and"
#~ " protocol type. The second line "
#~ "contains up to 44 bytes of "
#~ "base64-encoded random string, to use in"
#~ " the authentication packet, and ends "
#~ "with up to 23 spaces."
#~ msgstr ""

#~ msgid ""
#~ "The Tarantool protocol mandates use of"
#~ " a few integer constants serving as"
#~ " keys in maps used in the "
#~ "protocol. These constants are defined in"
#~ " `src/box/iproto_constants.h "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_"
#~ msgstr ""

#~ msgid ""
#~ "-- -- Value for <code> key in request can be:\n"
#~ "-- User command codes\n"
#~ "<select>  ::= 0x01\n"
#~ "<insert>  ::= 0x02\n"
#~ "<replace> ::= 0x03\n"
#~ "<update>  ::= 0x04\n"
#~ "<delete>  ::= 0x05\n"
#~ "<call_16> ::= 0x06\n"
#~ "<auth>    ::= 0x07\n"
#~ "<eval>    ::= 0x08\n"
#~ "<upsert>  ::= 0x09\n"
#~ "<call>    ::= 0x0a\n"
#~ "-- Admin command codes\n"
#~ "<ping>    ::= 0x40\n"
#~ "\n"
#~ "-- -- Value for <code> key in response can be:\n"
#~ "<OK>      ::= 0x00\n"
#~ "<ERROR>   ::= 0x8XXX"
#~ msgstr ""

#~ msgid ""
#~ "When a client connects to the "
#~ "server, the server responds with a "
#~ "128-byte text greeting message. Part of"
#~ " the greeting is base-64 encoded "
#~ "session salt - a random string "
#~ "which can be used for authentication."
#~ " The length of decoded salt (44 "
#~ "bytes) exceeds the amount necessary to"
#~ " sign the authentication message (first "
#~ "20 bytes). An excess is reserved "
#~ "for future authentication schemas."
#~ msgstr ""

#~ msgid ""
#~ "PREPARE SCRAMBLE:\n"
#~ "\n"
#~ "    LEN(ENCODED_SALT) = 44;\n"
#~ "    LEN(SCRAMBLE)     = 20;\n"
#~ "\n"
#~ "prepare 'chap-sha1' scramble:\n"
#~ "\n"
#~ "    salt = base64_decode(encoded_salt);\n"
#~ "    step_1 = sha1(password);\n"
#~ "    step_2 = sha1(step_1);\n"
#~ "    step_3 = sha1(salt, step_2);\n"
#~ "    scramble = xor(step_1, step_3);\n"
#~ "    return scramble;\n"
#~ "\n"
#~ "AUTHORIZATION BODY: CODE = 0x07\n"
#~ "\n"
#~ "+==================+====================================+\n"
#~ "|                  |        +-------------+-----------+ |\n"
#~ "|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
#~ "|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
#~ "| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |    MP_BIN   | |\n"
#~ "|                  |        +-------------+-----------+ |\n"
#~ "|                  |                   MP_ARRAY         |\n"
#~ "+==================+====================================+\n"
#~ "                        MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ ":code:`<key>` holds the user name. "
#~ ":code:`<tuple>` must be an array of "
#~ "2 fields: authentication mechanism (\"chap-"
#~ "sha1\" is the only supported mechanism"
#~ " right now) and password, encrypted "
#~ "according to the specified mechanism. "
#~ "Authentication in Tarantool is optional, "
#~ "if no authentication is performed, "
#~ "session user is 'guest'. The server "
#~ "responds to authentication packet with a"
#~ " standard response with 0 tuples."
#~ msgstr ""

#~ msgid ""
#~ "CALL_16: CODE - 0x06 Call a stored"
#~ " function, returning an array of "
#~ "tuples. This is deprecated; CALL (0x0a)"
#~ " is recommended instead."
#~ msgstr ""

#~ msgid ""
#~ "CALL_16 BODY:\n"
#~ "\n"
#~ "+=======================+==================+\n"
#~ "|                       |                  |\n"
#~ "|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
#~ "| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
#~ "|                       |                  |\n"
#~ "+=======================+==================+\n"
#~ "                    MP_MAP"
#~ msgstr ""

#~ msgid ""
#~ "CALL: CODE - 0x0a Similar to "
#~ "CALL_16, but -- like EVAL, CALL "
#~ "returns a list of values, unconverted"
#~ msgstr ""

#~ msgid ""
#~ "Convenience macros which define hexadecimal"
#~ " constants for return codes can be"
#~ " found in `src/box/errcode.h "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_"
#~ msgstr ""

#~ msgid ""
#~ "JOIN:\n"
#~ "\n"
#~ "In the beginning you must send JOIN\n"
#~ "                         HEADER                          BODY\n"
#~ "+================+================+===================++-------+\n"
#~ "|                |                |    SERVER_UUID    ||       |\n"
#~ "|   0x00: 0x41   |   0x01: SYNC   |   0x24: UUID      || EMPTY |\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT | MP_INT: MP_STRING ||       |\n"
#~ "|                |                |                   ||       |\n"
#~ "+================+================+===================++-------+\n"
#~ "               MP_MAP                                   MP_MAP\n"
#~ "\n"
#~ "Then server, which we connect to, "
#~ "will send last SNAP file by, "
#~ "simply,\n"
#~ "creating a number of INSERTs (with additional LSN and ServerID)\n"
#~ "(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
#~ "\n"
#~ "+================+================++============================+\n"
#~ "|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                ||        |                 | |\n"
#~ "|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
#~ "| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
#~ "|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
#~ "|                |                ||               MP_MAP       |\n"
#~ "+================+================++============================+\n"
#~ "               MP_MAP                      MP_MAP\n"
#~ "\n"
#~ "SUBSCRIBE:\n"
#~ "\n"
#~ "Then you must send SUBSCRIBE:\n"
#~ "\n"
#~ "                              HEADER\n"
#~ "+===================+===================+\n"
#~ "|                   |                   |\n"
#~ "|     0x00: 0x41    |    0x01: SYNC     |\n"
#~ "|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
#~ "|                   |                   |\n"
#~ "+===================+===================+\n"
#~ "|    SERVER_UUID    |    CLUSTER_UUID   |\n"
#~ "|   0x24: UUID      |   0x25: UUID      |\n"
#~ "| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
#~ "|                   |                   |\n"
#~ "+===================+===================+\n"
#~ "                 MP_MAP\n"
#~ "\n"
#~ "      BODY\n"
#~ "+================+\n"
#~ "|                |\n"
#~ "|   0x26: VCLOCK |\n"
#~ "| MP_INT: MP_INT |\n"
#~ "|                |\n"
#~ "+================+\n"
#~ "      MP_MAP\n"
#~ "\n"
#~ "Then you must process every query that'll came through other masters.\n"
#~ "Every request between masters will have Additional LSN and SERVER_ID."
#~ msgstr ""

#~ msgid ""
#~ "Apart from a log sequence number "
#~ "and the data change request (formatted"
#~ " as in :ref:`Tarantool's binary protocol"
#~ " <box_protocol-iproto_protocol>`), each WAL "
#~ "record contains a header, some metadata,"
#~ " and then the data formatted "
#~ "according to `msgpack "
#~ "<https://en.wikipedia.org/wiki/MessagePack>`_ rules. For"
#~ " example this is what the WAL "
#~ "file looks like after the first "
#~ "INSERT request (\"s:insert({1})\") for the "
#~ "introductory sandbox exercise \":ref:`Starting "
#~ "Tarantool and making your first database"
#~ " <user_guide_getting_started-first_database>`“. On "
#~ "the left are the hexadecimal bytes "
#~ "that one would see with: |br| ``$"
#~ " hexdump 00000000000000000000.xlog`` |br| and "
#~ "on the right are comments."
#~ msgstr ""

#~ msgid ""
#~ "The server attempts to locate the "
#~ "original tuple by primary key. If "
#~ "found, a reference to the tuple is"
#~ " retained for later use."
#~ msgstr ""

#~ msgid ""
#~ "A message is sent to WAL writer"
#~ " running in a separate thread, "
#~ "requesting that the change be recorded"
#~ " in the WAL. The server switches "
#~ "to work on the next request until"
#~ " the write is acknowledged."
#~ msgstr ""

#~ msgid ""
#~ "The WAL writer employs a number of"
#~ " durability modes, as defined in "
#~ "configuration variable :ref:`wal_mode <index-"
#~ "wal_mode>`. It is possible to turn "
#~ "the write-ahead log completely off, "
#~ "by setting :ref:`wal_mode "
#~ "<cfg_binary_logging_snapshots-wal_mode>` to *none*. "
#~ "Even without the write-ahead log "
#~ "it's still possible to take a "
#~ "persistent copy of the entire data "
#~ "set with the :ref:`box.snapshot() <admin-"
#~ "snapshot>` request."
#~ msgstr ""

#~ msgid ""
#~ "The format of a snapshot .snap "
#~ "file is nearly the same as the "
#~ "format of a WAL .xlog file. "
#~ "However, the snapshot header differs: it"
#~ " contains the server's global unique "
#~ "identifier and the snapshot file's "
#~ "position in history, relative to earlier"
#~ " snapshot files. Also, the content "
#~ "differs: an .xlog file may contain "
#~ "records for any data-change requests "
#~ "(inserts, updates, upserts, and deletes), "
#~ "a .snap file may only contain "
#~ "records of inserts to memtx spaces."
#~ msgstr ""

#~ msgid ""
#~ "Primarily, the .snap file's records are"
#~ " ordered by space id. Therefore the"
#~ " records of system spaces, such as"
#~ " _schema and _space and _index and"
#~ " _func and _priv and _cluster, will"
#~ " be at the start of the .snap"
#~ " file, before the records of any "
#~ "spaces that were created by users."
#~ msgstr ""

#~ msgid ""
#~ "The recovery process begins when "
#~ "box.cfg{} happens for the first time "
#~ "after the Tarantool server starts."
#~ msgstr ""

#~ msgid ""
#~ "The recovery process must recover the"
#~ " databases as of the moment when "
#~ "the server was last shut down. For"
#~ " this it may use the latest "
#~ "snapshot file and any WAL files "
#~ "that were written after the snapshot."
#~ " One complicating factor is that "
#~ "Tarantool has two engines -- the "
#~ "memtx data must be reconstructed "
#~ "entirely from the snapshot and the "
#~ "WAL files, while the vinyl data "
#~ "will be on disk but might require"
#~ " updating around the time of a "
#~ "checkpoint. (When a snapshot happens, "
#~ "Tarantool tells the vinyl engine to "
#~ "make a checkpoint, and the snapshot "
#~ "operation is rolled back if anything "
#~ "goes wrong, so vinyl's checkpoint is "
#~ "at least as fresh as the snapshot"
#~ " file.)"
#~ msgstr ""

#~ msgid ""
#~ "Read the configuration parameters in the"
#~ " ``box.cfg{}`` request. Parameters which "
#~ "affect recovery may include :ref:`work_dir "
#~ "<cfg_basic-work_dir>`, :ref:`wal_dir <cfg_basic-"
#~ "wal_dir>`, :ref:`snap_dir <cfg_basic-snap_dir>`, "
#~ ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`, "
#~ ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
#~ "panic_on_snap_error>`, and :ref:`panic_on_wal_error "
#~ "<cfg_binary_logging_snapshots-panic_on_wal_error>`."
#~ msgstr ""

#~ msgid ""
#~ "Find the latest snapshot file. Use "
#~ "its data to reconstruct the in-"
#~ "memory databases. Instruct the vinyl "
#~ "engine to recover to the latest "
#~ "checkpoint."
#~ msgstr ""

#~ msgid ""
#~ "There are actually two variations of "
#~ "the reconstruction procedure for the "
#~ "memtx databases, depending whether the "
#~ "recovery process is \"default\"."
#~ msgstr ""

#~ msgid ""
#~ "If it is default (``panic_on_snap_error`` "
#~ "is ``true`` and ``panic_on_wal_error`` is "
#~ "``true``), memtx can read data in "
#~ "the snapshot with all indexes disabled."
#~ " First, all tuples are read into "
#~ "memory. Then, primary keys are built "
#~ "in bulk, taking advantage of the "
#~ "fact that the data is already "
#~ "sorted by primary key within each "
#~ "space."
#~ msgstr ""

#~ msgid ""
#~ "If it is not default "
#~ "(``panic_on_snap_error`` is ``false`` or "
#~ "``panic_on_wal_error`` is ``false``), Tarantool "
#~ "performs additional checking. Indexes are "
#~ "enabled at the start, and tuples "
#~ "are added one by one. This means"
#~ " that any unique-key constraint "
#~ "violations will be caught, and any "
#~ "duplicates will be skipped. Normally "
#~ "there will be no constraint violations"
#~ " or duplicates, so these checks are"
#~ " only made if an error has "
#~ "occurred."
#~ msgstr ""

#~ msgid ""
#~ "Find the WAL file that was made"
#~ " at the time of, or after, the"
#~ " snapshot file. Read its log entries"
#~ " until the log-entry LSN is "
#~ "greater than the LSN of the "
#~ "snapshot, or greater than the LSN "
#~ "of the vinyl checkpoint. This is "
#~ "the recovery process's \"start position\"; "
#~ "it matches the current state of "
#~ "the engines."
#~ msgstr ""

#~ msgid ""
#~ "Once again the startup procedure is "
#~ "initiated by the ``box.cfg{}`` request. "
#~ "One of the box.cfg parameters may "
#~ "be :ref:`replication_source <cfg_replication-"
#~ "replication_source>`. We will refer to "
#~ "this server, which is starting up "
#~ "due to box.cfg, as the \"local\" "
#~ "server to distinguish it from the "
#~ "other servers in a cluster, which "
#~ "we will refer to as \"distant\" "
#~ "servers."
#~ msgstr ""

#~ msgid ""
#~ "*If there is no snapshot .snap "
#~ "file and replication_source is empty*: "
#~ "|br| then the local server assumes "
#~ "it is an unreplicated \"standalone\" "
#~ "server, or is the first server of"
#~ " a new replication cluster. It will"
#~ " generate new UUIDs for itself and"
#~ " for the cluster. The server UUID "
#~ "is stored in the _cluster space; "
#~ "the cluster UUID is stored in the"
#~ " _schema space. Since a snapshot "
#~ "contains all the data in all the"
#~ " spaces, that means the local "
#~ "server's snapshot will contain the "
#~ "server UUID and the cluster UUID. "
#~ "Therefore, when the local server "
#~ "restarts on later occasions, it will "
#~ "be able to recover these UUIDs "
#~ "when it reads the .snap file."
#~ msgstr ""

#~ msgid ""
#~ "*If there is no snapshot .snap "
#~ "file and replication_source is not empty"
#~ " and the _cluster space contains no"
#~ " other server UUIDs*: |br| then the"
#~ " local server assumes it is not "
#~ "a standalone server, but is not "
#~ "yet part of a cluster. It must "
#~ "now join the cluster. It will send"
#~ " its server UUID to the first "
#~ "distant server which is listed in "
#~ "replication_source, which will act as a"
#~ " master. This is called the \"join"
#~ " request\". When a distant server "
#~ "receives a join request, it will "
#~ "send back:"
#~ msgstr ""

#~ msgid "the distant server's cluster UUID,"
#~ msgstr ""

#~ msgid ""
#~ "the contents of the distant server's "
#~ ".snap file. |br| When the local "
#~ "server receives this information, it "
#~ "puts the cluster UUID in its "
#~ "_schema space, puts the distant server's"
#~ " UUID and connection information in "
#~ "its _cluster space, and makes a "
#~ "snapshot containing all the data sent"
#~ " by the distant server. Then, if "
#~ "the local server has data in its"
#~ " WAL .xlog files, it sends that "
#~ "data to the distant server. The "
#~ "distant server will receive this and "
#~ "update its own copy of the data,"
#~ " and add the local server's UUID "
#~ "to its _cluster space."
#~ msgstr ""

#~ msgid ""
#~ "*If there is no snapshot .snap "
#~ "file and replication_source is not empty"
#~ " and the _cluster space contains "
#~ "other server UUIDs*: |br| then the "
#~ "local server assumes it is not a"
#~ " standalone server, and is already "
#~ "part of a cluster. It will send"
#~ " its server UUID and cluster UUID "
#~ "to all the distant servers which "
#~ "are listed in replication_source. This "
#~ "is called the \"on-connect handshake\"."
#~ " When a distant server receives an"
#~ " on-connect handshake: |br|"
#~ msgstr ""

#~ msgid ""
#~ "the distant server compares its own "
#~ "copy of the cluster UUID to the"
#~ " one in the on-connect handshake. "
#~ "If there is no match, then the "
#~ "handshake fails and the local server "
#~ "will display an error."
#~ msgstr ""

#~ msgid ""
#~ "the distant server looks for a "
#~ "record of the connecting instance in "
#~ "its _cluster space. If there is "
#~ "none, then the handshake fails. |br| "
#~ "Otherwise the handshake is successful. "
#~ "The distant server will read any "
#~ "new information from its own .snap "
#~ "and .xlog files, and send the new"
#~ " requests to the local server."
#~ msgstr ""

#~ msgid ""
#~ "In the end ... the local server"
#~ " knows what cluster it belongs to,"
#~ " the distant server knows that the"
#~ " local server is a member of "
#~ "the cluster, and both servers have "
#~ "the same database contents."
#~ msgstr ""

#~ msgid ""
#~ "*If there is a snapshot file and"
#~ " replication source is not empty*: "
#~ "|br| first the local server goes "
#~ "through the recovery process described "
#~ "in the previous section, using its "
#~ "own .snap and .xlog files. Then it"
#~ " sends a \"subscribe\" request to all"
#~ " the other servers of the cluster."
#~ " The subscribe request contains the "
#~ "server vector clock. The vector clock"
#~ " has a collection of pairs 'server"
#~ " id, lsn' for every server in "
#~ "the _cluster system space. Each distant"
#~ " server, upon receiving a subscribe "
#~ "request, will read its .xlog files' "
#~ "requests and send them to the "
#~ "local server if (lsn of .xlog file"
#~ " request) is greater than (lsn of "
#~ "the vector clock in the subscribe "
#~ "request). After all the other servers"
#~ " of the cluster have responded to "
#~ "the local server's subscribe request, "
#~ "the server startup is complete."
#~ msgstr ""

#~ msgid "The following temporary limitations apply for version 1.7:"
#~ msgstr ""

#~ msgid ""
#~ "The URIs in replication_source should "
#~ "all be in the same order on "
#~ "all servers. This is not mandatory "
#~ "but is an aid to consistency."
#~ msgstr ""

#~ msgid ""
#~ "The servers of a cluster should be"
#~ " started up at slightly different "
#~ "times. This is not mandatory but "
#~ "prevents a situation where each server"
#~ " is waiting for the other server "
#~ "to be ready."
#~ msgstr ""

#~ msgid ""
#~ "The maximum number of entries in "
#~ "the _cluster space is 32. Tuples "
#~ "for out-of-date replicas are not"
#~ " automatically re-used, so if this"
#~ " 32-replica limit is reached, users "
#~ "may have to reorganize the _cluster "
#~ "space manually."
#~ msgstr ""

#~ msgid "Package major version - 1 for 1.7.0."
#~ msgstr ""

#~ msgid "Package minor version - 7 for 1.7.0."
#~ msgstr ""

#~ msgid "Package patch version - 0 for 1.7.0."
#~ msgstr ""

#~ msgid ""
#~ "A string with major-minor-patch-"
#~ "commit-id identifier of the release, "
#~ "e.g. 1.7.0-1216-g73f7154."
#~ msgstr ""

#~ msgid ":ref:`genindex`"
#~ msgstr ""

#~ msgid ""
#~ "For one page HTML documentation, please,"
#~ " use `this link </doc/singlehtml.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "Tarantool's DBMS server uses the "
#~ "**storage engine** concept, where different"
#~ " sets of algorithms and data "
#~ "structures can be used for different "
#~ "situations. Two storage engines are "
#~ "built-in: an in-memory engine which"
#~ " has all the data and indexes "
#~ "in RAM, and a two-level B-tree "
#~ "engine for data sets whose size is"
#~ " 10 to 1000 times the amount of"
#~ " available RAM. All storage engines "
#~ "in Tarantool support transactions and "
#~ "replication by using a common **write"
#~ " ahead log** (WAL). This ensures "
#~ "consistency and crash safety of the "
#~ "persistent state. Changes are not "
#~ "considered complete until the WAL is "
#~ "written. The logging subsystem supports "
#~ "group commit."
#~ msgstr ""
#~ "В архитектуре серверной части СУБД "
#~ "Tarantool'а реализована концепция \"движков\" "
#~ "базы данных (storage engines), где в "
#~ "разных ситуациях используются разные наборы"
#~ " алгоритмов и структуры данных. В "
#~ "Tarantool'е есть два встроенных движка: "
#~ "in-memory движок, который держит все "
#~ "данные и индексы в оперативной памяти,"
#~ " и двухуровневый движок для B-деревьев, "
#~ "который обрабатывает данные размером в "
#~ "10-1000 раз больше того, что может "
#~ "поместиться в оперативной памяти. Все "
#~ "движки в Tarantool'е поддерживают транзакции"
#~ " и репликацию, поскольку они используют "
#~ "единый механизм **упреждающей записи** (WAL"
#~ " = write ahead log). Это механизм "
#~ "обеспечивает согласованность и сохранность "
#~ "данных при сбоях. Таким образом, "
#~ "изменения не считаются завершенными, пока "
#~ "не проходит запись в лог WAL. "
#~ "Подсистема логирования также поддерживает "
#~ "групповые коммиты. "

#~ msgid ""
#~ "**Tarantool's disk-based storage engine** "
#~ "is a fusion of ideas from modern"
#~ " filesystems, log-structured merge trees"
#~ " and classical B-trees. All data is"
#~ " organized into **ranges**. Each range "
#~ "is represented by a file on disk."
#~ " Range size is a configuration option"
#~ " and normally is around 64MB. Each"
#~ " range is a collection of pages, "
#~ "serving different purposes. Pages in a"
#~ " fully merged range contain non-"
#~ "overlapping ranges of keys. A range "
#~ "can be partially merged if there "
#~ "were a lot of changes in its "
#~ "key range recently. In that case "
#~ "some pages represent new keys and "
#~ "values in the range. The disk-"
#~ "based storage engine is append only: "
#~ "new data never overwrites old data. "
#~ "The disk-based storage engine is "
#~ "named :ref:`vinyl <index-vinyl>`."
#~ msgstr ""
#~ "**Дисковый движок** (:ref:`vinyl <index-"
#~ "vinyl>`) совмещает в себе подходы, "
#~ "заимствованные из современных файловых систем,"
#~ " журналируемых merge-деревьев (log-structured "
#~ "merge trees) и классических B-деревьев. "
#~ "Все данные в этом движке разбиты "
#~ "по забегам (runs), где каждый забег "
#~ "представляет собой файл на диске. "
#~ "Максимальный размер забега обычно равен "
#~ "64МБ, и его можно настраивать. Каждый"
#~ " забег -- это набор страниц, которые"
#~ " нужны для каких-то целей. Если забег"
#~ " полностью смержен, то диапазоны ключей "
#~ "на его страницах не пересекаются. Если"
#~ " же диапазоны ключей в забеге в "
#~ "какой-то момент сильно изменялись, то мы"
#~ " имеем дело с частично смерженным "
#~ "забегом. В этом случае на некоторых "
#~ "страницах появились новые ключи и "
#~ "значения, которых ранее не было в "
#~ "данном забеге. Дисковый движок обновляет "
#~ "данные по принципу дописывания в конец:"
#~ " новые данные никогда не затирают "
#~ "старые."

#~ msgid ""
#~ "This reference covers all options and"
#~ " parameters which can be set for "
#~ "Tarantool on the command line or "
#~ "in an initialization file."
#~ msgstr ""

#~ msgid ""
#~ "$ ./tarantool --version\n"
#~ "Tarantool 1.7.0-1216-g73f7154\n"
#~ "Target: Linux-x86_64-Debug\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "A method for parsing URIs is "
#~ "illustrated in :ref:`Cookbook recipes "
#~ "<cookbook-uri>`."
#~ msgstr ""

#~ msgid ""
#~ "$ export LISTEN_URI=3301\n"
#~ "$ ~/tarantool/src/tarantool script.lua ARG\n"
#~ "... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
#~ "... main/101/script.lua C> log level 5\n"
#~ "... main/101/script.lua I> mapping 107374184"
#~ " bytes for a shared arena...\n"
#~ "... main/101/script.lua I> recovery start\n"
#~ "... main/101/script.lua I> recovering from "
#~ "'./00000000000000000000.snap'\n"
#~ "... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
#~ "... main/102/leave_local_hot_standby I> ready to accept requests\n"
#~ "Starting  ARG\n"
#~ "... main C> entering the event loop"
#~ msgstr ""

#~ msgid ""
#~ "If one wishes to start an "
#~ "interactive session on the same terminal"
#~ " after initialization is complete, one "
#~ "can use :ref:`console.start() <console-"
#~ "start>`."
#~ msgstr ""

#~ msgid ""
#~ "Configuration parameters have the form: "
#~ "|br| :extsamp:`{**{box.cfg}**}{[{*{key = value}*}"
#~ " [, {*{key = value ...}*}]]}`"
#~ msgstr ""

#~ msgid ""
#~ "Run the server as a background "
#~ "task. The :ref:`logger <cfg_logging-logger>`"
#~ " and :ref:`pid_file <cfg_basic-pid_file>` "
#~ "parameters must be non-null for "
#~ "this to work."
#~ msgstr ""

#~ msgid ""
#~ "Add the given string to the "
#~ "server's :ref:`Process title <administration-"
#~ "proctitle>` (what’s shown in the COMMAND"
#~ " column for :samp:`ps -ef` and "
#~ ":samp:`top -c` commands)."
#~ msgstr ""

#~ msgid "Type: string |br| Default: null |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid ""
#~ "The read/write data port number or "
#~ ":ref:`URI <index-uri>` (Universal Resource "
#~ "Identifier) string. Has no default "
#~ "value, so **must be specified** if "
#~ "connections will occur from remote "
#~ "clients that do not use the "
#~ ":ref:`“admin port” <administration-admin_ports>`."
#~ " Connections made with :samp:`listen={URI}` "
#~ "are sometimes called \"binary protocol\" "
#~ "or \"primary port\" connections."
#~ msgstr ""

#~ msgid ""
#~ "A typical value is 3301. The "
#~ "listen parameter may also be set "
#~ "for local hot standby."
#~ msgstr ""

#~ msgid "Type: integer or string |br| Default: null |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid "Type: string |br| Default: null |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid ""
#~ "Put the server in read-only mode."
#~ " After this, any requests that try"
#~ " to change data will fail with "
#~ "error ER_READONLY."
#~ msgstr ""

#~ msgid "Type: boolean |br| Default: false |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid ""
#~ "A directory where snapshot (.snap) files"
#~ " will be stored. Can be relative "
#~ "to :ref:`work_dir <cfg_basic-work_dir>`. If"
#~ " not specified, defaults to work_dir. "
#~ "See also :ref:`wal_dir <cfg_basic-wal_dir>`."
#~ msgstr ""

#~ msgid "Type: string |br| Default: \".\" |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid ""
#~ "A directory where vinyl files or "
#~ "subdirectories will be stored. Can be"
#~ " relative to :ref:`work_dir <cfg_basic-"
#~ "work_dir>`. If not specified, defaults "
#~ "to work_dir."
#~ msgstr ""

#~ msgid ""
#~ "A directory where write-ahead log "
#~ "(.xlog) files are stored. Can be "
#~ "relative to :ref:`work_dir <cfg_basic-"
#~ "work_dir>`. Sometimes wal_dir and "
#~ ":ref:`snap_dir <cfg_basic-snap_dir>` are "
#~ "specified with different values, so that"
#~ " write-ahead log files and snapshot"
#~ " files can be stored on different "
#~ "disks. If not specified, defaults to "
#~ "work_dir."
#~ msgstr ""

#~ msgid ""
#~ "A directory where database working files"
#~ " will be stored. The server switches"
#~ " to work_dir with :manpage:`chdir(2)` after"
#~ " start. Can be relative to the "
#~ "current directory. If not specified, "
#~ "defaults to the current directory. Other"
#~ " directory parameters may be relative "
#~ "to work_dir, for example |br| "
#~ ":codenormal:`box.cfg{work_dir='/home/user/A',wal_dir='B',snap_dir='C'}`"
#~ " |br| will put xlog files in "
#~ "/home/user/A/B, snapshot files in "
#~ "/home/user/A/C, and all other files or"
#~ " subdirectories in /home/user/A."
#~ msgstr ""

#~ msgid ""
#~ "Size of the largest allocation unit. "
#~ "It can be increased if it is "
#~ "necessary to store large tuples."
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 1048576 |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid ""
#~ "Size of the smallest allocation unit."
#~ " It can be decreased if most of"
#~ " the tuples are very small. The "
#~ "value must be between 8 and "
#~ "1048280 inclusive."
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 16 |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid "The default vinyl configuration can be changed with"
#~ msgstr ""

#~ msgid ""
#~ "vinyl = {\n"
#~ "  run_age_wm = *number*,\n"
#~ "  run_age_period = *number of seconds*,\n"
#~ "  memory_limit = *number of gigabytes*,\n"
#~ "  compact_wm = *number*,\n"
#~ "  threads = *number*,\n"
#~ "  run_age = *number*,\n"
#~ "  run_prio = *number*,\n"
#~ "}"
#~ msgstr ""

#~ msgid "This method may change in the future."
#~ msgstr ""

#~ msgid "Default values are:"
#~ msgstr ""

#~ msgid ""
#~ "vinyl = {\n"
#~ "  run_age_wm = 0,\n"
#~ "  run_age_period = 0,\n"
#~ "  memory_limit = 1,\n"
#~ "  compact_wm = 2,\n"
#~ "  threads = 5,\n"
#~ "  run_age = 0,\n"
#~ "  run_prio = 2,\n"
#~ "}"
#~ msgstr ""

#~ msgid ""
#~ "The interval between actions by the "
#~ "snapshot daemon, in seconds. If "
#~ "``snapshot_period`` is set to a value"
#~ " greater than zero, and there is "
#~ "activity which causes change to a "
#~ "database, then the snapshot daemon will"
#~ " call :ref:`box.snapshot <admin-snapshot>` "
#~ "every ``snapshot_period`` seconds, creating a"
#~ " new snapshot file each time."
#~ msgstr ""

#~ msgid ""
#~ "For example: ``box.cfg{snapshot_period=3600}`` will"
#~ " cause the snapshot daemon to create"
#~ " a new database snapshot once per "
#~ "hour."
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 0 |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid ""
#~ "The maximum number of snapshots that "
#~ "may exist on the snap_dir directory "
#~ "before the snapshot daemon will remove"
#~ " old snapshots. If snapshot_count equals"
#~ " zero, then the snapshot daemon does"
#~ " not remove old snapshots. For "
#~ "example:"
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 6 |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
#~ "panic_on_snap_error>`, |br| :ref:`panic_on_wal_error "
#~ "<cfg_binary_logging_snapshots-panic_on_wal_error>`, |br|"
#~ " :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
#~ "rows_per_wal>`, |br| :ref:`snap_io_rate_limit "
#~ "<cfg_binary_logging_snapshots-snap_io_rate_limit>`, |br| "
#~ ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
#~ " |br| :ref:`wal_dir_rescan_delay "
#~ "<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` |br|"
#~ msgstr ""

#~ msgid ""
#~ "If there is an error while reading"
#~ " a write-ahead log file (at "
#~ "server start or to relay to a "
#~ "replica), abort."
#~ msgstr ""

#~ msgid "Type: boolean |br| Default: true |br| Dynamic: yes |br|"
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 500000 |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid ""
#~ "Reduce the throttling effect of "
#~ ":ref:`box.snapshot <admin-snapshot>` on "
#~ "INSERT/UPDATE/DELETE performance by setting a"
#~ " limit on how many megabytes per "
#~ "second it can write to disk. The"
#~ " same can be achieved by splitting"
#~ " :ref:`wal_dir <cfg_basic-wal_dir>` and "
#~ ":ref:`snap_dir <cfg_basic-snap_dir>` locations "
#~ "and moving snapshots to a separate "
#~ "disk."
#~ msgstr ""

#~ msgid "Type: float |br| Default: null |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid "Type: string |br| Default: \"write\" |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid ""
#~ "Number of seconds between periodic scans"
#~ " of the write-ahead-log file "
#~ "directory, when checking for changes to"
#~ " write-ahead-log files for the "
#~ "sake of replication or local hot "
#~ "standby."
#~ msgstr ""

#~ msgid "Type: float |br| Default: 2 |br| Dynamic: no |br|"
#~ msgstr ""

#~ msgid ""
#~ "If replication_source is not an empty"
#~ " string, the server is considered to"
#~ " be a Tarantool :ref:`replica <index-"
#~ "box_replication>`. The replica server will "
#~ "try to connect to the master which"
#~ " replication_source specifies with a "
#~ ":ref:`URI <index-uri>` (Universal Resource "
#~ "Identifier), for example "
#~ ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`."
#~ msgstr ""

#~ msgid ""
#~ "If there is more than one "
#~ "replication source in a cluster, specify"
#~ " an array of URIs, for example "
#~ "|br| :codenormal:`box.cfg{replication_source = "
#~ "{`:codeitalic:`uri#1,uri#2`:codenormal:`}}` |br|"
#~ msgstr ""

#~ msgid ""
#~ "If one of the URIs is \"self\" "
#~ "-- that is, if one of the "
#~ "URIs is for the same server that"
#~ " :codenormal:`box.cfg{}` is being executed "
#~ "on -- then it is ignored. Thus "
#~ "it is possible to use the same "
#~ "replication_source specification on multiple "
#~ "servers."
#~ msgstr ""

#~ msgid ""
#~ "The default user name is ‘guest’. "
#~ "A replica server does not accept "
#~ "data-change requests on the :ref:`listen"
#~ " <cfg_basic-listen>` port. The "
#~ "replication_source parameter is dynamic, that"
#~ " is, to enter master mode, simply "
#~ "set replication_source to an empty "
#~ "string and issue "
#~ ":code:`box.cfg{replication_source=`:samp:`{new-value}`:code:`}`."
#~ msgstr ""

#~ msgid "Type: string |br| Default: null |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid ""
#~ ":ref:`io_collect_interval <cfg_networking-"
#~ "io_collect_interval>`, |br| :ref:`readahead "
#~ "<cfg_networking-readahead>`  |br|"
#~ msgstr ""

#~ msgid ""
#~ "The server will sleep for "
#~ "io_collect_interval seconds between iterations "
#~ "of the event loop. Can be used "
#~ "to reduce CPU load in deployments "
#~ "in which the number of client "
#~ "connections is large, but requests are"
#~ " not so frequent (for example, each"
#~ " connection issues just a handful of"
#~ " requests per second)."
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 16320 |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid ""
#~ "By setting log_level, one can enable "
#~ "logging of all classes below or "
#~ "equal to the given level. Tarantool "
#~ "prints its logs to the standard "
#~ "error stream by default, but this "
#~ "can be changed with the :ref:`logger "
#~ "<cfg_logging-logger>` configuration parameter."
#~ msgstr ""

#~ msgid "Type: integer |br| Default: 5 |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid ""
#~ "By default, the log is sent to "
#~ "the standard error stream (``stderr``). "
#~ "If ``logger`` is specified, the log "
#~ "is sent to a file, or to a"
#~ " pipe, or to the system logger."
#~ msgstr ""

#~ msgid ""
#~ "This will start the program ``cronolog``"
#~ " when the server starts, and will "
#~ "send all log messages to the "
#~ "standard input (``stdin``) of cronolog. "
#~ "If the ``logger`` string begins with "
#~ "'|' or has the prefix \"pipe:\", "
#~ "then the string is interpreted as "
#~ "a Unix `pipeline "
#~ "<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
#~ msgstr ""

#~ msgid ""
#~ "When logging to a file, tarantool "
#~ "reopens the log on SIGHUP. When "
#~ "log is a program, its pid is "
#~ "saved in the :ref:`log.logger_pid <log-"
#~ "logger_pid>` variable. You need to send"
#~ " it a signal to rotate logs."
#~ msgstr ""

#~ msgid "Type: float |br| Default: 0.5 |br| Dynamic: **yes** |br|"
#~ msgstr ""

#~ msgid "**Logging example:**"
#~ msgstr ""

#~ msgid ""
#~ "This will illustrate how \"rotation\" "
#~ "works, that is, what happens when "
#~ "the server is writing to a log "
#~ "and signals are used when archiving "
#~ "it."
#~ msgstr ""

#~ msgid ""
#~ "On Terminal #2: use ``mv`` so the"
#~ " log file is now named "
#~ "`Log_file.bak`. The result of this is:"
#~ " the next log message will go "
#~ "to `Log_file.bak`. |br|"
#~ msgstr ""

#~ msgid "On Terminal #1: put a message \"Log Line #2\" in the log file. |br|"
#~ msgstr ""

#~ msgid ""
#~ "On Terminal #2: use ``ps`` to find"
#~ " the process ID of the Tarantool "
#~ "server. |br|"
#~ msgstr ""

#~ msgid ""
#~ "On Terminal #2: use ``kill -HUP`` "
#~ "to send a SIGHUP signal to the "
#~ "Tarantool server. The result of this "
#~ "is: Tarantool will open `Log_file` "
#~ "again, and the next log message "
#~ "will go to `Log_file`. (The same "
#~ "effect could be accomplished by "
#~ "executing log.rotate() on the server.) "
#~ "|br|"
#~ msgstr ""

#~ msgid ""
#~ "The contents of the ``box`` library "
#~ "can be inspected at runtime with "
#~ "``box``, with no arguments. The "
#~ "submodules inside the box library are:"
#~ msgstr ""

#~ msgid ""
#~ "Emulate a request error, with text "
#~ "based on one of the pre-defined"
#~ " Tarantool errors defined in the file"
#~ " `errcode.h "
#~ "<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_"
#~ " in the source tree. Lua constants"
#~ " which correspond to those Tarantool "
#~ "errors are defined as members of "
#~ "``box.error``, for example ``box.error.NO_SUCH_USER"
#~ " == 45``."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
#~ "---\n"
#~ "- error: Arbitrary message\n"
#~ "...\n"
#~ "tarantool> box.schema.space.create('#')\n"
#~ "---\n"
#~ "- error: Invalid identifier '#' "
#~ "(expected letters, digits or an "
#~ "underscore)\n"
#~ "...\n"
#~ "tarantool> box.error.last()\n"
#~ "---\n"
#~ "- line: 278\n"
#~ "  code: 70\n"
#~ "  type: ClientError\n"
#~ "  message: Invalid identifier '#' "
#~ "(expected letters, digits or an "
#~ "underscore)\n"
#~ "  file: "
#~ "/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc"
#~ "\n"
#~ "...\n"
#~ "tarantool> box.error.clear()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.error.last()\n"
#~ "---\n"
#~ "- null\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Execute a function, provided it has "
#~ "not been executed before. A passed "
#~ "value is checked to see whether "
#~ "the function has already been executed."
#~ " If it has been executed before, "
#~ "nothing happens. If it has not "
#~ "been executed before, the function is"
#~ " invoked. For an explanation why "
#~ "``box.once`` is useful, see the section"
#~ " :ref:`Preventing Duplicate Actions <index-"
#~ "preventing_duplicate_actions>`."
#~ msgstr ""

#~ msgid "arguments, that must be passed to function"
#~ msgstr ""

#~ msgid ""
#~ "The processor time. Derived from C "
#~ "function clock_gettime(CLOCK_PROCESS_CPUTIME_ID). This "
#~ "is the best function to use with"
#~ " benchmarks that need to calculate "
#~ "how much time has been spent "
#~ "within a CPU."
#~ msgstr ""

#~ msgid ""
#~ "The thread time. Derived from C "
#~ "function clock_gettime(CLOCK_THREAD_CPUTIME_ID). This "
#~ "is the best function to use with"
#~ " benchmarks that need to calculate "
#~ "how much time has been spent "
#~ "within a thread within a CPU."
#~ msgstr ""

#~ msgid ""
#~ "The time that a function takes "
#~ "within a processor. This function uses"
#~ " clock.proc(), therefore it calculates "
#~ "elapsed CPU time. Therefore it is "
#~ "not useful for showing actual elapsed"
#~ " time."
#~ msgstr ""

#~ msgid ":samp:`{function}` = function or function reference;"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`{function parameters}` = whatever "
#~ "values are required by the function."
#~ msgstr ""

#~ msgid ""
#~ "table. first element = seconds of "
#~ "CPU time; second element = whatever "
#~ "the function returns."
#~ msgstr ""

#~ msgid ""
#~ "-- Benchmark a function which sleeps 10 seconds.\n"
#~ "-- NB: bench() will not calculate sleep time.\n"
#~ "-- So the returned value will be {a number less than 10, 88}.\n"
#~ "clock = require('clock')\n"
#~ "fiber = require('fiber')\n"
#~ "function f(param)\n"
#~ "  fiber.sleep(param)\n"
#~ "  return 88\n"
#~ "end\n"
#~ "clock.bench(f,10)"
#~ msgstr ""

#~ msgid ""
#~ "The console module allows one Tarantool"
#~ " server to access another Tarantool "
#~ "server, and allows one Tarantool server"
#~ " to start listening on an :ref:`admin"
#~ " port <administration-admin_ports>`."
#~ msgstr ""

#~ msgid ""
#~ "Connect to the server at :ref:`URI "
#~ "<index-uri>`, change the prompt from "
#~ "':samp:`tarantool>`' to ':samp:`{uri}>`', and "
#~ "act henceforth as a client until "
#~ "the user ends the session or types"
#~ " :code:`control-D`."
#~ msgstr ""

#~ msgid ""
#~ "The console.connect function allows one "
#~ "Tarantool server, in interactive mode, "
#~ "to access another Tarantool server. "
#~ "Subsequent requests will appear to be"
#~ " handled locally, but in reality the"
#~ " requests are being sent to the "
#~ "remote server and the local server "
#~ "is acting as a client. Once "
#~ "connection is successful, the prompt "
#~ "will change and subsequent requests are"
#~ " sent to, and executed on, the "
#~ "remote server. Results are displayed on"
#~ " the local server. To return to "
#~ "local mode, enter :code:`control-D`."
#~ msgstr ""

#~ msgid ""
#~ "If the Tarantool server at :samp:`uri`"
#~ " requires authentication, the connection "
#~ "might look something like: "
#~ ":code:`console.connect('admin:secretpassword@distanthost.com:3301')`."
#~ msgstr ""

#~ msgid ""
#~ "There are no restrictions on the "
#~ "types of requests that can be "
#~ "entered, except those which are due "
#~ "to privilege restrictions -- by default"
#~ " the login to the remote server "
#~ "is done with user name = 'guest'."
#~ " The remote server could allow for"
#~ " this by granting at least one "
#~ "privilege: "
#~ ":code:`box.schema.user.grant('guest','execute','universe')`."
#~ msgstr ""

#~ msgid "the URI of the remote server"
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: the connection will "
#~ "fail if the target Tarantool server "
#~ "was not initiated with "
#~ ":code:`box.cfg{listen=...}`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> console = require('console')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> console.connect('198.18.44.44:3301')\n"
#~ "---\n"
#~ "...\n"
#~ "198.18.44.44:3301> -- prompt is telling us that server is remote"
#~ msgstr ""

#~ msgid ""
#~ "Listen on :ref:`URI <index-uri>`. The"
#~ " primary way of listening for "
#~ "incoming requests is via the "
#~ "connection-information string, or URI, "
#~ "specified in :code:`box.cfg{listen=...}`. The "
#~ "alternative way of listening is via "
#~ "the URI specified in "
#~ ":code:`console.listen(...)`. This alternative way"
#~ " is called \"administrative\" or simply "
#~ ":ref:`\"admin port\" <administration-admin_ports>`."
#~ " The listening is usually over a "
#~ "local host with a Unix domain "
#~ "socket."
#~ msgstr ""

#~ msgid "the URI of the local server"
#~ msgstr ""

#~ msgid ""
#~ "A special use of ``console.start()`` is"
#~ " with :ref:`initialization files <index-"
#~ "init_label>`. Normally, if one starts "
#~ "the tarantool server with :samp:`tarantool "
#~ "{initialization file}` there is no "
#~ "console. This can be remedied by "
#~ "adding these lines at the end of"
#~ " the initialization file:"
#~ msgstr ""

#~ msgid ""
#~ "console = require('console')\n"
#~ "console.start()"
#~ msgstr ""

#~ msgid ""
#~ "Set the auto-completion flag. If "
#~ "auto-completion is `true`, and the "
#~ "user is using tarantool as a "
#~ "client or the user is using "
#~ "tarantool via console.connect(), then hitting"
#~ " the TAB key may cause tarantool "
#~ "to complete a word automatically. The"
#~ " default auto-completion value is "
#~ "`true`."
#~ msgstr ""

#~ msgid ""
#~ "crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
#~ "crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
#~ msgstr ""

#~ msgid ""
#~ "crypto = require('crypto')\n"
#~ "\n"
#~ "-- print aes-192 digest of 'AB', with one step, then incrementally\n"
#~ "print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
#~ "c = crypto.cipher.aes192.cbc.encrypt.new()\n"
#~ "c:init()\n"
#~ "c:update('A', 'key')\n"
#~ "c:update('B', 'key')\n"
#~ "print(c:result())\n"
#~ "c:free()\n"
#~ "\n"
#~ "-- print sha-256 digest of 'AB', with one step, then incrementally\n"
#~ "print(crypto.digest.sha256('AB'))\n"
#~ "c = crypto.digest.sha256.new()\n"
#~ "c:init()\n"
#~ "c:update('A')\n"
#~ "c:update('B')\n"
#~ "print(c:result())\n"
#~ "c:free()"
#~ msgstr ""

#~ msgid ""
#~ "crypto.cipher.aes256.cbc.encrypt('string', 'key') == "
#~ "digest.aes256cbc.encrypt('string', 'key')\n"
#~ "crypto.digest.md4('string') == digest.md4('string')\n"
#~ "crypto.digest.md5('string') == digest.md5('string')\n"
#~ "crypto.digest.sha('string') == digest.sha('string')\n"
#~ "crypto.digest.sha1('string') == digest.sha1('string')\n"
#~ "crypto.digest.sha224('string') == digest.sha224('string')\n"
#~ "crypto.digest.sha256('string') == digest.sha256('string')\n"
#~ "crypto.digest.sha384('string') == digest.sha384('string')\n"
#~ "crypto.digest.sha512('string') == digest.sha512('string')"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`delimiter = {string}` -- single-"
#~ "byte character to designate end-of-"
#~ "field, default = comma"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`quote_char = {string}` -- single-"
#~ "byte character to designate encloser of"
#~ " string, default = quote mark"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`chunk_size = {number}` -- number "
#~ "of characters to read at once "
#~ "(usually for file-IO efficiency), "
#~ "default = 4096"
#~ msgstr ""

#~ msgid ""
#~ ":samp:`skip_head_lines = {number}` -- number"
#~ " of lines to skip at the start"
#~ " (usually for a header), default 0"
#~ msgstr ""

#~ msgid ""
#~ "Readable file :file:`./file.csv` contains two"
#~ " CSV records. Explanation of fio is"
#~ " in section :ref:`fio <fio-section>`. "
#~ "Source CSV file and example "
#~ "respectively:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> -- input in file.csv is:\n"
#~ "tarantool> -- a,\"b,c \",d\n"
#~ "tarantool> -- a\\\\211\\\\128b\n"
#~ "tarantool> fio = require('fio')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> csv.load(f, {chunk_size = 4096})\n"
#~ "---\n"
#~ "- - - a\n"
#~ "    - 'b,c '\n"
#~ "    - d\n"
#~ "  - - a\\\\211\\\\128b\n"
#~ "...\n"
#~ "tarantool> f:close(nn)\n"
#~ "---\n"
#~ "- true\n"
#~ "..."
#~ msgstr ""

#~ msgid "any object which has a write() method"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> password_insert('Secret Password')\n"
#~ "---\n"
#~ "- 'Password is not valid'\n"
#~ "..."
#~ msgstr ""

#~ msgid "Can't modify data on a replication slave."
#~ msgstr ""

#~ msgid ""
#~ "Take advantage of Lua's mechanisms for"
#~ " `\"Error handling and exceptions\" "
#~ "<http://www.lua.org/pil/8.4.html>`_, particularly "
#~ "``pcall``. That is, instead of simply"
#~ " invoking with |br| :samp:`box.space.{space-"
#~ "name}:{function-name}()` |br| say |br| "
#~ ":samp:`if pcall(box.space.{space-name}:{function-"
#~ "name}() ...`"
#~ msgstr ""

#~ msgid ""
#~ "For some Tarantool box functions, pcall"
#~ " also returns error details including "
#~ "a file-name and line-number within"
#~ " Tarantool's source code. This can be"
#~ " seen by unpacking. For example: |br|"
#~ " ``x, y = pcall(function() "
#~ "box.schema.space.create('') end)`` |br| "
#~ "``y:unpack()``"
#~ msgstr ""

#~ msgid "Put messages in a log using the :ref:`log module <log>`."
#~ msgstr ""

#~ msgid ""
#~ "And filter messages that are "
#~ "automatically generated, with the :ref:`logger"
#~ " <cfg_logging-logger>` configuration parameter."
#~ msgstr ""

#~ msgid ""
#~ "The ``errno`` module has a function "
#~ "``strerror()`` which will return the "
#~ "text of an operating-system error, "
#~ "given its error number. Typically this"
#~ " module is used within a function "
#~ "or within a Lua program, in "
#~ "association with a module whose "
#~ "functions can return operating-system "
#~ "errors, such as :ref:`fio <fio-module>`."
#~ msgstr ""

#~ msgid ""
#~ "Return a string, given an error "
#~ "number. The string will contain the "
#~ "conventional error message for the "
#~ "current operating system. If ``code`` is"
#~ " not supplied, the error message will"
#~ " be for the last operating-system-"
#~ "related function, or 0."
#~ msgstr ""

#~ msgid "Return type: string"
#~ msgstr ""

#~ msgid ""
#~ "This function displays the result of "
#~ "a call to :ref:`fio.open() <fio-open>`"
#~ " which causes error 2 (errno.ENOENT)."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> function f()\n"
#~ "         >   local fio = require('fio')\n"
#~ "         >   local errno = require('errno')\n"
#~ "         >   fio.open('no_such_file')\n"
#~ "         >   print(errno.strerror())\n"
#~ "         > end\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> f()\n"
#~ "No such file or directory\n"
#~ "---\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> fiber.kill(fiber.id())\n"
#~ "---\n"
#~ "- error: fiber is cancelled\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Change the fiber name. By default "
#~ "the Tarantool server's interactive-mode "
#~ "fiber is named 'interactive' and new "
#~ "fibers created due to :ref:`fiber.create "
#~ "<fiber-create>` are named 'lua'. Giving"
#~ " fibers distinct names makes it "
#~ "easier to distinguish them when using"
#~ " :ref:`fiber.info <fiber-info>`."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> fiber.self():cancel()\n"
#~ "---\n"
#~ "- error: fiber is cancelled\n"
#~ "..."
#~ msgstr ""

#~ msgid "Submodule `fiber-cond`"
#~ msgstr ""

#~ msgid ""
#~ "The ``fiber-cond`` submodule has a "
#~ "synchronization mechanism for fibers, similar"
#~ " to \"Condition Variables\" and similar "
#~ "to operating-system functions such as"
#~ " pthread_cond_wait() plus pthread_cond_signal()."
#~ msgstr ""

#~ msgid ""
#~ "Call ``fiber.cond()`` to create a named"
#~ " condition variable, which will be "
#~ "called cond for examples in this "
#~ "section. Call ``cond:wait()`` to make a"
#~ " fiber wait for a signal via a"
#~ " condition variable. Call ``cond:signal()`` "
#~ "to send a signal to wake up "
#~ "a single fiber that has executed "
#~ "``cond:wait()``. Call ``cond:broadcast()`` to "
#~ "send a signal to all fibers that"
#~ " have executed ``cond:wait()``."
#~ msgstr ""

#~ msgid "Create a new condition variable."
#~ msgstr ""

#~ msgid "new condition variable."
#~ msgstr ""

#~ msgid "Lua object"
#~ msgstr ""

#~ msgid ""
#~ "Make the current fiber go to "
#~ "sleep, waiting until until another fiber"
#~ " invokes the ``signal()`` or "
#~ "``broadcast()`` method on the cond "
#~ "object. The sleep causes an implicit "
#~ ":ref:`fiber.yield() <fiber-yield>`."
#~ msgstr ""

#~ msgid "number of seconds to wait, default = forever."
#~ msgstr ""

#~ msgid ""
#~ "If timeout is provided, and a "
#~ "signal doesn't happen for the duration"
#~ " of the timeout, ``wait()`` returns "
#~ "false. If a signal or broadcast "
#~ "happens, ``wait()`` returns true."
#~ msgstr ""

#~ msgid ""
#~ "Wake up a single fiber that has"
#~ " executed ``wait()`` for the same "
#~ "variable."
#~ msgstr ""

#~ msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
#~ msgstr ""

#~ msgid ""
#~ "Assume that a tarantool server is "
#~ "running and listening for connections on"
#~ " localhost port 3301. Assume that "
#~ "guest users have privileges to connect."
#~ " We will use the tarantoolctl utility"
#~ " to start two clients."
#~ msgstr ""

#~ msgid "On terminal #1, say"
#~ msgstr ""

#~ msgid ""
#~ "tarantoolctl connect '3301'\n"
#~ "fiber = require('fiber')\n"
#~ "cond = fiber.cond()\n"
#~ "cond:wait()"
#~ msgstr ""

#~ msgid ""
#~ "The job will hang because "
#~ "``cond:wait()`` -- without an optional "
#~ "timeout argument -- will go to "
#~ "sleep until the condition variable "
#~ "changes."
#~ msgstr ""

#~ msgid "On terminal #2, say"
#~ msgstr ""

#~ msgid ""
#~ "tarantoolctl connect '3301'\n"
#~ "cond:signal()"
#~ msgstr ""

#~ msgid ""
#~ "Now look again at terminal #1. It"
#~ " will show that the waiting stopped,"
#~ " and the ``cond:wait()`` function returned"
#~ " ``true``."
#~ msgstr ""

#~ msgid ""
#~ "This example depended on the use "
#~ "of a global conditional variable with"
#~ " the arbitrary name ``cond``. In real"
#~ " life, programmers would make sure to"
#~ " use different conditional variable names"
#~ " for different applications."
#~ msgstr ""

#~ msgid ""
#~ "positive integer as great as the "
#~ "maximum number of slots (spaces for "
#~ "``get`` or ``put`` messages) that might"
#~ " be pending at any given time."
#~ msgstr ""

#~ msgid ""
#~ "Send a message using a channel. If"
#~ " the channel is full, ``channel:put()`` "
#~ "blocks until there is a free slot"
#~ " in the channel."
#~ msgstr ""

#~ msgid ""
#~ "If timeout is provided, and there "
#~ "is no free slot in the channel "
#~ "for the duration of the timeout, "
#~ "``channel:put()`` returns false. Otherwise it"
#~ " returns true."
#~ msgstr ""

#~ msgid ""
#~ "Close the channel. All waiters in "
#~ "the channel will be woken up. All"
#~ " following ``channel:put()`` or ``channel:get()``"
#~ " operations will return an error "
#~ "(``nil``)."
#~ msgstr ""

#~ msgid ""
#~ "Fetch a message from a channel. If"
#~ " the channel is empty, ``channel:get()``"
#~ " blocks until there is a message."
#~ msgstr ""

#~ msgid ""
#~ "the message placed on the channel "
#~ "by ``channel:put()``. If timeout is "
#~ "provided, and there is no message "
#~ "in the channel for the duration of"
#~ " the timeout, ``channel:get()`` returns "
#~ "nil."
#~ msgstr ""

#~ msgid "Check whether the specified channel is empty (has no messages)."
#~ msgstr ""

#~ msgid "true if the specified channel is empty"
#~ msgstr ""

#~ msgid ""
#~ "Find out how many messages are on"
#~ " the channel. The answer is 0 "
#~ "if the channel is empty."
#~ msgstr ""

#~ msgid "Check whether the specified channel is full."
#~ msgstr ""

#~ msgid "true if the specified channel is full (has no room for a new message)."
#~ msgstr ""

#~ msgid ""
#~ "Check whether the specified channel is"
#~ " empty and has readers waiting for"
#~ " a message (because they have issued"
#~ " ``channel:get()`` and then blocked)."
#~ msgstr ""

#~ msgid "true if blocked users are waiting. Otherwise false."
#~ msgstr ""

#~ msgid ""
#~ "Check whether the specified channel is"
#~ " full and has writers waiting "
#~ "(because they have issued ``channel:put()``"
#~ " and then blocked due to lack "
#~ "of room)."
#~ msgstr ""

#~ msgid "true if the specified channel is already closed. Otherwise false."
#~ msgstr ""

#~ msgid ""
#~ "Mode bits can be passed as a "
#~ "number or as string constants, for "
#~ "example ''`S_IWUSR`\". Mode bits are "
#~ "significant if flags include `O_CREATE` "
#~ "or `O_TMPFILE`. Mode bits can be "
#~ "combined by enclosing them in braces."
#~ msgstr ""

#~ msgid ""
#~ "Lua fun, also known as the Lua "
#~ "Functional Library, takes advantage of "
#~ "the features of LuaJIT to help "
#~ "users create complex functions. Inside "
#~ "the module are \"sequence processors\" "
#~ "such as map, filter, reduce, zip "
#~ "-- they take a user-written "
#~ "function as an argument and run it"
#~ " against every element in a sequence,"
#~ " which can be faster or more "
#~ "convenient than a user-written loop. "
#~ "Inside the module are \"generators\" "
#~ "such as range, tabulate, and rands "
#~ "-- they return a bounded or "
#~ "boundless series of values. Within the"
#~ " module are \"reducers\", \"filters\", "
#~ "\"composers\" ... or, in short, all "
#~ "the important features found in "
#~ "languages like Standard ML, Haskell, or"
#~ " Erlang."
#~ msgstr ""

#~ msgid ""
#~ "The full documentation is `On the "
#~ "luafun section of github`_. However, the"
#~ " first chapter can be skipped because"
#~ " installation is already done, it's "
#~ "inside Tarantool. All that is needed "
#~ "is the usual :code:`require` request. "
#~ "After that, all the operations described"
#~ " in the Lua fun manual will "
#~ "work, provided they are preceded by "
#~ "the name returned by the :code:`require`"
#~ " request. For example:"
#~ msgstr ""

#~ msgid ""
#~ "-- When nil is assigned to a Lua-table field, the field is null\n"
#~ "tarantool> {nil, 'a', 'b'}\n"
#~ "---\n"
#~ "- - null\n"
#~ "  - a\n"
#~ "  - b\n"
#~ "...\n"
#~ "-- When json.NULL is assigned to a"
#~ " Lua-table field, the field is "
#~ "json.NULL\n"
#~ "tarantool> {json.NULL, 'a', 'b'}\n"
#~ "---\n"
#~ "- - null\n"
#~ "  - a\n"
#~ "  - b\n"
#~ "...\n"
#~ "-- When json.NULL is assigned to a JSON field, the field is null\n"
#~ "tarantool> json.encode({field2 = json.NULL, "
#~ "field1 = 'a', field3 = 'c'}\n"
#~ "---\n"
#~ "- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
#~ "..."
#~ msgstr ""

#~ msgid "``cfg.encode_invalid_numbers`` - allow nan and inf (default is true)"
#~ msgstr ""

#~ msgid ""
#~ "``cfg.encode_use_tostring`` - use tostring for"
#~ " unrecognizable types (default is false)"
#~ msgstr ""

#~ msgid ""
#~ "``cfg.encode_invalid_as_nil`` - use null for"
#~ " all unrecognizable types (default is "
#~ "false)"
#~ msgstr ""

#~ msgid "``cfg.encode_load_metatables`` - load metatables (default is false)"
#~ msgstr ""

#~ msgid ""
#~ "The same configuration settings exist "
#~ "for json, for :ref:`MsgPack <msgpack-"
#~ "module>`, and for :ref:`YAML <yaml-"
#~ "module>`. >>>>>>> Fix every NOTE to "
#~ "be highlighted on site + JSON cfg"
#~ " rewritten"
#~ msgstr ""

#~ msgid ""
#~ "The Tarantool server puts all diagnostic"
#~ " messages in a log file specified "
#~ "by the :ref:`logger <cfg_logging-logger>` "
#~ "configuration parameter. Diagnostic messages "
#~ "may be either system-generated by "
#~ "the server's internal code, or user-"
#~ "generated with the ``log.log_level_function_name``"
#~ " function."
#~ msgstr ""

#~ msgid ""
#~ "The actual output will be a line"
#~ " containing the current timestamp, a "
#~ "module name, 'E' or 'W' or 'I' "
#~ "or 'D' or 'R' depending on "
#~ "``log_level_function_name``, and ``message``. Output"
#~ " will not occur if "
#~ "``log_level_function_name`` is for a type "
#~ "greater than :ref:`log_level <cfg_logging-"
#~ "log_level>`. Messages may contain C-style "
#~ "format specifiers %d or %s, so "
#~ ":samp:`log.error('...%d...%s',{x},{y})` will work if"
#~ " x is a number and y is a"
#~ " string."
#~ msgstr ""

#~ msgid ""
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
#~ "tarantool> log = require('log')\n"
#~ "tarantool> log.error('Error')\n"
#~ "tarantool> log.info('Info %s', box.info.version)\n"
#~ "tarantool> os.exit()\n"
#~ "$ less tarantool.txt"
#~ msgstr ""

#~ msgid ""
#~ "2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
#~ "2...1 [5257] main/101/interactive C> log level 3\n"
#~ "2...1 [5261] main/101/spawner C> initialized\n"
#~ "2...0 [5257] main/101/interactive [C]:-1 E> Error"
#~ msgstr ""

#~ msgid ""
#~ "The ``net.box`` module contains connectors "
#~ "to remote database systems. One variant,"
#~ " to be discussed later, is connecting"
#~ " to MySQL or MariaDB or PostgreSQL"
#~ " (see :ref:`SQL DBMS modules "
#~ "<dbms_modules>` reference). The other variant,"
#~ " which is discussed in this section,"
#~ " is connecting to Tarantool servers "
#~ "via a network using the built-in"
#~ " ``net.box`` module."
#~ msgstr ""

#~ msgid "You can call the following methods:"
#~ msgstr ""

#~ msgid ""
#~ "``require('net.box')`` to get a ``net.box``"
#~ " object (named ``net_box`` for examples "
#~ "in this section),"
#~ msgstr ""

#~ msgid ""
#~ "``net_box.new()`` to connect and get a"
#~ " connection object (named ``conn`` for "
#~ "examples in this section),"
#~ msgstr ""

#~ msgid ""
#~ "other ``net.box()`` routines, passing "
#~ "``conn:``, to execute requests on a "
#~ "remote box,"
#~ msgstr ""

#~ msgid ":ref:`conn:close <socket-close>` to disconnect."
#~ msgstr ""

#~ msgid ""
#~ "All ``net.box`` methods are fiber-safe,"
#~ " that is, it is safe to share"
#~ " and use the same connection object"
#~ " across multiple concurrent fibers. In "
#~ "fact, it's perhaps the best programming"
#~ " practice with Tarantool. When multiple "
#~ "fibers use the same connection, all "
#~ "requests are pipelined through the same"
#~ " network socket, but each fiber gets"
#~ " back a correct response. Reducing "
#~ "the number of active sockets lowers "
#~ "the overhead of system calls and "
#~ "increases the overall server performance. "
#~ "There are, however, cases when a "
#~ "single connection is not enough — "
#~ "for example, when it's necessary to "
#~ "prioritize requests or to use different"
#~ " authentication IDs."
#~ msgstr ""

#~ msgid ""
#~ "Since Tarantool 1.7.2, support for the"
#~ " Lua console protocol in ``net.box`` "
#~ "was dropped. Now only the binary "
#~ "protocol is supported."
#~ msgstr ""

#~ msgid "The diagram below shows possible connection states and transitions:"
#~ msgstr ""

#~ msgid ""
#~ "Create a new connection. The connection"
#~ " is established on demand, at the "
#~ "time of the first request. It can"
#~ " be re-established automatically after "
#~ "a disconnect (see ``reconnect_after`` option"
#~ " below). The returned ``conn`` object "
#~ "supports methods for making remote "
#~ "requests, such as select, update or "
#~ "delete."
#~ msgstr ""

#~ msgid ""
#~ "For a local Tarantool server, there "
#~ "is a pre-created always-established "
#~ "connection object named :samp:`{net_box}.self`. "
#~ "Its purpose is to make polymorphic "
#~ "use of the ``net_box`` API easier. "
#~ "Therefore :samp:`conn = "
#~ "{net_box}.new('localhost:3301')` can be replaced "
#~ "by :samp:`conn = {net_box}.self`. However, "
#~ "there is an important difference between"
#~ " the embedded connection and a remote"
#~ " one. With the embedded connection, "
#~ "requests which do not modify data "
#~ "do not yield. When using a remote"
#~ " connection, due to :ref:`the implicit "
#~ "rules <atomic-the_implicit_yield_rules>` any "
#~ "request can yield, and database state"
#~ " may have changed by the time "
#~ "it regains control."
#~ msgstr ""

#~ msgid "Possible options:"
#~ msgstr ""

#~ msgid ""
#~ "`wait_connected`: by default, connection "
#~ "creation is blocked until the connection"
#~ " is established, but passing "
#~ "``wait_connected=false`` makes it return "
#~ "immediately. Also, passing a timeout "
#~ "makes it wait before returning (e.g. "
#~ "``wait_connected=1.5`` makes it wait at "
#~ "most 1.5 secs). |br| Note: In the"
#~ " presence of ``reconnect_after``, "
#~ "``wait_connected`` ignores transient failures. "
#~ "The wait completes once the connection"
#~ " is established or is closed "
#~ "explicitly."
#~ msgstr ""

#~ msgid ""
#~ "`reconnect_after`: a ``net.box`` instance "
#~ "automatically reconnects any time the "
#~ "connection is broken or if a "
#~ "connection attempt fails. This makes "
#~ "transient network failures become transparent"
#~ " to the application. Reconnect happens "
#~ "automatically in the background, so "
#~ "queries/requests that suffered due to "
#~ "connectivity loss are transparently retried."
#~ " The number of retries is unlimited,"
#~ " connection attempts are done over "
#~ "the specified timeout (e.g. "
#~ "``reconnect_after=5`` for 5 secs). Once "
#~ "a connection is explicitly closed (or"
#~ " garbage-collected), reconnects stop."
#~ msgstr ""

#~ msgid ""
#~ "`call_16`: [since 1.7.2] by default, "
#~ "``net.box`` connections comply with a "
#~ "new binary protocol command for CALL,"
#~ " which is not backward compatible "
#~ "with previous versions. The new CALL "
#~ "no longer restricts a function to "
#~ "returning an array of tuples and "
#~ "allows returning an arbitrary MsgPack/JSON "
#~ "result, including scalars, nil and void"
#~ " (nothing). The old CALL is left "
#~ "intact for backward compatibility. It "
#~ "will be removed in the next major"
#~ " release. All programming language drivers"
#~ " will be gradually changed to use "
#~ "the new CALL. To connect to a "
#~ "Tarantool instance that uses the old "
#~ "CALL, specify ``call_16=true``."
#~ msgstr ""

#~ msgid "possible options are `wait_connected`, `reconnect_after` and `call_16`"
#~ msgstr ""

#~ msgid ""
#~ "conn = net_box.new('localhost:3301')\n"
#~ "conn = net_box.new('127.0.0.1:3302', {wait_connected = false})\n"
#~ "conn = net_box.new('127.0.0.1:3303', "
#~ "{reconnect_after = 5, call_16 = true})"
#~ msgstr ""

#~ msgid "in seconds"
#~ msgstr ""

#~ msgid "[since 1.7.2] Wait for a target state."
#~ msgstr ""

#~ msgid "target states"
#~ msgstr ""

#~ msgid ""
#~ "true when a target state is "
#~ "reached, false on timeout or connection"
#~ " closure"
#~ msgstr ""

#~ msgid ""
#~ "-- wait infinitely for 'active' state:\n"
#~ "conn:wait_state('active')\n"
#~ "\n"
#~ "-- wait for 1.5 secs at most:\n"
#~ "conn:wait_state('active', 1.5)\n"
#~ "\n"
#~ "-- wait infinitely for either `active` or `fetch_schema` state:\n"
#~ "conn:wait_state({active=true, fetch_schema=true})"
#~ msgstr ""

#~ msgid ""
#~ "Due to :ref:`the implicit yield rules"
#~ " <atomic-the_implicit_yield_rules>` a local "
#~ ":samp:`box.space.{space-name}:select`:code:`{...}` does"
#~ " not yield, but a remote "
#~ ":samp:`conn.space.{space-name}:select`:code:`{...}` call"
#~ " does yield, so global variables or"
#~ " database tuples data may change when"
#~ " a remote :samp:`conn.space.{space-"
#~ "name}:select`:code:`{...}` occurs."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`conn:eval({Lua-string})` evaluates and "
#~ "executes the expression in Lua-string,"
#~ " which may be any statement or "
#~ "series of statements. An :ref:`execute "
#~ "privilege <authentication-privileges>` is "
#~ "required; if the user does not "
#~ "have it, an administrator may grant "
#~ "it with :samp:`box.schema.user.grant({username}, "
#~ "'execute', 'universe')`."
#~ msgstr ""

#~ msgid "This example shows the use of most of the ``net.box`` methods."
#~ msgstr ""

#~ msgid "The sandbox configuration for this example assumes that:"
#~ msgstr ""

#~ msgid "the Tarantool server is running on ``localhost 127.0.0.1:3301``,"
#~ msgstr ""

#~ msgid ""
#~ "there is a space named ``tester`` "
#~ "with a numeric primary key and "
#~ "with a tuple that contains a key"
#~ " value = 800,"
#~ msgstr ""

#~ msgid "the current user has read, write and execute privileges."
#~ msgstr ""

#~ msgid "Here are commands for a quick sandbox setup:"
#~ msgstr ""

#~ msgid ""
#~ "box.cfg{listen = 3301}\n"
#~ "s = box.schema.space.create('tester')\n"
#~ "s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
#~ "t = s:insert({800, 'TEST'})\n"
#~ "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
#~ msgstr ""

#~ msgid "And here starts the example:"
#~ msgstr ""

#~ msgid ""
#~ "Convert a string or a Lua number"
#~ " to a 64-bit integer. The result "
#~ "can be used in arithmetic, and the"
#~ " arithmetic will be 64-bit integer "
#~ "arithmetic rather than floating-point "
#~ "arithmetic. (Operations on an unconverted "
#~ "Lua number use floating-point "
#~ "arithmetic.) The ``tonumber64()`` function is"
#~ " added by Tarantool; the name is "
#~ "global."
#~ msgstr ""

#~ msgid ""
#~ "Typically a socket session will begin"
#~ " with the setup functions, will set"
#~ " one or more flags, will have a"
#~ " loop with sending and receiving "
#~ "functions, will end with the teardown"
#~ " functions -- as an example at "
#~ "the end of this section will show."
#~ " Throughout, there may be error-"
#~ "checking and waiting functions for "
#~ "synchronization. To prevent a fiber "
#~ "containing socket functions from \"blocking\""
#~ " other fibers, the :ref:`implicit yield "
#~ "rules <atomic-the_implicit_yield_rules>` will "
#~ "cause a yield so that other "
#~ "processes may take over, as is the"
#~ " norm for cooperative multitasking."
#~ msgstr ""

#~ msgid ""
#~ "Parameters: ``host`` = (string) host "
#~ "name or IP; ``port`` = (integer) "
#~ "host port, may be 0; ``handler-"
#~ "function`` = (function or table "
#~ "containing function) what to execute "
#~ "when a connection occurs; ``timeout`` ="
#~ " (integer) number of seconds to wait"
#~ " before timing out."
#~ msgstr ""

#~ msgid ""
#~ "The handler-function parameter may be"
#~ " a function name (for example "
#~ "``function_55``) a function declaration (for"
#~ " example ``function () print('!') end``),"
#~ " or a table including handler = "
#~ "function (for example ``{handler=function_55, "
#~ "name='A'}``)."
#~ msgstr ""

#~ msgid ""
#~ "In this example a connection is "
#~ "made over the internet between the "
#~ "Tarantool server and tarantool.org, then "
#~ "an HTTP \"head\" message is sent, "
#~ "and a response is received: \"``HTTP/1.1"
#~ " 200 OK``\" or something else if "
#~ "the site has moved. This is not"
#~ " a useful way to communicate with "
#~ "this particular site, but shows that "
#~ "the system works."
#~ msgstr ""

#~ msgid ""
#~ "Start two shells. The first shell "
#~ "will be the server. The second "
#~ "shell will be the client."
#~ msgstr ""

#~ msgid ""
#~ "On the second shell, use the socat"
#~ " utility to ship the tmp.txt file "
#~ "to the server's host and port:"
#~ msgstr ""

#~ msgid ""
#~ "tarantool> tarantool = require('tarantool')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> tarantool\n"
#~ "---\n"
#~ "- build:\n"
#~ "    target: Linux-x86_64-RelWithDebInfo\n"
#~ "    options: cmake . "
#~ "-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
#~ "    mod_format: so\n"
#~ "    flags: ' -fno-common -fno-"
#~ "omit-frame-pointer -fno-stack-protector "
#~ "-fexceptions\n"
#~ "      -funwind-tables -fopenmp -msse2 "
#~ "-std=c11 -Wall -Wextra -Wno-sign-compare"
#~ " -Wno-strict-aliasing\n"
#~ "      -fno-gnu89-inline'\n"
#~ "    compiler: /usr/bin/x86_64-linux-gnu-gcc"
#~ " /usr/bin/x86_64-linux-gnu-g++\n"
#~ "  uptime: 'function: 0x408668e0'\n"
#~ "  version: 1.7.0-66-g9093daa\n"
#~ "  pid: 'function: 0x40866900'\n"
#~ "...\n"
#~ "tarantool> tarantool.pid()\n"
#~ "---\n"
#~ "- 30155\n"
#~ "...\n"
#~ "tarantool> tarantool.uptime()\n"
#~ "---\n"
#~ "- 108.64641499519\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> uuid = require('uuid')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> uuid(), uuid.bin(), uuid.str()\n"
#~ "---\n"
#~ "- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
#~ "- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
#~ "- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
#~ "...\n"
#~ "tarantool> uu = uuid()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> #uui:bin(), #uu:str(), type(uu), uu:isnil()\n"
#~ "---\n"
#~ "- 16\n"
#~ "- 36\n"
#~ "- cdata\n"
#~ "- false\n"
#~ "..."
#~ msgstr ""

#~ msgid "Module `xlog`"
#~ msgstr ""

#~ msgid ""
#~ "The xlog module contains one function:"
#~ " pairs(). It can be used to "
#~ "read Tarantool's snapshot files or "
#~ "write-ahead-log (WAL) files. A "
#~ "description of the file format is "
#~ "in section :ref:`Data persistence and "
#~ "the WAL file format <internals-"
#~ "data_persistence>`."
#~ msgstr ""

#~ msgid "Open a file, and allow iterating over one file entry at a time."
#~ msgstr ""

#~ msgid ""
#~ "Return: `iterator <https://www.lua.org/pil/7.1.html>`_ "
#~ "which can be used in a for/end "
#~ "loop."
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: File does not contain"
#~ " properly formatted snapshot or write-"
#~ "ahead-log information."
#~ msgstr ""

#~ msgid ""
#~ "This will read the first write-"
#~ "ahead-log (WAL) file that was created"
#~ " in the :ref:`wal_dir <cfg_basic-wal_dir>`"
#~ " directory by the introductory sandbox "
#~ "exercise \":ref:`Starting Tarantool and making"
#~ " your first database "
#~ "<user_guide_getting_started-first_database>`“."
#~ msgstr ""

#~ msgid ""
#~ "Each result from ``pairs()`` is "
#~ "formatted with MsgPack so its structure"
#~ " can be specified with :ref:`__serialize"
#~ " <msgpack-serialize>`."
#~ msgstr ""

#~ msgid ""
#~ "xlog = require('xlog')\n"
#~ "t = {}\n"
#~ "for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
#~ "  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
#~ "  end\n"
#~ "return t"
#~ msgstr ""

#~ msgid "The first lines of the result will look like:"
#~ msgstr ""

#~ msgid ""
#~ "...\n"
#~ "---\n"
#~ "- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
#~ "                'tuple': [['+', 2, 1]]},\n"
#~ "     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
#~ "                'lsn': 1, 'server_id': 1}}\n"
#~ "  - {'BODY':   {'space_id': 280,\n"
#~ "                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
#~ "     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
#~ "                'lsn': 2, 'server_id': 1}}"
#~ msgstr ""

#~ msgid ""
#~ "The Tarantool rocks allow for connecting"
#~ " to an SQL server and executing "
#~ "SQL statements the same way that a"
#~ " MySQL or PostgreSQL client does. The"
#~ " SQL statements are visible as Lua"
#~ " methods. Thus Tarantool can serve as"
#~ " a \"MySQL Lua Connector\" or "
#~ "\"PostgreSQL Lua Connector\", which would "
#~ "be useful even if that was all "
#~ "Tarantool could do. But of course "
#~ "Tarantool is also a DBMS, so the"
#~ " module also is useful for any "
#~ "operations, such as database copying and"
#~ " accelerating, which work best when "
#~ "the application can work on both "
#~ "SQL and Tarantool inside the same "
#~ "Lua routine. The methods for "
#~ "connect/select/insert/etc. are similar to the"
#~ " ones in the :ref:`net.box <net_box-"
#~ "module>` module."
#~ msgstr ""

#~ msgid ""
#~ "It will be necessary to install "
#~ "Tarantool's MySQL driver shared library, "
#~ "load it, and use it to connect "
#~ "to a MySQL server. After that, one"
#~ " can pass any MySQL statement to "
#~ "the server and receive results, "
#~ "including multiple result sets."
#~ msgstr ""

#~ msgid ""
#~ "Check the instructions for :ref:`Downloading"
#~ " and installing a binary package "
#~ "<user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package>` that apply"
#~ " for the environment where tarantool "
#~ "was installed. In addition to installing"
#~ " ``tarantool``, install ``tarantool-dev``. "
#~ "For example, on Ubuntu, add the "
#~ "line"
#~ msgstr ""

#~ msgid "See also :ref:`Modules <modules>`."
#~ msgstr ""

#~ msgid ""
#~ "The example was run on an Ubuntu"
#~ " 12.04 (\"precise\") machine where "
#~ "tarantool had been installed in a "
#~ "/usr subdirectory, and a copy of "
#~ "MySQL had been installed on ~/mysql-5.5."
#~ " The mysqld server is already running"
#~ " on the local host 127.0.0.1."
#~ msgstr ""

#~ msgid ""
#~ "$ export TMDIR=~/mysql-5.5\n"
#~ "$ # Check that the include subdirectory exists by looking\n"
#~ "$ # for .../include/mysql.h. (If this fails, there's a chance\n"
#~ "$ # that it's in .../include/mysql/mysql.h instead.)\n"
#~ "$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
#~ "OK\n"
#~ "\n"
#~ "$ # Check that the library subdirectory exists and has the\n"
#~ "$ # necessary .so file.\n"
#~ "$ [ -f $TMDIR/lib/libmysqlclient.so ] &&"
#~ " echo \"OK\" || echo \"Error\"\n"
#~ "OK\n"
#~ "\n"
#~ "$ # Check that the mysql client can connect using some factory\n"
#~ "$ # defaults: port = 3306, user = 'root', user password = '',\n"
#~ "$ # database = 'test'. These can be changed, provided one uses\n"
#~ "$ # the changed values in all places.\n"
#~ "$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
#~ "    --password= --database=test\n"
#~ "Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
#~ "Your MySQL connection id is 25\n"
#~ "Server version: 5.5.35 MySQL Community Server (GPL)\n"
#~ "...\n"
#~ "Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
#~ "\n"
#~ "$ # Insert a row in database test, and quit.\n"
#~ "mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
#~ "Query OK, 0 rows affected (0.13 sec)\n"
#~ "mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
#~ "Query OK, 1 row affected (0.02 sec)\n"
#~ "mysql> QUIT\n"
#~ "Bye\n"
#~ "\n"
#~ "$ # Install luarocks\n"
#~ "$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
#~ "Setting up luarocks (2.0.8-2) ...\n"
#~ "\n"
#~ "$ # Set up the Tarantool rock list in ~/.luarocks,\n"
#~ "$ # following instructions at rocks.tarantool.org\n"
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
#~ "    ~/.luarocks/config.lua\n"
#~ "\n"
#~ "$ # Ensure that the next \"install\" will get files from Tarantool\n"
#~ "$ # master repository. The resultant display is normal for Ubuntu\n"
#~ "$ # 12.04 precise\n"
#~ "$ cat /etc/apt/sources.list.d/tarantool.list\n"
#~ "deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
#~ "deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
#~ "\n"
#~ "$ # Install tarantool-dev. The "
#~ "displayed line should show version = "
#~ "1.6\n"
#~ "$ sudo apt-get -y install "
#~ "tarantool-dev | grep -E \"Setting "
#~ "up|already\"\n"
#~ "Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
#~ "$\n"
#~ "\n"
#~ "$ # Use luarocks to install locally, that is, relative to $HOME\n"
#~ "$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
#~ "Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
#~ "... (more info about building the "
#~ "Tarantool/MySQL driver appears here)\n"
#~ "mysql scm-1 is now built and installed in ~/.luarocks/\n"
#~ "\n"
#~ "$ # Ensure driver.so now has been created in a place\n"
#~ "$ # tarantool will look at\n"
#~ "$ find ~/.luarocks -name \"driver.so\"\n"
#~ "~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
#~ "\n"
#~ "$ # Change directory to a directory which can be used for\n"
#~ "$ # temporary tests. For this example we assume that the name\n"
#~ "$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
#~ "$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
#~ "$ # home directory for the machine that's used for this test.)\n"
#~ "$ cd /home/pgulutzan/tarantool_sandbox\n"
#~ "\n"
#~ "$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
#~ "\n"
#~ "$ tarantool\n"
#~ "tarantool: version 1.7.0-222-g48b98bb\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool>"
#~ msgstr ""

#~ msgid ""
#~ "Create a Lua function that will "
#~ "connect to the MySQL server, (using "
#~ "some factory default values for the "
#~ "port and user and password), retrieve"
#~ " one row, and display the row. "
#~ "For explanations of the statement types"
#~ " used here, read the Lua tutorial "
#~ "earlier in the Tarantool user manual."
#~ msgstr ""

#~ msgid ""
#~ "It will be necessary to install "
#~ "Tarantool's PostgreSQL driver shared library,"
#~ " load it, and use it to connect"
#~ " to a PostgreSQL server. After that,"
#~ " one can pass any PostgreSQL "
#~ "statement to the server and receive "
#~ "results."
#~ msgstr ""

#~ msgid ""
#~ "Check the instructions for :ref:`Downloading"
#~ " and installing a binary package "
#~ "<user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package>` that apply"
#~ " for the environment where tarantool "
#~ "was installed. In addition to installing"
#~ " ``tarantool``, install ``tarantool-dev``. "
#~ "For example, on Ubuntu, add the "
#~ "line:"
#~ msgstr ""

#~ msgid ""
#~ "The example was run on an Ubuntu"
#~ " 12.04 (\"precise\") machine where "
#~ "tarantool had been installed in a "
#~ "/usr subdirectory, and a copy of "
#~ "PostgreSQL had been installed on /usr."
#~ " The PostgreSQL server is already "
#~ "running on the local host 127.0.0.1."
#~ msgstr ""

#~ msgid ""
#~ "$ # Check that the include subdirectory exists\n"
#~ "$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
#~ "$ [ -f /usr/include/postgresql/libpq-fe.h "
#~ "] && echo \"OK\" || echo \"Error\""
#~ "\n"
#~ "OK\n"
#~ "\n"
#~ "$ # Check that the library "
#~ "subdirectory exists and has the "
#~ "necessary .so file.\n"
#~ "$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so "
#~ "] && echo \"OK\" || echo \"Error\""
#~ "\n"
#~ "OK\n"
#~ "\n"
#~ "$ # Check that the psql client "
#~ "can connect using some factory defaults:"
#~ "\n"
#~ "$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
#~ "$ # database = 'postgres'. These can be changed, provided one changes\n"
#~ "$ # them in all places. Insert a row in database postgres, and quit.\n"
#~ "$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
#~ "Password for user postgres:\n"
#~ "psql (9.3.10)\n"
#~ "SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
#~ "Type \"help\" for help.\n"
#~ "\n"
#~ "postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
#~ "CREATE TABLE\n"
#~ "postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
#~ "INSERT 0 1\n"
#~ "postgres=# \\q\n"
#~ "$\n"
#~ "\n"
#~ "$ # Install luarocks\n"
#~ "$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
#~ "Setting up luarocks (2.0.8-2) ...\n"
#~ "\n"
#~ "$ # Set up the Tarantool rock list in ~/.luarocks,\n"
#~ "$ # following instructions at rocks.tarantool.org\n"
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
#~ "        ~/.luarocks/config.lua\n"
#~ "\n"
#~ "$ # Ensure that the next "
#~ "\"install\" will get files from "
#~ "Tarantool master\n"
#~ "$ # repository. The resultant display"
#~ " is normal for Ubuntu 12.04 precise"
#~ "\n"
#~ "$ cat /etc/apt/sources.list.d/tarantool.list\n"
#~ "deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
#~ "deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
#~ "\n"
#~ "$ # Install tarantool-dev. The "
#~ "displayed line should show version = "
#~ "1.7\n"
#~ "$ sudo apt-get -y install "
#~ "tarantool-dev | grep -E \"Setting "
#~ "up|already\"\n"
#~ "Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
#~ "$\n"
#~ "\n"
#~ "$ # Use luarocks to install locally, that is, relative to $HOME\n"
#~ "$ luarocks install pg "
#~ "POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
#~ ""
#~ "Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
#~ "... (more info about building the "
#~ "Tarantool/PostgreSQL driver appears here)\n"
#~ "pg scm-1 is now built and installed in ~/.luarocks/\n"
#~ "\n"
#~ "$ # Ensure driver.so now has been created in a place\n"
#~ "$ # tarantool will look at\n"
#~ "$ find ~/.luarocks -name \"driver.so\"\n"
#~ "~/.luarocks/lib/lua/5.1/pg/driver.so\n"
#~ "\n"
#~ "$ # Change directory to a directory which can be used for\n"
#~ "$ # temporary tests. For this example we assume that the\n"
#~ "$ # name of this directory is $HOME/tarantool_sandbox.\n"
#~ "$ # (Change \"$HOME\" to whatever is the user's actual\n"
#~ "$ # home directory for the machine that's used for this test.)\n"
#~ "cd $HOME/tarantool_sandbox\n"
#~ "\n"
#~ "$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
#~ "\n"
#~ "$ tarantool\n"
#~ "tarantool: version 1.7.0-412-g803b15c\n"
#~ "type 'help' for interactive help\n"
#~ "tarantool>"
#~ msgstr ""

#~ msgid ""
#~ "Create a Lua function that will "
#~ "connect to the PostgreSQL server, (using"
#~ " some factory default values for the"
#~ " port and user and password), "
#~ "retrieve one row, and display the "
#~ "row. For explanations of the statement"
#~ " types used here, read the Lua "
#~ "tutorial earlier in the Tarantool user"
#~ " manual."
#~ msgstr ""

#~ msgid ""
#~ "fiber = require('fiber')\n"
#~ "expd = require('expirationd')\n"
#~ "box.cfg{}\n"
#~ "e = box.schema.space.create('expirationd_test')\n"
#~ "e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
#~ "e:replace{1, fiber.time() + 3}\n"
#~ "e:replace{2, fiber.time() + 30}\n"
#~ "function is_tuple_expired(args, tuple)\n"
#~ "  if (tuple[2] < fiber.time()) then return true end\n"
#~ "  return false\n"
#~ "  end\n"
#~ "expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
#~ "retval = {}\n"
#~ "fiber.sleep(2)\n"
#~ "expd.task_stats()\n"
#~ "fiber.sleep(2)\n"
#~ "expd.task_stats()\n"
#~ "expd.kill_task('expirationd_test')\n"
#~ "e:drop()\n"
#~ "os.exit()"
#~ msgstr ""

#~ msgid ""
#~ "With sharding, the tuples of a "
#~ "tuple set are distributed to multiple"
#~ " nodes, with a Tarantool database "
#~ "server on each node. With this "
#~ "arrangement, each server is handling "
#~ "only a subset of the total data,"
#~ " so larger loads can be handled "
#~ "by simply adding more computers to "
#~ "a network."
#~ msgstr ""

#~ msgid ""
#~ "A temporary list of recent update "
#~ "requests. Sometimes called \"batching\". Since"
#~ " updates to a sharded database can"
#~ " be slow, it may speed up "
#~ "throughput to send requests to a "
#~ "queue rather than wait for the "
#~ "update to finish on ever node. The"
#~ " shard module has functions for "
#~ "adding requests to the queue, which "
#~ "it will process without further "
#~ "intervention. Queuing is optional."
#~ msgstr ""

#~ msgid "The number of replicas in each shard."
#~ msgstr ""

#~ msgid ""
#~ "A complete copy of the data. The"
#~ " shard module handles both sharding "
#~ "and replication. One shard can contain"
#~ " one or more replicas. When a "
#~ "write occurs, the write is attempted "
#~ "on every replica in turn. The "
#~ "shard module does not use the "
#~ "built-in replication feature."
#~ msgstr ""

#~ msgid ""
#~ "A physical location where the nodes "
#~ "are closely connected, with the same "
#~ "security and backup and access points."
#~ " The simplest example of a zone "
#~ "is a single computer with a single"
#~ " tarantool-server instance. A shard's "
#~ "replicas should be in different zones."
#~ msgstr ""

#~ msgid "sudo apt-get install tarantool-shard tarantool-pool"
#~ msgstr ""

#~ msgid ""
#~ "Or, download from github tarantool/shard "
#~ "and compile as described in the "
#~ "README. Then, before using the module,"
#~ " say ``shard = require('shard')``"
#~ msgstr ""

#~ msgid ""
#~ "Possible Errors: Redundancy should not "
#~ "be greater than the number of "
#~ "servers; the servers must be alive; "
#~ "two replicas of the same shard "
#~ "should not be in the same zone."
#~ msgstr ""

#~ msgid ""
#~ "The number of replicas per shard "
#~ "(redundancy) is 3. The number of "
#~ "servers is 3. The shard module "
#~ "will conclude that there is only "
#~ "one shard."
#~ msgstr ""

#~ msgid ""
#~ "This describes three shards. Each shard"
#~ " has two replicas. Since the number"
#~ " of servers is 7, and the "
#~ "number of replicas per shard is 2,"
#~ " and dividing 7 / 2 leaves a"
#~ " remainder of 1, one of the "
#~ "servers will not be used. This is"
#~ " not necessarily an error, because "
#~ "perhaps one of the servers in the"
#~ " list is not alive."
#~ msgstr ""

#~ msgid ""
#~ "There is only one shard, and that"
#~ " shard contains only one replica. So"
#~ " this isn't illustrating the features "
#~ "of either replication or sharding, it's"
#~ " only illustrating what the syntax "
#~ "is, and what the messages look "
#~ "like, that anyone could duplicate in "
#~ "a minute or two with the magic "
#~ "of cut-and-paste."
#~ msgstr ""

#~ msgid ""
#~ "$ mkdir ~/tarantool_sandbox_1\n"
#~ "$ cd ~/tarantool_sandbox_1\n"
#~ "$ rm -r *.snap\n"
#~ "$ rm -r *.xlog\n"
#~ "$ ~/tarantool-1.7/src/tarantool\n"
#~ "\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.space.create('tester')\n"
#~ "tarantool> box.space.tester:create_index('primary', {})\n"
#~ "tarantool> box.schema.user.passwd('admin', 'password')\n"
#~ "tarantool> cfg = {\n"
#~ "         >   servers = {\n"
#~ "         >       { uri = 'localhost:3301', zone = '1' },\n"
#~ "         >   },\n"
#~ "         >   login = 'admin';\n"
#~ "         >   password = 'password';\n"
#~ "         >   redundancy = 1;\n"
#~ "         >   binary = 3301;\n"
#~ "         > }\n"
#~ "tarantool> shard = require('shard')\n"
#~ "tarantool> shard.init(cfg)\n"
#~ "tarantool> -- Now put something in ...\n"
#~ "tarantool> shard.tester:insert{1,'Tuple #1'}"
#~ msgstr ""

#~ msgid ""
#~ "There are two shards, and each "
#~ "shard contains one replica. This "
#~ "requires two nodes. In real life "
#~ "the two nodes would be two "
#~ "computers, but for this illustration the"
#~ " requirement is merely: start two "
#~ "shells, which we'll call Terminal#1 and"
#~ " Terminal #2."
#~ msgstr ""

#~ msgid ""
#~ "$ mkdir ~/tarantool_sandbox_1\n"
#~ "$ cd ~/tarantool_sandbox_1\n"
#~ "$ rm -r *.snap\n"
#~ "$ rm -r *.xlog\n"
#~ "$ ~/tarantool-1.7/src/tarantool\n"
#~ "\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.space.create('tester')\n"
#~ "tarantool> box.space.tester:create_index('primary', {})\n"
#~ "tarantool> box.schema.user.passwd('admin', 'password')\n"
#~ "tarantool> console = require('console')\n"
#~ "tarantool> cfg = {\n"
#~ "         >   servers = {\n"
#~ "         >     { uri = 'localhost:3301', zone = '1' },\n"
#~ "         >     { uri = 'localhost:3302', zone = '2' },\n"
#~ "         >   },\n"
#~ "         >   login = 'admin',\n"
#~ "         >   password = 'password',\n"
#~ "         >   redundancy = 1,\n"
#~ "         >   binary = 3301,\n"
#~ "         > }\n"
#~ "tarantool> shard = require('shard')\n"
#~ "tarantool> shard.init(cfg)\n"
#~ "tarantool> -- Now put something in ...\n"
#~ "tarantool> shard.tester:insert{1,'Tuple #1'}"
#~ msgstr ""

#~ msgid ""
#~ "$ mkdir ~/tarantool_sandbox_2\n"
#~ "$ cd ~/tarantool_sandbox_2\n"
#~ "$ rm -r *.snap\n"
#~ "$ rm -r *.xlog\n"
#~ "$ ~/tarantool-1.7/src/tarantool\n"
#~ "\n"
#~ "tarantool> box.cfg{listen = 3302}\n"
#~ "tarantool> box.schema.space.create('tester')\n"
#~ "tarantool> box.space.tester:create_index('primary', {})\n"
#~ "tarantool> box.schema.user.passwd('admin', 'password')\n"
#~ "tarantool> console = require('console')\n"
#~ "tarantool> cfg = {\n"
#~ "         >   servers = {\n"
#~ "         >     { uri = 'localhost:3301', zone = '1' };\n"
#~ "         >     { uri = 'localhost:3302', zone = '2' };\n"
#~ "         >   };\n"
#~ "         >   login = 'admin';\n"
#~ "         >   password = 'password';\n"
#~ "         >   redundancy = 1;\n"
#~ "         >   binary = 3302;\n"
#~ "         > }\n"
#~ "tarantool> shard = require('shard')\n"
#~ "tarantool> shard.init(cfg)\n"
#~ "tarantool> -- Now get something out ...\n"
#~ "tarantool> shard.tester:select{1}"
#~ msgstr ""

#~ msgid ""
#~ "Tarantool can call C code with "
#~ ":ref:`modules <modules-example_c>`, or with"
#~ " :ref:`ffi <cookbook-ffi_printf>`, or with"
#~ " C stored procedures. This tutorial "
#~ "only is about the third option, C"
#~ " stored procedures. In fact the "
#~ "routines are always \"C functions\" but"
#~ " the phrase \"stored procedure\" is "
#~ "commonly used for historical reasons."
#~ msgstr ""

#~ msgid ""
#~ "Check that these items exist on "
#~ "the computer: |br| * Tarantool 1.7 "
#~ "|br| * A gcc compiler, any modern"
#~ " version should work |br| * "
#~ "\"module.h\" |br| * \"msgpuck.h\" |br|"
#~ msgstr ""

#~ msgid ""
#~ "The \"module.h\" file will exist if "
#~ "Tarantool 1.7 was installed from source."
#~ " Otherwise Tarantool's \"developer\" package "
#~ "must be installed. For example on "
#~ "Ubuntu say |br| :code:`sudo apt-get "
#~ "install tarantool-dev` |br| or on "
#~ "Fedora say |br| :code:`dnf -y install"
#~ " tarantool-devel`"
#~ msgstr ""

#~ msgid ""
#~ "The \"msgpuck.h\" file will exist if "
#~ "Tarantool 1.7 was installed from source."
#~ " Otherwise the \"msgpuck\" package must "
#~ "be installed from "
#~ "`https://github.com/rtsisyk/msgpuck "
#~ "<https://github.com/rtsisyk/msgpuck>`_."
#~ msgstr ""

#~ msgid ""
#~ "Requests will be done using tarantool"
#~ " as a :ref:`client <administration-"
#~ "using_tarantool_as_a_client>`. Start tarantool, and"
#~ " enter these requests."
#~ msgstr ""

#~ msgid ""
#~ "We are going to use the "
#~ "\"tarantool_sandbox\" that was created in "
#~ "section :ref:`first database "
#~ "<user_guide_getting_started-first_database>`. So there"
#~ " is a single space, and a "
#~ "numeric primary key, and a running "
#~ "tarantool server which also serves as"
#~ " a client."
#~ msgstr ""

#~ msgid ""
#~ "In earlier versions of Tarantool, "
#~ "multi-line functions had to be "
#~ "enclosed within \"delimiters\". They are "
#~ "no longer necessary, and so they "
#~ "will not be used in this tutorial."
#~ " However, they are still supported. "
#~ "Users who wish to use delimiters, "
#~ "or users of older versions of "
#~ "Tarantool, should check the syntax "
#~ "description for :ref:`declaring a delimiter"
#~ " <administration-setting_delimiter>` before "
#~ "proceeding."
#~ msgstr ""

#~ msgid ""
#~ "We begin by declaring a variable "
#~ "\"``string_value``\". The word \"``local``\" "
#~ "means that string_value appears only in"
#~ " ``main_function``. If we didn't use "
#~ "\"``local``\" then ``string_value`` would be"
#~ " visible everywhere - even by other"
#~ " users using other clients connected "
#~ "to this server! Sometimes that's a "
#~ "very desirable feature for inter-client"
#~ " communication, but not this time."
#~ msgstr ""

#~ msgid ""
#~ "The standard Lua function `os.clock() "
#~ "<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>` "
#~ "will return the number of CPU "
#~ "seconds since the start. Therefore, by"
#~ " getting start_time = number of "
#~ "seconds just before the inserting, and"
#~ " then getting end_time = number of"
#~ " seconds just after the inserting, we"
#~ " can calculate (end_time - start_time) "
#~ "= elapsed time in seconds. We will"
#~ " display that value by putting it "
#~ "in a request without any assignments,"
#~ " which causes Tarantool to send the"
#~ " value to the client, which prints"
#~ " it. (Lua's answer to the C "
#~ "``printf()`` function, which is ``print()``,"
#~ " will also work.)"
#~ msgstr ""

#~ msgid ""
#~ "And the function is complete. Time "
#~ "to test it. Starting with an empty"
#~ " database, defined the same way as"
#~ " the sandbox database that was "
#~ "introduced in :ref:`first database "
#~ "<user_guide_getting_started-first_database>`,"
#~ msgstr ""

#~ msgid ""
#~ "-- if tester is left over from some previous test, destroy it\n"
#~ "box.space.tester:drop()\n"
#~ "box.schema.space.create('tester')\n"
#~ "box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
#~ msgstr ""

#~ msgid ""
#~ "function indexed_pattern_search(space_name, field_no, pattern)\n"
#~ "  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
#~ "  if (box.space[space_name] == nil) then\n"
#~ "    print(\"Error: Failed to find the specified space\")\n"
#~ "    return nil\n"
#~ "  end\n"
#~ "  local index_no = -1\n"
#~ "  for i=0,box.schema.INDEX_MAX,1 do\n"
#~ "    if (box.space[space_name].index[i] == nil) then break end\n"
#~ "    if (box.space[space_name].index[i].type == \"TREE\"\n"
#~ "        and "
#~ "box.space[space_name].index[i].parts[1].fieldno == "
#~ "field_no\n"
#~ "        and (box.space[space_name].index[i].parts[1].type"
#~ " == \"scalar\"\n"
#~ "        or box.space[space_name].index[i].parts[1].type"
#~ " == \"string\")) then\n"
#~ "      index_no = i\n"
#~ "      break\n"
#~ "    end\n"
#~ "  end\n"
#~ "  if (index_no == -1) then\n"
#~ "    print(\"Error: Failed to find an appropriate index\")\n"
#~ "    return nil\n"
#~ "  end\n"
#~ "  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
#~ "  local index_search_key = \"\"\n"
#~ "  local index_search_key_length = 0\n"
#~ "  local last_character = \"\"\n"
#~ "  local c = \"\"\n"
#~ "  local c2 = \"\"\n"
#~ "  for i=1,string.len(pattern),1 do\n"
#~ "    c = string.sub(pattern, i, i)\n"
#~ "    if (last_character ~= \"%\") then\n"
#~ "      if (c == '^' or c =="
#~ " \"$\" or c == \"(\" or c "
#~ "== \")\" or c == \".\"\n"
#~ "                   or c == \"[\" or "
#~ "c == \"]\" or c == \"*\" or"
#~ " c == \"+\"\n"
#~ "                   or c == \"-\" or c == \"?\") then\n"
#~ "        break\n"
#~ "      end\n"
#~ "      if (c == \"%\") then\n"
#~ "        c2 = string.sub(pattern, i + 1, i + 1)\n"
#~ "        if (string.match(c2, \"%p\") == nil) then break end\n"
#~ "        index_search_key = index_search_key .. c2\n"
#~ "      else\n"
#~ "        index_search_key = index_search_key .. c\n"
#~ "      end\n"
#~ "    end\n"
#~ "    last_character = c\n"
#~ "  end\n"
#~ "  index_search_key_length = string.len(index_search_key)\n"
#~ "  if (index_search_key_length < 3) then\n"
#~ "    print(\"Error: index search key \""
#~ " .. index_search_key .. \" is too "
#~ "short\")\n"
#~ "    return nil\n"
#~ "  end\n"
#~ "  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
#~ "  local result_set = {}\n"
#~ "  local number_of_tuples_in_result_set = 0\n"
#~ "  local previous_tuple_field = \"\"\n"
#~ "  while true do\n"
#~ "    local number_of_tuples_since_last_yield = 0\n"
#~ "    local is_time_for_a_yield = false\n"
#~ "    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
#~ "    for _,tuple in box.space[space_name].index[index_no]:\n"
#~ "    pairs(index_search_key,{iterator = box.index.GE}) do\n"
#~ "      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
#~ "      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
#~ "      > index_search_key) then\n"
#~ "        break\n"
#~ "      end\n"
#~ "      -- SEE NOTE #6 \"INNER LOOP:"
#~ " BREAK AFTER EVERY 10 TUPLES -- "
#~ "MAYBE\"\n"
#~ "      number_of_tuples_since_last_yield = "
#~ "number_of_tuples_since_last_yield + 1\n"
#~ "      if (number_of_tuples_since_last_yield >= 10\n"
#~ "          and tuple[field_no] ~= previous_tuple_field) then\n"
#~ "        index_search_key = tuple[field_no]\n"
#~ "        is_time_for_a_yield = true\n"
#~ "        break\n"
#~ "        end\n"
#~ "      previous_tuple_field = tuple[field_no]\n"
#~ "      -- SEE NOTE #7 \"INNER LOOP:"
#~ " ADD TO RESULT SET IF PATTERN "
#~ "MATCHES\"\n"
#~ "      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
#~ "        number_of_tuples_in_result_set = "
#~ "number_of_tuples_in_result_set + 1\n"
#~ "        result_set[number_of_tuples_in_result_set] = tuple\n"
#~ "      end\n"
#~ "    end\n"
#~ "    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
#~ "    if (is_time_for_a_yield ~= true) then\n"
#~ "      break\n"
#~ "    end\n"
#~ "    require('fiber').yield()\n"
#~ "  end\n"
#~ "  return result_set\n"
#~ "end"
#~ msgstr ""

#~ msgid ""
#~ "NOTE #1 \"FIND AN APPROPRIATE INDEX\""
#~ " |br| The caller has passed "
#~ "space_name (a string) and field_no (a"
#~ " number). The requirements are: |br| "
#~ "(a) index type must be \"TREE\" "
#~ "because for other index types (HASH, "
#~ "BITSET, RTREE) a search with iterator=GE"
#~ " will not return strings in order "
#~ "by string value; |br| (b) field_no "
#~ "must be the first index part; |br|"
#~ " (c) the field must contain strings,"
#~ " because for other data types (such"
#~ " as \"unsigned\") pattern searches are "
#~ "not possible; |br| If these requirements"
#~ " are not met by any index, then"
#~ " print an error message and return"
#~ " nil."
#~ msgstr ""

#~ msgid ""
#~ "box.space.t:drop()\n"
#~ "box.schema.space.create('t')\n"
#~ "box.space.t:create_index('primary',{})\n"
#~ "box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
#~ "\n"
#~ "box.space.t:insert{1,'A','a'}\n"
#~ "box.space.t:insert{2,'AB',''}\n"
#~ "box.space.t:insert{3,'ABC','a'}\n"
#~ "box.space.t:insert{4,'ABCD',''}\n"
#~ "box.space.t:insert{5,'ABCDE','a'}\n"
#~ "box.space.t:insert{6,'ABCDE',''}\n"
#~ "box.space.t:insert{7,'ABCDEF','a'}\n"
#~ "box.space.t:insert{8,'ABCDF',''}\n"
#~ "indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
#~ msgstr ""

#~ msgid ""
#~ "Here is a summary of significant "
#~ "changes introduced in specific versions "
#~ "of Tarantool."
#~ msgstr ""
#~ "Здесь собрана информация о существенных "
#~ "изменениях, которые произошли в конкретных "
#~ "версиях Tarantool'а."

#~ msgid "What's new in Tarantool 1.7?"
#~ msgstr "Что нового в Tarantool 1.7?"

#~ msgid ""
#~ "The disk-based storge engine, which "
#~ "was called `sophia` or `phia` in "
#~ "earlier versions, is superseded by the"
#~ " `vinyl` storage engine."
#~ msgstr ""
#~ "Дисковый движок, который в более ранних"
#~ " версиях Tarantool'а назывался `sophia` и"
#~ " `phia`, заменен новым движком под "
#~ "названием `vinyl`."

#~ msgid "There are new types for indexed fields."
#~ msgstr "Добавлены новые типы индексируемых полей."

#~ msgid "The LuaJIT version is updated."
#~ msgstr "Обновлена версия LuaJIT."

#~ msgid ""
#~ "Automatic replication cluster bootstrap (to"
#~ " make it easier to configure a "
#~ "new replication cluster) is supported."
#~ msgstr ""
#~ "У кластера репликации появилась возможность"
#~ " самонастройки, что существенно упрощает "
#~ "настройку нового кластера."

#~ msgid "The ``space_object:inc()`` function is removed."
#~ msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#~ msgid "The ``space_object:dec()`` function is removed."
#~ msgstr "Функция ``space_object:dec()`` объявлена устаревшей."

#~ msgid ""
#~ "The contents of the ``box`` library "
#~ "can be inspected at runtime with "
#~ "``box``, with no arguments. The "
#~ "submodules inside the box library are:"
#~ " ``box.schema``, ``box.tuple``, ``box.space``, "
#~ "``box.index``, ``box.cfg``, ``box.info``, "
#~ "``box.slab``, ``box.stat``. Every submodule "
#~ "contains one or more Lua functions. "
#~ "A few submodules contain members as "
#~ "well as functions. The functions allow"
#~ " data definition (create alter drop), "
#~ "data manipulation (insert delete update "
#~ "upsert select replace), and introspection "
#~ "(inspecting contents of spaces, accessing "
#~ "server configuration)."
#~ msgstr ""

#~ msgid ""
#~ "See also :ref:`fiber.time64 <fiber-time64>`"
#~ " and :ref:`os.clock() <os-clock>`."
#~ msgstr ""

#~ msgid ""
#~ "Set the auto-completion flag. If "
#~ "auto-completion is `true`, and the "
#~ "user is using tarantool as a "
#~ "client, then hitting the TAB key "
#~ "may cause tarantool to complete a "
#~ "word automatically. The default auto-"
#~ "completion value is `true`."
#~ msgstr ""

#~ msgid ""
#~ ":samp:`chunk-size = {number}` -- number"
#~ " of characters to read at once "
#~ "(usually for file-IO efficiency), "
#~ "default = 4096"
#~ msgstr ""

#~ msgid ""
#~ "In the current version of the "
#~ "binary protocol, error message, which is"
#~ " normally more descriptive than error "
#~ "code, is not present in server "
#~ "response. The actual message may contain"
#~ " a file name, a detailed reason "
#~ "or operating system error code. All "
#~ "such messages, however, are logged in"
#~ " the error log. Below follow only "
#~ "general descriptions of some popular "
#~ "codes. A complete list of errors "
#~ "can be found in file `errcode.h`_ "
#~ "in the source tree."
#~ msgstr ""

#~ msgid ""
#~ "If timeout is provided, and the "
#~ "channel doesn't become empty for the "
#~ "duration of the timeout, ``channel:put()`` "
#~ "returns false. Otherwise it returns "
#~ "true."
#~ msgstr ""

#~ msgid "the value placed on the channel by an earlier ``channel:put()``."
#~ msgstr ""

#~ msgid "lua_object"
#~ msgstr ""

#~ msgid "Module `jit`"
#~ msgstr ""

#~ msgid ""
#~ "The ``jit`` module has functions for "
#~ "tracing the LuaJIT Just-In-Time "
#~ "compiler's progress, showing the byte-"
#~ "code or assembler output that the "
#~ "compiler produces, and in general "
#~ "providing information about what LuaJIT "
#~ "does with Lua code."
#~ msgstr ""

#~ msgid "Prints the byte code of a function."
#~ msgstr ""

#~ msgid ""
#~ "function f()\n"
#~ "  print(\"D\")\n"
#~ "end\n"
#~ "jit.bc.dump(f)"
#~ msgstr ""

#~ msgid "For a list of available options, read `the source code of bc.lua`_."
#~ msgstr ""

#~ msgid "Prints the i386 assembler code of a string of bytes"
#~ msgstr ""

#~ msgid ""
#~ "-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
#~ "jit.dis_x86.disass('\\x97')"
#~ msgstr ""

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of dis_x86.lua`_."
#~ msgstr ""

#~ msgid "Prints the x86-64 assembler code of a string of bytes"
#~ msgstr ""

#~ msgid ""
#~ "-- Disassemble hexadecimal 97 which is"
#~ " the x86-64 code for xchg eax, "
#~ "edi\n"
#~ "jit.dis_x64.disass('\\x97')"
#~ msgstr ""

#~ msgid ""
#~ "For a list of available options, "
#~ "read `the source code of dis_x64.lua`_."
#~ msgstr ""

#~ msgid "Prints the intermediate or machine code of following Lua code"
#~ msgstr ""

#~ msgid ""
#~ "-- Show the machine code of a Lua \"for\" loop\n"
#~ "jit.dump.on('m')\n"
#~ "local x = 0;\n"
#~ "for i = 1, 1e6 do\n"
#~ "  x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.dump.off()"
#~ msgstr ""

#~ msgid "For a list of available options, read `the source code of dump.lua`_."
#~ msgstr ""

#~ msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
#~ msgstr ""

#~ msgid ""
#~ "-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
#~ "jit.v.on()\n"
#~ "local x = 0\n"
#~ "for i = 1, 1e6 do\n"
#~ "    x = x + i\n"
#~ "end\n"
#~ "print(x)\n"
#~ "jit.v.off()"
#~ msgstr ""

#~ msgid "For a list of available options, read `the source code of v.lua`_."
#~ msgstr ""

#~ msgid ""
#~ "The ``net.box`` module contains connectors "
#~ "to remote database systems. One variant,"
#~ " to be discussed later, is for "
#~ "connecting to MySQL or MariaDB or "
#~ "PostgreSQL — that variant is the "
#~ "subject of the :ref:`SQL DBMS modules"
#~ " <dbms_modules>` appendix. In this section"
#~ " the subject is the built-in "
#~ "variant, ``net.box``. This is for "
#~ "connecting to tarantool servers via a"
#~ " network."
#~ msgstr ""

#~ msgid ""
#~ "For the local tarantool server there "
#~ "is a pre-created always-established "
#~ "connection object named :samp:`{net_box}.self`. "
#~ "Its purpose is to make polymorphic "
#~ "use of the ``net_box`` API easier. "
#~ "Therefore :samp:`conn = "
#~ "{net_box}.new('localhost:3301')` can be replaced "
#~ "by :samp:`conn = {net_box}.self`. However, "
#~ "there is an important difference between"
#~ " the embedded connection and a remote"
#~ " one. With the embedded connection, "
#~ "requests which do not modify data "
#~ "do not yield. When using a remote"
#~ " connection, due to :ref:`the implicit "
#~ "rules <atomic-the_implicit_yield_rules>` any "
#~ "request can yield, and database state"
#~ " may have changed by the time "
#~ "it regains control."
#~ msgstr ""

#~ msgid ""
#~ "due to :ref:`the implicit yield rules"
#~ " <atomic-the_implicit_yield_rules>` a local "
#~ ":samp:`box.space.{space-name}:select`:code:`{...}` does"
#~ " not yield, but a remote "
#~ ":samp:`conn.space.{space-name}:select`:code:`{...}` call"
#~ " does yield, so global variables or"
#~ " database tuples data may change when"
#~ " a remote :samp:`conn.space.{space-"
#~ "name}:select`:code:`{...}` occurs."
#~ msgstr ""

#~ msgid ""
#~ "The os module contains the functions "
#~ ":ref:`execute() <os-execute>`, :ref:`rename() "
#~ "<os-rename>`, :ref:`getenv() <os-getenv>`, "
#~ ":ref:`remove() <os-remove>`, :ref:`date() "
#~ "<os-date>`, :ref:`exit() <os-exit>`, "
#~ ":ref:`time() <os-time>`, :ref:`clock() <os-"
#~ "clock>`, :ref:`tmpname() <os-tmpname>`. Most"
#~ " of these functions are described in"
#~ " the Lua manual Chapter 22 `The "
#~ "Operating System Library "
#~ "<https://www.lua.org/pil/contents.html#22>`_."
#~ msgstr ""

#~ msgid "Exit the program. If this is done on the server, then the server stops."
#~ msgstr ""

#~ msgid "tcp_connect('127.0.0.1', 3301)"
#~ msgstr ""

#~ msgid ""
#~ "The ``socket.tcp_server()`` function makes "
#~ "Tarantool act as a server that can"
#~ " accept connections. Usually the same "
#~ "objective is accomplished with "
#~ "``box.cfg{listen=...)``."
#~ msgstr ""

#~ msgid "socket.tcp_server('localhost', 3302, function () end)"
#~ msgstr ""

#~ msgid ""
#~ "maximum number of bytes to read "
#~ "for example 50 means \"stop after "
#~ "50 bytes\""
#~ msgstr ""

#~ msgid ""
#~ "Return all available data from the "
#~ "socket buffer if non-blocking. Rarely"
#~ " used. For details see `this "
#~ "description`_."
#~ msgstr ""

#~ msgid ""
#~ "In this example a connection is "
#~ "made over the internet between the "
#~ "Tarantool server and tarantool.org, then "
#~ "an HTTP \"head\" message is sent, "
#~ "and a response is received: \"``HTTP/1.1"
#~ " 200 OK``\". This is not a "
#~ "useful way to communicate with this "
#~ "particular site, but shows that the "
#~ "system works."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> socket = require('socket')\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> type(sock)\n"
#~ "---\n"
#~ "- table\n"
#~ "...\n"
#~ "tarantool> sock:error()\n"
#~ "---\n"
#~ "- null\n"
#~ "...\n"
#~ "tarantool> sock:send(\"HEAD / HTTP/1.0rnHost: tarantool.orgrnrn\")\n"
#~ "---\n"
#~ "- true\n"
#~ "...\n"
#~ "tarantool> sock:read(17)\n"
#~ "---\n"
#~ "- \"HTTP/1.1 200 OKrn\"\n"
#~ "...\n"
#~ "tarantool> sock:close()\n"
#~ "---\n"
#~ "- true\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "Additionally one can see the uptime "
#~ "and the server version and the "
#~ "process id. Those information items can"
#~ " also be accessed with :ref:`box.info "
#~ "<box_introspection-box_info>` but use of "
#~ "the tarantool module is recommended."
#~ msgstr ""

#~ msgid ""
#~ "Form a Lua iterator function for "
#~ "going through CSV records one field "
#~ "at a time."
#~ msgstr ""

#~ msgid ""
#~ "Local storage within the fiber. The "
#~ "storage can contain any number of "
#~ "named values, subject to memory "
#~ "limitations. Naming may be done with "
#~ ":samp:`{fiber_object}.storage.{name}` or "
#~ ":samp:`fiber_object}.storage['{name}'].` or with a"
#~ " number :samp:`{fiber_object}.storage[{number}]`. "
#~ "Values may be either numbers or "
#~ "strings. The storage is garbage-"
#~ "collected when :samp:`{fiber_object}:cancel()` "
#~ "happens."
#~ msgstr ""

#~ msgid "Lua reference"
#~ msgstr "Справочник по Lua API"

#~ msgid "Lua rocks reference"
#~ msgstr "Справочник по Lua rocks"

#~ msgid "A module is an optional library which enhances Tarantool functionality."
#~ msgstr ""

#~ msgid ""
#~ "For examples of creating one's own "
#~ "module with Lua or C, see `this"
#~ " link`_."
#~ msgstr ""

#~ msgid ""
#~ "Who is developing Tarantool? |br| There"
#~ " is an engineering team employed by"
#~ " Mail.Ru -- check out our commit "
#~ "logs on github.com/tarantool. The development"
#~ " is fully open. Most of the "
#~ "connectors' authors, and the maintainers "
#~ "for different distributions, come from "
#~ "the wider community."
#~ msgstr ""
#~ "Кто разрабатывает Tarantool? |br| Во-первых,"
#~ " этим занимается команда разработки в "
#~ "Mail.Ru — см. историю коммитов на "
#~ "github.com/tarantool. Вся разработка ведется "
#~ "открытым образом. Кроме того, активную "
#~ "роль играют члены сообщества разработчиков "
#~ "Tarantool'а. Их силами было создано "
#~ "большинство коннекторов и ведутся доработки"
#~ " под разные дистрибутивы."

#~ msgid ""
#~ "Now that it's a bit clearer how"
#~ " to make a variable, we can "
#~ "change ``string_function()`` so that, instead"
#~ " of returning a fixed literal 'Hello"
#~ " world\", it returns a random letter"
#~ " between 'A' and 'Z'."
#~ msgstr ""

#~ msgid ""
#~ "The :ref:`os.clock() <os-clock>` function "
#~ "will return the number of CPU "
#~ "seconds since the start. Therefore, by"
#~ " getting start_time = number of "
#~ "seconds just before the inserting, and"
#~ " then getting end_time = number of"
#~ " seconds just after the inserting, we"
#~ " can calculate (end_time - start_time) "
#~ "= elapsed time in seconds. We will"
#~ " display that value by putting it "
#~ "in a request without any assignments,"
#~ " which causes Tarantool to send the"
#~ " value to the client, which prints"
#~ " it. (Lua's answer to the C "
#~ "``printf()`` function, which is ``print()``,"
#~ " will also work.)"
#~ msgstr ""

#~ msgid ""
#~ "The ``box.info`` submodule provides access "
#~ "to information about server variables. "
#~ "Some important ones:"
#~ msgstr ""

#~ msgid ""
#~ "**server.uuid** holds the unique identifier"
#~ " of the server. This value is "
#~ "also in the :ref:`box.space._cluster "
#~ "<box_space-cluster>` system space."
#~ msgstr ""

#~ msgid ""
#~ "**pid** is the process ID of the"
#~ " server. This value is also shown "
#~ "by the :ref:`tarantool <tarantool-build>` "
#~ "module."
#~ msgstr ""

#~ msgid ""
#~ "**version** is the Tarantool version. "
#~ "This value is also shown by "
#~ ":ref:`tarantool --version <index-"
#~ "tarantool_version>`."
#~ msgstr ""

#~ msgid "**uptime** is the number of seconds since the server started."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.info()\n"
#~ "---\n"
#~ "- server:\n"
#~ "    lsn: 158\n"
#~ "    ro: false\n"
#~ "    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
#~ "    id: 1\n"
#~ "  version: 1.7.0-1216-g73f7154\n"
#~ "  pid: 12932\n"
#~ "  status: running\n"
#~ "  vclock:\n"
#~ "  - 158\n"
#~ "  replication:\n"
#~ "    status: off\n"
#~ "  uptime: 908\n"
#~ "...\n"
#~ "tarantool> box.info.pid\n"
#~ "---\n"
#~ "- 12932\n"
#~ "...\n"
#~ "tarantool> box.info.status\n"
#~ "---\n"
#~ "- running\n"
#~ "...\n"
#~ "tarantool> box.info.uptime\n"
#~ "---\n"
#~ "- 1065\n"
#~ "...\n"
#~ "tarantool> box.info.version\n"
#~ "---\n"
#~ "- 1.7.0-66-g9093daa\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "The ``box.slab`` submodule provides access "
#~ "to slab allocator statistics. The slab"
#~ " allocator is the main allocator used"
#~ " to store tuples. This can be "
#~ "used to monitor the total memory "
#~ "use and memory fragmentation."
#~ msgstr ""

#~ msgid ""
#~ "The display of slabs is broken "
#~ "down by the slab size -- 64-byte,"
#~ " 136-byte, and so on. The example "
#~ "omits the slabs which are empty. "
#~ "The example display is saying that: "
#~ "there are 16 items stored in the"
#~ " 64-byte slab (and 16*64=102 so "
#~ "bytes_used = 1024); there is 1 "
#~ "item stored in the 136-byte slab "
#~ "(and 136*1=136 so bytes_used = 136); "
#~ "the arena_used value is the total "
#~ "of all the bytes_used values (1024+136"
#~ " = 1160); the arena_size value is "
#~ "the arena_used value plus the total "
#~ "of all the bytes_free values "
#~ "(1160+4193200+4194088 = 8388448). The "
#~ "arena_size and arena_used values are the"
#~ " amount of the % of "
#~ ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` "
#~ "that is already distributed to the "
#~ "slab allocator."
#~ msgstr ""

#~ msgid ""
#~ "tarantool> box.slab.info().arena_used\n"
#~ "---\n"
#~ "- 4194304\n"
#~ "...\n"
#~ "tarantool> box.slab.info().arena_size\n"
#~ "---\n"
#~ "- 104857600\n"
#~ "...\n"
#~ "tarantool> box.slab.stats()\n"
#~ "---\n"
#~ "- - mem_free: 16248\n"
#~ "    mem_used: 48\n"
#~ "    item_count: 2\n"
#~ "    item_size: 24\n"
#~ "    slab_count: 1\n"
#~ "    slab_size: 16384\n"
#~ "  - mem_free: 15736\n"
#~ "    mem_used: 560\n"
#~ "    item_count: 14\n"
#~ "    item_size: 40\n"
#~ "    slab_count: 1\n"
#~ "    slab_size: 16384\n"
#~ "    <...>\n"
#~ "...\n"
#~ "tarantool> box.slab.stats()[1]\n"
#~ "---\n"
#~ "- mem_free: 15736\n"
#~ "  mem_used: 560\n"
#~ "  item_count: 14\n"
#~ "  item_size: 40\n"
#~ "  slab_count: 1\n"
#~ "  slab_size: 16384\n"
#~ "..."
#~ msgstr ""

#~ msgid ""
#~ "In :ref:`box.info <box_introspection-box_info>` "
#~ "there is a ``box.info.replication.status`` "
#~ "field: \"off\", \"stopped\", \"connecting\", "
#~ "\"auth\", \"follow\", or \"disconnected\". "
#~ "|br| If a replica's status is "
#~ "\"follow\", then there will be two "
#~ "more fields: |br| ``box.info.replication.idle`` "
#~ "= the number of seconds the "
#~ "replica has been idle, |br| "
#~ "``box.info.replication.lag`` = the number of"
#~ " seconds the replica is behind the"
#~ " master."
#~ msgstr ""
#~ "В пакете :ref:`box.info <box_introspection-"
#~ "box_info>` есть поле "
#~ ":code:`box.info.replication.status`, которое отражает "
#~ "статус репликации для данной реплики: "
#~ "\"off\", \"stopped\", \"connecting\", \"auth\", "
#~ "\"follow\" или \"disconnected\". |br| Если "
#~ "реплика имеет статус \"follow\", то "
#~ "можно получить уточняющую информацию из "
#~ "еще двух полей: |br| "
#~ ":code:`box.info.replication.idle` = время (в "
#~ "секундах), которое реплика провела в "
#~ "состоянии бездействия, |br| "
#~ ":code:`box.info.replication.lag` = время (в "
#~ "секундах), на которое реплика отстает от"
#~ " главного сервера."

#~ msgid "**hello_world.lua**"
#~ msgstr ""

#~ msgid "**console_start.lua**"
#~ msgstr ""

#~ msgid "**fio_read.lua**"
#~ msgstr ""

#~ msgid "**fio_write.lua**"
#~ msgstr ""

#~ msgid "**ffi_printf.lua**"
#~ msgstr ""

#~ msgid "**ffi_gettimeofday.lua**"
#~ msgstr ""

#~ msgid "**ffi_zlib.lua**"
#~ msgstr ""

#~ msgid "**ffi_meta.lua**"
#~ msgstr ""

#~ msgid "**print_arrays.lua**"
#~ msgstr ""

#~ msgid "**count_array.lua**"
#~ msgstr ""

#~ msgid "**count_array_with_nils.lua**"
#~ msgstr ""

#~ msgid "**count_array_with_nulls.lua**"
#~ msgstr ""

#~ msgid "**count_map.lua**"
#~ msgstr ""

#~ msgid "**swap.lua**"
#~ msgstr ""

#~ msgid "**uri.lua**"
#~ msgstr ""

#~ msgid "**class.lua**"
#~ msgstr ""

#~ msgid "**garbage.lua**"
#~ msgstr ""

#~ msgid "**fiber_producer_and_consumer.lua**"
#~ msgstr ""

#~ msgid "**socket_tcpconnect.lua**"
#~ msgstr ""

#~ msgid "**socket_tcp_echo.lua**"
#~ msgstr ""

#~ msgid "**getaddrinfo.lua**"
#~ msgstr ""

#~ msgid "**socket_udp_echo.lua**"
#~ msgstr ""

#~ msgid "**http_get.lua**"
#~ msgstr ""

#~ msgid "**http_send.lua**"
#~ msgstr ""

#~ msgid "**http_server.lua**"
#~ msgstr ""

#~ msgid "**http_generate_html.lua**"
#~ msgstr ""

#~ msgid ""
#~ "This method provides iteration support "
#~ "within an index. The :codeitalic:`bitset-"
#~ "value` or :codeitalic:`search-value` parameter"
#~ " specifies what must match within the"
#~ " index. The :codeitalic:`iterator-type` "
#~ "parameter specifies the rule for "
#~ "matching and ordering. Different index "
#~ "types support different iterators. For "
#~ "example, a TREE index maintains a "
#~ "strict order of keys and can "
#~ "return all tuples in ascending or "
#~ "descending order, starting from the "
#~ "specified key. Other index types, "
#~ "however, do not support ordering."
#~ msgstr ""

#~ msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
#~ msgstr ""

#~ msgid ":samp:`{iterator-type}` = as defined in tables below."
#~ msgstr ""

#~ msgid ""
#~ "this method returns an iterator closure,"
#~ " i.e. a function which can be "
#~ "used to get the next value on "
#~ "each invocation"
#~ msgstr ""

#~ msgid "function, tuple"
#~ msgstr ""

#~ msgid ""
#~ "Possible errors: Selected iteration type "
#~ "is not supported for the index "
#~ "type, or search value is not "
#~ "supported for the iteration type."
#~ msgstr ""

#~ msgid ""
#~ "A search-value can be a number "
#~ "(for example ``1234``), a string (for"
#~ " example ``'abcd'``), or a table of"
#~ " numbers and strings (for example "
#~ "``{1234, 'abcd'}``). Each part of a "
#~ "search-value will be compared to "
#~ "each part of an index key."
#~ msgstr ""

#~ msgid ""
#~ "the tuples whose primary-key fields "
#~ "are equal to the passed field-"
#~ "values. If the number of passed "
#~ "field-values is less than the number"
#~ " of fields in the primary key, "
#~ "then only the passed field-values "
#~ "are compared, so ``select{1,2}`` will "
#~ "match a tuple whose primary key is"
#~ " ``{1,2,3}``."
#~ msgstr ""

#~ msgid "Deletes all tuples. ."
#~ msgstr ""

#~ msgid "Note re storage engine: vinyl does not support ``truncate()``."
#~ msgstr ""

#~ msgid "Note re storage engine: vinyl does not support ``auto_increment()``."
#~ msgstr ""

#~ msgid "A helper function to prepare for iterating over all tuples in a space."
#~ msgstr ""

#~ msgid ""
#~ "function which can be used in a"
#~ " for/end loop. Within the loop, a "
#~ "value is returned for each iteration."
#~ msgstr ""

#~ msgid ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| SPACE 'tester'                             |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | TUPLE SET 'tester'                     | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Tuple: [ 1 ]                      |  | |\n"
#~ "| | | Tuple: [ 2, 'Music' ]             |  | |\n"
#~ "| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | INDEX 'primary'                        | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Key: 1                            |  | |\n"
#~ "| | | Key: 2                            |  | |\n"
#~ "| | | Key: 3                            |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"
#~ msgstr ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| ПРОСТРАНСТВО 'tester'                      |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Кортеж: [ 1 ]                     |  | |\n"
#~ "| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
#~ "| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | ИНДЕКС 'primary'                       | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Ключ: 1                           |  | |\n"
#~ "| | | Ключ: 2                           |  | |\n"
#~ "| | | Ключ: 3                           |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"

#~ msgid ""
#~ "Despite their resemblance to implicit "
#~ "yield requests, :ref:`truncate <box_space-"
#~ "truncate>` and :ref:`drop <box_space-drop>`"
#~ " do not cause implicit yield. Despite"
#~ " their resemblance to functions of "
#~ "the fio module, functions of the "
#~ ":ref:`os <os-module>` module do not "
#~ "cause implicit yield. Despite its "
#~ "resemblance to commit, :ref:`rollback "
#~ "<atomic-box_rollback>` does not enable "
#~ "yields."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, for index searches, ``nil``"
#~ " is considered to be equal to "
#~ "any scalar. |br| With vinyl, ``nil`` "
#~ "or missing parts are not allowed."
#~ msgstr ""

#~ msgid ""
#~ "With memtx, the :ref:`alter() <box_index-"
#~ "alter>` and :ref:`len() <box_space-len>` "
#~ "and :ref:`random() <box_index-random>` and "
#~ ":ref:`auto_increment() <box_space-auto_increment>` "
#~ "and :ref:`truncate() <box_space-truncate>` "
#~ "functions are supported. |br| With "
#~ "vinyl, they are not."
#~ msgstr ""

#~ msgid ""
#~ "The PHP driver is `tarantool-php "
#~ "<https://github.com/tarantool/tarantool-php>`_. It "
#~ "is not supplied as part of the "
#~ "Tarantool repository; it must be "
#~ "installed separately. It can be "
#~ "installed with :program:`git`. It requires "
#~ "other modules which should be installed"
#~ " first. For example, on Ubuntu, the"
#~ " installation could look like this:"
#~ msgstr ""
#~ "Tarantool-коннектор для языка PHP называется"
#~ " `tarantool-php <https://github.com/tarantool"
#~ "/tarantool-php>`_. Он устанавливается отдельно"
#~ " от Tarantool'а с помощью :program:`git`"
#~ " и требует предварительной установки еще"
#~ " несколько зависимых модулей. Вот пример"
#~ " установки этого коннектора под Ubuntu:"

#~ msgid ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"
#~ msgstr ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"

#~ msgid ""
#~ "At this point there is a file "
#~ "named :file:`~/tarantool-php/modules/tarantool.so`. "
#~ "PHP will only find it if the "
#~ "PHP initialization file :file:`php.ini` "
#~ "contains a line like "
#~ ":samp:`extension=./tarantool.so`, or if PHP is"
#~ " started with the option :samp:`-d "
#~ "extension=~/tarantool-php/modules/tarantool.so`."
#~ msgstr ""
#~ "После отработки всех команд будет создан"
#~ " файл с именем :file:`~/tarantool-"
#~ "php/modules/tarantool.so`. PHP увидит его, "
#~ "только если в файле инициализации "
#~ ":file:`php.ini` есть строка вида "
#~ ":samp:`extension=./tarantool.so`, либо если при "
#~ "запуске PHP вы укажете опцию :samp:`-d"
#~ " extension=~/tarantool-php/modules/tarantool.so`."

#~ msgid ""
#~ "The example program only shows one "
#~ "request and does not show all "
#~ "that's necessary for good practice. For"
#~ " that, please see `tarantool-python "
#~ "project at GitHub <http://github.com/tarantool"
#~ "/tarantool-python>`_. For an example of "
#~ "using Python API with `queue managers"
#~ " for Tarantool <https://github.com/tarantool/queue>`_,"
#~ " see `queue-python project at GitHub"
#~ " <https://github.com/tarantool/queue-python>`_."
#~ msgstr ""
#~ "В этой программе мы привели пример "
#~ "использования лишь одного запроса. Для "
#~ "полноценной работы с Tarantool'ом с "
#~ "помощью Python API, пожалуйста, обратитесь "
#~ "к документации из `проекта tarantool-"
#~ "python на GitHub <http://github.com/tarantool"
#~ "/tarantool-python>`_. А на странице "
#~ "`проекта queue-python на GitHub "
#~ "<https://github.com/tarantool/queue-python>`_ вы "
#~ "сможете найти примеры использования Python "
#~ "API для работы с `очередями сообщений"
#~ " в Tarantool'е <https://github.com/tarantool/queue>`_."

#~ msgid "Start the tarantoolctl utility:"
#~ msgstr "Запустите утилиту ``tarantoolctl``:"

#~ msgid ""
#~ "You can repeat ``box.space...:insert{}`` and"
#~ " ``box.space...:select{}`` indefinitely, on "
#~ "either Tarantool instance. When the "
#~ "testing is over: To drop the "
#~ "space: ``s:drop()``. To stop tarantoolctl: "
#~ "Ctrl+C or Ctrl+D. To stop tarantool "
#~ "(an alternative): :ref:`os.exit() <os-exit>`."
#~ " To stop tarantool (from another "
#~ "terminal): ``sudo pkill -f tarantool``. "
#~ "To destroy the test: ``rm -r "
#~ "~/tarantool_sandbox``."
#~ msgstr ""
#~ "Вы можете повторно вводить команды "
#~ ":code:`box.space...:insert{}` и "
#~ ":code:`box.space...:select{}` сколько угодно раз,"
#~ " на любом экземпляре Tarantool'а. В "
#~ "конце тестирования воспользуйтесь следующими "
#~ "командами. Чтобы удалить пространство: "
#~ ":code:`s:drop()`. Чтобы остановить  "
#~ "``tarantoolctl``: Ctrl+C или Ctrl+D. Чтобы "
#~ "остановить Tarantool (альтернативный вариант): "
#~ ":ref:`os.exit() <os-exit>`. Чтобы остановить"
#~ " Tarantool (с другого терминала): "
#~ ":code:`sudo pkill -f tarantool`. Чтобы "
#~ "удалить тестовую базу: :code:`rm -r "
#~ "~/tarantool_sandbox`."

#~ msgid "Other sources"
#~ msgstr "Другие источники"

#~ msgid "`English`_"
#~ msgstr "`Форум (eng)`_"

#~ msgid "`Russian`_"
#~ msgstr "`Форум (рус)`_"

#~ msgid ""
#~ "Tarantool 1.6 manual  This manual "
#~ "embraces all aspects of using Tarantool:"
#~ " from introductory information and "
#~ "exercises for beginners -- to advanced"
#~ " instructions and detailed references for"
#~ " power users and contributors.  "
#~ "Документация находится в процессе перевода "
#~ "и может отставать от английской версии."
#~ "      <div class=\"badge-icon\"></div>  See "
#~ "also  Other formats:  Single-page HTML"
#~ "  PDF  /Users/artembo/work/doc/doc/1.6/index.rst:86: "
#~ "(WARNING/2) Bullet list ends without a"
#~ " blank line; unexpected unindent.  "
#~ "Resources:  Documentation archive  Articles  "
#~ "/Users/artembo/work/doc/doc/1.6/index.rst:89: (WARNING/2) "
#~ "Bullet list ends without a blank "
#~ "line; unexpected unindent.  Support:  Форум"
#~ " в Google  Чат в Telegram  Support:"
#~ "  Google forum  Telegram chat"
#~ msgstr ""

#~ msgid "**Resources:**"
#~ msgstr "**Ресурсы:**"

