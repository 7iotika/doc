# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-11-11 17:16+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: 2016-09-23 13:01+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"#-#-#-#-#  dev_guide.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-22 19:56+0300\n"
"PO-Revision-Date: 2016-09-22 21:29+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"#-#-#-#-#  faq.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-08-03 08:48+0300\n"
"PO-Revision-Date: 2016-09-22 20:02+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"#-#-#-#-#  intro.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: 2016-09-23 12:30+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"#-#-#-#-#  reference.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: 2016-09-22 21:19+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"#-#-#-#-#  reference_capi.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-08-19 12:23+0300\n"
"PO-Revision-Date: 2016-07-20 14:11+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"#-#-#-#-#  reference_lua.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-08-19 12:23+0300\n"
"PO-Revision-Date: 2016-08-19 13:23+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"X-Generator: Poedit 1.8.8\n"
"#-#-#-#-#  reference_rock.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-01 13:35+0300\n"
"PO-Revision-Date: 2016-08-19 13:21+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"#-#-#-#-#  tutorials.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: 2016-09-22 21:35+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"#-#-#-#-#  whats_new.po (Tarantool 1.7)  #-#-#-#-#\n"
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-22 20:32+0300\n"
"PO-Revision-Date: 2016-09-23 05:34+0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"
"Language: ru\n"
"X-Generator: Poedit 1.8.9\n"
"X-Poedit-Bookmarks: 1698,-1,-1,-1,-1,-1,-1,-1,-1,-1\n"

#: ../doc.rst:33
msgid "Tarantool - Documentation"
msgstr ""

msgid ""
"Here is a complete Tarantool manual. It embraces all aspects of using "
"Tarantool: from introductory information and excercises for beginners -- to "
"advanced instructions and detailed references for power users and "
"contributors.A single-page version of this manual is available here."
msgstr ""

#: ../doc.rst:39
msgid ""
"Here is a **complete Tarantool manual**. It embraces all aspects of using "
"Tarantool: from introductory information and excercises for beginners -- to "
"advanced instructions and detailed references for power users and "
"contributors."
msgstr ""

#: ../doc.rst:44
msgid "A single-page version of this manual is available `here`_."
msgstr ""

#: ../whats_new.rst:30
msgid "What's new?"
msgstr "Что нового?"

#: ../doc.rst:53
msgid "`What's new in Tarantool 1.7?`_"
msgstr ""

#: ../intro.rst:28
#, fuzzy
msgid "Overview"
msgstr ""
"#-#-#-#-#  dev_guide.po (Tarantool 1.7)  #-#-#-#-#\n"
"Общие сведения о протоколе\n"
"#-#-#-#-#  intro.po (Tarantool 1.7)  #-#-#-#-#\n"
"Общие сведения"

#: ../doc.rst:57
msgid "`An application server together with a database manager`_"
msgstr ""

#: ../doc.rst:58
msgid "`Database features`_"
msgstr ""

#: ../tutorials/index.rst:30
msgid "Tutorials"
msgstr "Практикум"

#: ../doc.rst:62
msgid "`Lua tutorials`_"
msgstr ""

#: ../doc.rst:63
msgid "`C tutorial`_"
msgstr ""

#: ../book/index.rst:30
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc.rst:67
msgid "`Preface`_"
msgstr ""

#: ../doc.rst:68
msgid "`Database`_"
msgstr ""

#: ../doc.rst:69
msgid "`Application server`_"
msgstr ""

#: ../doc.rst:70
msgid "`Server administration`_"
msgstr ""

#: ../doc.rst:71
msgid "`Connectors`_"
msgstr ""

#: ../doc.rst:72
msgid "`FAQ`_"
msgstr ""

#: ../reference/index.rst:30
msgid "Reference"
msgstr "Справочники"

#: ../doc.rst:76
msgid "`Built-in library reference`_"
msgstr ""

#: ../doc.rst:77
msgid "`Rocks reference`_"
msgstr ""

#: ../doc.rst:78
msgid "`Configuration reference`_"
msgstr ""

#: ../dev_guide/index.rst:30
msgid "Contributor's Guide"
msgstr "Руководство участника проекта"

#: ../doc.rst:82
msgid "`C API reference`_"
msgstr ""

#: ../doc.rst:83
msgid "`Internals`_"
msgstr ""

#: ../doc.rst:84
msgid "`Build and contribute`_"
msgstr ""

#: ../doc.rst:85
msgid "`Guidelines`_"
msgstr ""

#: ../doc.rst:91
msgid ""
"Here are other sources -- besides the manual -- where you can get more "
"information about Tarantool."
msgstr ""

#: ../doc.rst:99
msgid "Discussion boards"
msgstr ""

#: ../doc.rst:101
msgid "`English`_"
msgstr ""

#: ../doc.rst:102
msgid "`Russian`_"
msgstr ""

#: ../doc.rst:104
msgid "Telegram chat"
msgstr ""

#: ../doc.rst:106
msgid "tl;dr? ;-) Feel free to ask your question in our `telegram chat`_."
msgstr ""

#: ../book/administration.rst:30
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../book/administration.rst:32
msgid ""
"Typical server administration tasks include starting and stopping the "
"server, reloading configuration, taking snapshots, log rotation."
msgstr ""
"Типичные задачи администрирования серверной части включают в себя запуск и "
"остановку сервера, перезагрузку настроек, создание снимков, ротацию логов."

#: ../book/administration.rst:39
msgid "Using tarantool as a client"
msgstr "Использование tarantool в качестве клиента"

#: ../book/administration.rst:43
msgid ""
"If :program:`tarantool` is started without an :ref:`initialization file "
"<index-init_label>`, or if the initialization file contains :ref:`console."
"start() <console-start>`, then :program:`tarantool` enters interactive mode. "
"There will be a prompt (\"``tarantool>``\") and it will be possible to enter "
"requests. When used this way, :program:`tarantool` can be a client for a "
"remote server."
msgstr ""
"Если :program:`tarantool` запущен без :ref:`файла инициализации <index-"
"init_label>`, или же в файле инициализации указана функция :ref:`console."
"start() <console-start>`, то :program:`tarantool` стартует в интерактивном "
"режиме: он выводит приглашение командной строки (\"``tarantool>``\"), и "
"запросы можно вводить прямо в консоли. В таком режиме :program:`tarantool` "
"можно использовать в качестве клиента для удаленного сервера."

#: ../book/administration.rst:49
msgid ""
"This section shows all legal syntax for the :program:`tarantool` program, "
"with short notes and examples. Other client programs may have similar "
"options and request syntaxes. Some of the information in this section is "
"duplicated in the chapter :ref:`Configuration reference <index-book_cfg>`."
msgstr ""
"В этом разделе описаны синтаксические правила для ввода запросов в консоли "
"Tarantool'а, с примечаниями и примерами. Другие клиентские программы могут "
"иметь схожие параметры и синтаксис запросов. Некоторые сведения из этого "
"раздела дублируются в главе :ref:`Справочник по конфигурированию <index-"
"book_cfg>`."

#: ../book/administration.rst:56
msgid "Conventions used in this section"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../book/administration.rst:58
msgid ""
"Tokens are character sequences which are treated as syntactic units within "
"requests. Square brackets [ and ] enclose optional syntax. Three dots in a "
"row ... mean the preceding tokens may be repeated. A vertical bar | means "
"the preceding and following tokens are mutually exclusive alternatives."
msgstr ""
"Токены — это последовательности символов, которые рассматриваются как "
"синтаксические единицы в рамках запроса. Квадратные скобки [ и ] "
"используются для обозначения необязательных токенов. Три точки в строке ... "
"означают, что предыдущие токены могут повторяться. Вертикальная черта | "
"означает, что предыдущие и последующие токены являются взаимоисключающими "
"альтернативами."

#: ../book/administration.rst:65
msgid "Options when starting client from the command line"
msgstr "Параметры запуска клиента из командной строки"

#: ../book/administration.rst:67
msgid "General form:"
msgstr "Общий вид:"

#: ../book/administration.rst:72
msgid ""
"$ **tarantool**\n"
"OR\n"
"$ **tarantool** *options*\n"
"OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""
"$ tarantool\n"
"ИЛИ\n"
"$ tarantool опции\n"
"ИЛИ\n"
"$ tarantool файл-инициализации-на-lua [ аргументы ]"

#: ../book/administration.rst:78
msgid ""
"Here *lua-initialization-file* can be any script containing code for "
"initializing. Effect: The code in the file is executed during startup. "
"Example: :samp:`init.lua`. |br| Notes: If a script is used, there will be no "
"prompt. The script should contain configuration information including :samp:"
"`box.cfg{...listen=...}` or :samp:`box.listen(...)` so that a separate "
"program can connect to the server via one of the ports."
msgstr ""
"*файл-инициализации-на-lua* — это любой скрипт, содержащий логику "
"инициализации. Код из этого файла выполняется при запуске Tarantool'а.  "
"Например: :samp:`init.lua`. |br| Примечания: При использовании скрипта, "
"Tarantool не выводит приглашение командной строки. Скрипт должен содержать "
"конфигурационные настройки, в т.ч. :samp:`box.cfg{...listen=...}` или :samp:"
"`box.listen(...)`, чтобы внешние программы могли установить соединение с "
"Tarantool-сервером на одном из указанных портов."

#: ../book/administration.rst:85
msgid ""
"*Option* is one of the following (in alphabetical order by the long form of "
"the option):"
msgstr ""
"*Опция* — это одно из следующих значений (указаны в алфавитном порядке, по "
"полному имени опции):"

#: ../book/administration.rst:90
msgid ""
"Client displays a help message including a list of options. Example: :samp:"
"`tarantool --help` The program stops after displaying the help."
msgstr ""
"Tarantool-клиент выводит краткую справку, включая список всех параметров. "
"Например: :samp:`tarantool --help`. Вывод останавливается после показа "
"справки."

#: ../book/administration.rst:96
msgid ""
"Client displays version information. Example: :samp:`tarantool --version`. "
"The program stops after displaying the version."
msgstr ""
"Tarantool-клиент выводит свой номер версии. Например: :samp:`tarantool --"
"version`. Вывод останавливается после показа номера версии."

#: ../book/administration.rst:102
msgid "Tokens, requests, and special key combinations"
msgstr "Токены, запросы и специальные комбинации клавиш"

#: ../book/administration.rst:104
msgid ""
"Procedure identifiers are: Any sequence of letters, digits, or underscores "
"which is legal according to the rules for Lua identifiers. Procedure "
"identifiers are also called function names. |br| Note: function names are "
"case sensitive so ``insert`` and ``Insert`` are not the same thing."
msgstr ""
"Идентификатором процедуры может быть любая последовательность букв, цифр и/"
"или подчеркиваний, которая отвечает правилам именования идентификаторов в "
"Lua. Термин \"идентификаторы процедур\" также применяют к именам функций. |"
"br| Примечание: в случае с именами функций регистр имеет значение, поэтому "
"``insert`` и ``Insert`` — это не одно и то же."

#: ../book/administration.rst:110
msgid ""
"String literals are: Any sequence of zero or more characters enclosed in "
"single quotes. Double quotes are legal but single quotes are preferred. "
"Enclosing in double square brackets is good for multi-line strings as "
"described in `Lua documentation <http://www.lua.org/pil/2.4.html>`_. |br| "
"Examples: 'Hello, world', 'A', [[A\\\\B!]]."
msgstr ""
"Строковым литералом может быть любая последовательность из нуля и более "
"символов, которая заключена в *одинарные кавычки*. *Двойные кавычки* также "
"допустимы, но предпочтительным вариантом являются одинарные кавычки. А "
"*двойные квадратные скобки* нужны для многострочных литералов (см. "
"`документацию по языку Lua <http://www.lua.org/pil/2.4.html>`_). |br| "
"Например: 'Hello, world', 'A', [[A\\\\B!]]."

#: ../book/administration.rst:116
msgid ""
"Numeric literals are: Any sequence of one or more digits, not enclosed in "
"quotes, optionally preceded by - (minus sign). Large or floating-point "
"numeric literals may include decimal points, exponential notation, or "
"suffixes.|br| Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL."
msgstr ""
"Числовым литералом может быть любая последовательность символов, состоящая "
"из одной и более цифр с необязательным знаком + или - в начале. В состав "
"больших числовых литералов, а также числовых литералов с плавающей точкой "
"может входить десятичный разделитель (запятая или точка), символы для "
"экспоненциального представления и суффиксы. |br| Например: 500, -500, 5e2, "
"500.1, 5LL, 5ULL."

#: ../book/administration.rst:122
msgid ""
"Single-byte tokens are: , or ( or ) or arithmetic operators. |br| Examples: "
"* , ( )."
msgstr ""
"Однобайтовым символом может быть запятая, открывающая или закрывающая "
"круглая скобка, а также арифметический оператор. |br| Например: * , ( )."

#: ../book/administration.rst:125
msgid ""
"Tokens must be separated from each other by one or more spaces, except that "
"spaces are not necessary around single-byte tokens or string literals."
msgstr ""
"Токены должны разделяться одним или бОльшим количеством пробелов. "
"Исключением являются однобайтовые токены и строковые литералы — вокруг них "
"пробелы не нужны."

#: ../book/administration.rst:132
msgid "Requests"
msgstr "Запросы"

#: ../book/administration.rst:134
msgid ""
"Generally requests are entered following the prompt in interactive mode "
"while :program:`tarantool` is running. (A prompt will be the word "
"'tarantool' and a greater-than sign, for example :samp:`tarantool>`). The "
"end-of-request marker is by default a newline (line feed)."
msgstr ""
"Запросы вводятся после приглашения командной строки, когда Tarantool "
"работает в интерактивном режиме. (Приглашение — это слово tarantool и знак "
"\"больше\", вот так: :samp:`tarantool>`). Маркером конца запроса по "
"умолчанию является перевод строки."

#: ../book/administration.rst:139
msgid ""
"For multi-line requests, it is possible to change the end-of-request marker. "
"Syntax: :samp:`console = require('console'); console.delimiter({string-"
"literal})`. The string-literal must be a value in single quotes. Effect: "
"string becomes end-of-request delimiter, so newline alone is not treated as "
"end of request. To go back to normal mode: :samp:`console.delimiter('')"
"{string-literal}`. Delimiters are usually not necessary because Tarantool "
"can tell when a multi-line request has not ended (for example, if it sees "
"that a function declaration does not have an :samp:`end` keyword). Example:"
msgstr ""
"Для ввода многострочных запросов можно задать другой маркер конца запроса. "
"Для этого введите команду следующего вида: :samp:`console = "
"require('console'); console.delimiter({новый-маркер})`. В качестве нового "
"маркера укажите строковый литерал в одинарных кавычках. После этого вам "
"нужно будет вводить указанный маркер в конце каждого запроса, потому что "
"Tarantool перестанет интерпретировать перевод строки как конец запроса. "
"Чтобы вернуться к обычному режиму, введите: :samp:`console.delimiter('')"
"{string-literal}`. Как правило, задавать свой маркер нет необходимости, "
"поскольку Tarantool сам распознает, что запрос введен не полностью (скажем, "
"когда Tarantool не встречает слова :samp:`end` в объявлении функции). "
"Например:"

#: ../book/administration.rst:148
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"

#: ../book/administration.rst:157
msgid ""
"See :ref:`here <box_protocol-iproto_protocol>` a condensed Backus-Naur Form "
"[BNF] description of the suggested form of client requests."
msgstr ""
"См. также :ref:`описание формата клиентских запросов <box_protocol-"
"iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form)."

#: ../book/administration.rst:160
msgid ""
"In *interactive* mode, one types requests and gets results. Typically the "
"requests are typed in by the user following prompts. Here is an example of "
"an interactive-mode Tarantool client session:"
msgstr ""
"Работая в  *интерактивном* режиме, Tarantool-сервер принимает введенные "
"запросы и выводит результаты. Запросы, как правило, вводит пользователь. Вот "
"пример интерактивной пользовательской сессии:"

#: ../book/administration.rst:164
msgid ""
"$ tarantool\n"
"[ tarantool will display an introductory message\n"
"  including version number here ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ tarantool will display configuration information here ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ tarantool may display an in-progress message here ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master "
"shutdown\n"
"$"
msgstr ""
"$ tarantool\n"
"[ здесь tarantool выводит приветствие и номер версии ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ здесь tarantool выводит свои текущие настройки ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ здесь tarantool может вывести сообщение о том,\n"
"  что идет обработка запроса ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master "
"shutdown\n"
"$"

#: ../book/administration.rst:193
msgid "Explanatory notes about what Tarantool displayed in the above example:"
msgstr "Пояснения к приведенному выше примеру:"

#: ../book/administration.rst:195
msgid ""
"Many requests return typed objects. In the case of :samp:`box."
"cfg{listen=3301}`, this result is displayed on the screen. If the request "
"had assigned the result to a variable, for example :samp:`c = box."
"cfg{listen=3301}`, then the result would not have been displayed on the "
"screen."
msgstr ""
"На многие запросы Tarantool возвращает типизированные объекты. В ответ на "
"запрос :samp:`box.cfg{listen=3301}` Tarantool выведет результат на экран. "
"Если в запросе задано, что его результат должен быть записан в некоторую "
"переменную, например :samp:`c = box.cfg{listen=3301}`, то в таком случае "
"вывода результата на экран не происходит."

#: ../book/administration.rst:199
msgid ""
"A display of an object always begins with \"``---``\" and ends with \"``...``"
"\"."
msgstr ""
"Вывод объекта в Tarantool'е всегда начинается со строки \"``---``\" и "
"заканчивается строкой \"``...``\"."

#: ../book/administration.rst:200
msgid ""
"The insert request returns an object of type = tuple, so the object display "
"line begins with a single dash ('``-``'). However, the select request "
"returns an object of type = table of tuples, so the object display line "
"begins with two dashes ('``- -``')."
msgstr ""
"По запросу на вставку данных возвращается объект типа кортеж (tuple), и в "
"этом случае перед выводом будет стоять одиночное тире ('``-``'). А по "
"запросу на выборку данных возвращается объект типа таблица кортежей (table "
"of tuples), и в этом случае перед выводом будут стоять два тире ('``- -``')."

#: ../book/administration.rst:209
msgid "Utility tarantoolctl"
msgstr "Утилита tarantoolctl"

#: ../doc/book/administration.rst:216 ../book/administration.rst:213
msgid ""
"With :program:`tarantoolctl`, you can say: \"start an instance of the "
"Tarantool server which runs a single user-written Lua program, allocating "
"disk resources specifically for that program, via a standardized deployment "
"method.\""
msgstr ""

#: ../doc/book/administration.rst:220 ../book/administration.rst:217
msgid ""
"If Tarantool was installed with Debian or Red Hat installation packages, the "
"script is in :file:`/usr/bin/tarantoolctl` or :file:`/usr/local/bin/"
"tarantoolctl`. The script handles such things as: starting, stopping, "
"rotating logs, logging in to the application's console, and checking status."
msgstr ""

#: ../doc/book/administration.rst:227 ../book/administration.rst:224
#, fuzzy
msgid ""
"Also, you can use :program:`tarantoolctl` :ref:`as a client <administration-"
"tarantoolctl_connect>` to connect to another instance of Tarantool server "
"and pass requests."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../book/administration.rst:230
msgid "Configuration for tarantoolctl"
msgstr "Конфигурирование tarantoolctl"

#: ../book/administration.rst:232
msgid ""
"The :program:`tarantoolctl` script will look for a configuration file in the "
"current directory (:file:`$PWD/.tarantoolctl`). If that fails, it looks in "
"the current user's home directory (:file:`$HOME/.config/tarantool/"
"tarantool`). If that fails, it looks in the SYSCONFDIR directory (usually :"
"file:`/etc/sysconfig/tarantool`, but it may be different on some platforms). "
"Most of the settings are similar to the settings used by :samp:`box.cfg{...}"
"`; however, :program:`tarantoolctl` adjusts some of them by adding an "
"application name. A copy of :file:`usr/local/etc/default/tarantool`, with "
"defaults for all settings, would look like this:"
msgstr ""
"Скрипт :program:`tarantoolctl` сначала проверяет наличие файла конфигурации "
"в текущей директории (:file:`$PWD/.tarantoolctl`). Если не находит, то "
"проверяет домашнюю директорию текущего пользователя (:file:`$HOME/.config/"
"tarantool/tarantool`). Если опять не находит, то проверяет директорию, "
"указанную в переменной SYSCONFDIR (обычно это :file:`/etc/sysconfig/"
"tarantool`, но на разных платформах этот путь может различаться). "
"Большинство параметров :program:`tarantoolctl` аналогичны тем, что задаются "
"в запросе :samp:`box.cfg{...}`; однако :program:`tarantoolctl` меняет "
"значение некоторых параметров, дописывая к ним имя приложения. Далее "
"приводится копия файла :file:`usr/local/etc/default/tarantool`, где для всех "
"параметров указаны их значения по умолчанию:"

#: ../book/administration.rst:243
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../book/administration.rst:255
msgid "The settings in the above script are:"
msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#: ../book/administration.rst:259
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../book/administration.rst:258
msgid ""
"The directory for the pid file and control-socket file. The script will add "
"\":samp:`/{instance-name}`\" to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл. Скрипт :program:"
"`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:263
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../book/administration.rst:262
msgid ""
"The directory for the write-ahead :file:`*.xlog` files. The script will add "
"\":samp:`/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся :file:`*.xlog`-файлы. Скрипт :program:"
"`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:267
msgid "``snap_dir``"
msgstr "``snap_dir``"

#: ../book/administration.rst:266
msgid ""
"The directory for the snapshot :file:`*.snap` files. The script will add \":"
"samp:`/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся :file:`*.snap`-файлы. Скрипт :program:"
"`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:271
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../book/administration.rst:270
msgid ""
"The directory for the vinyl-storage-engine files. The script will add \":"
"samp:`/vinyl/{instance-name}`\" to the directory-name."
msgstr ""
"Директория, где хранятся файлы движка vinyl. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../book/administration.rst:275
msgid "``logger``"
msgstr "``logger``"

#: ../book/administration.rst:274
msgid ""
"The place where the application log will go. The script will add \":samp:`/"
"{instance-name}.log`\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от Tarantool-"
"приложений. Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-"
"name}`\" к имени директории."

#: ../book/administration.rst:279
msgid "``username``"
msgstr "``username``"

#: ../book/administration.rst:278
msgid ""
"The user that runs the Tarantool server. This is the operating-system user "
"name rather than the Tarantool-client user name."
msgstr ""
"Имя пользователя, из-под которого запущен Tarantool-сервер. Это имя "
"пользователя в операционной системе, а не в Tarantool-клиенте."

#: ../book/administration.rst:286
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../book/administration.rst:282
msgid ""
"The directory where all applications for this host are stored. The user who "
"writes an application for :program:`tarantoolctl` must put the application's "
"source code in this directory, or a symbolic link. For examples in this "
"section the application name ``my_app`` will be used, and its source will "
"have to be in :samp:`{instance_dir}/my_app.lua`."
msgstr ""
"Имя директории, где хранятся исходные файлы всех Tarantool-приложений для "
"данного хоста. Пользователю, который пишет приложение для :program:"
"`tarantoolctl`, нужно положить исходный код своего приложения в эту "
"директорию или настроить симлинк. Далее для примеров в этом разделе мы "
"используем Tarantool-приложение с именем ``my_app``, и его исходный код "
"должен лежать в файле :samp:`{instance_dir}/my_app.lua`."

#: ../book/administration.rst:290
msgid "Commands for tarantoolctl"
msgstr "Команды для tarantoolctl"

#: ../book/administration.rst:292
msgid ""
"The command format is :samp:`tarantoolctl {operation} {application_name}`, "
"where operation is one of: start, stop, enter, logrotate, status, eval. "
"Thus ..."
msgstr ""
"Команды для :program:`tarantoolctl` имеют вид :samp:`tarantoolctl {операция} "
"{имя_приложения}`. В качестве *операции* можно указать одно из следующих "
"значений: start, stop, enter, logrotate, status, eval."

#: ../book/administration.rst:297
msgid "Start application *<application>*"
msgstr "Запустить приложение с именем *<application>*"

#: ../book/administration.rst:301
msgid "Stop application"
msgstr "Остановить приложение"

#: ../book/administration.rst:305
msgid "Show application's admin console"
msgstr "Вывести консоль для управления приложением"

#: ../book/administration.rst:309
msgid "Rotate application's log files (make new, remove old)"
msgstr ""
"Произвести ротацию журналов указанного приложения (создать новые, удалить "
"старые)"

#: ../book/administration.rst:313
msgid "Check application's status"
msgstr "Проверить статус приложения"

#: ../book/administration.rst:317
msgid "Execute code from *<scriptname>* on an instance of application"
msgstr ""
"Выполнить код из файла *<scriptname>* от имени запущенного экземпляра "
"приложения *<application>*"

#: ../doc/book/administration.rst:324 ../book/administration.rst:321
msgid ""
"Connect to a Tarantool server running at the specified :ref:`URI <index-uri>`"
msgstr ""

#: ../book/administration.rst:325
msgid "Typical code snippets for tarantoolctl"
msgstr "Примеры кода для tarantoolctl"

#: ../book/administration.rst:327
msgid "A user can check whether ``my_app`` is running with these lines:"
msgstr "Проверить, запущено ли приложение ``my_app``:"

#: ../book/administration.rst:329
msgid ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"
msgstr ""
"if tarantoolctl status my_app; then\n"
"...\n"
"fi"

#: ../book/administration.rst:335
msgid ""
"A user can initiate, for boot time, an :file:`init.d` set of instructions:"
msgstr ""
"Выполнить инструкции из файла :file:`init.d` во время запуска приложения:"

#: ../book/administration.rst:337
msgid ""
"for (each file mentioned in the instance_dir directory):\n"
"    tarantoolctl start `basename $ file .lua`"
msgstr ""
"for (каждый файл в директории instance_dir):\n"
"    tarantoolctl start `basename $ file .lua`"

#: ../book/administration.rst:342
msgid ""
"A user can set up a further configuration file for log rotation, like this:"
msgstr "Указать файл конфигурации для ротации журнала, например:"

#: ../book/administration.rst:347
msgid ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"
msgstr ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"

#: ../book/administration.rst:362
msgid "A detailed example for tarantoolctl"
msgstr "Подробный пример для tarantoolctl"

#: ../doc/book/administration.rst:367 ../book/administration.rst:364
#, fuzzy
msgid ""
"The example's objective is to make a temporary directory where :program:"
"`tarantoolctl` can start a long-running application and monitor it."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В этом примере мы создадим временную директорию, в которой :program:"
"`tarantoolctl` сможет запускать и мониторить некое долго работающее "
"приложение."

#: ../book/administration.rst:367
msgid ""
"The assumptions are: the root password is known, the computer is only being "
"used for tests, the Tarantool server is ready to run but is not currently "
"running, tarantoolctl is installed along the user's path, and there "
"currently is no directory named :file:`tarantool_test`."
msgstr ""
"Итак, наши исходные условия: нам известен пароль root-пользователя; "
"компьютер используется только для тестирования; Tarantool-сервер настроен и "
"готов к запуску, но пока еще не запущен ;программа :program:`tarantoolctl` "
"установлена в пользовательском окружении; пока не существует директории с "
"именем :file:`tarantool_test`."

#: ../book/administration.rst:372
msgid "Create a directory named :file:`/tarantool_test`:"
msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#: ../book/administration.rst:374
msgid "$ sudo mkdir /tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../book/administration.rst:378
msgid ""
"Edit :file:`/usr/local/etc/default/tarantool`. It might be necessary to say :"
"samp:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
msgstr ""
"Отредактируем файл :file:`/usr/local/etc/default/tarantool`. Для этого нам "
"сначала может понадобиться выполнить команду :samp:`sudo mkdir /usr/local/"
"etc/default`. Указанный файл будет содержать следующие настройки:"

#: ../book/administration.rst:382
msgid ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""
msgstr ""
"default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    vinyl_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""

#: ../book/administration.rst:394
msgid ""
"Make the ``my_app`` application file, that is, :file:`/tarantool_test/my_app."
"lua`. Let the file contents be:"
msgstr ""
"Создадим файл :file:`/tarantool_test/my_app.lua` для приложения ``my_app``:"

#: ../book/administration.rst:397
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../book/administration.rst:413
msgid "Tell :program:`tarantoolctl` to start the application ..."
msgstr "С помощью :program:`tarantoolctl` запустим наше приложение..."

#: ../book/administration.rst:415
msgid ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"
msgstr ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"

#: ../book/administration.rst:420
msgid ""
"... expect to see messages indicating that the instance has started. Then ..."
msgstr ""
"... и получим сообщения о том, что экземпляр нашего приложения запущен. "
"Затем скажем:"

#: ../book/administration.rst:422
msgid "$ ls -l /tarantool_test/my_app"
msgstr "$ ls -l /tarantool_test/my_app"

#: ../book/administration.rst:426
msgid ""
"... expect to see the :file:`.snap` file and the :file:`.xlog` file. Then ..."
msgstr "... и увидим :file:`.snap`-файл и :file:`.xlog`-файл. Затем скажем:"

#: ../book/administration.rst:428
msgid "$ sudo less /tarantool_test/log/my_app.log"
msgstr "$ sudo less /tarantool_test/log/my_app.log"

#: ../book/administration.rst:432
msgid ""
"... expect to see the contents of ``my_app``'s log, including error "
"messages, if any. Then ..."
msgstr ""
"... и увидим содержимое файла журнала для приложения ``my_app``, в т.ч. "
"сообщения об ошибках, если они были. Затем скажем:"

#: ../book/administration.rst:435
msgid ""
"$ cd /tarantool_test\n"
"$ # assume that 'tarantool' invokes the tarantool server\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ cd /tarantool_test\n"
"$ # допустим, что 'tarantool' запускает Tarantool-сервер\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/administration.rst:445
msgid "... expect to see several tuples that ``my_app`` has created."
msgstr ""
"... и увидим те несколько кортежей, которые создало приложение ``my_app``."

#: ../book/administration.rst:447
msgid ""
"Stop. The only clean way to stop ``my_app`` is with :program:`tarantoolctl`, "
"thus:"
msgstr ""
"Всё. Теперь остановим приложение ``my_app``. Единственный корректный способ "
"— это использовать :program:`tarantoolctl`:"

#: ../book/administration.rst:449
msgid "$ sudo tarantoolctl stop my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../book/administration.rst:453
msgid ""
"Clean up. Restore the original contents of :file:`/usr/local/etc/default/"
"tarantool`, and ..."
msgstr ""
"Почистим систему после тестирования. Приведем содержимое файла :file:`/usr/"
"local/etc/default/tarantool` к исходному виду и удалим нашу тестовую "
"директорию:"

#: ../book/administration.rst:456
msgid ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"
msgstr ""
"$ cd /\n"
"$ sudo rm -R tarantool_test"

#: ../doc/book/administration.rst:468 ../book/administration.rst:465
#, fuzzy
msgid "An example for tarantoolctl connect"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Подробный пример для tarantoolctl"

#: ../book/administration.rst:467
msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#: ../doc/book/administration.rst:476 ../book/administration.rst:473
#, fuzzy
msgid ""
"There are alternatives to :program:`tarantoolctl connect` -- you can use "
"the :ref:`console module <console-module>` or the :ref:`net.box module "
"<net_box-module>` from a Tarantool server. Also, you can write your client "
"programs with any of the Connectors. However, most of the examples in this "
"manual illustrate usage with either :program:`tarantoolctl connect` or with :"
"ref:`using the Tarantool server as a client <administration-"
"using_tarantool_as_a_client>`."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Вместо :program:`tarantoolctl connect` вы можете использовать модули :ref:"
"`console <console-module>` или :ref:`net.box <net_box-module>` из библиотеки "
"Tarantool'а. Еще одна альтернатива — это написать клиентскую программу под "
"любой из существующих Tarantool-коннекторов. Но для большинства примеров в "
"текущей документации мы используем :program:`tarantoolctl connect` или :ref:"
"`Tarantool-сервер в качестве клиента <administration-"
"using_tarantool_as_a_client>`."

#: ../book/administration.rst:485
msgid "Administrative ports"
msgstr "Служебные порты"

#: ../book/administration.rst:487
msgid ""
"\"Admin port\", \"admin console\", and \"text protocol\" all refer to the "
"same thing: a connection which is set up with :ref:`console.listen(...) "
"<console-listen>` for entry of requests by administrators."
msgstr ""
"Термины \"порт для администрирования\", \"консоль для администрирования\", "
"\"текстовый протокол\" относятся к установке соединения с помощью :ref:"
"`console.listen(...) <console-listen>` для ввода запросов от администраторов."

#: ../book/administration.rst:492
msgid ""
"\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a "
"different thing: a connection which is set up with :ref:`box.cfg{listen=...} "
"<cfg_basic-listen>` for entry of requests by anyone."
msgstr ""
"Термины \"бинарный порт\", \"бинарный протокол\", \"первичный порт\" "
"относятся к другому виду соединения — тому, что устанавливается с помощью "
"параметра :ref:`box.cfg{listen=...} <cfg_basic-listen>` и предназначено для "
"ввода запросов от любых пользователей."

#: ../book/administration.rst:497
msgid ""
"Ordinary connections to the Tarantool server should go via a binary port. "
"But admin ports are useful for special cases involving security."
msgstr ""
"Для обычных соединений с Tarantool-сервером должен использоваться бинарный "
"протокол. А порты для администрирования нужны для особых случаев, когда "
"повышены требования к безопасности."

#: ../book/administration.rst:500
msgid "When you connect to an admin port:"
msgstr "При установке соединение через порт для администрирования:"

#: ../book/administration.rst:502
msgid "No password is necessary"
msgstr "Пароль не требуется"

#: ../book/administration.rst:503
msgid "The user is automatically 'admin', a user with many privileges."
msgstr "Пользователь автоматически получает привилегии администратора."

#: ../book/administration.rst:505
msgid ""
"Therefore you must set up admin ports very cautiously. If it is a TCP port, "
"it should only be opened for a specific IP. Ideally it should not be a TCP "
"port at all, it should be a Unix domain socket, so that access to the server "
"machine is required. Thus a typical setup for an admin port is:"
msgstr ""
"Поэтому порты для администрирования следует настраивать очень осторожно. "
"Если это TCP-порт, то он должен быть открыть только для определенного IP-"
"адреса. В идеале мы рекомендуем вовсе не использовать TCP-порты. Вместо них "
"лучше настроить доменный Unix-сокет, который требует настройки прав доступа "
"к серверной машине. Тогда типичная настройка порта для администрирования "
"будет выглядеть следующим образом:"

#: ../book/administration.rst:511
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../book/administration.rst:515
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../book/administration.rst:517
msgid "admin:any_string@/var/lib/tarantool/socket_name.sock"
msgstr "admin:any_string@/var/lib/tarantool/socket_name.sock"

#: ../book/administration.rst:521
msgid ""
"if the listener has the privilege to write on :file:`/var/lib/tarantool` and "
"the connector has the privilege to read on :file:`/var/lib/tarantool`. "
"Alternatively both setup and connection can be done with :ref:`tarantoolctl "
"<administration-tarantoolctl>`."
msgstr ""
"Это в том случае, если у сервера (listener'а) есть привилегии на запись в "
"файл :file:`/var/lib/tarantool`, а на стороне клиента (connector'а) есть "
"привилегии на чтение из того же файла. Аналогично можно установить "
"соединение и задать настройки с помощью :ref:`tarantoolctl <administration-"
"tarantoolctl>`."

#: ../book/administration.rst:526
msgid ""
"If no administrator password exists which could be given out to users, and "
"admin ports are restricted or are sockets, then requests which require "
"'admin' privileges can only occur locally, and are subject to Unix security "
"and monitoring."
msgstr ""
"Если не задан пароль администратора, который можно сообщить пользователям, а "
"порты для администрирования настроены с ограничением доступа по IP либо "
"через сокеты, то запросы, требующие привилегий администратора, можно делать "
"только локально, где вопросы безопасности и мониторинга регулируются с "
"помощью средств Unix-системы."

#: ../book/administration.rst:531
msgid ""
"For additional security, some requests are illegal. For example, :ref:`"
"\"conn:eval\" <net_box-eval>`  will result in the error message \"- error: "
"console does not support this request type\" because ``conn:eval`` requires "
"the binary protocol."
msgstr ""
"В целях дополнительной безопасности некоторые запросы на портах для "
"администрирования запрещены. Например, :ref:`conn:eval <net_box-eval>` "
"вернет сообщение об ошибке ``- error: console does not support this request "
"type``, поскольку запрос ``conn:eval`` должен осуществляться в рамках "
"бинарного протокола."

#: ../book/administration.rst:536
msgid ""
"If security via admin ports is not necessary, it is still possible to be an "
"admin user by :ref:`using the tarantool server as a client <administration-"
"using_tarantool_as_a_client>`, or by connecting to a binary port with a "
"valid password."
msgstr ""
"Если вопросы безопасности на портах для администрирования неактуальны, то "
"стать пользователем с правами администратора можно, :ref:`используя "
"Tarantool-сервер в качестве клиента <administration-"
"using_tarantool_as_a_client>` или указав администраторский пароль при "
"установке соединения по бинарному протоколу."

#: ../book/administration.rst:541
msgid ""
"To find out whether a TCP port is an admin port, use :program:`telnet`. For "
"example:"
msgstr ""
"Выяснить, является ли некий TCP-порт портом для администрирования, можно с "
"помощью :program:`telnet`. Например:"

#: ../doc/book/administration.rst:547
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.2-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"
msgstr ""

#: ../book/administration.rst:553
msgid ""
"In this example the response does not include the word \"binary\" and does "
"include the words \"Lua console\". Therefore it is clear that this is a "
"successful connection to an admin port, and admin requests can now be "
"entered on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua "
"console\". Это значит, что мы установили соединение на порту для "
"администрирования и можем вводить администраторские запросы на этом "
"терминале."

#: ../book/administration.rst:560
msgid "Administrative requests"
msgstr "Служебные запросы"

#: ../doc/book/admin.rst:1 ../book/admin.rst:1
msgid ""
"To learn which functions are considered to be administrative, type "
"``help()``. A reference description also follows below:"
msgstr ""

#: ../doc/book/admin.rst:8 ../book/admin.rst:8
msgid ""
"Take a snapshot of all data and store it in :ref:`snap_dir <cfg_basic-"
"snap_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first "
"enters the delayed garbage collection mode for all data. In this mode, "
"tuples which were allocated before the snapshot has started are not freed "
"until the snapshot has finished. To preserve consistency of the primary key, "
"used to iterate over tuples, a copy-on-write technique is employed. If the "
"master process changes part of a primary key, the corresponding process page "
"is split, and the snapshot process obtains an old copy of the page. In "
"effect, the snapshot process uses multi-version concurrency control in order "
"to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../doc/book/admin.rst:19 ../book/admin.rst:19
#, python-format
msgid ""
"Since a snapshot is written sequentially, one can expect a very high write "
"performance (averaging to 80MB/second on modern disks), which means an "
"average database instance gets saved in a matter of minutes. Note: as long "
"as there are any changes to the parent index memory through concurrent "
"updates, there are going to be page splits, and therefore one needs to have "
"some extra free memory to run this command. 10% of :ref:`slab_alloc_arena "
"<cfg_storage-slab_alloc_arena>` is, on average, sufficient. This statement "
"waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../doc/book/admin.rst:28 ../book/admin.rst:28
msgid ""
"Change Notice: prior to Tarantool version 1.6.6, the snapshot process caused "
"a fork, which could cause occasional latency spikes. Starting with Tarantool "
"version 1.6.6, the snapshot process creates a consistent read view and "
"writes this view to the snapshot file from a separate thread."
msgstr ""

#: ../doc/book/admin.rst:33 ../book/admin.rst:33
msgid ""
"Although box.snapshot() does not cause a fork, there is a separate fiber "
"which may produce snapshots at regular intervals -- see the discussion of "
"the :ref:`snapshot daemon <book_cfg_snapshot_daemon>`."
msgstr ""

#: ../doc/book/admin.rst:37 ../doc/book/box/authentication.rst:152
#: ../doc/book/box/authentication.rst:275 ../doc/book/box/box_cfg.rst:42
#: ../doc/book/box/box_index.rst:73 ../doc/book/box/box_index.rst:447
#: ../doc/book/box/box_index.rst:583 ../doc/book/box/box_index.rst:612
#: ../doc/book/box/box_index.rst:641 ../doc/book/box/box_index.rst:670
#: ../doc/book/box/box_index.rst:698 ../doc/book/box/box_index.rst:769
#: ../doc/book/box/box_index.rst:791 ../doc/book/box/box_index.rst:812
#: ../doc/book/box/box_info.rst:78 ../doc/book/box/box_schema.rst:162
#: ../doc/book/box/box_schema.rst:192 ../doc/book/box/box_schema.rst:221
#: ../doc/book/box/box_schema.rst:237 ../doc/book/box/box_schema.rst:255
#: ../doc/book/box/box_schema.rst:272 ../doc/book/box/box_schema.rst:291
#: ../doc/book/box/box_schema.rst:306 ../doc/book/box/box_schema.rst:319
#: ../doc/book/box/box_schema.rst:343 ../doc/book/box/box_schema.rst:371
#: ../doc/book/box/box_schema.rst:386 ../doc/book/box/box_schema.rst:409
#: ../doc/book/box/box_schema.rst:428 ../doc/book/box/box_schema.rst:441
#: ../doc/book/box/box_slab.rst:55 ../doc/book/box/box_slab.rst:115
#: ../doc/book/box/box_slab.rst:157 ../doc/book/box/box_space.rst:287
#: ../doc/book/box/box_space.rst:317 ../doc/book/box/box_space.rst:395
#: ../doc/book/box/box_space.rst:416 ../doc/book/box/box_space.rst:435
#: ../doc/book/box/box_space.rst:470 ../doc/book/box/box_space.rst:538
#: ../doc/book/box/box_space.rst:641 ../doc/book/box/box_space.rst:664
#: ../doc/book/box/box_space.rst:692 ../doc/book/box/box_space.rst:730
#: ../doc/book/box/box_space.rst:749 ../doc/book/box/box_space.rst:772
#: ../doc/book/box/box_space.rst:789 ../doc/book/box/box_space.rst:819
#: ../doc/book/box/box_space.rst:850 ../doc/book/box/box_space.rst:887
#: ../doc/book/box/box_space.rst:923 ../doc/book/box/box_space.rst:965
#: ../doc/book/box/box_space.rst:1009 ../doc/book/box/box_tuple.rst:62
#: ../doc/book/box/triggers.rst:58 ../doc/book/box/triggers.rst:85
#: ../doc/book/box/triggers.rst:157 ../doc/book/box/triggers.rst:188
#: ../doc/book/box/triggers.rst:206
#: ../doc/dev_guide/documentation_guidelines.rst:225
#: ../doc/dev_guide/documentation_guidelines.rst:263
#: ../doc/dev_guide/reference_capi/coio.rst:68
#: ../doc/dev_guide/reference_capi/say.rst:77
#: ../doc/dev_guide/reference_capi/tuple.rst:158
#: ../doc/reference/reference_lua/box_error.rst:76
#: ../doc/reference/reference_lua/box_error.rst:114
#: ../doc/reference/reference_lua/clock.rst:54
#: ../doc/reference/reference_lua/clock.rst:76
#: ../doc/reference/reference_lua/clock.rst:94
#: ../doc/reference/reference_lua/clock.rst:112
#: ../doc/reference/reference_lua/clock.rst:134
#: ../doc/reference/reference_lua/console.rst:74
#: ../doc/reference/reference_lua/console.rst:107
#: ../doc/reference/reference_lua/console.rst:132
#: ../doc/reference/reference_lua/crypto.rst:67
#: ../doc/reference/reference_lua/crypto.rst:96
#: ../doc/reference/reference_lua/csv.rst:73
#: ../doc/reference/reference_lua/csv.rst:152
#: ../doc/reference/reference_lua/csv.rst:195
#: ../doc/reference/reference_lua/fiber.rst:91
#: ../doc/reference/reference_lua/fiber.rst:115
#: ../doc/reference/reference_lua/fiber.rst:135
#: ../doc/reference/reference_lua/fiber.rst:155
#: ../doc/reference/reference_lua/fiber.rst:169
#: ../doc/reference/reference_lua/fiber.rst:186
#: ../doc/reference/reference_lua/fiber.rst:205
#: ../doc/reference/reference_lua/fiber.rst:232
#: ../doc/reference/reference_lua/fiber.rst:248
#: ../doc/reference/reference_lua/fiber.rst:268
#: ../doc/reference/reference_lua/fiber.rst:289
#: ../doc/reference/reference_lua/fiber.rst:314
#: ../doc/reference/reference_lua/fiber.rst:334
#: ../doc/reference/reference_lua/fiber.rst:359
#: ../doc/reference/reference_lua/fiber.rst:379
#: ../doc/reference/reference_lua/fiber.rst:424
#: ../doc/reference/reference_lua/fiber.rst:443
#: ../doc/reference/reference_lua/fio.rst:55
#: ../doc/reference/reference_lua/fio.rst:75
#: ../doc/reference/reference_lua/fio.rst:93
#: ../doc/reference/reference_lua/fio.rst:115
#: ../doc/reference/reference_lua/fio.rst:135
#: ../doc/reference/reference_lua/fio.rst:173
#: ../doc/reference/reference_lua/fio.rst:194
#: ../doc/reference/reference_lua/fio.rst:209
#: ../doc/reference/reference_lua/fio.rst:222
#: ../doc/reference/reference_lua/fio.rst:246
#: ../doc/reference/reference_lua/fio.rst:269
#: ../doc/reference/reference_lua/fio.rst:288
#: ../doc/reference/reference_lua/fio.rst:311
#: ../doc/reference/reference_lua/fio.rst:327
#: ../doc/reference/reference_lua/fio.rst:362
#: ../doc/reference/reference_lua/fio.rst:384
#: ../doc/reference/reference_lua/fio.rst:407
#: ../doc/reference/reference_lua/fio.rst:437
#: ../doc/reference/reference_lua/fio.rst:455
#: ../doc/reference/reference_lua/fio.rst:478
#: ../doc/reference/reference_lua/fio.rst:496
#: ../doc/reference/reference_lua/fio.rst:528
#: ../doc/reference/reference_lua/json.rst:51
#: ../doc/reference/reference_lua/json.rst:89
#: ../doc/reference/reference_lua/json.rst:115
#: ../doc/reference/reference_lua/net_box.rst:119
#: ../doc/reference/reference_lua/net_box.rst:136
#: ../doc/reference/reference_lua/net_box.rst:150
#: ../doc/reference/reference_lua/net_box.rst:163
#: ../doc/reference/reference_lua/net_box.rst:178
#: ../doc/reference/reference_lua/net_box.rst:200
#: ../doc/reference/reference_lua/net_box.rst:258
#: ../doc/reference/reference_lua/net_box.rst:274
#: ../doc/reference/reference_lua/net_box.rst:285
#: ../doc/reference/reference_lua/other.rst:43
#: ../doc/reference/reference_lua/other.rst:80
#: ../doc/reference/reference_lua/pickle.rst:92
#: ../doc/reference/reference_lua/pickle.rst:137
#: ../doc/reference/reference_lua/socket.rst:141
#: ../doc/reference/reference_lua/socket.rst:159
#: ../doc/reference/reference_lua/socket.rst:176
#: ../doc/reference/reference_lua/socket.rst:246
#: ../doc/reference/reference_lua/socket.rst:402
#: ../doc/reference/reference_lua/strict.rst:44
#: ../doc/reference/reference_lua/tap.rst:96
#: ../doc/reference/reference_lua/tap.rst:138
#: ../doc/reference/reference_lua/tarantool.rst:45
#: ../doc/reference/reference_rock/dbms.rst:217
#: ../doc/reference/reference_rock/dbms.rst:241
#: ../doc/reference/reference_rock/dbms.rst:265
#: ../doc/reference/reference_rock/dbms.rst:562
#: ../doc/reference/reference_rock/dbms.rst:586
#: ../doc/reference/reference_rock/dbms.rst:609 ../book/admin.rst:37
#: ../book/box/authentication.rst:152 ../book/box/authentication.rst:275
#: ../book/box/box_index.rst:70 ../book/box/box_index.rst:443
#: ../book/box/box_index.rst:579 ../book/box/box_index.rst:608
#: ../book/box/box_index.rst:637 ../book/box/box_index.rst:666
#: ../book/box/box_index.rst:694 ../book/box/box_index.rst:765
#: ../book/box/box_index.rst:787 ../book/box/box_index.rst:808
#: ../book/box/box_introspection.rst:14 ../book/box/box_introspection.rst:57
#: ../book/box/box_introspection.rst:114 ../book/box/box_schema.rst:159
#: ../book/box/box_schema.rst:189 ../book/box/box_schema.rst:218
#: ../book/box/box_schema.rst:234 ../book/box/box_schema.rst:252
#: ../book/box/box_schema.rst:269 ../book/box/box_schema.rst:288
#: ../book/box/box_schema.rst:303 ../book/box/box_schema.rst:316
#: ../book/box/box_schema.rst:340 ../book/box/box_schema.rst:368
#: ../book/box/box_schema.rst:383 ../book/box/box_schema.rst:406
#: ../book/box/box_schema.rst:425 ../book/box/box_schema.rst:438
#: ../book/box/box_space.rst:284 ../book/box/box_space.rst:314
#: ../book/box/box_space.rst:392 ../book/box/box_space.rst:413
#: ../book/box/box_space.rst:432 ../book/box/box_space.rst:467
#: ../book/box/box_space.rst:535 ../book/box/box_space.rst:638
#: ../book/box/box_space.rst:661 ../book/box/box_space.rst:689
#: ../book/box/box_space.rst:727 ../book/box/box_space.rst:746
#: ../book/box/box_space.rst:769 ../book/box/box_space.rst:786
#: ../book/box/box_space.rst:818 ../book/box/box_space.rst:851
#: ../book/box/box_space.rst:875 ../book/box/box_space.rst:911
#: ../book/box/box_space.rst:953 ../book/box/box_space.rst:997
#: ../book/box/box_tuple.rst:59 ../book/box/triggers.rst:58
#: ../book/box/triggers.rst:85 ../book/box/triggers.rst:157
#: ../book/box/triggers.rst:188 ../book/box/triggers.rst:206
#: ../dev_guide/documentation_guidelines.rst:222
#: ../dev_guide/documentation_guidelines.rst:260
#: ../dev_guide/reference_capi/coio.rst:65
#: ../dev_guide/reference_capi/say.rst:74
#: ../dev_guide/reference_capi/tuple.rst:155
#: ../reference/reference_lua/box_error.rst:71
#: ../reference/reference_lua/box_error.rst:107
#: ../reference/reference_lua/clock.rst:51
#: ../reference/reference_lua/clock.rst:72
#: ../reference/reference_lua/clock.rst:90
#: ../reference/reference_lua/clock.rst:108
#: ../reference/reference_lua/clock.rst:130
#: ../reference/reference_lua/console.rst:71
#: ../reference/reference_lua/console.rst:104
#: ../reference/reference_lua/console.rst:129
#: ../reference/reference_lua/crypto.rst:64
#: ../reference/reference_lua/crypto.rst:93
#: ../reference/reference_lua/csv.rst:70 ../reference/reference_lua/csv.rst:149
#: ../reference/reference_lua/csv.rst:192
#: ../reference/reference_lua/fiber.rst:88
#: ../reference/reference_lua/fiber.rst:112
#: ../reference/reference_lua/fiber.rst:132
#: ../reference/reference_lua/fiber.rst:152
#: ../reference/reference_lua/fiber.rst:166
#: ../reference/reference_lua/fiber.rst:183
#: ../reference/reference_lua/fiber.rst:202
#: ../reference/reference_lua/fiber.rst:229
#: ../reference/reference_lua/fiber.rst:245
#: ../reference/reference_lua/fiber.rst:265
#: ../reference/reference_lua/fiber.rst:286
#: ../reference/reference_lua/fiber.rst:311
#: ../reference/reference_lua/fiber.rst:331
#: ../reference/reference_lua/fiber.rst:356
#: ../reference/reference_lua/fiber.rst:376
#: ../reference/reference_lua/fiber.rst:421
#: ../reference/reference_lua/fiber.rst:440
#: ../reference/reference_lua/fio.rst:52 ../reference/reference_lua/fio.rst:72
#: ../reference/reference_lua/fio.rst:90 ../reference/reference_lua/fio.rst:112
#: ../reference/reference_lua/fio.rst:132
#: ../reference/reference_lua/fio.rst:170
#: ../reference/reference_lua/fio.rst:191
#: ../reference/reference_lua/fio.rst:206
#: ../reference/reference_lua/fio.rst:219
#: ../reference/reference_lua/fio.rst:243
#: ../reference/reference_lua/fio.rst:266
#: ../reference/reference_lua/fio.rst:285
#: ../reference/reference_lua/fio.rst:308
#: ../reference/reference_lua/fio.rst:324
#: ../reference/reference_lua/fio.rst:357
#: ../reference/reference_lua/fio.rst:379
#: ../reference/reference_lua/fio.rst:402
#: ../reference/reference_lua/fio.rst:432
#: ../reference/reference_lua/fio.rst:450
#: ../reference/reference_lua/fio.rst:473
#: ../reference/reference_lua/fio.rst:491
#: ../reference/reference_lua/fio.rst:523 ../reference/reference_lua/jit.rst:40
#: ../reference/reference_lua/jit.rst:55 ../reference/reference_lua/jit.rst:68
#: ../reference/reference_lua/jit.rst:82 ../reference/reference_lua/jit.rst:103
#: ../reference/reference_lua/json.rst:48
#: ../reference/reference_lua/json.rst:86
#: ../reference/reference_lua/json.rst:112
#: ../reference/reference_lua/net_box.rst:77
#: ../reference/reference_lua/net_box.rst:93
#: ../reference/reference_lua/net_box.rst:107
#: ../reference/reference_lua/net_box.rst:120
#: ../reference/reference_lua/net_box.rst:136
#: ../reference/reference_lua/net_box.rst:194
#: ../reference/reference_lua/net_box.rst:210
#: ../reference/reference_lua/net_box.rst:221
#: ../reference/reference_lua/os.rst:55 ../reference/reference_lua/os.rst:78
#: ../reference/reference_lua/os.rst:97 ../reference/reference_lua/os.rst:114
#: ../reference/reference_lua/os.rst:132 ../reference/reference_lua/os.rst:147
#: ../reference/reference_lua/os.rst:160 ../reference/reference_lua/os.rst:175
#: ../reference/reference_lua/os.rst:190
#: ../reference/reference_lua/other.rst:40
#: ../reference/reference_lua/other.rst:77
#: ../reference/reference_lua/pickle.rst:89
#: ../reference/reference_lua/pickle.rst:134
#: ../reference/reference_lua/socket.rst:135
#: ../reference/reference_lua/socket.rst:153
#: ../reference/reference_lua/socket.rst:170
#: ../reference/reference_lua/socket.rst:198
#: ../reference/reference_lua/socket.rst:232
#: ../reference/reference_lua/socket.rst:379
#: ../reference/reference_lua/strict.rst:41
#: ../reference/reference_lua/tap.rst:93 ../reference/reference_lua/tap.rst:135
#: ../reference/reference_lua/tarantool.rst:42
#: ../reference/reference_rock/dbms.rst:214
#: ../reference/reference_rock/dbms.rst:238
#: ../reference/reference_rock/dbms.rst:262
#: ../reference/reference_rock/dbms.rst:559
#: ../reference/reference_rock/dbms.rst:583
#: ../reference/reference_rock/dbms.rst:606 ../reference_capi/coio.rst:65
#: ../reference_capi/say.rst:74 ../reference_capi/tuple.rst:155
#: ../reference_lua/box_error.rst:71 ../reference_lua/box_error.rst:107
#: ../reference_lua/clock.rst:51 ../reference_lua/clock.rst:72
#: ../reference_lua/clock.rst:90 ../reference_lua/clock.rst:108
#: ../reference_lua/clock.rst:130 ../reference_lua/console.rst:71
#: ../reference_lua/console.rst:104 ../reference_lua/console.rst:129
#: ../reference_lua/crypto.rst:64 ../reference_lua/crypto.rst:93
#: ../reference_lua/csv.rst:70 ../reference_lua/csv.rst:149
#: ../reference_lua/csv.rst:191 ../reference_lua/fiber.rst:88
#: ../reference_lua/fiber.rst:112 ../reference_lua/fiber.rst:132
#: ../reference_lua/fiber.rst:152 ../reference_lua/fiber.rst:166
#: ../reference_lua/fiber.rst:183 ../reference_lua/fiber.rst:202
#: ../reference_lua/fiber.rst:229 ../reference_lua/fiber.rst:245
#: ../reference_lua/fiber.rst:265 ../reference_lua/fiber.rst:286
#: ../reference_lua/fiber.rst:311 ../reference_lua/fiber.rst:331
#: ../reference_lua/fiber.rst:356 ../reference_lua/fiber.rst:376
#: ../reference_lua/fiber.rst:421 ../reference_lua/fiber.rst:440
#: ../reference_lua/fio.rst:52 ../reference_lua/fio.rst:72
#: ../reference_lua/fio.rst:90 ../reference_lua/fio.rst:112
#: ../reference_lua/fio.rst:132 ../reference_lua/fio.rst:170
#: ../reference_lua/fio.rst:191 ../reference_lua/fio.rst:206
#: ../reference_lua/fio.rst:219 ../reference_lua/fio.rst:243
#: ../reference_lua/fio.rst:266 ../reference_lua/fio.rst:285
#: ../reference_lua/fio.rst:308 ../reference_lua/fio.rst:324
#: ../reference_lua/fio.rst:357 ../reference_lua/fio.rst:379
#: ../reference_lua/fio.rst:402 ../reference_lua/fio.rst:432
#: ../reference_lua/fio.rst:450 ../reference_lua/fio.rst:473
#: ../reference_lua/fio.rst:491 ../reference_lua/fio.rst:523
#: ../reference_lua/jit.rst:40 ../reference_lua/jit.rst:55
#: ../reference_lua/jit.rst:68 ../reference_lua/jit.rst:82
#: ../reference_lua/jit.rst:103 ../reference_lua/json.rst:48
#: ../reference_lua/json.rst:86 ../reference_lua/json.rst:112
#: ../reference_lua/net_box.rst:77 ../reference_lua/net_box.rst:93
#: ../reference_lua/net_box.rst:107 ../reference_lua/net_box.rst:120
#: ../reference_lua/net_box.rst:136 ../reference_lua/net_box.rst:194
#: ../reference_lua/net_box.rst:210 ../reference_lua/net_box.rst:221
#: ../reference_lua/os.rst:55 ../reference_lua/os.rst:78
#: ../reference_lua/os.rst:97 ../reference_lua/os.rst:114
#: ../reference_lua/os.rst:132 ../reference_lua/os.rst:147
#: ../reference_lua/os.rst:160 ../reference_lua/os.rst:175
#: ../reference_lua/os.rst:190 ../reference_lua/other.rst:40
#: ../reference_lua/other.rst:77 ../reference_lua/pickle.rst:89
#: ../reference_lua/pickle.rst:134 ../reference_lua/socket.rst:135
#: ../reference_lua/socket.rst:152 ../reference_lua/socket.rst:169
#: ../reference_lua/socket.rst:197 ../reference_lua/socket.rst:231
#: ../reference_lua/socket.rst:378 ../reference_lua/strict.rst:41
#: ../reference_lua/tap.rst:93 ../reference_lua/tap.rst:135
#: ../reference_lua/tarantool.rst:42 ../reference_rock/dbms.rst:214
#: ../reference_rock/dbms.rst:238 ../reference_rock/dbms.rst:262
#: ../reference_rock/dbms.rst:559 ../reference_rock/dbms.rst:583
#: ../reference_rock/dbms.rst:606
msgid "**Example:**"
msgstr ""

#: ../doc/book/admin.rst:39 ../book/admin.rst:39
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/book/admin.rst:54 ../book/admin.rst:54
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead log. "
"Once a snapshot is taken, old WALs can be deleted as long as all replicas "
"are up to date. But the WAL which was current at the time ``box.snapshot()`` "
"started must be kept for recovery, since it still contains log records "
"written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/book/admin.rst:60 ../book/admin.rst:60
msgid ""
"An alternative way to save a snapshot is to send the server SIGUSR1 UNIX "
"signal. While this approach could be handy, it is not recommended for use in "
"automation: a signal provides no way to find out whether the snapshot was "
"taken successfully or not."
msgstr ""

#: ../doc/book/admin.rst:67 ../book/admin.rst:67
msgid ""
"Fork and dump a core. Since Tarantool stores all tuples in memory, it can "
"take some time. Mainly useful for debugging."
msgstr ""

#: ../book/administration.rst:566
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/book/administration.rst:571
msgid ""
"For server introspection, use the reports provided by functions in the "
"following submodules:"
msgstr ""

#: ../doc/book/administration.rst:574
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all "
"configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/book/administration.rst:576
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total "
"use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/book/administration.rst:579
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect "
"Tarantool's server variables)"
msgstr ""

#: ../doc/book/administration.rst:581
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect "
"Tarantool's request and network statistics)"
msgstr ""

#: ../book/administration.rst:572
msgid "Replication"
msgstr "Репликация"

#: ../book/replication.rst:3
msgid ""
"Replication allows multiple Tarantool servers to work on copies of the same "
"databases. The databases are kept in synch because each server can "
"communicate its changes to all the other servers. Servers which share the "
"same databases are a \"cluster\". Each server in a cluster also has a "
"numeric identifier which is unique within the cluster, known as the \"server "
"id\"."
msgstr ""
"Механизм репликации позволяет сразу многим Tarantool-серверам работать с "
"копиями одних и тех же баз данных. При этом все базы остаются в "
"синхронизированном состоянии благодаря тому, что каждый сервер может "
"сообщать другим серверам о совершенных им изменениях. Сервера, которые "
"работают над одними и теми же базами, представляют собой \"кластер\". У "
"каждого сервера в кластере есть числовой идентификатор (server id), "
"уникальный в рамках кластера."

#: ../book/replication.rst:9
msgid ""
"To set up replication, it's necessary to set up the master servers which "
"make the original data-change requests, set up the replica servers which "
"copy data-change requests from masters, and establish procedures for "
"recovery from a degraded state."
msgstr ""
"Чтобы настроить репликацию, необходимо настроить главные сервера (master), "
"которые первыми обрабатывают запросы на изменение данных, затем настроить "
"сервера-реплики (replica), которые копируют к себе запросы на изменение "
"данных с главных серверов, и прописать процедуры для восстановления после "
"сбоя."

#: ../book/replication.rst:16
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../book/replication.rst:18
msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its write-ahead log (WAL). Each record in the WAL represents a "
"single Tarantool data-change request such as INSERT or UPDATE or DELETE, and "
"is assigned a monotonically growing log sequence number (LSN). In essence, "
"Tarantool replication is row-based: each data change command is fully "
"deterministic and operates on a single tuple."
msgstr ""
"Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика "
"непрерывно опрашивает главный сервер на предмет обновлений в его WAL-файле "
"(write ahead log) и применяет эти обновления на своей стороне. Каждая запись "
"в WAL-файле представляет собой один запрос на изменение данных (например, "
"INSERT, UPDATE или DELETE) и присвоенный данной записи номер (LSN = log "
"sequence number). Номера присваиваются в порядке возрастания. По сути, "
"репликация в Tarantool'е является построчной: все команды на изменение "
"данных полностью детерминированы, и каждая такая команда относится только к "
"одному кортежу."

#: ../book/replication.rst:25
msgid ""
"A stored program invocation is not written to the write-ahead log. Instead, "
"log events for actual data-change requests, performed by the Lua code, are "
"written to the log. This ensures that possible non-determinism of Lua does "
"not cause replication to go out of sync."
msgstr ""
"Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале событий "
"(event log). Таким образом гарантируется, что не детерминированное поведение "
"логики на Lua не приведет к рассинхронизации реплицированных данных."

#: ../doc/book/replication.rst:32 ../book/replication.rst:32
#, fuzzy
msgid "Setting up a master"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Настройка главного сервера"

#: ../book/replication.rst:34
msgid ""
"To prepare the master for connections from the replica, it's only necessary "
"to include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` "
"request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen"
"\" URI can accept connections from as many replicas as necessary on that "
"URI. Each replica has its own :ref:`replication state <index-"
"monitoring_replica_actions>`."
msgstr ""
"Чтобы настроить возможность установки соединения для реплик, на стороне "
"главного сервера требуется лишь указать значение для параметра \":ref:"
"`listen <cfg_basic-listen>`\" в init-запросе ``box.cfg``. Например, ``box."
"cfg{listen=3301}``. Когда URI для прослушивания задан, главный сервер готов "
"принимать запросы на соединение от любого количества реплик. Каждая реплика "
"при этом находится в некотором :ref:`статусе репликации <index-"
"monitoring_replica_actions>`."

#: ../book/replication.rst:42
msgid "Setting up a replica"
msgstr "Настройка сервера-реплики"

#: ../book/replication.rst:44
msgid ""
"A server requires a valid snapshot (.snap) file. A snapshot file is created "
"for a server the first time that ``box.cfg`` occurs for it. If this first "
"``box.cfg`` request occurs without a \"replication source\" clause, then the "
"server is a master and starts its own new cluster with a new unique UUID. If "
"this first ``box.cfg`` request occurs with a \"replication source\" clause, "
"then the server is a replica and its snapshot file, along with the cluster "
"information, is constructed from the write-ahead logs of the master. "
"Therefore, to start replication, specify :ref:`replication_source "
"<cfg_replication-replication_source>` in a ``box.cfg`` request. When a "
"replica contacts a master for the first time, it becomes part of a cluster. "
"On subsequent occasions, it should always contact a master in the same "
"cluster."
msgstr ""
"Каждому Tarantool-серверу необходим корректный файл со статическим снимком "
"данных (.snap-файл). Файл-снимок создается на сервере при первом запросе "
"``box.cfg``. Если при первом таком запросе на сервере не определен источник "
"репликации (replication source), то сервер стартует в режиме главного "
"сервера и создает для себя новый кластер с новым уникальными UUID. Если же "
"источник репликации при первом ``box.cfg``-запросе определен, то сервер "
"стартует в режиме реплики, а файл-снимок и информация о кластере берутся из "
"WAL-файлов на главном сервере. Поэтому при настройке репликации нужно "
"указать параметр :ref:`replication_source <cfg_replication-"
"replication_source>` в запросе ``box.cfg``. При первом соединении с главным "
"сервером сервер-реплика включается в состав кластера. В дальнейшем такая "
"реплика общается только с главным сервером из данного кластера."

#: ../book/replication.rst:56
msgid ""
"Once connected to the master, the replica requests all changes that happened "
"after the latest local LSN. It is therefore necessary to keep WAL files on "
"the master host as long as there are replicas that haven't applied them yet. "
"A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap "
"file and the WAL .xlog files), then starting replication again - the replica "
"will then catch up with the master by retrieving all the master's tuples. "
"Again, this procedure works only if the master's WAL files are present."
msgstr ""
"После установки соединения с главным сервером реплика запрашивает у него все "
"изменения, чьи LSN-номера в WAL-файле больше номера последнего локального "
"изменения на реплике. Поэтому WAL-файлы на главном сервере нужно хранить до "
"тех пор, пока все реплики не применят изменения из этих WAL-файлов на своей "
"стороне. Состояние реплики можно \"обнулить\", удалив все файлы репликации (."
"snap-файл со снимком и .xlog-файлы с записями WAL) и запустив сервер снова. "
"Реплика при этом возьмет все кортежи с главного сервера и придет в "
"синхронизированное состояние. Обратите внимание, что такая процедура "
"\"обнуления\" сработает, только если на главном сервере будут доступны все "
"нужные WAL-файлы."

#: ../book/replication.rst:66
msgid ""
"Replication parameters are \"dynamic\", which allows the replica to become a "
"master and vice versa with the help of the :ref:`box.cfg <box_introspection-"
"box_cfg>` statement."
msgstr ""
"Параметры репликации можно менять на лету, что позволяет назначать реплику "
"на роль главного сервера и наоборот. Для этого используется запрос :ref:`box."
"cfg <box_introspection-box_cfg>`."

#: ../book/replication.rst:72
msgid ""
"The replica does not inherit the master's configuration parameters, such as "
"the ones that cause the :ref:`snapshot daemon <book_cfg_snapshot_daemon>` to "
"run on the master. To get the same behavior, one would have to set the "
"relevant parameters explicitly so that they are the same on both master and "
"replica."
msgstr ""
"Реплика не берет настройки конфигурации с главного сервера, например "
"настройки запуска :ref:`фоновой программы для работы со снимками "
"<book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же "
"настройки на реплике, нужно задать их явным образом."

#: ../book/replication.rst:80
msgid ""
"Replication requires privileges. Privileges for accessing spaces could be "
"granted directly to the user who will start the replica. However, it is more "
"usual to grant privileges for accessing spaces to a :ref:`role "
"<authentication-rep_role>`, and then grant the role to the user who will "
"start the replica."
msgstr ""
"Репликация требует настройки привилегий. Привилегии для доступа к "
"пространствам можно задать напрямую для пользователя, под чьим именем "
"запущен сервер-реплика. Но обычно привилегии на доступ к пространствам "
"задаются с помощью :ref:`роли <authentication-rep_role>`, которая затем "
"присваивается пользователю, под чьим именем запущен сервер-реплика."

#: ../book/replication.rst:88
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../book/replication.rst:90
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable - due "
"to hardware or network failure, or due to a programming bug. There is no "
"automatic way for a replica to detect that the master is gone forever, since "
"sources of failure and replication environments vary significantly. So the "
"detection of degraded state requires a human inspection."
msgstr ""
"\"Сбой\" — это ситуация, когда главный сервер становится недоступен "
"вследствие проблем с оборудованием, сетевых неполадок или программной "
"ошибки. У реплики нет способа автоматически обнаружить, что связь с главным "
"сервером утеряна насовсем, поскольку причины сбоя и окружение, в котором "
"развернута репликация, могут быть очень разными. Поэтому обнаруживать сбой "
"должен человек."

#: ../doc/book/replication.rst:96
msgid ""
"However, once a master failure is detected, the recovery is simple: declare "
"that the replica is now the new master, by saying :codenormal:`box.cfg{... "
"listen=`:codeitalic:`URI`:codenormal:`}`. Then, if there are updates on the "
"old master that were not propagated before the old master went down, they "
"would have to be re-applied manually."
msgstr ""

#: ../doc/book/replication.rst:104 ../book/replication.rst:104
#, fuzzy
msgid "Quick startup of a new simple two-server cluster"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#: ../book/replication.rst:106
msgid "Step 1. Start the first server thus:"
msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#: ../book/replication.rst:985
msgid ""
"box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""
"box.cfg{listen = *uri#1*}\n"
"-- в этом запросе можно задать больше ограничений\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"

#: ../book/replication.rst:116
msgid "... Now a new cluster exists."
msgstr "... Итак, создался новый кластер."

#: ../book/replication.rst:118
msgid ""
"Step 2. Check where the second server's files will go by looking at its "
"directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:"
"`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when "
"the second server joins for the first time, it has to be working with a "
"clean state so that the initial copy of the first server's databases can "
"happen without conflicts."
msgstr ""
"Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы "
"репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-"
"snap_dir>` (для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для ."
"xlog-файлов). В указанных директориях должно быть пусто, чтобы не случилось "
"конфликта с теми начальными данными, что придут с первого сервера, когда "
"второй сервер присоединится к кластеру."

#: ../book/replication.rst:124
msgid "Step 3. Start the second server thus:"
msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#: ../book/replication.rst:1003
msgid ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""
"box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"

#: ../book/replication.rst:134
msgid ""
"... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is "
"listening on."
msgstr ""
"... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено "
"прослушивание у первого сервера."

#: ../book/replication.rst:136
msgid "That's all."
msgstr "Вот и всё."

#: ../book/replication.rst:138
msgid ""
"In this configuration, the first server is the \"master\" and the second "
"server is the \"replica\". Henceforth every change that happens on the "
"master will be visible on the replica. A simple two-server cluster with the "
"master on one computer and the replica on a different computer is very "
"common and provides two benefits: FAILOVER (because if the master goes down "
"then the replica can take over), or LOAD BALANCING (because clients can "
"connect to either the master or the replica for select requests). Sometimes "
"the replica may be configured with the additional parameter :ref:`read_only "
"= true <cfg_basic-read_only>`."
msgstr ""
"В описанной выше конфигурации первый сервер выполняет роль \"главного\", а "
"второй служит \"репликой\". Далее все изменения, происходящие на стороне "
"главного сервера, будут доступны с реплики. Простой кластер из двух "
"серверов, где главный сервер запущен на одном компьютере, а сервер-реплика — "
"на другом, встречается очень часто и обладает двумя важными преимуществами: "
"FAILOVER (т.е. отказоустойчивость, поскольку в случае отключения главного "
"сервера его место может занять сервер-реплика) и LOAD BALANCING (т.е. "
"балансировка нагрузки, поскольку клиенты могут обращаться с SELECT-запросами "
"как к главному серверу, так и к реплике). При необходимости в настройках "
"реплики можно задать параметр :ref:`read_only = true <cfg_basic-read_only>`."

#: ../book/replication.rst:151
msgid "Monitoring a replica's actions"
msgstr "Мониторинг действий реплики"

#: ../doc/book/replication.rst:153
msgid ""
"In :ref:`box.info <box_introspection-box_info>` there is a ``box.info."
"replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", "
"\"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", "
"then there will be more fields -- the list is in the section :ref:`Submodule "
"box.info <box_introspection-box_info>`."
msgstr ""

#: ../book/replication.rst:159
msgid ""
"In the :ref:`log <log>` there is a record of replication activity. If a "
"primary server is started with:"
msgstr ""
"В :ref:`журнале <log>` ведется запись о действиях, связанных с репликацией. "
"Если главный сервер запущен со следующими настройками:"

#: ../book/replication.rst:1039
msgid ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""
"box.cfg{\n"
"  <...>,\n"
"  logger = *имя_файла_для_ведения_журнала*,\n"
"  <...>\n"
"}"

#: ../book/replication.rst:171
msgid ""
"then there will be lines in the log file, containing the word \"relay\", "
"when a replica connects or disconnects."
msgstr ""
"то на каждую установку/потерю соединения реплики с главным сервером в "
"журнале будут появляться строчки со словом \"relay\"."

#: ../book/replication.rst:178
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../book/replication.rst:180
msgid ""
"Suppose that the replica tries to do something that the master has already "
"done. For example: |br| ``box.schema.space.create('X')`` |br| This would "
"cause an error, \"Space X exists\". For this particular situation, the code "
"could be changed to: |br| ``box.schema.space.create('X', "
"{if_not_exists=true})`` |br| But there is a more general solution: the :samp:"
"`box.once({key}, {function})` method. If ``box.once()`` has been called "
"before with the same :samp:`{key}` value, then :samp:`{function}` is "
"ignored; otherwise :samp:`{function}` is executed. Therefore, actions which "
"should only occur once during the life of a replicated session should be "
"placed in a function which is executed via ``box.once()``. For example:"
msgstr ""
"Предположим, что реплика пытается сделать нечто, что уже было сделано на "
"главном сервере. Например: |br| :code:`box.schema.space.create('X')` |br| "
"Это приведет к ошибке \"Space X exists\" (\"Пространство X уже существует"
"\"). В данном частном случае можно скорректировать инструкцию следующим "
"образом: |br| :code:`box.schema.space.create('X', {if_not_exists=true})` |"
"br| Но существует и более общее решение: использовать метод :samp:`box."
"once({key}, {function})`. Если :code:`box.once()` был вызван ранее с тем же "
"значением параметра :samp:`{key}`, то функция :samp:`{function}` "
"игнорируется; в противном случае функция :samp:`{function}` будет выполнена. "
"Поэтому действия, которые должны совершаться только один раз за время "
"текущей сессии репликации, нужно помещать в функцию и вызывать ее с помощью "
"метода :code:`box.once()`. Например:"

#: ../book/replication.rst:195
msgid ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""
"function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"

#: ../book/replication.rst:204
msgid "Master-master replication"
msgstr "Репликация по схеме master-master"

#: ../book/replication.rst:206
msgid ""
"In the simple master-replica configuration, the master's changes are seen by "
"the replica, but not vice versa, because the master was specified as the "
"sole replication source. In the master-master configuration, also sometimes "
"called multi-master configuration, it's possible to go both ways. Starting "
"with the simple configuration, the first server has to say:"
msgstr ""
"В случае настройки репликации по схеме master-replica изменения на главном "
"сервере доступны для просмотра с реплики, но не наоборот, потому как главный "
"сервер в такой схеме указан в качестве единственного источника репликации. В "
"случае схемы master-master (иногда ее также называет multi-master) просмотр "
"изменений возможен в любом направлении. В простом случае (master-master с "
"двумя серверами) на первом сервере нужно задать следующие настройки:"

#: ../book/replication.rst:1090
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr "box.cfg{ replication_source = *uri#2* }"

#: ../book/replication.rst:218
msgid ""
"This request can be performed at any time -- :ref:`replication_source "
"<cfg_replication-replication_source>` is a dynamic parameter."
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр :ref:"
"`replication_source <cfg_replication-replication_source>` можно задавать на "
"ходу."

#: ../book/replication.rst:221
msgid ""
"In this configuration, both servers are \"masters\" and both servers are "
"\"replicas\". Henceforth every change that happens on either server will be "
"visible on the other. The failover benefit is still present, and the load-"
"balancing benefit is enhanced (because clients can connect to either server "
"for data-change requests as well as select requests)."
msgstr ""
"В данном примере оба сервера являются одновременно и \"главными\", и "
"\"репликами\". Поэтому каждое изменение, которое случается на одном сервере, "
"становится доступно для просмотра с другого сервера. Отказоустойчивость в "
"такой конфигурации сохраняется, а возможности по балансировке нагрузки "
"становятся еще шире (теперь клиенты могут обращаться к обоим серверам со "
"всеми типами запросов — как на чтение данных, так и на изменение)."

#: ../book/replication.rst:227
msgid ""
"If two operations for the same tuple take place \"concurrently\" (which can "
"involve a long interval because replication is asynchronous), and one of the "
"operations is ``delete`` or ``replace``, there is a possibility that servers "
"will end up with different contents."
msgstr ""
"Если две операции над одним и тем же кортежем производятся \"параллельно"
"\" (а это может потребовать много времени, поскольку репликация — это "
"асинхронный процесс), причем одна из операций — это ``delete``, а вторая — "
"``replace``, то существует вероятность, что данные на серверах станут "
"различаться."

#: ../book/replication.rst:234
msgid "All the \"What If?\" questions"
msgstr "Ответы на вопросы \"Что если?\""

#: ../book/replication.rst:236
msgid ""
"Q: What if there are more than two servers with master-master? |br| A: On "
"each server, specify the :ref:`replication_source <cfg_replication-"
"replication_source>` for all the others. For example, server #3 would have a "
"request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
"`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :"
"codenormal:`}`"
msgstr ""
"Вопрос: Что если в кластере вида master-master более двух серверов? |br| "
"Ответ: На каждом сервере нужно задать параметр :ref:`replication_source "
"<cfg_replication-replication_source>` и указать в нем все остальные сервера. "
"Например, для сервера #3 настройки будут следующими: |br| :codenormal:`box."
"cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:"
"codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"

#: ../book/replication.rst:243
msgid ""
"Q: What if a server should be taken out of the cluster? |br| A: For a "
"replica, run ``box.cfg{}`` again specifying a blank replication source: |br| "
"``box.cfg{replication_source=''}``"
msgstr ""
"Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: Для "
"реплики — выполните запрос ``box.cfg{}``, указав пустой источник репликации: "
"|br| ``box.cfg{replication_source=''}``"

#: ../book/replication.rst:247
msgid ""
"Q: What if a server leaves the cluster? |br| A: The other servers carry on. "
"If the wayward server rejoins, it will receive all the updates that the "
"other servers made while it was away."
msgstr ""
"Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: "
"Остальные сервера продолжают работать. Если выбывший сервер снова "
"возвращается в кластер, то он получит информацию о всех изменениях, которые "
"произошли на остальных серверах за время его отсутствия."

#: ../book/replication.rst:251
msgid ""
"Q: What if two servers both change the same tuple? |br| A: The last changer "
"wins. For example, suppose that server#1 changes the tuple, then server#2 "
"changes the tuple. In that case server#2's change overrides whatever "
"server#1 did. In order to keep track of who came last, Tarantool implements "
"a `vector clock <https://en.wikipedia.org/wiki/Vector_clock>`_."
msgstr ""
"Вопрос: Что если два сервера совершают изменения, связанные с одним и тем же "
"кортежем? |br| Ответ: Применятся последние из совершенных изменений. Для "
"примера предположим, что сервер #1 меняет некоторый кортеж, а затем сервер "
"#2 меняет тот же кортеж. В данном случае изменения сервера #2 затрут "
"изменения сервера #1. Чтобы отслеживать, кто был последним, в Tarantool'е "
"используются `векторные часы <https://en.wikipedia.org/wiki/Vector_clock>`_."

#: ../book/replication.rst:257
msgid ""
"Q: What if two servers both insert the same tuple? |br| A: If a master tries "
"to insert a tuple which a replica has inserted already, this is an example "
"of a severe error. Replication stops. It will have to be restarted manually."
msgstr ""
"Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? |"
"br| Ответ: Если главный сервер попытается вставить кортеж, который уже был "
"вставлен на реплике, то это будет пример серьезной ошибки. Репликация "
"остановится, и ее придется перезапускать в ручную."

#: ../book/replication.rst:262
msgid ""
"Q: What if a master disappears and the replica must take over? |br| A: A "
"message will appear on the replica stating that the connection is lost. The "
"replica must now become independent, which can be done by saying ``box."
"cfg{replication_source=''}``."
msgstr ""
"Вопрос: Что если главный сервер становится недоступен и пользователям "
"приходится переключаться реплику? |br| Ответ: Реплика получает сообщение, "
"что связь потеряна. Теперь реплика должна начать работать независимо. Для "
"этого ей нужно задать пустой источник репликации, выполнив на стороне "
"реплики запрос ``box.cfg{replication_source=''}``."

#: ../book/replication.rst:267
msgid ""
"Q: What if it's necessary to know what cluster a server is in? |br| A: The "
"identification of the cluster is a UUID which is generated when the first "
"master starts for the first time. This UUID is stored in a tuple of the :ref:"
"`box.space._schema <box_space-schema>` system space. So to see it, say: "
"``box.space._schema:select{'cluster'}``"
msgstr ""
"Вопрос: Что если нужно посмотреть, к какому кластеру принадлежит данный "
"сервер? |br| Ответ: Идентификатором кластера является UUID, который "
"генерируется при первом запуске главного сервера. Данный UUID хранится в "
"системном пространстве :ref:`box.space._schema <box_space-schema>`. Чтобы "
"посмотреть UUID кластера, введите запрос ``box.space._schema:"
"select{'cluster'}``"

#: ../book/replication.rst:273
msgid ""
"Q: What if it's necessary to know what other servers belong in the cluster? |"
"br| A: The universal identification of a server is a UUID in ``box.info."
"server.uuid``. The ordinal identification of a server within a cluster is a "
"number in ``box.info.server.id``. To see all the servers in the cluster, "
"say: ``box.space._cluster:select{}``. This will return a table with all "
"{server.id, server.uuid} tuples for every server that has ever joined the "
"cluster."
msgstr ""
"Вопрос: Что если нужно посмотреть, какие сервера входят в кластер? |br| "
"Ответ: У каждого сервера есть универсальный идентификатор — это его UUID в "
"поле ``box.info.server.uuid``. Также у сервера есть его порядковый "
"идентификатор в кластере — это номер в поле ``box.info.server.id``. Чтобы "
"увидеть номера всех серверов в кластере, введите запрос: ``box.space."
"_cluster:select{}``. Данный запрос возвращает таблицу со всеми кортежами "
"вида {server.id, server.uuid} для всех серверов, что когда-либо входили в "
"данный кластер."

#: ../book/replication.rst:281
msgid ""
"Q: What if one of the server's files is corrupted or deleted? |br| A: Stop "
"the server, destroy all the database files (the ones with extension \"snap\" "
"or \"xlog\" or \".inprogress\"), restart the server, and catch up with the "
"master by contacting it again (just say ``box.cfg{...replication_source=...}"
"``)."
msgstr ""
"Вопрос: Что если какой-то из файлов репликации на реплике поврежден или "
"удален? |br| Ответ: Нужно остановить сервер, удалить все файлы, относящиеся "
"к базе данных (это файлы с расширениями \"snap\", \"xlog\" и \".inprogress"
"\"), снова запустить сервер и ввести запрос ``box.cfg{..."
"replication_source=...}``, чтобы восстановить соединение с главным сервером "
"и загрузить данные с него."

#: ../book/replication.rst:287
msgid ""
"Q: What if replication causes security concerns? |br| A: Prevent "
"unauthorized replication sources by associating a password with every user "
"that has access privileges for the relevant spaces, and every user that has "
"a replication :ref:`role <authentication-rep_role>`. That way, the :ref:`URI "
"<index-uri>` for the :ref:`replication_source <cfg_replication-"
"replication_source>` parameter will always have to have the long form |br| "
"``replication_source='username:password@host:port'``"
msgstr ""
"Вопрос: Что если при репликации возникают вопросы, связанные с "
"безопасностью? |br| Ответ: Чтобы предотвратить появление несанкционированных "
"источников репликации, нужно задать пароль для каждого пользователя, у "
"которого есть привилегии доступа к соответствующим пространствам, а также "
"для каждого пользователя, у которого настроена :ref:`репликационная роль "
"<authentication-rep_role>`. Заметьте, что :ref:`URI <index-uri>` для "
"параметра :ref:`replication_source <cfg_replication-replication_source>` "
"теперь нужно всегда указывать в полном виде: |br| "
"``replication_source='username:password@host:port'``"

#: ../doc/book/replication.rst:294
msgid ""
"Q: What if advanced users want to understand better how it all works? |br| "
"A: See the description of server startup with replication in the :ref:"
"`Internals <internals-replication>` section."
msgstr ""

#: ../book/replication.rst:301
msgid "Hands-on replication tutorial"
msgstr "Практическое руководство по репликации"

#: ../book/replication.rst:303
msgid ""
"After following the steps here, an administrator will have experience "
"creating a cluster and adding a replica."
msgstr ""
"Ниже приводятся пошаговые инструкции, которые помогут вам получить "
"практический опыт администрирования кластера, а именно опыт создания "
"кластера и добавления реплики."

#: ../book/replication.rst:306
msgid ""
"Start two shells. Put them side by side on the screen. (This manual has a "
"tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to "
"switch to the display of the other shell.)"
msgstr ""
"Запустите два терминала, каждый в своем окне, и расположите их рядом на "
"экране. (Далее в примерах оба терминала показаны в виде закладок. Щелкните "
"на заголовок закладки — \"Terminal #1\" или \"Terminal #2\", — чтобы увидеть "
"вывод на соответствующем терминале.)"

#: ../book/replication.rst:332 ../book/replication.rst:339
#: ../book/replication/1_2.rst:1
msgid "$"
msgstr "$"

#: ../book/replication.rst:343
msgid ""
"On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#: ../book/replication.rst:345
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user."
"grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.user."
"grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:357
msgid ""
"The result is that a new cluster is set up, and the server's UUID is "
"displayed. Now the screen looks like this: (except that UUID values are "
"always different):"
msgstr ""
"В результате были заданы настройки нового кластера, а на экране был выведен "
"UUID текущего сервера. Теперь вывод на экране выглядит следующим образом (за "
"тем исключением, что UUID у вас будут другие):"

#: ../book/replication/1_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user."
"grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user."
"grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../book/replication.rst:389
msgid ""
"On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#: ../book/replication.rst:391
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:404
msgid ""
"The result is that a replica is set up. Messages appear on Terminal #1 "
"confirming that the replica has connected and that the WAL contents have "
"been shipped to the replica. Messages appear on Terminal #2 showing that "
"replication is starting. Also on Terminal#2 the _cluster UUID values are "
"displayed, and one of them is the same as the _cluster UUID value that was "
"displayed on Terminal #1, because both servers are in the same cluster."
msgstr ""
"В результате были заданы настройки сервера-реплики. На экране первого "
"терминала (Terminal #1) появились сообщения с подтверждениями, что реплика "
"установила соединение с главным сервером и что содержимое WAL-файла было "
"отправлено на реплику. На экране второго терминала (Terminal #2) появились "
"сообщения о том, что репликация начинается, а также там были выведены UUID "
"из системного пространства _cluster (один из них совпадает с UUID в первом "
"терминале, поскольку оба сервера входят в общий кластер)."

#: ../book/replication/2_1.rst:1
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../book/replication/2_2.rst:1 ../book/replication/3_2.rst:1
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
"snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
"inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000."
"snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog."
"inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../book/replication.rst:440
msgid "On Terminal #1, execute these requests:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:442
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#: ../book/replication.rst:448 ../book/replication.rst:615
msgid "Now the screen looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/3_1.rst:1 ../book/replication/4_1.rst:1
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication.rst:479
msgid ""
"The creation and insertion were successful on Terminal #1. Nothing has "
"happened on Terminal #2."
msgstr ""
"В первом терминале успешно отработали операции CREATE и INSERT. Но во втором "
"терминале ничего не произошло."

#: ../book/replication.rst:482
msgid "On Terminal #2, execute these requests:"
msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#: ../book/replication.rst:484
msgid ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""
"tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#: ../book/replication.rst:490
msgid ""
"Now the screen looks like this (remember to click on the \"Terminal #2\" tab "
"when looking at Terminal #2 results):"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/4_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../book/replication.rst:521
msgid ""
"The selection and insertion were successful on Terminal #2. Nothing has "
"happened on Terminal #1."
msgstr ""
"Во втором терминале успешно отработали операции SELECT и INSERT. Но в первом "
"терминале ничего не произошло."

#: ../book/replication.rst:524
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr ""
"В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#: ../book/replication.rst:526
msgid ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""
"$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"

#: ../book/replication.rst:532
msgid ""
"Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that "
"fact. The ``ls -l`` commands show that both servers have made snapshots, "
"which have similar sizes because they both contain the same tuples."
msgstr ""
"Теперь Tarantool-сервер в первом терминале остановлен. В окне второго "
"терминала появились сообщения об этом событии. С помощью команд ``ls -l`` мы "
"убедились, что на обоих серверах создались файлы-снимки с одинаковыми "
"размерами, поскольку там содержатся одни и те же кортежи."

#: ../book/replication/5_1.rst:1 ../book/replication/6_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../book/replication/5_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../book/replication.rst:565
msgid "On Terminal #2, ignore the error messages, and execute these requests:"
msgstr ""
"Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и "
"выполните следующие запросы:"

#: ../book/replication.rst:568
msgid ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"

#: ../book/replication.rst:573
msgid "Now the screen looks like this (ignoring the error messages):"
msgstr ""
"Теперь вывод на экране выглядит следующим образом (сообщения об ошибках мы "
"не приводим):"

#: ../book/replication/6_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../book/replication.rst:605
msgid ""
"Terminal #2 has done a select and an insert, even though Terminal #1 is down."
msgstr ""
"Запросы SELECT и INSERT во втором терминале отработали несмотря на то, что "
"сервер в первом терминале остановлен."

#: ../book/replication.rst:607
msgid "On Terminal #1 execute these commands:"
msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#: ../book/replication.rst:609
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication/7_1.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../book/replication/7_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../book/replication.rst:646
msgid ""
"The master has reconnected to the cluster, and has NOT found what the "
"replica wrote while the master was away. That is not a surprise -- the "
"replica has not been asked to act as a replication source."
msgstr ""
"Главный сервер снова установил соединение с кластером и НЕ обнаружил "
"изменения, сделанные репликой за время его недоступности. Это и не "
"удивительно: мы же не просили реплику выступать в качестве источника "
"репликации."

#: ../book/replication.rst:650
msgid "On Terminal #1, say:"
msgstr "В первом терминале (Terminal #1) введите:"

#: ../book/replication.rst:652
msgid ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../book/replication.rst:659
msgid "The screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../book/replication/8_1.rst:1
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000."
"xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000."
"xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../book/replication/8_2.rst:1
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../book/replication.rst:704
msgid ""
"This shows that the two servers are once again in synch, and that each "
"server sees what the other server wrote."
msgstr ""
"Тут мы видим, что оба сервера снова синхронизовались и что каждый из них "
"видит те записи, которые сделал другой."

#: ../book/replication.rst:707
msgid ""
"To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and "
"then on either terminal say:"
msgstr ""
"Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих "
"терминалах, а затем на каждом из них выполните следующие команды:"

#: ../book/replication.rst:710
msgid ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""
"$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"

#: ../book/administration.rst:578
msgid "Backups"
msgstr "Резервное копирование"

#: ../book/administration.rst:580
msgid ""
"The exact procedure for backing up a database depends on: how up-to-date the "
"database must be, how frequently backups must be taken, whether it is okay "
"to disrupt other users, and whether the procedure should be optimized for "
"size (saving disk space) or for speed (saving time). So there is a spectrum "
"of possible policies, ranging from cold-and-simple to hot-and-difficult."
msgstr ""
"При выборе конкретной процедуры для резервного копирования базы данных нужно "
"учитывать следующие требования: насколько актуальной должна быть копия, "
"можно ли временно отключать других пользователей, а также нужна ли "
"оптимизация размера копии (чтобы копия занимала меньше места на диске) или "
"скорости самой процедуры (чтобы процедура занимала меньше времени). Выбирать "
"можно из нескольких вариантов в диапазоне от \"простого и холодного\" до "
"\"трудного и горячего\"."

#: ../doc/book/administration.rst:605 ../book/administration.rst:591
#, fuzzy
msgid "Cold backup"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**\"Холодное\" резервирование**"

#: ../book/administration.rst:593
msgid ""
"In essence: The last snapshot file is a backup of the entire database; and "
"the WAL files that are made after the last snapshot are incremental backups. "
"Therefore taking a backup is a matter of copying the snapshot and WAL files."
msgstr ""
"Суть процедуры: последний созданный Tarantool'ом файл-снимок является "
"резервной копией всей базы; а WAL-файлы, созданные следом, являются "
"инкрементными копиями. Поэтому вся процедура резервирования сводится к "
"копированию последнего файла-снимка и последующих WAL-файлов."

#: ../book/administration.rst:598
msgid ""
"Prevent all users from writing to the database. This can be done by shutting "
"down the server, or by saying ``box.cfg{read_only=true}`` and then ensuring "
"that all earlier writes are complete (:program:`fsync` can be used for this "
"purpose)."
msgstr ""
"Временно запретите всем пользователям делать записи в базе. Для этого можно "
"остановить Tarantool-сервер, либо ввести запрос ``box.cfg{read_only=true}`` "
"и убедиться, что все обращения на запись завершились (для этого можно "
"использовать :program:`fsync`)."

#: ../book/administration.rst:602
msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
msgstr ""
"Если вы хотите создать резеврную копию для всей базы целиком, введите "
"запрос :samp:`box.snapshot()`."

#: ../book/administration.rst:604
msgid ""
"Use :program:`tar` to make a (possibly compressed) copy of the latest :file:"
"`.snap` and :file:`.xlog` files on the :ref:`snap_dir <cfg_basic-snap_dir>` "
"and :ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""
"С помощью :program:`tar` создайте сжатую (насколько это можно) копию "
"последнего :file:`.snap`-файла и последующих :file:`.xlog`-файлов из "
"директорий :ref:`snap_dir <cfg_basic-snap_dir>` и :ref:`wal_dir <cfg_basic-"
"wal_dir>`."

#: ../book/administration.rst:608
msgid "If there is a security policy, encrypt the tar file."
msgstr ""
"Если того требуют правила безопасности, зашифруйте получившийся :file:`tar`-"
"файл."

#: ../book/administration.rst:609
msgid "Copy the tar file to a safe place."
msgstr "Скопируйте :file:`tar`-файл в надежное место."

#: ../book/administration.rst:611
msgid ""
"... Later, restoring the database is a matter of taking the tar file and "
"putting its contents back in the ``snap_dir`` and ``wal_dir`` directories."
msgstr ""
"... В дальнейшем вы сможете восстановить базу данных, просто взяв этот :file:"
"`tar`-файл и разархивировав его содержимое в директории ``snap_dir`` и "
"``wal_dir``."

#: ../doc/book/administration.rst:631 ../book/administration.rst:617
#, fuzzy
msgid "Continuous remote backup"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Постоянное удаленное резервирование**"

#: ../book/administration.rst:619
msgid ""
"In essence: :ref:`replication <index-box_replication>` is useful for backup "
"as well as for load balancing. Therefore taking a backup is a matter of "
"ensuring that any given replica is up to date, and doing a cold backup on "
"it. Since all the other replicas continue to operate, this is not a cold "
"backup from the end user's point of view. This could be done on a regular "
"basis, with a cron job or with a Tarantool fiber."
msgstr ""
"Суть процедуры: для резервирования (а также для балансирования нагрузки) "
"можно использовать :ref:`репликацию <index-box_replication>`. Процедура "
"резервирования в рамках репликационного кластера сводится к тому, чтобы "
"держать все реплики в актуальном состоянии и периодически делать с них "
"\"холодные\" копии. Поскольку во время снятия копии с какой-либо одной "
"реплики все остальные реплики продолжают синхронизироваться с главным "
"сервером, то эта процедура несколько отличается от описанной выше процедуры "
"\"холодного\" резервирования. Регулярное резервирование в кластере можно "
"настроить с помощью планировщика :program:`cron` или Tarantool-файбера."

#: ../doc/book/administration.rst:643 ../book/administration.rst:629
#, fuzzy
msgid "Hot backup"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**\"Горячее\" резервирование**"

#: ../book/administration.rst:631
msgid ""
"In essence: The logged changes done since the last cold backup must be "
"secured, while the system is running."
msgstr ""
"Суть процедуры: по ходу работы системы нужно сохранять записи об изменениях, "
"сделанных со времени последнего \"холодного\" резервирования."

#: ../book/administration.rst:635
msgid ""
"For this purpose you need a \"file copy\" utility that will do the copying "
"remotely and continuously, copying only the parts of a file that are "
"changing. One such utility is `rsync <https://en.wikipedia.org/wiki/rsync>`_."
msgstr ""
"Для этого вам понадобится специальная утилита для копирования частей файлов "
"(например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит "
"удаленно и на постоянной основе копировать только изменившиеся части файлов-"
"снимков и WAL-файлов, а не все эти файлы целиком."

#: ../book/administration.rst:640
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should be "
"frequent production of new snapshot files or new WAL files as changes occur, "
"so that only the new files need to be copied."
msgstr ""
"Вы можете взять и обычную утилиту (для копирования файлов целиком), но тогда "
"вам придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы "
"нужно было копировать только новые файлы."

#: ../book/administration.rst:644
msgid "Note re storage engine: vinyl databases require additional steps."
msgstr ""
"Примечание про движок: при организации резервирования для баз данных на "
"движке vinyl понадобятся дополнительные действия."

#: ../book/administration.rst:648
msgid "Updates/upgrades"
msgstr "Обновление сервера и базы данных"

#: ../book/administration.rst:652
msgid "Updating Tarantool in production"
msgstr "Обновление Tarantool'а в условиях эксплуатации"

#: ../book/administration.rst:654
msgid ""
"First, put your application's business logic in a Tarantool-Lua module that "
"exports its functions for CALL."
msgstr ""
"Во-первых, вынесите всю бизнес-логику своего приложения в отдельный "
"Tarantool-модуль на языке Lua так, чтобы все нужные функции были доступны "
"для вызова извне (CALL)."

#: ../book/administration.rst:657
msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
msgstr "Вот пример такого модуля, файл :file:`/usr/share/tarantool/myapp.lua`:"

#: ../doc/book/administration.rst:673 ../book/administration.rst:659
#, fuzzy
msgid ""
"local function start()\n"
"  -- Initial version\n"
"  box.once(\"myapp:.1.0\", function()\n"
"  box.schema.space.create(\"somedata\")\n"
"  box.space.somedata:create_index(\"primary\")\n"
"  ...\n"
"\n"
"  -- migration code from 1.0 to 1.1\n"
"  box.once(\"myapp:.v1.1\", function()\n"
"  box.space.somedata.index.primary:alter(...)\n"
"  ...\n"
"\n"
"  -- migration code from 1.1 to 1.2\n"
"  box.once(\"myapp:.v1.2\", function()\n"
"  box.space.somedata.space:alter(...)\n"
"  box.space.somedata:insert(...)\n"
"  ...\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"  -- stop all background fibers and cleanup resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"  -- do some business\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"  stop = stop;\n"
"  api_for_call = api_for_call;\n"
"}"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"local function start()\n"
"-- Первоначальная версия\n"
"box.once(\"myapp:.1.0\", function()\n"
"box.schema.space.create(\"somedata\")\n"
"box.space.somedata:create_index(\"primary\")\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.0 на 1.1\n"
"box.once(\"myapp:.v1.1\", function()\n"
"box.space.somedata.index.primary:alter(...)\n"
"...\n"
"end\n"
"\n"
"-- Код для миграции с 1.1 на 1.2\n"
"box.once(\"myapp:.v1.2\", function()\n"
"box.space.somedata.space:alter(...)\n"
"box.space.somedata:insert(...)\n"
"...\n"
"end\n"
"\n"
"-- Если нужно, запустить файберы в фоновом режиме\n"
"\n"
"local function stop()\n"
"-- Остановить все фоновые файберы и освободить ресурсы\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"-- Сделать что-то полезное\n"
"end\n"
"\n"
"return {\n"
"start = start;\n"
"stop = stop;\n"
"api_for_call = api_for_call;\n"
"}"

#: ../book/administration.rst:696
msgid ""
"This file is maintained by the application's developers. On its side, "
"Tarantool Team provides templates for you to `assemble deb/rpm packages "
"<https://github.com/tarantool/modulekit>`_ and utilities to quickly "
"`assemble packages for specific platforms <https://github.com/tarantool/"
"build>`_. If needed, you can split applications into standalone files and/or "
"modules."
msgstr ""
"Поддержка этого файла лежит на стороне разработчиков приложения. А команда "
"разработки Tarantool'а со своей стороны предлагает шаблоны, для того чтобы "
"вы могли `создать у себя deb/rpm-сборку <https://github.com/tarantool/"
"modulekit>`_, а также утилиты для быстрого `создания сборок под разные "
"платформы <https://github.com/tarantool/build>`_. Если понадобится, вы "
"можете разбить приложения на отдельные файлы и/или модули."

#: ../book/administration.rst:703
msgid ""
"Second, put an initialization script to the :file:`/etc/tarantool/instances."
"available` directory."
msgstr ""
"Во вторых, положите скрипт инициализации в директорию :file:`/etc/tarantool/"
"instances.available`."

#: ../book/administration.rst:706
msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
msgstr ""
"Вот пример такого скрипта, файл :file:`/etc/tarantool/instances.available/"
"myappcfg.lua`:"

#: ../doc/book/administration.rst:722 ../book/administration.rst:708
#, fuzzy
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"  listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"  -- hot code reload using tarantoolctl or dofile()\n"
"\n"
"  -- unload old application\n"
"  myapp.stop()\n"
"  -- clear cache for loaded modules and dependencies\n"
"  package.loaded['myapp'] = nil\n"
"  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- load a new version of app and all dependencies\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
"\n"
"-- Выгрузка старого приложения\n"
"myapp.stop()\n"
"-- Очистка кеша от загруженных модулей и зависимостей\n"
"package.loaded['myapp'] = nil\n"
"package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- Загрузка новой версии приложения и всех зависимостей\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"

#: ../book/administration.rst:730
msgid ""
"As a more detailed example, you can take the :file:`example.lua` script that "
"ships with Tarantool and defines all configuration options."
msgstr ""
"Более детальный пример (со всеми настройками) содержится в файле :file:"
"`example.lua`, который входит в состав дистрибутива Tarantool'а."

#: ../book/administration.rst:733
msgid ""
"This initialization script is actually a configuration file and should be "
"maintained by system administrators, while developers only provide a "
"template."
msgstr ""
"Этот скрипт инициализации по сути является конфигурационным файлом. Его "
"поддержкой должны заниматься системные администраторы, в то время как "
"разработчики только предоставляют им шаблон."

#: ../book/administration.rst:737
msgid ""
"Now update your app file in :file:`/usr/share/tarantool`. Replace your "
"application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and "
"manually reload the :file:`myappcfg.lua` initialization script using :"
"program:`tarantoolctl`:"
msgstr ""
"Теперь обновите файл с вашим приложением в директории :file:`/usr/share/"
"tarantool`. Замените старую версию файла (например, :file:`/usr/share/"
"tarantool/myapp.lua`) и вручную загрузите скрипт инициализации :file:"
"`myappcfg.lua` с помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:742
msgid "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"
msgstr "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"

#: ../book/administration.rst:746
msgid ""
"After that, you need to manually flush the cache of ``package.loaded`` "
"modules."
msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#: ../book/administration.rst:748
msgid ""
"For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction "
"directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/"
"debian` directory."
msgstr ""
"Чтобы создать deb/rpm-сборку, вы можете добавить инструкцию ``tarantoolctl "
"eval`` прямо в спецификацию Tarantool'а в файле :file:`RPM.spec` и в "
"директории :file:`/debian`."

#: ../book/administration.rst:752
msgid ""
"Finally, clients make a CALL to ``myapp.api_for_call`` and other API "
"functions."
msgstr ""
"В итоге клиенты делают вызов (CALL) функции ``myapp.api_for_call`` и других "
"функций из API."

#: ../book/administration.rst:754
msgid ""
"In the case of ``tarantool-http``, there is no need to start the binary "
"protocol at all."
msgstr ""
"Если вы используете ``tarantool-http``, то запускать бинарный протокол не "
"нужно."

#: ../doc/book/administration.rst:773 ../book/administration.rst:759
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../book/administration.rst:761
msgid ""
"This information applies for users who created databases with older versions "
"of the Tarantool server, and have now installed a newer version. The request "
"to make in this case is: :samp:`box.schema.upgrade()`."
msgstr ""
"Эта информация полезна в том случае, если у вас есть база данных, работающая "
"на какой-либо старой версии Tarantool'а, а теперь вы установили Tarantool "
"новой версии. В этом случае выполните запрос :samp:`box.schema.upgrade()`."

#: ../book/administration.rst:765
msgid ""
"For example, here is what happens when one runs :samp:`box.schema.upgrade()` "
"with a database that was created in early 2015. Only a small part of the "
"output is shown."
msgstr ""
"Например, вот что происходит, если выполнить запрос :samp:`box.schema."
"upgrade()` для базы, созданной в начале 2015 года (для примера показана лишь "
"малая часть выводимых сообщений):"

#: ../book/administration.rst:769
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../book/administration.rst:782
msgid "Server signal handling"
msgstr "Обработка сигналов от сервера"

#: ../book/administration.rst:784
msgid "The server processes these signals during the main thread event loop:"
msgstr ""
"Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#: ../book/administration.rst:787
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../book/administration.rst:789
msgid ""
"may cause log file rotation, see :ref:`the example in section \"Logging\" "
"<cfg_logging-logging_example>`."
msgstr ""
"может привести к ротации лога, см. :ref:`пример в разделе \"Запись в журнал"
"\" <cfg_logging-logging_example>`."

#: ../book/administration.rst:791
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../book/administration.rst:793
msgid ""
"may cause saving of a snapshot, see the description of :ref:`box.snapshot "
"<admin-snapshot>`."
msgstr ""
"может привести к сохранению снимка, см. описание функции :ref:`box.snapshot "
"<admin-snapshot>`."

#: ../book/administration.rst:795
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../book/administration.rst:797
msgid "may cause graceful shutdown (information will be saved first)."
msgstr ""
"может привести к корректному завершению работы (с предварительным "
"сохранением всех данных)."

#: ../book/administration.rst:798
msgid "SIGINT"
msgstr "SIGINT"

#: ../book/administration.rst:800
msgid "(also known as keyboard interrupt) may cause graceful shutdown."
msgstr ""
"(или \"прерывание с клавиатуры\") может привести к корректному завершению "
"работы (с предварительным сохранением всех данных)."

#: ../book/administration.rst:801
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../book/administration.rst:803
msgid "causes shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../book/administration.rst:805
msgid ""
"Other signals will result in behavior defined by the operating system. "
"Signals other than SIGKILL may be ignored, especially if the server is "
"executing a long-running procedure which prevents return to the main thread "
"event loop."
msgstr ""
"Действие других сигналов определяется операционной системой. Все сигналы, "
"кроме SIGKILL, могут быть проигнорированы, особенно если Tarantool-сервер "
"выполняет длительную процедуру, которая позволяет вернуться к главному циклу."

#: ../book/administration.rst:813
msgid "Process title"
msgstr "Название процесса"

#: ../book/administration.rst:815
msgid ""
"Linux and FreeBSD operating systems allow a running process to modify its "
"title, which otherwise contains the program name. Tarantool uses this "
"feature to help meet the needs of system administration, such as figuring "
"out what services are running on a host, their status, and so on."
msgstr ""
"Операционные системы Linux и FreeBSD позволяют запущенному процессу менять "
"его название (title), в котором изначально содержится имя программы (name). "
"Tarantool использует эту возможность, чтобы упростить работу системного "
"администратора, например посмотреть, какие службы запущены на хосте, их "
"статус и т.д."

#: ../book/administration.rst:820
msgid "A Tarantool server's process title has these components:"
msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#: ../book/administration.rst:822
msgid ""
":extsamp:`{**{program_name}**} [{**{initialization_file_name}**}] "
"{**{<role_name>}**} [{**{custom_proc_title}**}]`"
msgstr ""
":extsamp:`{**{имя_программы}**} [{**{имя_файла_инициализации}**}] "
"{**{<имя_роли>}**} [{**{название_процесса}**}]`"

#: ../book/administration.rst:824
msgid "**program_name** is typically \"tarantool\"."
msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#: ../book/administration.rst:825
msgid ""
"**initialization_file_name** is the name of an :ref:`initialization file "
"<index-init_label>`, if one was specified."
msgstr ""
"**имя_файла_инициализации** — это имя  :ref:`файла инициализации на Lua "
"<index-init_label>`, если этот файл был указан при запуске."

#: ../book/administration.rst:827
msgid "**role_name** is:"
msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#: ../book/administration.rst:829
msgid "\"running\" (ordinary node \"ready to accept requests\"),"
msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#: ../book/administration.rst:830
msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
msgstr ""
"\"loading\" (узел, который загружает данные из ранее сохраненного снимка и "
"WAL-файла),"

#: ../book/administration.rst:831
msgid "\"orphan\" (not in a cluster),"
msgstr "\"orphan\" (узел не входит в состав кластера),"

#: ../doc/book/administration.rst:846 ../book/administration.rst:832
msgid "\"hot_standby\", or"
msgstr ""

#: ../book/administration.rst:833
msgid "\"dumper\" + process-id (saving a snapshot)."
msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#: ../book/administration.rst:835
msgid ""
"**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-"
"custom_proc_title>` configuration parameter, if one was specified."
msgstr ""
"**название_процесса** — это необязательное название Tarantool-процесса в "
"системе, которое берется из конфигурационного параметра :ref:"
"`custom_proc_title <cfg_basic-custom_proc_title>`, если он указан."

#: ../book/administration.rst:839
msgid "For example:"
msgstr "Например:"

#: ../book/administration.rst:841
msgid ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
"script.lua <running>"
msgstr ""
"$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
"script.lua <running>"

#: ../book/administration.rst:848
msgid "System-specific administration notes"
msgstr "Заметки по администрированию для разных платформ"

#: ../doc/book/administration.rst:864 ../book/administration.rst:850
#, fuzzy
msgid ""
"This section will contain information about issues or features which exist "
"on some platforms but not others - for example, on certain versions of a "
"particular Linux distribution."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В этом разделе приводится информация по проблемам и особенностям, которые "
"относятся только к конкретным платформам. Например, к определенным версиям "
"Linux-систем."

#: ../book/administration.rst:856
msgid "Debian GNU/Linux and Ubuntu"
msgstr "Debian GNU/Linux and Ubuntu"

#: ../book/administration.rst:858
msgid "Setting up an instance:"
msgstr "Настройка конкретного экземпляра Tarantool-сервера:"

#: ../book/administration.rst:860
msgid ""
"$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/"
"tarantool/instances.enabled/"
msgstr ""
"$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/"
"tarantool/instances.enabled/"

#: ../book/administration.rst:864
msgid "Starting all instances:"
msgstr "Запуск всех экземпляров:"

#: ../book/administration.rst:866
msgid "$ service tarantool start"
msgstr "$ service tarantool start"

#: ../book/administration.rst:870
msgid "Stopping all instances:"
msgstr "Остановка всех экземпляров:"

#: ../book/administration.rst:872
msgid "$ service tarantool stop"
msgstr "$ service tarantool stop"

#: ../book/administration.rst:876
msgid "Starting/stopping one instance:"
msgstr "Запуск/остановка конкретного экземпляра:"

#: ../book/administration.rst:878
msgid "$ service tarantool-instance-name start/stop"
msgstr "$ service tarantool-instance-name start/stop"

#: ../book/administration.rst:884
msgid "Fedora, RHEL, CentOS"
msgstr "Fedora, RHEL, CentOS"

#: ../book/administration.rst:886
msgid ""
"There are no known permanent issues. For transient issues, go to http://"
"github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or "
"\"Fedora\" or \"Red Hat\" in the search box."
msgstr ""
"Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
"http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
"\"RHEL\", \"CentOS\", \"Fedora\" или \"Red Hat\"."

#: ../book/administration.rst:892
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../book/administration.rst:894
msgid ""
"There are no known permanent issues. For transient issues, go to http://"
"github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search "
"box."
msgstr ""
"Известных воспроизводящихся дефектов для данной платформы нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
"http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
"\"FreeBSD\"."

#: ../book/administration.rst:900
msgid "Mac OS X"
msgstr "Mac OS X"

#: ../book/administration.rst:902
msgid ""
"There are no known permanent issues. For transient issues, go to http://"
"github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
msgstr ""
"Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
"столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
"http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
"\"OS X\"."

#: ../book/administration.rst:908
msgid "Notes for systemd users"
msgstr "Заметки для пользователей systemd"

#: ../book/administration.rst:910
msgid ""
"Tarantool fully supports :program:`systemd` for managing instances and "
"supervising database daemons."
msgstr ""
"Tarantool полностью поддерживает работу с :program:`systemd` как со "
"средством для управления экземплярами и контроля за фоновыми программами "
"базы данных."

#: ../book/administration.rst:915
msgid "Instance management"
msgstr "Управление экземплярами"

#: ../book/administration.rst:917
msgid ""
"Tarantool was designed to have multiple running instances of Tarantool on "
"the same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@"
"${MYAPP}` to manage your databases and Lua applications."
msgstr ""
"В архитектуре Tarantool'а заложена возможность запуска сразу многих "
"экземпляров Tarantool-сервера на одной машине. С помощью :samp:`systemctl "
"{start|stop|restart|status} tarantool@${MYAPP}` можно управлять базами "
"данных и Lua-приложениями."

#: ../book/administration.rst:924
msgid "Creating instances"
msgstr "Создание экземпляров"

#: ../book/administration.rst:926
msgid ""
"Simply put your Lua configuration to :file:`/etc/tarantool/instances."
"available/${MYAPP}.lua`:"
msgstr ""
"Задайте все настройки в виде Lua-скрипта и поместите их в файл :file:`/etc/"
"tarantool/instances.available/${MYAPP}.lua`:"

#: ../book/administration.rst:929
msgid ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"
msgstr ""
"box.cfg{listen = 3313}\n"
"require('myappcode').start()"

#: ../book/administration.rst:934
msgid "(this minimal example is sufficient)."
msgstr "(это пример минимально достаточной конфигурации)."

#: ../book/administration.rst:936
msgid ""
"Another starting point could be the :file:`example.lua` script that ships "
"with Tarantool and defines all options."
msgstr ""
"Также вы можете посмотреть пример Lua-скрипт в файле :file:`example.lua`, "
"который входит в состав дистрибутива Tarantool'а и содержит значения всех "
"опций."

#: ../book/administration.rst:941
msgid "Starting instances"
msgstr "Запуск экземпляров"

#: ../book/administration.rst:943
msgid ""
"Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` "
"instance:"
msgstr ""
"Для запуска экземпляра ``${MYAPP}`` выполните команду :samp:`systemctl start "
"tarantool@${MYAPP}`:"

#: ../book/administration.rst:945
msgid ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"example.lua <running>"
msgstr ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"example.lua <running>"

#: ../book/administration.rst:951
msgid "(console examples here and further on are for Fedora)."
msgstr "(здесь и далее мы приводим примеры консольного вывода для Fedora)."

#: ../book/administration.rst:953
msgid ""
"Use :samp:`systemctl enable tarantool@${MYAPP}` to enable ``${MYAPP}`` "
"instance for auto-load during system startup."
msgstr ""
"Для автоматической загрузки экземпляра ``${MYAPP}`` во время запуска всей "
"системы используйте команду :samp:`systemctl enable tarantool@${MYAPP}`."

#: ../book/administration.rst:958
msgid "Monitoring instances"
msgstr "Мониторинг экземпляров"

#: ../book/administration.rst:960
msgid ""
"Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``"
"${MYAPP}`` instance:"
msgstr ""
"Для проверки информации об экземпляре ``${MYAPP}`` выполните команду :samp:"
"`systemctl status tarantool@${MYAPP}`:"

#: ../book/administration.rst:963
msgid ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"
msgstr ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"

#: ../book/administration.rst:976
msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
msgstr ""
"Для проверки журнала загрузки выполните команду :samp:`journalctl -u "
"tarantool@${MYAPP}`:"

#: ../book/administration.rst:978
msgid ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/"
"tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/"
"tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"
msgstr ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/"
"tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/"
"tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"

#: ../book/administration.rst:990
msgid "Attaching to instances"
msgstr "Подсоединение к экземплярам"

#: ../book/administration.rst:992
msgid ""
"You can attach to a running Tarantool instance and evaluate some Lua code "
"using the :program:`tarantoolctl` utility:"
msgstr ""
"Вы можете подсоединиться к запущенному экземпляру Tarantool-сервера и "
"выполнить некий Lua-скрипт с помощью утилиты :program:`tarantoolctl`:"

#: ../book/administration.rst:995
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"

#: ../book/administration.rst:1009
msgid "Checking logs"
msgstr "Проверка журнала"

#: ../book/administration.rst:1011
msgid ""
"Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
msgstr ""
"Tarantool ведет записи о важных событиях в файле :file:`/var/log/tarantool/"
"${MYAPP}.log`."

#: ../book/administration.rst:1013
msgid "Let's write something to the log file:"
msgstr "Давайте запишем что-нибудь в файл журнала:"

#: ../book/administration.rst:1015
msgid ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
"README.systemd readers\")\n"
"---\n"
"..."
msgstr ""
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
"README.systemd readers\")\n"
"---\n"
"..."

#: ../book/administration.rst:1025
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../book/administration.rst:1027
msgid ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
"tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
"UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
"started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
"connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
"systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
"disconnected"
msgstr ""
"$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
"tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
"UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
"started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
"connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
"systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
"disconnected"

#: ../book/administration.rst:1041
msgid ""
"Log rotation is enabled by default if you have :program:`logrotate` "
"installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the "
"default behavior."
msgstr ""
"Для ротации журнала нужно установить программу :program:`logrotate`. "
"Настройки для ротации можно задать в файле :file:`/etc/logrotate.d/"
"tarantool`."

#: ../book/administration.rst:1047
msgid "Stopping instances"
msgstr "Остановка экземпляров"

#: ../book/administration.rst:1049
msgid ""
"Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the "
"running ``${MYAPP}`` instance."
msgstr ""
"Для просмотра информации о запущенном экземпляре ``${MYAPP}`` выполните "
"команду :samp:`systemctl stop tarantool@${MYAPP}`."

#: ../book/administration.rst:1052
msgid "$ systemctl stop tarantool@example"
msgstr "$ systemctl stop tarantool@example"

#: ../book/administration.rst:1058
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../book/administration.rst:1060
msgid ""
"All instances are automatically restarted by :program:`systemd` in case of "
"failure."
msgstr ""
"Если какой-либо экземпляр Tarantool-сервера выходит из строя, :program:"
"`systemd` автоматически перезапускает его."

#: ../book/administration.rst:1062
msgid "Let's try to destroy an instance:"
msgstr "Давайте попробуем вывести из строя один экземпляр:"

#: ../book/administration.rst:1064
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
"closed connection"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
"closed connection"

#: ../book/administration.rst:1075
msgid ""
"Now let's make sure that :program:`systemd` has revived our Tarantool "
"instance:"
msgstr "А теперь убедимся, что :program:`systemd` перезапустила его:"

#: ../book/administration.rst:1077
msgid ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../book/administration.rst:1082
msgid "Finally, let's check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../book/administration.rst:1084
msgid ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/"
"tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/"
"tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."
msgstr ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/"
"tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/"
"tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."

#: ../book/administration.rst:1099
msgid "Customizing the service file"
msgstr "Правка настроек сервисного файла"

#: ../book/administration.rst:1101
msgid ""
"Please don't modify the :file:`tarantool@.service` file in-place, because it "
"will be overwritten during package upgrades. It is recommended to copy this "
"file to :file:`/etc/systemd/system` and then modify the required settings. "
"Alternatively, you can create a directory named :file:`unit.d/` within :file:"
"`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that "
"only changes the required settings. Please see ``systemd.unit(5)`` manual "
"page for additional information."
msgstr ""
"Пожалуйста, не редактируйте файл :file:`tarantool@.service` по месту, "
"поскольку все ваши изменения будут перезаписаны при последующих обновлениях "
"Tarantool'а. Мы рекомендуем скопировать этот файл в :file:`/etc/systemd/"
"system` и править настройки уже в копии. Либо вы можете создать "
"поддиректорию с именем :file:`unit.d/` в директории :file:`/etc/systemd/"
"system` и положить туда drop-in файл с именем :file:`name.conf`, в котором "
"будут указаны только те настройки, которые нужно поменять. См. подробности в "
"``systemd.unit(5)``."

#: ../book/administration.rst:1110
msgid "Debugging"
msgstr "Отладка"

#: ../book/administration.rst:1112
msgid ""
":program:`coredumpctl` automatically saves core dumps and stack traces in "
"case of a crash. Here is how it works:"
msgstr ""
"При аварийном завершении Tarantool-сервера, :program:`coredumpctl` "
"автоматически сохраняет дампы памяти (core dumps) и трассировку стека (stack "
"traces). Вот как работает этот механизм:"

#: ../book/administration.rst:1115
msgid ""
"$ # !!! please never do this on the production system !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)"
"[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
"closed connection"
msgstr ""
"$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
"  # в условиях промышленной эксплуатации !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)"
"[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
"closed connection"

#: ../book/administration.rst:1125
msgid ""
":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of "
"the Tarantool daemon:"
msgstr ""
"Введем :samp:`coredumpctl list /usr/bin/tarantool`, чтобы получить отчет о "
"последних аварийных завершениях Tarantool-демона:"

#: ../book/administration.rst:1128
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../book/administration.rst:1135
msgid ""
":samp:`coredumpctl info <pid>` shows the stack trace and other useful "
"information:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию, введем :samp:"
"`coredumpctl info <pid>`:"

#: ../book/administration.rst:1137
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example."
"service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example."
"service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../book/administration.rst:1172
msgid ""
":samp:`coredumpctl -o filename.core info <pid>` saves the core dump into a "
"file."
msgstr ""
"Теперь введем :samp:`coredumpctl -o filename.core info <pid>`, чтобы "
"сохранить дамп памяти в отдельный файл."

#: ../book/administration.rst:1174
msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
msgstr ""
"Далее с помощью команды :samp:`coredumpctl gdb <pid>` запустим отладчик :"
"program:`gdb` и подадим сохраненный дамп памяти ему на вход."

#: ../book/administration.rst:1176
msgid ""
"It is highly recommended to install the ``tarantool-debuginfo`` package to "
"improve :program:`gdb` experience. Example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать "
"отладку средствами :program:`gdb` более эффективной. Например:"

#: ../book/administration.rst:1179
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../book/administration.rst:1186
msgid ""
":program:`gdb` also provides information about the ``debuginfo`` packages "
"you need to install:"
msgstr ""
"С помощью :program:`gdb` вы можете узнать, какие еще ``debuginfo``-пакеты "
"нужно установить:"

#: ../book/administration.rst:1188
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../book/administration.rst:1199
msgid ""
"Symbol names are present in stack traces even if you don't have the "
"``tarantool-debuginfo`` package installed."
msgstr ""
"В трассировке стека используются символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../book/administration.rst:1202
msgid ""
"For additional information, please refer to the documentation provided with "
"your Linux distribution."
msgstr "Дополнительно см. документацию по вашей Linux-системе."

#: ../book/administration.rst:1207
msgid "Precautions"
msgstr "Особые указания"

#: ../book/administration.rst:1209
msgid ""
"Please don't use ``tarantoolctl {start,stop,restart}`` to control instances "
"started by :program:`systemd`. It is still possible to use :program:"
"`tarantoolctl` to start and stop instances from your local directories (e."
"g. :file:`${HOME}`) without obtaining ``ROOT`` access."
msgstr ""
"Пожалуйста, не используйте ``tarantoolctl {start,stop,restart}`` для "
"управления экземплярами, которые были запущены с помощью :program:`systemd`. "
"Но вы можете использовать :program:`tarantoolctl` для запуска/остановки "
"экземпляров в ваших локальных директориях (например, :file:`${HOME}`), что "
"не требует пользовательских прав уровня ``ROOT``."

#: ../book/administration.rst:1214
msgid ""
":program:`tarantoolctl` is configured to work properly with :program:"
"`systemd`. Please don't modify system-wide settings of :program:"
"`tarantoolctl`, such as paths, directory permissions and usernames. "
"Otherwise, you have a chance to shoot yourself in the foot."
msgstr ""
"Утилита :program:`tarantoolctl` уже настроена так, чтобы корректно работать "
"с :program:`systemd`. Пожалуйста, не меняйте общесистемные настройки для :"
"program:`tarantoolctl`, такие как пути, настройки прав для директорий и "
"имена пользователей, т.к. это может привести к неожиданным проблемам."

#: ../book/administration.rst:1219
msgid ""
":program:`systemd` scripts are maintained by the Tarantool Team (http://"
"tarantool.org). Please file tickets directly to the upstream's bug tracker "
"(https://github.com/tarantool/tarantool/issues/) rather than to your Linux "
"distribution."
msgstr ""
"Поддержкой скриптов для :program:`systemd` занимается команда разработки "
"Tarantool'а (http://tarantool.org). Если у вас возникли проблемы при работе "
"Tarantool'а с :program:`systemd`, то мы просим сообщать об этом нашей "
"команде (https://github.com/tarantool/tarantool/issues/), а не разработчикам "
"вашего Linux-дистрибутива."

#: ../book/box/index.rst:742
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/book/administration.rst:1242
msgid ""
"These limitations exist due to decisions by packagers to support systemd "
"alongside sysvinit."
msgstr ""

#: ../doc/book/administration.rst:1245
msgid ""
"``/etc/init.d/tarantool start`` under systemd, or ``systemctl start "
"tarantool`` (without an @instance argument), will start only those instances "
"which were enabled before reboot or before the last time that systemd was "
"reloaded with ``systemctl daemon-reload``."
msgstr ""

#: ../doc/book/administration.rst:1250
msgid ""
"(``systemctl start tarantool``, without an @instance argument, is provided "
"only for interoperability with sysvinit scripts. Please use ``systemctl "
"start tarantool@instance`` instead.)"
msgstr ""

#: ../doc/book/administration.rst:1254
msgid ""
"``/etc/init.d/tarantool stop`` under systemd, or ``systemctl tarantool "
"stop`` (without an @instance argument), will do nothing."
msgstr ""

#: ../doc/book/administration.rst:1258
msgid ""
"Starting with Tarantool version 1.7.1.42, a new version of tarantool-common "
"is required. (tarantool-common is a downloadable package which provides "
"scripts to work with tarantool configuration and log files.) An attempt to "
"upgrade tarantool-common will cause restart of all instances."
msgstr ""

#: ../doc/book/administration.rst:1266
msgid "sysvinit -> systemd conversion"
msgstr ""

#: ../doc/book/administration.rst:1268
msgid ""
"These instructions apply only for Debian/Ubuntu distros where both sysvinit "
"and systemd exist."
msgstr ""

#: ../doc/book/administration.rst:1271
msgid "Install new systemd-enabled packages."
msgstr ""

#: ../doc/book/administration.rst:1273
msgid ""
"#For each instancename in /etc/tarantool/instances.enabled/: |br| #To enable "
"the instance to be automatically loaded by systemd: |br| ``systemctl enable "
"tarantool@instancename``"
msgstr ""

#: ../doc/book/administration.rst:1277
msgid ""
"#The following command does nothing but is recommended for consistency: |br| "
"``/etc/init.d/tarantool stop``"
msgstr ""

#: ../doc/book/administration.rst:1280
msgid ""
"#Disable sysvinit-compatible wrappers: |br| ``systemctl disable tarantool; "
"update-rc.d tarantool remove``"
msgstr ""

#: ../book/app_server.rst:30
msgid "Application server"
msgstr "Сервер приложений"

#: ../book/app_server.rst:36
msgid "About modules/rocks"
msgstr "Про модули/rocks"

#: ../doc/book/app_server.rst:41 ../book/app_server.rst:38
msgid ""
"Alongside with using Tarantool as a database manager, you can also use it as "
"an application server. This means that you can write your own logic, install "
"it as a module in Tarantool — and see Tarantool perform your logic. So, a "
"module is an optional library which enhances Tarantool functionality."
msgstr ""

#: ../doc/book/app_server.rst:46 ../book/app_server.rst:43
msgid ""
"Tarantool's native language for writing modules is Lua. Modules in Lua are "
"also called \"rocks\". If you are new to Lua, we recommend following this "
"`Lua modules tutorial <http://lua-users.org/wiki/ModulesTutorial>`_ before "
"reading this section."
msgstr ""

#: ../book/app_server.rst:51
msgid "Installing an existing module"
msgstr "Установка существующего модуля"

#: ../book/app_server.rst:53
msgid ""
"Modules that come from Tarantool developers and community contributors are "
"available at `rocks.tarantool.org <http://rocks.tarantool.org>`_. Some of "
"them -- :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-"
"mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:"
"`shard <shard-module>` -- are discussed elsewhere in this manual."
msgstr ""
"Модули, созданные командой Tarantool'а и членами сообщества разработчиков, "
"выложены на `rocks.tarantool.org <http://rocks.tarantool.org>`_. Про "
"некоторые из этих модулей — :ref:`expirationd <expirationd-module>`, :ref:"
"`mysql <dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-"
"postgresql-example>`, :ref:`shard <shard-module>` -- подробнее говорится в "
"других разделах текущей документации."

#: ../book/app_server.rst:61
msgid ""
"**Step 1:** Install LuaRocks. A general description of installing LuaRocks "
"on a Unix system is given in the `LuaRocks Quick Start Guide <http://"
"luarocks.org/#quick-start>`_. For example, on Ubuntu you could say:"
msgstr ""
"**Шаг 1:** Установите LuaRocks. Общее описание того, как установить LuaRocks "
"в Unix-системе, приводится в `кратком руководстве по LuaRocks <http://"
"luarocks.org/#quick-start>`_. Например, установить LuaRocks в Ubuntu можно "
"следующей командой:"

#: ../book/app_server.rst:66
msgid "$ sudo apt-get install luarocks"
msgstr "$ sudo apt-get install luarocks"

#: ../book/app_server.rst:70
msgid ""
"**Step 2:** Add the Tarantool repository to the list of rocks servers. This "
"is done by putting `rocks.tarantool.org <http://rocks.tarantool.org>`_ in "
"the :file:`.luarocks/config.lua` file:"
msgstr ""
"**Шаг 2:** Добавьте репозиторий Tarantool'а в список rocks-серверов. Для "
"этого добавьте `rocks.tarantool.org <http://rocks.tarantool.org>`_ в файл :"
"file:`.luarocks/config.lua`:"

#: ../book/app_server.rst:74
msgid ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
"config.lua"
msgstr ""
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
"config.lua"

#: ../book/app_server.rst:79
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../book/app_server.rst:81
msgid "search the repositories with"
msgstr "искать существующие модули в общем репозитории"

#: ../book/app_server.rst:88
msgid "add new modules to the local repository with"
msgstr "добавлять новые модули в свой локальный репозиторий"

#: ../book/app_server.rst:95
msgid "load any module for Tarantool with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../book/app_server.rst:102
msgid ""
"... and that is why examples in this manual often begin with ``require`` "
"requests."
msgstr ""
"(вот почему многие примеры в этой документации начинаются с вызова "
"``require``.)"

#: ../book/app_server.rst:104
msgid ""
"See `\"tarantool/rocks\" repository at GitHub <https://github.com/tarantool/"
"rocks>`_ for more examples and information about contributing."
msgstr ""
"Далее на странице `репозитория \"tarantool/rocks\" на GitHub <https://github."
"com/tarantool/rocks>`_ вы можете посмотреть примеры модулей и инструкции по "
"добавлению собственных модулей в общий репозиторий."

#: ../doc/book/app_server.rst:110 ../book/app_server.rst:107
msgid ""
"For developers, we provide :ref:`instructions on creating their own "
"Tarantool modules in Lua, C/C++ and Lua+C <develop_modules>`."
msgstr ""

#: ../book/app_server.rst:114
msgid "Creating a new Lua module locally"
msgstr "Создание нового модуля на языке Lua"

#: ../book/app_server.rst:116
msgid ""
"As an example, let's create a new Lua file named :file:`mymodule.lua`, "
"containing a named function which will be exported. Then, in Tarantool: "
"load, examine, and call."
msgstr ""
"Для примера создадим новый Lua-файл с именем :file:`mymodule.lua`, в котором "
"опишем экспортируемую функцию с некоторым именем, а затем с помощью "
"Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
"функцию."

#: ../book/app_server.rst:120
msgid "The Lua file should look like this:"
msgstr "Lua-файл в нашем примере будет таким:"

#: ../book/app_server.rst:122
msgid ""
"-- mymodule - a simple Tarantool module\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../book/app_server.rst:131 ../book/app_server.rst:210
msgid "The requests to load, examine and call look like this:"
msgstr ""
"Для загрузки и просмотра модуля, а также вызова описанной в нем функции, "
"выполним следующие команды:"

#: ../book/app_server.rst:136
msgid ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."
msgstr ""
"tarantool> **mymodule = require('mymodule')**\n"
"---\n"
"...\n"
"\n"
"tarantool> **mymodule**\n"
"---\n"
"- myfun: 'function: 0x405edf20'\n"
"...\n"
"\n"
"tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
"Hello world\n"
"---\n"
"..."

#: ../book/app_server.rst:154
msgid "Creating a new C/C++ module locally"
msgstr "Создание нового модуля на языке C/C++"

#: ../book/app_server.rst:156
msgid ""
"As an example, let's create a new C file named :file:`mycmodule.c`, "
"containing a named function which will be exported. Then, in Tarantool: "
"load, examine, and call."
msgstr ""
"Для примера создадим новый C-файл с именем :file:`mymodule.c`, в котором "
"опишем экспортируемую функцию с некоторым именем, а затем с помощью "
"Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
"функцию."

#: ../book/app_server.rst:160
msgid "Prerequisite: install ``tarantool-dev`` first."
msgstr ""
"Обратите внимание, что для корректной работы требуется заранее установить "
"модуль ``tarantool-dev``."

#: ../book/app_server.rst:162
msgid "The C file should look like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../doc/book/app_server.rst:167
#, python-format
msgid ""
"/* mycmodule - a simple Tarantool module */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool/module.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"
msgstr ""

#: ../book/app_server.rst:196
msgid ""
"Use :program:`gcc` to compile the code for a shared library (without a \"lib"
"\" prefix), then use :program:`ls` to examine it:"
msgstr ""
"С помощью :program:`gcc` скомпилируем наш код в виде shared-библиотеки (без "
"префикса \"lib\"), а затем просмотрим ее содержимое с помощью :program:`ls`:"

#: ../book/app_server.rst:202
msgid ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule."
"so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
msgstr ""
"$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule."
"so**\n"
"$ **ls mycmodule.so -l**\n"
"-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#: ../book/app_server.rst:206
msgid ""
"Tarantool's developers recommend using Tarantool's `CMake scripts <https://"
"github.com/tarantool/modulekit>`_ which will handle some of the build steps "
"automatically."
msgstr ""
"Для автоматизации сборки рекомендуется использовать `CMake-скрипты для "
"Tarantool'а <https://github.com/tarantool/modulekit>`_."

#: ../book/app_server.rst:215
msgid ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."
msgstr ""
"tarantool> **myсmodule = require('myсmodule')**\n"
"---\n"
"...\n"
"tarantool> **myсmodule**\n"
"---\n"
"- myfun: 'function: 0x4100ec98'\n"
"...\n"
"tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
"---\n"
"- Hello, world\n"
"..."

#: ../book/app_server.rst:227
msgid ""
"You can also create modules with C++, provided that the code does not throw "
"exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в их "
"коде не будут выбрасываться исключения."

#: ../book/app_server.rst:232
msgid "Creating a mixed Lua/C module locally"
msgstr "Создание нового модуля на смеси языков Lua/C"

#: ../book/app_server.rst:234
msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#: ../book/app_server.rst:236
msgid ""
"Create a C module (submodule) and name it ``myfunmodule.internal`` or "
"something like that."
msgstr ""
"Создайте (вложенный) модуль на C и назовите его, например, ``myfunmodule."
"internal``."

#: ../book/app_server.rst:239
msgid ""
"Load the C module from your Lua code using :samp:`require('myfunmodule."
"internal')` and then wrap or use it."
msgstr ""
"Загрузите новый C-модуль из Lua-кода с помощью :samp:`require('myfunmodule."
"internal')`, а затем сделайте для него обертку или вызывайте его функции "
"напрямую."

#: ../book/app_server.rst:242
msgid ""
"For a sample of a mixed Lua/C module, see `\"tarantool/http\" repository at "
"GitHub <https://github.com/tarantool/http>`_."
msgstr ""
"Примеры модулей на смеси языков Lua/C можно посмотреть в `репозитории "
"\"tarantool/http\" на GitHub <https://github.com/tarantool/http>`_."

#: ../book/app_server.rst:247
msgid "Tips for special situations"
msgstr "Примечания для особых случаев"

#: ../book/app_server.rst:249
msgid ""
"Lua caches all loaded modules in the ``package.loaded`` table. To reload a "
"module from disk, set its key to `nil`:"
msgstr ""
"В среде Lua все загруженные модули кешируются в таблице ``package.loaded``. "
"Чтобы перегрузить какой-либо модуль с диска, укажите для его ключа значение "
"`nil`:"

#: ../book/app_server.rst:257
msgid ""
"Use ``package.path`` to search for :file:`.lua` modules, and use ``package."
"cpath`` to search for C binary modules."
msgstr ""
"Для поиска :file:`.lua`-модулей используйте команду ``package.path``, а для "
"поиска бинарных модулей на C используйте команду ``package.cpath``."

#: ../book/app_server.rst:278
msgid ""
"Question-marks stand for the module name that was specified earlier when "
"saying :extsamp:`require('{*{modulename}*}')`."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при "
"вызове :extsamp:`require('{*{имя_модуля}*}')`."

#: ../book/app_server.rst:281
msgid ""
"To see the internal state from within a Lua module, use :samp:`state` and "
"create a local variable inside the scope of the file:"
msgstr ""
"Для просмотра внутреннего состояния прямо изнутри Lua-модуля используйте :"
"samp:`state` и соответствующую локальную переменную в рамках модуля:"

#: ../book/app_server.rst:284
msgid ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- use state\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule\n"
"local exports = {}\n"
"local state = {}\n"
"exports.myfun = function()\n"
"    state.x = 42 -- используем state\n"
"end\n"
"return exports"

#: ../book/app_server.rst:294
msgid ""
"Notice that Lua examples in this manual use *local* variables. Use *global* "
"variables with caution, since the module's users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода "
"используются *локальные* переменные. Будьте аккуратны, если в своих модулях "
"вы будете использовать *глобальные* переменные, поскольку пользователи ваших "
"модулей могут не знать об этих переменных."

#: ../book/app_server.rst:300
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../doc/book/cookbook.rst:3 ../book/cookbook.rst:3
msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""

#: ../doc/book/cookbook.rst:5 ../book/cookbook.rst:5
msgid ""
"Any of the programs can be executed by copying the code into a .lua file, "
"and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./"
"{program-name}.lua` on the terminal. As is usual for Tarantool/Lua programs, "
"the first line is a \"hashbang\" |br| #!/usr/bin/env tarantool |br| This "
"runs the Tarantool Lua application server, which should be on the execution "
"path."
msgstr ""

#: ../doc/book/cookbook.rst:13 ../book/cookbook.rst:13
msgid "Use freely."
msgstr ""

#: ../doc/book/cookbook.rst:19
msgid "hello_world.lua"
msgstr ""

#: ../doc/book/cookbook.rst:21 ../book/cookbook.rst:19
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/book/cookbook.rst:23 ../book/cookbook.rst:21
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/book/cookbook.rst:33
msgid "console_start.lua"
msgstr ""

#: ../doc/book/cookbook.rst:35 ../book/cookbook.rst:31
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) "
"if this is the first time the server has been run. Then use :ref:`console."
"start() <console-start>` to start interactive mode."
msgstr ""

#: ../doc/book/cookbook.rst:39 ../book/cookbook.rst:35
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/book/cookbook.rst:60
msgid "fio_read.lua"
msgstr ""

#: ../doc/book/cookbook.rst:62 ../book/cookbook.rst:56
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/book/cookbook.rst:64 ../book/cookbook.rst:58
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/book/cookbook.rst:82
msgid "fio_write.lua"
msgstr ""

#: ../doc/book/cookbook.rst:84 ../book/cookbook.rst:76
msgid ""
"Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/book/cookbook.rst:86 ../book/cookbook.rst:78
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/book/cookbook.rst:104
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/book/cookbook.rst:106 ../book/cookbook.rst:96
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/book/cookbook.rst:109 ../book/cookbook.rst:99
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/book/cookbook.rst:124
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/book/cookbook.rst:126 ../book/cookbook.rst:114
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"function: gettimeofday(). This delivers time with millisecond precision, "
"unlike the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../doc/book/cookbook.rst:130 ../book/cookbook.rst:118
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""

#: ../doc/book/cookbook.rst:154
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/book/cookbook.rst:156 ../book/cookbook.rst:142
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"library function. (For help understanding ffi, see the `FFI tutorial <http://"
"luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/book/cookbook.rst:159 ../book/cookbook.rst:145
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/book/cookbook.rst:204
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/book/cookbook.rst:206 ../book/cookbook.rst:190
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C "
"object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/book/cookbook.rst:210 ../book/cookbook.rst:194
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/book/cookbook.rst:240
msgid "print_arrays.lua"
msgstr ""

#: ../doc/book/cookbook.rst:242 ../book/cookbook.rst:224
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator "
"function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is "
"recommended for map-like tables or mixed tables.) The display will look "
"like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 "
"v2\"."
msgstr ""

#: ../doc/book/cookbook.rst:250 ../book/cookbook.rst:232
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/book/cookbook.rst:264
msgid "count_array.lua"
msgstr ""

#: ../doc/book/cookbook.rst:266 ../book/cookbook.rst:246
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua table. "
"This operation has O(log(N)) complexity."
msgstr ""

#: ../doc/book/cookbook.rst:269 ../book/cookbook.rst:249
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/book/cookbook.rst:280
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/book/cookbook.rst:282 ../book/cookbook.rst:260
msgid ""
"Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple \"#"
"\" operator to deliver improper results. The \"print(#t)\" instruction will "
"print \"4\"; the \"print(counter)\" instruction will print \"3\"; the "
"\"print(max)\" instruction will print \"10\". Other table functions, such as "
"table.sort(), will also misbehave when \"nils\" are present."
msgstr ""

#: ../doc/book/cookbook.rst:290 ../book/cookbook.rst:268
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/book/cookbook.rst:310
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/book/cookbook.rst:312 ../book/cookbook.rst:288
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == "
"missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, "
"all the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../doc/book/cookbook.rst:317 ../book/cookbook.rst:293
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/book/cookbook.rst:340
msgid "count_map.lua"
msgstr ""

#: ../doc/book/cookbook.rst:342 ../book/cookbook.rst:316
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/book/cookbook.rst:344 ../book/cookbook.rst:318
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/book/cookbook.rst:357
msgid "swap.lua"
msgstr ""

#: ../doc/book/cookbook.rst:359 ../book/cookbook.rst:331
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../doc/book/cookbook.rst:361 ../book/cookbook.rst:333
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/book/cookbook.rst:374
msgid "uri.lua"
msgstr ""

#: ../doc/book/cookbook.rst:376 ../book/cookbook.rst:346
msgid ""
"Use built-in function :code:`uri_parse` to see what is in a `URI "
"<configuration-uri>`:"
msgstr ""

#: ../doc/book/cookbook.rst:378 ../book/cookbook.rst:348
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local uri = require('uri')\n"
"local r= uri.parse(\"scheme://login:password@host:service:/path1/path2/path3?"
"q1=v1&q2=v2#fragment\")\n"
"print('r.password=',r.password)\n"
"print('r.path=',r.path)\n"
"print('r.scheme',r.scheme)\n"
"print('r.login=',r.login)\n"
"print('r.query=',r.query)\n"
"print('r.service=',r.service)\n"
"print('r.fragment=',r.fragment)\n"
"print('r.host=',r.host)"
msgstr ""

#: ../doc/book/cookbook.rst:397
msgid "class.lua"
msgstr ""

#: ../doc/book/cookbook.rst:399 ../book/cookbook.rst:367
msgid ""
"Create a class, create a metatable for the class, create an instance of the "
"class. Another illustration is at `http://lua-users.org/wiki/"
"LuaClassesWithMetatable <http://lua-users.org/wiki/"
"LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/book/cookbook.rst:403 ../book/cookbook.rst:371
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/book/cookbook.rst:437
msgid "garbage.lua"
msgstr ""

#: ../doc/book/cookbook.rst:439 ../book/cookbook.rst:405
msgid ""
"Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual."
"html#2.10>`_ with the `collectgarbage function <https://www.lua.org/"
"manual/5.1/manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/book/cookbook.rst:442 ../book/cookbook.rst:408
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/book/cookbook.rst:452
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/book/cookbook.rst:454 ../book/cookbook.rst:418
msgid ""
"Start one fiber for producer and one fiber for consumer. Use :ref:`fiber."
"channel() <fiber_ipc-channel>` to exchange data and synchronize. One can "
"tweak the channel size (:code:`ch_size` in the program code) to control the "
"number of simultaneous tasks waiting for processing."
msgstr ""

#: ../doc/book/cookbook.rst:459 ../book/cookbook.rst:423
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/book/cookbook.rst:513
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/book/cookbook.rst:515 ../book/cookbook.rst:477
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote "
"host via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../doc/book/cookbook.rst:519 ../book/cookbook.rst:481
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/book/cookbook.rst:537
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/book/cookbook.rst:539 ../book/cookbook.rst:499
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP "
"server, by creating a function that handles requests and echos them, and "
"passing the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This "
"program has been used to test with 100,000 clients, with each client getting "
"a separate fiber."
msgstr ""

#: ../doc/book/cookbook.rst:547 ../book/cookbook.rst:507
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../doc/book/cookbook.rst:570
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/book/cookbook.rst:572 ../book/cookbook.rst:530
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking "
"DNS resolution, getting both the AF_INET6 and AF_INET information for "
"'google.com'. This technique is not always necessary for tcp connections "
"because :ref:`socket.tcp_connect() <socket-tcp_connect>` performs `socket."
"getaddrinfo` under the hood, before trying to connect to the first available "
"address."
msgstr ""

#: ../doc/book/cookbook.rst:580 ../book/cookbook.rst:538
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/book/cookbook.rst:600
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/book/cookbook.rst:602 ../book/cookbook.rst:558
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be "
"implemented with sockets and fibers."
msgstr ""

#: ../doc/book/cookbook.rst:607 ../book/cookbook.rst:563
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/book/cookbook.rst:656 ../book/cookbook.rst:612
msgid ""
"A function for a client that connects to this server could look something "
"like this ..."
msgstr ""

#: ../doc/book/cookbook.rst:659 ../book/cookbook.rst:615
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/book/cookbook.rst:680
msgid "http_get.lua"
msgstr ""

#: ../doc/book/cookbook.rst:682 ../book/cookbook.rst:636
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to get data via HTTP."
msgstr ""

#: ../doc/book/cookbook.rst:685 ../book/cookbook.rst:639
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?"
"q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/book/cookbook.rst:703
msgid "http_send.lua"
msgstr ""

#: ../doc/book/cookbook.rst:705 ../book/cookbook.rst:657
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to send data via "
"HTTP."
msgstr ""

#: ../doc/book/cookbook.rst:708 ../book/cookbook.rst:660
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/book/cookbook.rst:725
msgid "http_server.lua"
msgstr ""

#: ../doc/book/cookbook.rst:727 ../book/cookbook.rst:677
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool "
"into a web server."
msgstr ""

#: ../doc/book/cookbook.rst:730 ../book/cookbook.rst:680
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/book/cookbook.rst:747
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/book/cookbook.rst:749 ../book/cookbook.rst:697
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks (like "
"PHP). Therefore there is no need to learn new languages in order to write "
"templates."
msgstr ""

#: ../doc/book/cookbook.rst:755 ../book/cookbook.rst:703
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/book/cookbook.rst:768 ../book/cookbook.rst:716
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it "
"would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/book/cookbook.rst:771 ../book/cookbook.rst:719
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/book/box/box_cfg.rst:33 ../book/box/box_introspection.rst:5
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/book/box/box_cfg.rst:37 ../book/box/box_introspection.rst:9
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server "
"configuration parameters (see \"Configuration reference\" for :ref:`a "
"complete description of all configuration parameters <box_cfg_params>`). Use "
"``box.cfg`` without braces to get read-only access to those parameters."
msgstr ""

#: ../doc/book/box/box_cfg.rst:44 ../book/box/box_introspection.rst:16
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:30
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/book/box/box_index.rst:35 ../book/box/box_index.rst:32
msgid ""
"The ``box.index`` submodule provides read-only access for index definitions "
"and index keys. Indexes are contained in :samp:`box.space.{space-name}."
"index` array within each space object. They provide an API for ordered "
"iteration over tuples. This API is a direct binding to corresponding methods "
"of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../doc/book/box/box_index.rst:47 ../book/box/box_index.rst:44
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/book/box/box_index.rst:49 ../doc/book/box/box_index.rst:59
#: ../doc/book/box/box_index.rst:67 ../doc/book/box/box_index.rst:435
#: ../doc/book/box/box_index.rst:598 ../doc/book/box/box_index.rst:627
#: ../doc/book/box/box_index.rst:658 ../doc/book/box/box_index.rst:686
#: ../doc/book/box/box_index.rst:719 ../doc/book/box/box_index.rst:738
#: ../doc/book/box/box_index.rst:755 ../doc/book/box/box_index.rst:782
#: ../doc/book/box/box_index.rst:803 ../doc/book/box/box_index.rst:826
#: ../doc/reference/reference_lua/clock.rst:126
#: ../doc/reference/reference_lua/socket.rst:241 ../book/box/box_index.rst:46
#: ../book/box/box_index.rst:56 ../book/box/box_index.rst:64
#: ../book/box/box_index.rst:114 ../book/box/box_index.rst:431
#: ../book/box/box_index.rst:594 ../book/box/box_index.rst:623
#: ../book/box/box_index.rst:654 ../book/box/box_index.rst:682
#: ../book/box/box_index.rst:715 ../book/box/box_index.rst:734
#: ../book/box/box_index.rst:751 ../book/box/box_index.rst:778
#: ../book/box/box_index.rst:799 ../book/box/box_index.rst:822
#: ../reference/reference_lua/clock.rst:122
#: ../reference/reference_lua/socket.rst:227 ../reference_lua/clock.rst:122
#: ../reference_lua/socket.rst:226
msgid "Parameters:"
msgstr ""

#: ../doc/book/box/box_index.rst:51 ../doc/book/box/box_index.rst:61
#: ../doc/book/box/box_index.rst:69 ../doc/book/box/box_index.rst:784
#: ../doc/book/box/box_index.rst:828 ../book/box/box_index.rst:48
#: ../book/box/box_index.rst:58 ../book/box/box_index.rst:66
#: ../book/box/box_index.rst:780 ../book/box/box_index.rst:824
msgid ""
":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`."
msgstr ""

#: ../doc/book/box/box_index.rst:53 ../doc/book/box/box_schema.rst:65
#: ../doc/book/box/box_schema.rst:71 ../doc/book/box/box_space.rst:177
#: ../doc/book/box/box_space.rst:179 ../doc/book/box/index.rst:150
#: ../doc/reference/reference_lua/fiber_cond.rst:65
#: ../doc/reference/reference_lua/fiber_ipc.rst:72
#: ../doc/reference/reference_lua/fiber_ipc.rst:96
#: ../doc/reference/reference_lua/fiber_ipc.rst:110
#: ../doc/reference/reference_lua/fiber_ipc.rst:118
#: ../doc/reference/reference_lua/fiber_ipc.rst:126
#: ../doc/reference/reference_lua/fiber_ipc.rst:131
#: ../doc/reference/reference_lua/fio.rst:171
#: ../doc/reference/reference_lua/fio.rst:267
#: ../doc/reference/reference_lua/fio.rst:309
#: ../doc/reference/reference_lua/fio.rst:325
#: ../doc/reference/reference_lua/fio.rst:382
#: ../doc/reference/reference_lua/fio.rst:453
#: ../doc/reference/reference_lua/net_box.rst:134
#: ../doc/reference/reference_lua/net_box.rst:148
#: ../doc/reference/reference_lua/net_box.rst:161
#: ../doc/reference/reference_lua/net_box.rst:176
#: ../doc/reference/reference_lua/socket.rst:244
#: ../doc/reference/reference_lua/socket.rst:423
#: ../doc/reference/reference_lua/socket.rst:434
#: ../doc/reference/reference_lua/tap.rst:94
#: ../doc/reference/reference_lua/tap.rst:126
#: ../doc/reference/reference_lua/tap.rst:157
#: ../doc/reference/reference_lua/tap.rst:168
#: ../doc/reference/reference_lua/tap.rst:185
#: ../doc/reference/reference_lua/tap.rst:193 ../book/box/box_index.rst:50
#: ../book/box/box_schema.rst:62 ../book/box/box_schema.rst:68
#: ../book/box/box_space.rst:174 ../book/box/box_space.rst:176
#: ../book/box/index.rst:165 ../reference/reference_lua/fiber_ipc.rst:69
#: ../reference/reference_lua/fiber_ipc.rst:92
#: ../reference/reference_lua/fiber_ipc.rst:106
#: ../reference/reference_lua/fiber_ipc.rst:114
#: ../reference/reference_lua/fiber_ipc.rst:122
#: ../reference/reference_lua/fiber_ipc.rst:127
#: ../reference/reference_lua/fio.rst:168
#: ../reference/reference_lua/fio.rst:264
#: ../reference/reference_lua/fio.rst:306
#: ../reference/reference_lua/fio.rst:322
#: ../reference/reference_lua/fio.rst:377
#: ../reference/reference_lua/fio.rst:448
#: ../reference/reference_lua/net_box.rst:91
#: ../reference/reference_lua/net_box.rst:105
#: ../reference/reference_lua/net_box.rst:118
#: ../reference/reference_lua/socket.rst:230
#: ../reference/reference_lua/socket.rst:400
#: ../reference/reference_lua/socket.rst:411
#: ../reference/reference_lua/tap.rst:91 ../reference/reference_lua/tap.rst:123
#: ../reference/reference_lua/tap.rst:154
#: ../reference/reference_lua/tap.rst:165
#: ../reference/reference_lua/tap.rst:182
#: ../reference/reference_lua/tap.rst:190 ../reference_lua/fiber_ipc.rst:69
#: ../reference_lua/fiber_ipc.rst:92 ../reference_lua/fiber_ipc.rst:106
#: ../reference_lua/fiber_ipc.rst:114 ../reference_lua/fiber_ipc.rst:122
#: ../reference_lua/fiber_ipc.rst:127 ../reference_lua/fio.rst:168
#: ../reference_lua/fio.rst:264 ../reference_lua/fio.rst:306
#: ../reference_lua/fio.rst:322 ../reference_lua/fio.rst:377
#: ../reference_lua/fio.rst:448 ../reference_lua/net_box.rst:91
#: ../reference_lua/net_box.rst:105 ../reference_lua/net_box.rst:118
#: ../reference_lua/socket.rst:229 ../reference_lua/socket.rst:399
#: ../reference_lua/socket.rst:410 ../reference_lua/tap.rst:91
#: ../reference_lua/tap.rst:123 ../reference_lua/tap.rst:154
#: ../reference_lua/tap.rst:165 ../reference_lua/tap.rst:182
#: ../reference_lua/tap.rst:190
msgid "boolean"
msgstr ""

#: ../doc/book/box/box_index.rst:57 ../book/box/box_index.rst:54
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/book/box/box_index.rst:65 ../book/box/box_index.rst:62
msgid "An array describing index key fields."
msgstr ""

#: ../doc/book/box/box_index.rst:71 ../doc/book/box/box_info.rst:76
#: ../doc/book/box/box_schema.rst:80 ../doc/book/box/box_slab.rst:53
#: ../doc/book/box/box_slab.rst:113 ../doc/book/box/box_slab.rst:155
#: ../doc/book/box/box_space.rst:747
#: ../doc/reference/reference_lua/clock.rst:132
#: ../doc/reference/reference_lua/csv.rst:71
#: ../doc/reference/reference_lua/fiber.rst:203
#: ../doc/reference/reference_lua/fio.rst:133
#: ../doc/reference/reference_lua/fio.rst:190
#: ../doc/reference/reference_lua/fio.rst:494
#: ../doc/reference/reference_lua/json.rst:87
#: ../doc/reference/reference_lua/msgpack.rst:58
#: ../doc/reference/reference_lua/pickle.rst:135
#: ../doc/reference/reference_lua/socket.rst:174
#: ../doc/reference/reference_lua/socket.rst:546
#: ../doc/reference/reference_lua/socket.rst:558
#: ../doc/reference/reference_lua/yaml.rst:54 ../book/box/box_index.rst:68
#: ../book/box/box_introspection.rst:55 ../book/box/box_schema.rst:77
#: ../book/box/box_space.rst:744 ../reference/reference_lua/clock.rst:128
#: ../reference/reference_lua/csv.rst:68
#: ../reference/reference_lua/fiber.rst:200
#: ../reference/reference_lua/fio.rst:130
#: ../reference/reference_lua/fio.rst:187
#: ../reference/reference_lua/fio.rst:489
#: ../reference/reference_lua/json.rst:84
#: ../reference/reference_lua/msgpack.rst:55
#: ../reference/reference_lua/pickle.rst:132
#: ../reference/reference_lua/socket.rst:168
#: ../reference/reference_lua/socket.rst:523
#: ../reference/reference_lua/socket.rst:535
#: ../reference/reference_lua/yaml.rst:51 ../reference_lua/clock.rst:128
#: ../reference_lua/csv.rst:68 ../reference_lua/fiber.rst:200
#: ../reference_lua/fio.rst:130 ../reference_lua/fio.rst:187
#: ../reference_lua/fio.rst:489 ../reference_lua/json.rst:84
#: ../reference_lua/msgpack.rst:55 ../reference_lua/pickle.rst:132
#: ../reference_lua/socket.rst:167 ../reference_lua/socket.rst:522
#: ../reference_lua/socket.rst:534 ../reference_lua/yaml.rst:51
msgid "table"
msgstr ""

#: ../doc/book/box/box_index.rst:75 ../book/box/box_index.rst:72
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:93
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/book/box/box_index.rst:96
msgid ""
"The :codeitalic:`search-key-value` parameter specifies what must match "
"within the index. The :codeitalic:`iterator-type` parameter specifies the "
"rule for matching and ordering. Different index types support different "
"iterators. For example, a TREE index maintains a strict order of keys and "
"can return all tuples in ascending or descending order, starting from the "
"specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../doc/book/box/box_index.rst:105 ../book/box/box_index.rst:100
msgid ""
"To understand consistency of tuples returned by an iterator, it's essential "
"to know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there "
"is a \"context switch\": which may happen due to :ref:`the-implicit-yield-"
"rules <atomic-the_implicit_yield_rules>`, or by an explicit call to :ref:"
"`fiber.yield <fiber-yield>`. When the execution flow returns to the yielded "
"procedure, the data set could have changed significantly. Iteration, resumed "
"after a yield point, does not preserve the read view, but continues with the "
"new content of the database. The tutorial :ref:`Indexed pattern search "
"<c_lua_tutorial-indexed_pattern_search>` shows one way that iterators and "
"yields can be used together."
msgstr ""

#: ../doc/book/box/box_index.rst:119
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :samp:`search-key-value` (type = Lua table or scalar) = "
"value to be matched against the index key, which may be multi-part; :samp:"
"`{iterator-type}` = as defined in tables below. The default iterator type is "
"'EQ'."
msgstr ""

#: ../doc/book/box/box_index.rst:124 ../doc/book/box/box_space.rst:875
msgid ""
"Return: `iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in "
"a for/end loop or with `totable() <https://rtsisyk.github.io/luafun/reducing."
"html#fun.totable>`_."
msgstr ""

#: ../doc/book/box/box_index.rst:127
msgid ""
"Possible errors: No such space; wrong type; Selected iteration type is not "
"supported for the index type; or search-key-value is not supported for the "
"iteration type."
msgstr ""

#: ../doc/book/box/box_index.rst:131
msgid "Complexity Factors: Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_index.rst:133
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example ``{1234, "
"'abcd'}``). Each part of a search-key-value will be compared to each part of "
"an index key."
msgstr ""

#: ../doc/book/box/box_index.rst:140 ../book/box/box_index.rst:136
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:144 ../book/box/box_index.rst:140
msgid ""
"Formally the logic for TREE index searches is: |br| comparison-operator is = "
"or >= or > or <= or < depending on iterator-type"
msgstr ""

#: ../doc/book/box/box_index.rst:157 ../book/box/box_index.rst:153
msgid ""
"if all comparison-results are true, then search-value \"matches\" index key."
msgstr ""

#: ../doc/book/box/box_index.rst:160 ../book/box/box_index.rst:156
msgid ""
"Notice how, according to this logic, regardless what the index-key-part "
"contains, the comparison-result for equality is always true when a search-"
"value-part is ``nil`` or is missing. This behavior of searches with nil is "
"subject to change."
msgstr ""

#: ../doc/book/box/authentication.rst:73 ../doc/book/box/box_index.rst:170
#: ../doc/book/box/box_index.rst:223 ../doc/book/box/box_index.rst:257
#: ../doc/book/box/box_index.rst:293 ../doc/book/box/box_schema.rst:63
#: ../doc/book/box/box_space.rst:169 ../book/box/authentication.rst:73
#: ../book/box/box_index.rst:166 ../book/box/box_index.rst:219
#: ../book/box/box_index.rst:253 ../book/box/box_index.rst:289
#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Type"
msgstr ""

#: ../doc/book/box/box_index.rst:170 ../doc/book/box/box_index.rst:223
#: ../doc/book/box/box_index.rst:257 ../doc/book/box/box_index.rst:293
#: ../book/box/box_index.rst:166 ../book/box/box_index.rst:219
#: ../book/box/box_index.rst:253 ../book/box/box_index.rst:289
msgid "Arguments"
msgstr ""

#: ../doc/book/box/authentication.rst:73 ../doc/book/box/box_index.rst:170
#: ../doc/book/box/box_index.rst:223 ../doc/book/box/box_index.rst:257
#: ../doc/book/box/box_index.rst:293 ../book/box/authentication.rst:73
#: ../book/box/box_index.rst:166 ../book/box/box_index.rst:219
#: ../book/box/box_index.rst:253 ../book/box/box_index.rst:289
msgid "Description"
msgstr ""

#: ../doc/book/box/box_index.rst:172 ../doc/book/box/box_index.rst:230
#: ../doc/book/box/box_index.rst:263 ../doc/book/box/box_index.rst:298
#: ../book/box/box_index.rst:168 ../book/box/box_index.rst:226
#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:294
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/book/box/box_index.rst:172 ../doc/book/box/box_index.rst:178
#: ../doc/book/box/box_index.rst:183 ../doc/book/box/box_index.rst:190
#: ../doc/book/box/box_index.rst:197 ../doc/book/box/box_index.rst:201
#: ../doc/book/box/box_index.rst:207 ../doc/book/box/box_index.rst:230
#: ../doc/book/box/box_index.rst:236 ../doc/book/box/box_index.rst:298
#: ../doc/book/box/box_index.rst:306 ../doc/book/box/box_index.rst:311
#: ../doc/book/box/box_index.rst:316 ../doc/book/box/box_index.rst:321
#: ../doc/book/box/box_index.rst:331 ../book/box/box_index.rst:168
#: ../book/box/box_index.rst:174 ../book/box/box_index.rst:179
#: ../book/box/box_index.rst:186 ../book/box/box_index.rst:193
#: ../book/box/box_index.rst:197 ../book/box/box_index.rst:203
#: ../book/box/box_index.rst:226 ../book/box/box_index.rst:232
#: ../book/box/box_index.rst:294 ../book/box/box_index.rst:302
#: ../book/box/box_index.rst:307 ../book/box/box_index.rst:312
#: ../book/box/box_index.rst:317 ../book/box/box_index.rst:327
msgid "search value"
msgstr ""

#: ../doc/book/box/box_index.rst:172 ../book/box/box_index.rst:168
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. Tuples are returned in ascending order by index "
"key. This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:178 ../book/box/box_index.rst:174
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/book/box/box_index.rst:178 ../book/box/box_index.rst:174
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:183 ../doc/book/box/box_index.rst:236
#: ../doc/book/box/box_index.rst:306 ../book/box/box_index.rst:179
#: ../book/box/box_index.rst:232 ../book/box/box_index.rst:302
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/book/box/box_index.rst:183 ../book/box/box_index.rst:179
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater "
"than a search value, it matches. Tuples are returned in ascending order by "
"index key."
msgstr ""

#: ../doc/book/box/box_index.rst:190 ../doc/book/box/box_index.rst:311
#: ../book/box/box_index.rst:186 ../book/box/box_index.rst:307
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/book/box/box_index.rst:190 ../book/box/box_index.rst:186
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key "
"is greater than or equal to a search value, it matches. Tuples are returned "
"in ascending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:197 ../doc/book/box/box_index.rst:259
#: ../doc/book/box/box_index.rst:295 ../book/box/box_index.rst:193
#: ../book/box/box_index.rst:255 ../book/box/box_index.rst:291
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/book/box/box_index.rst:197 ../book/box/box_index.rst:193
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/book/box/box_index.rst:201 ../doc/book/box/box_index.rst:316
#: ../book/box/box_index.rst:197 ../book/box/box_index.rst:312
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/book/box/box_index.rst:201 ../book/box/box_index.rst:197
msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index "
"key."
msgstr ""

#: ../doc/book/box/box_index.rst:207 ../doc/book/box/box_index.rst:321
#: ../book/box/box_index.rst:203 ../book/box/box_index.rst:317
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/book/box/box_index.rst:207 ../book/box/box_index.rst:203
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is "
"less than or equal to a search value, it matches. Tuples are returned in "
"descending order by index key."
msgstr ""

#: ../doc/book/box/box_index.rst:216 ../book/box/box_index.rst:212
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:225 ../book/box/box_index.rst:221
msgid "box.index.ALL"
msgstr ""

#: ../doc/book/box/box_index.rst:225 ../doc/book/box/box_index.rst:259
#: ../doc/book/box/box_index.rst:295 ../book/box/box_index.rst:221
#: ../book/box/box_index.rst:255 ../book/box/box_index.rst:291
msgid "none"
msgstr ""

#: ../doc/book/box/box_index.rst:225 ../book/box/box_index.rst:221
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""

#: ../doc/book/box/box_index.rst:230 ../book/box/box_index.rst:226
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a "
"search value, it matches. The number of returned tuples will be 0 or 1. This "
"is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:236 ../book/box/box_index.rst:232
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. "
"Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in "
"each search, and using the last returned value from the previous result as "
"the start search value for the next search."
msgstr ""

#: ../doc/book/box/box_index.rst:250 ../book/box/box_index.rst:246
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:259 ../book/box/box_index.rst:255
msgid ""
"All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:263 ../doc/book/box/box_index.rst:268
#: ../doc/book/box/box_index.rst:273 ../doc/book/box/box_index.rst:278
#: ../book/box/box_index.rst:259 ../book/box/box_index.rst:264
#: ../book/box/box_index.rst:269 ../book/box/box_index.rst:274
msgid "bitset value"
msgstr ""

#: ../doc/book/box/box_index.rst:263 ../book/box/box_index.rst:259
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned "
"in their order within the space. This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:268 ../book/box/box_index.rst:264
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:268 ../book/box/box_index.rst:264
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:273 ../book/box/box_index.rst:269
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:273 ../book/box/box_index.rst:269
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:278 ../book/box/box_index.rst:274
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/book/box/box_index.rst:278 ../book/box/box_index.rst:274
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, "
"it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:286 ../book/box/box_index.rst:282
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/book/box/box_index.rst:295 ../book/box/box_index.rst:291
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:298 ../book/box/box_index.rst:294
msgid ""
"If all points of the rectangle-or-box defined by the search value are the "
"same as the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space. \"Rectangle-or-box\" means "
"\"rectangle-or-box as explained in section about :ref:`RTREE <box_index-"
"rtree>`\". This is the default."
msgstr ""

#: ../doc/book/box/box_index.rst:306 ../book/box/box_index.rst:302
msgid ""
"If all points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:311 ../book/box/box_index.rst:307
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:316 ../book/box/box_index.rst:312
msgid ""
"If all points of the rectangle-or-box defined by the index key are within "
"the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:321 ../book/box/box_index.rst:317
msgid ""
"If all points of the rectangle-or-box defined by the index key are within, "
"or at the side of, the rectangle-or-box defined by the search key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:326 ../book/box/box_index.rst:322
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/book/box/box_index.rst:326 ../book/box/box_index.rst:322
msgid "search values"
msgstr ""

#: ../doc/book/box/box_index.rst:326 ../book/box/box_index.rst:322
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

#: ../doc/book/box/box_index.rst:331 ../book/box/box_index.rst:327
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/book/box/box_index.rst:331 ../book/box/box_index.rst:327
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""

#: ../doc/book/box/box_index.rst:337 ../book/box/box_index.rst:333
msgid "**First Example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:339 ../book/box/box_index.rst:335
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/book/box/box_index.rst:341 ../book/box/box_index.rst:337
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:387 ../book/box/box_index.rst:383
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:389 ../book/box/box_index.rst:385
msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. "
"The assumptions include that there is a one-part primary-key TREE index on "
"the first field, which must be a string. The iterator loop ensures that the "
"search will return tuples where the first value is greater than or equal to "
"'XY'. The conditional statement within the loop ensures that the looping "
"will stop when the first two letters are not 'XY'."
msgstr ""

#: ../doc/book/box/box_index.rst:397 ../book/box/box_index.rst:393
msgid ""
"for tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:405 ../book/box/box_index.rst:401
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../doc/book/box/box_index.rst:407 ../book/box/box_index.rst:403
msgid ""
"This Lua code finds all the tuples whose primary key values are greater than "
"or equal to 1000, and less than or equal to 1999 (this type of request is "
"sometimes called a \"range search\" or a \"between search\"). The "
"assumptions include that there is a one-part primary-key TREE index on the "
"first field, which must be a number. The iterator loop ensures that the "
"search will return tuples where the first value is greater than or equal to "
"1000. The conditional statement within the loop ensures that the looping "
"will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/book/box/box_index.rst:417 ../book/box/box_index.rst:413
msgid ""
"for tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:429 ../book/box/box_index.rst:425
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional parameters "
"that specify the iterator type, and the limit (that is, the maximum number "
"of tuples to return) and the offset (that is, which tuple to start with in "
"the list)."
msgstr ""

#: ../doc/book/box/box_index.rst:437 ../doc/book/box/box_index.rst:600
#: ../doc/book/box/box_index.rst:629 ../doc/book/box/box_index.rst:660
#: ../doc/book/box/box_index.rst:688 ../doc/book/box/box_index.rst:721
#: ../doc/book/box/box_index.rst:740 ../doc/book/box/box_index.rst:757
#: ../doc/book/box/box_index.rst:805 ../book/box/box_index.rst:116
#: ../book/box/box_index.rst:433 ../book/box/box_index.rst:596
#: ../book/box/box_index.rst:625 ../book/box/box_index.rst:656
#: ../book/box/box_index.rst:684 ../book/box/box_index.rst:717
#: ../book/box/box_index.rst:736 ../book/box/box_index.rst:753
#: ../book/box/box_index.rst:801
msgid ""
":samp:`{index_object}` = an :ref:`object reference <index-object_reference>`;"
msgstr ""

#: ../doc/book/box/box_index.rst:438 ../book/box/box_index.rst:434
msgid ":samp:`search-key` = values to be matched against the index key;"
msgstr ""

#: ../doc/book/box/box_index.rst:442 ../book/box/box_index.rst:438
msgid ":samp:`option(s)` any or all of"
msgstr ""

#: ../doc/book/box/box_index.rst:440 ../book/box/box_index.rst:436
msgid ":samp:`iterator = {iterator-type}`,"
msgstr ""

#: ../doc/book/box/box_index.rst:441 ../book/box/box_index.rst:437
msgid ":samp:`limit = {maximum-number-of-tuples}`,"
msgstr ""

#: ../doc/book/box/box_index.rst:442 ../book/box/box_index.rst:438
msgid ":samp:`offset = {start-tuple-number}`."
msgstr ""

#: ../doc/book/box/box_index.rst:444 ../book/box/box_index.rst:440
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/book/box/box_index.rst:445 ../doc/book/box/box_space.rst:311
#: ../book/box/box_index.rst:441 ../book/box/box_space.rst:308
msgid "array of tuples"
msgstr ""

#: ../doc/book/box/box_index.rst:449 ../book/box/box_index.rst:445
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:475 ../book/box/box_index.rst:471
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/book/box/box_index.rst:477 ../book/box/box_index.rst:473
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:486 ../book/box/box_index.rst:482
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed "
"index is the first (primary-key) index. Therefore, for the example above, "
"``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the "
"same two rows, via the 'primary' index."
msgstr ""

#: ../doc/book/box/box_index.rst:493 ../book/box/box_index.rst:489
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/book/box/box_index.rst:498 ../book/box/box_index.rst:494
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, "
"then every key in the index is considered to be a match, regardless of "
"iterator type. Therefore, for the example above, ``box.space.tester:select{}"
"`` will select every tuple in the tester space via the first (primary-key) "
"index."
msgstr ""

#: ../doc/book/box/box_index.rst:508 ../book/box/box_index.rst:504
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That "
"is, ``get`` can be used as a convenient shorthand to get the first tuple in "
"the tuple set that would be returned by ``select``. However, if there is "
"more than one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../doc/book/box/box_index.rst:516 ../book/box/box_index.rst:512
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/book/box/box_index.rst:518 ../book/box/box_index.rst:514
msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: "
"bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/book/box/box_index.rst:522 ../book/box/box_index.rst:518
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:569 ../book/box/box_index.rst:565
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""

#: ../doc/book/box/box_index.rst:571 ../doc/book/box/box_space.rst:375
#: ../book/box/box_index.rst:567 ../book/box/box_space.rst:299
#: ../book/box/box_space.rst:372
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to "
"be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/book/box/box_index.rst:575 ../book/box/box_index.rst:571
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/book/box/box_index.rst:576 ../doc/book/box/box_index.rst:606
#: ../doc/book/box/box_index.rst:635 ../doc/book/box/box_index.rst:664
#: ../doc/book/box/box_index.rst:728 ../doc/book/box/box_index.rst:745
#: ../doc/book/box/box_space.rst:282 ../doc/book/box/box_space.rst:380
#: ../doc/book/box/box_space.rst:461 ../doc/book/box/box_space.rst:519
#: ../doc/book/box/box_space.rst:658 ../doc/book/box/box_space.rst:843
#: ../doc/book/box/box_tuple.rst:56 ../doc/book/box/box_tuple.rst:200
#: ../doc/book/box/box_tuple.rst:201 ../doc/book/box/box_tuple.rst:292
#: ../doc/book/box/index.rst:156 ../book/box/box_index.rst:572
#: ../book/box/box_index.rst:602 ../book/box/box_index.rst:631
#: ../book/box/box_index.rst:660 ../book/box/box_index.rst:724
#: ../book/box/box_index.rst:741 ../book/box/box_space.rst:279
#: ../book/box/box_space.rst:377 ../book/box/box_space.rst:458
#: ../book/box/box_space.rst:516 ../book/box/box_space.rst:655
#: ../book/box/box_space.rst:844 ../book/box/box_tuple.rst:53
#: ../book/box/box_tuple.rst:197 ../book/box/box_tuple.rst:198
#: ../book/box/box_tuple.rst:289 ../book/box/index.rst:171
msgid "tuple"
msgstr ""

#: ../doc/book/box/box_index.rst:578 ../book/box/box_index.rst:574
msgid ""
"Possible errors: No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../doc/book/box/box_index.rst:580 ../book/box/box_index.rst:576
msgid ""
"Complexity Factors: Index size, Index type. See also :ref:`space_object:"
"get() <box_space-get>`."
msgstr ""

#: ../doc/book/box/box_index.rst:585 ../book/box/box_index.rst:581
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:596 ../book/box/box_index.rst:592
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/book/box/box_index.rst:601 ../doc/book/box/box_index.rst:630
#: ../book/box/box_index.rst:597 ../book/box/box_index.rst:626
msgid ":samp:`key-value`."
msgstr ""

#: ../doc/book/box/box_index.rst:603 ../book/box/box_index.rst:599
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is "
"supplied, returns the first key which is greater than or equal to ``key-"
"value``."
msgstr ""

#: ../doc/book/box/box_index.rst:608 ../doc/book/box/box_index.rst:637
#: ../book/box/box_index.rst:604 ../book/box/box_index.rst:633
msgid "Possible errors: index is not of type 'TREE'."
msgstr ""

#: ../doc/book/box/box_index.rst:610 ../doc/book/box/box_index.rst:639
#: ../doc/book/box/box_index.rst:666 ../doc/book/box/box_space.rst:880
#: ../book/box/box_index.rst:606 ../book/box/box_index.rst:635
#: ../book/box/box_index.rst:662
msgid "Complexity Factors: Index size, Index type."
msgstr ""

#: ../doc/book/box/box_index.rst:614 ../book/box/box_index.rst:610
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:625 ../book/box/box_index.rst:621
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/book/box/box_index.rst:632 ../book/box/box_index.rst:628
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is "
"supplied, returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../doc/book/box/box_index.rst:643 ../book/box/box_index.rst:639
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:654 ../book/box/box_index.rst:650
msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having "
"to iterate over the entire data set."
msgstr ""

#: ../doc/book/box/box_index.rst:661 ../book/box/box_index.rst:657
msgid ""
":samp:`random-value` (type = number) = an arbitrary non-negative integer."
msgstr ""

#: ../doc/book/box/box_index.rst:663 ../book/box/box_index.rst:659
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/book/box/box_index.rst:668 ../book/box/box_index.rst:664
msgid "Note re storage engine: vinyl does not support ``random()``."
msgstr ""

#: ../doc/book/box/box_index.rst:672 ../book/box/box_index.rst:668
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:683 ../book/box/box_index.rst:679
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""

#: ../doc/book/box/box_index.rst:689 ../book/box/box_index.rst:685
msgid ""
":samp:`{key-value}` (type = Lua table or scalar) = the value which must "
"match the key(s) in the specified index. The type may be a list of field-"
"values, or a tuple containing only the field-values;  :codeitalic:`iterator` "
"= comparison method."
msgstr ""

#: ../doc/book/box/box_index.rst:694 ../book/box/box_index.rst:690
msgid "the number of matching index keys."
msgstr ""

#: ../doc/book/box/box_index.rst:695 ../doc/book/box/box_index.rst:831
#: ../doc/book/box/box_schema.rst:67 ../doc/book/box/box_schema.rst:69
#: ../doc/book/box/box_session.rst:44 ../doc/book/box/box_session.rst:49
#: ../doc/book/box/box_session.rst:74 ../doc/book/box/box_space.rst:175
#: ../doc/book/box/box_tuple.rst:88 ../doc/book/box/box_tuple.rst:113
#: ../doc/book/box/box_tuple.rst:162 ../doc/book/box/index.rst:146
#: ../doc/reference/reference_lua/fiber.rst:266
#: ../doc/reference/reference_lua/fiber_ipc.rst:68
#: ../doc/reference/reference_lua/fiber_ipc.rst:85
#: ../doc/reference/reference_lua/fiber_ipc.rst:103
#: ../doc/reference/reference_lua/fio.rst:113
#: ../doc/reference/reference_lua/fio.rst:474
#: ../doc/reference/reference_lua/socket.rst:263
#: ../doc/reference/reference_lua/socket.rst:386 ../book/box/box_index.rst:691
#: ../book/box/box_index.rst:827 ../book/box/box_schema.rst:64
#: ../book/box/box_schema.rst:66 ../book/box/box_session.rst:41
#: ../book/box/box_session.rst:46 ../book/box/box_session.rst:71
#: ../book/box/box_space.rst:172 ../book/box/box_tuple.rst:85
#: ../book/box/box_tuple.rst:110 ../book/box/box_tuple.rst:159
#: ../book/box/index.rst:161 ../reference/reference_lua/fiber.rst:263
#: ../reference/reference_lua/fiber_ipc.rst:99
#: ../reference/reference_lua/fio.rst:110
#: ../reference/reference_lua/fio.rst:469
#: ../reference/reference_lua/socket.rst:249
#: ../reference/reference_lua/socket.rst:363 ../reference_lua/fiber.rst:263
#: ../reference_lua/fiber_ipc.rst:99 ../reference_lua/fio.rst:110
#: ../reference_lua/fio.rst:469 ../reference_lua/socket.rst:248
#: ../reference_lua/socket.rst:362
msgid "number"
msgstr ""

#: ../doc/book/box/box_index.rst:700 ../book/box/box_index.rst:696
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:713 ../doc/book/box/box_space.rst:480
#: ../doc/book/box/box_tuple.rst:277 ../book/box/box_index.rst:709
#: ../book/box/box_space.rst:477 ../book/box/box_tuple.rst:274
msgid "Update a tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:715 ../book/box/box_index.rst:711
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched "
"in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../doc/book/box/box_index.rst:722 ../book/box/box_index.rst:718
msgid ""
":samp:`{key}` (type = Lua table or scalar) = key to be matched against the "
"index key;"
msgstr ""

#: ../doc/book/box/box_index.rst:724 ../book/box/box_index.rst:720
msgid ""
":samp:`{operator, field_no, value}` (type = Lua table) = update operations "
"(see: :ref:`box.space...update() <box_space-update>`)."
msgstr ""

#: ../doc/book/box/box_index.rst:727 ../doc/book/box/box_space.rst:518
#: ../book/box/box_index.rst:723 ../book/box/box_space.rst:515
msgid "the updated tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:732 ../book/box/box_index.rst:728
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/book/box/box_index.rst:734 ../book/box/box_index.rst:730
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched "
"in this index instead of in the primary-key index. This index ought to be "
"unique."
msgstr ""

#: ../doc/book/box/box_index.rst:741 ../book/box/box_index.rst:737
msgid ""
":samp:`key` (type = Lua table or scalar) = key to be matched against the "
"index key."
msgstr ""

#: ../doc/book/box/box_index.rst:744 ../book/box/box_index.rst:740
msgid "the deleted tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:747 ../book/box/box_index.rst:743
msgid ""
"Note re storage engine: vinyl will return nil, rather than the deleted tuple."
msgstr ""

#: ../doc/book/box/box_index.rst:753 ../book/box/box_index.rst:749
msgid "Alter an index."
msgstr ""

#: ../doc/book/box/box_index.rst:758 ../book/box/box_index.rst:754
msgid ""
":samp:`{options}` = options list, same as the options list for :ref:"
"`create_index <box_space-create_index>`."
msgstr ""

#: ../doc/book/box/box_index.rst:761 ../doc/book/box/box_index.rst:808
#: ../doc/book/box/box_schema.rst:129 ../doc/book/box/box_schema.rst:289
#: ../doc/book/box/box_schema.rst:407 ../doc/book/box/box_space.rst:409
#: ../doc/book/box/box_space.rst:431 ../doc/book/box/box_space.rst:811
#: ../doc/book/box/index.rst:152 ../doc/book/box/triggers.rst:153
#: ../doc/book/box/triggers.rst:204
#: ../doc/dev_guide/documentation_guidelines.rst:259
#: ../doc/reference/reference_lua/console.rst:69
#: ../doc/reference/reference_lua/fiber.rst:312
#: ../doc/reference/reference_lua/fiber.rst:355
#: ../doc/reference/reference_lua/fiber_cond.rst:71
#: ../doc/reference/reference_lua/fiber_cond.rst:77
#: ../doc/reference/reference_lua/log.rst:59
#: ../doc/reference/reference_lua/msgpack.rst:175
#: ../doc/reference/reference_lua/tap.rst:64
#: ../doc/reference/reference_lua/tap.rst:75
#: ../doc/reference/reference_lua/tap.rst:82
#: ../doc/reference/reference_lua/tap.rst:136 ../book/box/box_index.rst:757
#: ../book/box/box_index.rst:804 ../book/box/box_schema.rst:126
#: ../book/box/box_schema.rst:286 ../book/box/box_schema.rst:404
#: ../book/box/box_space.rst:406 ../book/box/box_space.rst:428
#: ../book/box/box_space.rst:808 ../book/box/index.rst:167
#: ../book/box/triggers.rst:153 ../book/box/triggers.rst:204
#: ../dev_guide/documentation_guidelines.rst:256
#: ../reference/reference_lua/console.rst:66
#: ../reference/reference_lua/fiber.rst:309
#: ../reference/reference_lua/fiber.rst:352
#: ../reference/reference_lua/log.rst:56
#: ../reference/reference_lua/msgpack.rst:170
#: ../reference/reference_lua/tap.rst:61 ../reference/reference_lua/tap.rst:72
#: ../reference/reference_lua/tap.rst:79 ../reference/reference_lua/tap.rst:133
#: ../reference_lua/console.rst:66 ../reference_lua/fiber.rst:309
#: ../reference_lua/fiber.rst:352 ../reference_lua/log.rst:56
#: ../reference_lua/msgpack.rst:170 ../reference_lua/tap.rst:61
#: ../reference_lua/tap.rst:72 ../reference_lua/tap.rst:79
#: ../reference_lua/tap.rst:133
msgid "nil"
msgstr ""

#: ../doc/book/box/box_index.rst:763 ../book/box/box_index.rst:759
msgid ""
"Possible errors: Index does not exist, or the first index cannot be changed "
"to {unique = false}, or the alter function is only applicable for the memtx "
"storage engine."
msgstr ""

#: ../doc/book/box/box_index.rst:767 ../book/box/box_index.rst:763
msgid "Note re storage engine: vinyl does not support ``alter()``."
msgstr ""

#: ../doc/book/box/box_index.rst:771 ../book/box/box_index.rst:767
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:779 ../book/box/box_index.rst:775
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples "
"are deleted."
msgstr ""

#: ../doc/book/box/box_index.rst:786 ../book/box/box_index.rst:782
msgid "nil."
msgstr ""

#: ../doc/book/box/box_index.rst:788 ../book/box/box_index.rst:784
msgid ""
"Possible errors: Index does not exist, or a primary-key index cannot be "
"dropped while a secondary-key index exists."
msgstr ""

#: ../doc/book/box/box_index.rst:793 ../book/box/box_index.rst:789
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:801
#: ../doc/dev_guide/documentation_guidelines.rst:254
#: ../book/box/box_index.rst:797 ../dev_guide/documentation_guidelines.rst:251
msgid "Rename an index."
msgstr ""

#: ../doc/book/box/box_index.rst:806 ../book/box/box_index.rst:802
msgid ":samp:`{index-name}` (type = string) = new name for index."
msgstr ""

#: ../doc/book/box/box_index.rst:810
#: ../doc/dev_guide/documentation_guidelines.rst:261
#: ../book/box/box_index.rst:806 ../dev_guide/documentation_guidelines.rst:258
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/book/box/box_index.rst:814
#: ../doc/dev_guide/documentation_guidelines.rst:265
#: ../book/box/box_index.rst:810 ../dev_guide/documentation_guidelines.rst:262
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:820
#: ../doc/dev_guide/documentation_guidelines.rst:271
#: ../book/box/box_index.rst:127 ../book/box/box_index.rst:816
#: ../dev_guide/documentation_guidelines.rst:268
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_index.rst:824 ../book/box/box_index.rst:820
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/book/box/box_index.rst:830 ../doc/book/box/box_tuple.rst:112
#: ../book/box/box_index.rst:826 ../book/box/box_tuple.rst:109
msgid "number of bytes"
msgstr ""

#: ../doc/book/box/box_index.rst:835 ../book/box/box_index.rst:831
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/book/box/box_index.rst:837 ../book/box/box_index.rst:833
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary key. "
"The example function will:"
msgstr ""

#: ../doc/book/box/box_index.rst:841 ../book/box/box_index.rst:837
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/book/box/box_index.rst:842 ../book/box/box_index.rst:838
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/book/box/box_index.rst:845 ../book/box/box_index.rst:841
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/book/box/box_index.rst:844 ../book/box/box_index.rst:840
msgid "field[1] = 1000"
msgstr ""

#: ../doc/book/box/box_index.rst:845 ../book/box/box_index.rst:841
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/book/box/box_index.rst:846 ../book/box/box_index.rst:842
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/book/box/box_index.rst:847 ../book/box/box_index.rst:843
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/book/box/box_index.rst:848 ../book/box/box_index.rst:844
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/book/box/box_index.rst:849 ../book/box/box_index.rst:845
msgid "Return the formatted value."
msgstr ""

#: ../doc/book/box/box_index.rst:851 ../book/box/box_index.rst:847
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, :ref:"
"`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua "
"functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/book/box/box_index.rst:860 ../book/box/box_index.rst:856
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:885 ../doc/book/box/box_tuple.rst:340
#: ../book/box/box_index.rst:881 ../book/box/box_tuple.rst:337
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/book/box/box_index.rst:887 ../book/box/box_index.rst:883
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:904 ../book/box/box_index.rst:900
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/book/box/box_index.rst:906 ../book/box/box_index.rst:902
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators "
"and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named \"t"
"\", whose primary key was defined with :codenormal:`create_index('primary',"
"{parts={1,'string'}})`."
msgstr ""

#: ../doc/book/box/box_index.rst:916 ../book/box/box_index.rst:912
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:930 ../book/box/box_index.rst:926
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they "
"only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples. In this example the tuples "
"are merely printed, a page at a time. But it should be simple to change the "
"functionality, for example by yielding after each retrieval, or by breaking "
"when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/book/box/box_index.rst:940
#: ../doc/dev_guide/documentation_guidelines.rst:73
#: ../book/box/box_index.rst:936 ../dev_guide/documentation_guidelines.rst:70
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/book/box/box_index.rst:951 ../book/box/box_index.rst:947
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/book/box/box_index.rst:953 ../book/box/box_index.rst:949
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches "
"if the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric "
"objects with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles "
"will be illustrated."
msgstr ""

#: ../doc/book/box/box_index.rst:960 ../book/box/box_index.rst:956
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-"
"axis (vertical axis) coordinates in a grid of arbitrary size. Here is a "
"picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""

#: ../doc/book/box/box_index.rst:966 ../book/box/box_index.rst:962
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-"
"Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-"
"Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-"
"Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/book/box/box_index.rst:980 ../book/box/box_index.rst:976
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of "
"top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, "
"Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So "
"in the picture ... Rectangle#1 starts at position 1 on the X axis and "
"position 2 on the Y axis, and ends at position 3 on the X axis and position "
"4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates "
"are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally "
"Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a "
"\"point\" since it has zero width and zero height, so it could have been "
"described with only two digits: {10,11}."
msgstr ""

#: ../doc/book/box/box_index.rst:990 ../book/box/box_index.rst:986
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""

#: ../doc/book/box/box_index.rst:993 ../book/box/box_index.rst:989
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/book/box/box_index.rst:995 ../book/box/box_index.rst:991
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1008 ../book/box/box_index.rst:1004
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key "
"indexes.) The second field must be an \"array\", which means its values must "
"represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the "
"table by inserting two tuples, containing the coordinates of Rectangle#2 and "
"Rectangle#4."
msgstr ""

#: ../doc/book/box/box_index.rst:1014 ../book/box/box_index.rst:1010
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/book/box/box_index.rst:1019 ../book/box/box_index.rst:1015
msgid ""
"And now, following the description of `RTREE iterator types`_, we can search "
"the rectangles with these requests:"
msgstr ""

#: ../doc/book/box/box_index.rst:1024 ../book/box/box_index.rst:1020
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_index.rst:1040 ../book/box/box_index.rst:1036
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns "
"1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the "
"picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 "
"returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, "
"and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the "
"picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in "
"the picture)."
msgstr ""

#: ../doc/book/box/box_index.rst:1048 ../book/box/box_index.rst:1044
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/book/box/box_index.rst:1051 ../book/box/box_index.rst:1047
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1062 ../book/box/box_index.rst:1058
msgid ""
"The additional field here is ``dimension=3``. The default dimension is 2, "
"which is why it didn't need to be specified for the examples of rectangle. "
"The maximum dimension is 20. Now for insertions and selections there will "
"usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/book/box/box_index.rst:1066 ../book/box/box_index.rst:1062
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/book/box/box_index.rst:1071 ../book/box/box_index.rst:1067
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""

#: ../doc/book/box/box_index.rst:1074 ../book/box/box_index.rst:1070
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/book/box/box_index.rst:1085 ../book/box/box_index.rst:1081
msgid ""
"The additional field here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies "
"method. The optional distance calculator is 'manhattan', which can be a more "
"appropriate method if one is following the lines of a grid rather than "
"traveling in a straight line."
msgstr ""

#: ../doc/book/box/box_index.rst:1090 ../book/box/box_index.rst:1086
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/book/box/box_index.rst:1096 ../book/box/box_index.rst:1092
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""

#: ../doc/book/box/box_info.rst:33 ../book/box/box_introspection.rst:30
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/book/box/box_info.rst:37
msgid ""
"The ``box.info`` submodule provides access to information about server "
"variables."
msgstr ""

#: ../doc/book/box/box_info.rst:39
msgid "**server.lsn** Log Sequence Number for the latest entry in the WAL."
msgstr ""

#: ../doc/book/box/box_info.rst:40
msgid ""
"**server.ro**  True if the server is in \"read_only\" mode (same as :ref:"
"`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""

#: ../doc/book/box/box_info.rst:42
msgid ""
"**server.uuid** The unique identifier of this server, as stored in the "
"database. This value is also in the :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""

#: ../doc/book/box/box_info.rst:45
msgid "**server.id** The number of this server within a cluster."
msgstr ""

#: ../doc/book/box/box_info.rst:46
msgid ""
"**version** Tarantool version. This value is also shown by :ref:`tarantool --"
"version <index-tarantool_version>`."
msgstr ""

#: ../doc/book/box/box_info.rst:48
msgid ""
"**status** Usually this is 'running', but it can be 'loading', 'orphan', or "
"'hot_standby'."
msgstr ""

#: ../doc/book/box/box_info.rst:49
msgid "**vclock** Same as replication.vclock."
msgstr ""

#: ../doc/book/box/box_info.rst:50
msgid ""
"**pid** Process ID. This value is also shown by the :ref:`tarantool "
"<tarantool-build>` module. This value is also shown by the Linux \"ps -A\" "
"command."
msgstr ""

#: ../doc/book/box/box_info.rst:53
msgid ""
"**cluster.uuid** UUID of the cluster. Every server in a cluster will have "
"the same cluster.uuid value. This value is also in the :ref:`box.space."
"_schema <box_space-schema>` system space."
msgstr ""

#: ../doc/book/box/box_info.rst:55
msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
msgstr ""

#: ../doc/book/box/box_info.rst:56
msgid ""
"**replication.lag** Number of seconds that the replica is behind the master."
msgstr ""

#: ../doc/book/box/box_info.rst:57
msgid ""
"**replication.status** Usually this is 'follow', but it can be 'off', "
"'stopped', 'connecting', 'auth', or 'disconnected'."
msgstr ""

#: ../doc/book/box/box_info.rst:59
msgid "**replication.idle** Number of seconds that the server has been idle."
msgstr ""

#: ../doc/book/box/box_info.rst:60
msgid ""
"**replication.vclock** See the :ref:`discussion of \"vector clock\" "
"<internals-vector>` in the Internals section."
msgstr ""

#: ../doc/book/box/box_info.rst:61
msgid ""
"**replication.uuid** The unique identifier of a master to which this server "
"is connected."
msgstr ""

#: ../doc/book/box/box_info.rst:62
msgid ""
"**replication.uptime** Number of seconds since the server started. This "
"value can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/book/box/box_info.rst:65
msgid ""
"The replication fields are blank unless the server is a :ref:`replica <index-"
"box_replication>`. The replication fields are in an array if the server is a "
"replica for more than one master."
msgstr ""

#: ../doc/book/box/box_info.rst:70 ../book/box/box_introspection.rst:49
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate over "
"keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` "
"builds and returns a Lua table with all keys and values provided in the "
"submodule."
msgstr ""

#: ../doc/book/box/box_info.rst:75 ../book/box/box_introspection.rst:54
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/book/box/box_info.rst:80
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."
msgstr ""

#: ../book/box/box_schema.rst:30
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/book/box/box_schema.rst:37 ../book/box/box_schema.rst:34
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, and function tuples."
msgstr ""

#: ../doc/book/box/box_schema.rst:44 ../book/box/box_schema.rst:41
msgid "Create a space."
msgstr ""

#: ../doc/book/box/box_schema.rst:46 ../book/box/box_schema.rst:43
msgid ""
"name of space, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/book/box/box_schema.rst:48 ../book/box/box_schema.rst:45
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/book/box/box_schema.rst:50 ../book/box/box_schema.rst:47
msgid "space object"
msgstr ""

#: ../doc/book/box/box_schema.rst:51
#: ../doc/dev_guide/documentation_guidelines.rst:223
#: ../doc/reference/reference_lua/fiber.rst:89
#: ../doc/reference/reference_lua/fiber.rst:113
#: ../doc/reference/reference_lua/fiber.rst:133
#: ../doc/reference/reference_lua/fio.rst:358
#: ../doc/reference/reference_lua/net_box.rst:117
#: ../doc/reference/reference_lua/socket.rst:139
#: ../doc/reference/reference_lua/socket.rst:157
#: ../doc/reference/reference_lua/socket.rst:345
#: ../doc/reference/reference_lua/socket.rst:371
#: ../doc/reference/reference_lua/tap.rst:50 ../book/box/box_schema.rst:48
#: ../dev_guide/documentation_guidelines.rst:220
#: ../reference/reference_lua/fiber.rst:86
#: ../reference/reference_lua/fiber.rst:110
#: ../reference/reference_lua/fiber.rst:130
#: ../reference/reference_lua/fiber_ipc.rst:55
#: ../reference/reference_lua/fio.rst:353
#: ../reference/reference_lua/net_box.rst:75
#: ../reference/reference_lua/socket.rst:133
#: ../reference/reference_lua/socket.rst:151
#: ../reference/reference_lua/socket.rst:322
#: ../reference/reference_lua/socket.rst:348
#: ../reference/reference_lua/tap.rst:47 ../reference_lua/fiber.rst:86
#: ../reference_lua/fiber.rst:110 ../reference_lua/fiber.rst:130
#: ../reference_lua/fiber_ipc.rst:55 ../reference_lua/fio.rst:353
#: ../reference_lua/net_box.rst:75 ../reference_lua/socket.rst:133
#: ../reference_lua/socket.rst:150 ../reference_lua/socket.rst:321
#: ../reference_lua/socket.rst:347 ../reference_lua/tap.rst:47
msgid "userdata"
msgstr ""

#: ../doc/book/box/box_schema.rst:55 ../book/box/box_schema.rst:52
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/book/box/authentication.rst:73 ../doc/book/box/box_schema.rst:63
#: ../doc/book/box/box_space.rst:52 ../doc/book/box/box_space.rst:169
#: ../book/box/authentication.rst:73 ../book/box/box_schema.rst:60
#: ../book/box/box_space.rst:49 ../book/box/box_space.rst:166
msgid "Name"
msgstr ""

#: ../doc/book/box/box_schema.rst:63 ../doc/book/box/box_space.rst:169
#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Effect"
msgstr ""

#: ../doc/book/box/box_schema.rst:63 ../doc/book/box/box_space.rst:169
#: ../book/box/box_schema.rst:60 ../book/box/box_space.rst:166
msgid "Default"
msgstr ""

#: ../doc/book/box/box_schema.rst:65 ../book/box/box_schema.rst:62
msgid "temporary"
msgstr ""

#: ../doc/book/box/box_schema.rst:65 ../book/box/box_schema.rst:62
msgid "space is temporary"
msgstr ""

#: ../doc/book/box/box_schema.rst:65 ../doc/book/box/box_schema.rst:71
#: ../doc/reference/reference_lua/msgpack.rst:165 ../book/box/box_schema.rst:62
#: ../book/box/box_schema.rst:68 ../reference/reference_lua/msgpack.rst:160
#: ../reference_lua/msgpack.rst:160
msgid "false"
msgstr ""

#: ../doc/book/box/box_schema.rst:67 ../doc/book/box/box_space.rst:175
#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "id"
msgstr ""

#: ../doc/book/box/box_schema.rst:67 ../doc/book/box/box_space.rst:175
#: ../book/box/box_schema.rst:64 ../book/box/box_space.rst:172
msgid "unique identifier"
msgstr ""

#: ../doc/book/box/box_schema.rst:67 ../book/box/box_schema.rst:64
msgid "last space's id, +1"
msgstr ""

#: ../doc/book/box/box_schema.rst:69 ../book/box/box_schema.rst:66
msgid "field_count"
msgstr ""

#: ../doc/book/box/box_schema.rst:69 ../book/box/box_schema.rst:66
msgid "fixed field count"
msgstr ""

#: ../doc/book/box/box_schema.rst:69 ../book/box/box_schema.rst:66
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/book/box/box_schema.rst:71 ../doc/book/box/box_space.rst:179
#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "if_not_exists"
msgstr ""

#: ../doc/book/box/box_schema.rst:71 ../doc/book/box/box_space.rst:179
#: ../book/box/box_schema.rst:68 ../book/box/box_space.rst:176
msgid "no error if duplicate name"
msgstr ""

#: ../doc/book/box/box_schema.rst:74 ../book/box/box_schema.rst:71
msgid "engine"
msgstr ""

#: ../doc/book/box/box_schema.rst:74 ../book/box/box_schema.rst:71
msgid "storage engine = :ref:`'memtx' or 'vinyl' <index-two_storage_engines>`"
msgstr ""

#: ../doc/book/box/box_schema.rst:74 ../doc/book/box/box_schema.rst:78
#: ../doc/book/box/box_schema.rst:235 ../doc/book/box/box_session.rst:64
#: ../doc/book/box/index.rst:148 ../doc/reference/reference_lua/fiber.rst:184
#: ../doc/reference/reference_lua/fiber.rst:287
#: ../doc/reference/reference_lua/fiber.rst:332
#: ../doc/reference/reference_lua/fiber_ipc.rst:67
#: ../doc/reference/reference_lua/fiber_ipc.rst:89
#: ../doc/reference/reference_lua/fio.rst:53
#: ../doc/reference/reference_lua/fio.rst:73
#: ../doc/reference/reference_lua/fio.rst:91
#: ../doc/reference/reference_lua/json.rst:49
#: ../doc/reference/reference_lua/msgpack.rst:46
#: ../doc/reference/reference_lua/pickle.rst:88
#: ../doc/reference/reference_lua/socket.rst:283
#: ../doc/reference/reference_lua/socket.rst:314
#: ../doc/reference/reference_lua/socket.rst:330
#: ../doc/reference/reference_lua/yaml.rst:46 ../book/box/box_schema.rst:71
#: ../book/box/box_schema.rst:75 ../book/box/box_schema.rst:232
#: ../book/box/box_session.rst:61 ../book/box/index.rst:163
#: ../reference/reference_lua/fiber.rst:181
#: ../reference/reference_lua/fiber.rst:284
#: ../reference/reference_lua/fiber.rst:329
#: ../reference/reference_lua/fio.rst:50 ../reference/reference_lua/fio.rst:70
#: ../reference/reference_lua/fio.rst:88 ../reference/reference_lua/json.rst:46
#: ../reference/reference_lua/msgpack.rst:43
#: ../reference/reference_lua/pickle.rst:85
#: ../reference/reference_lua/socket.rst:269
#: ../reference/reference_lua/socket.rst:300
#: ../reference/reference_lua/yaml.rst:43 ../reference_lua/fiber.rst:181
#: ../reference_lua/fiber.rst:284 ../reference_lua/fiber.rst:329
#: ../reference_lua/fio.rst:50 ../reference_lua/fio.rst:70
#: ../reference_lua/fio.rst:88 ../reference_lua/json.rst:46
#: ../reference_lua/msgpack.rst:43 ../reference_lua/pickle.rst:85
#: ../reference_lua/socket.rst:268 ../reference_lua/socket.rst:299
#: ../reference_lua/yaml.rst:43
msgid "string"
msgstr ""

#: ../doc/book/box/box_schema.rst:74 ../book/box/box_schema.rst:71
msgid "'memtx'"
msgstr ""

#: ../doc/book/box/authentication.rst:75 ../doc/book/box/authentication.rst:78
#: ../doc/book/box/box_schema.rst:78 ../book/box/authentication.rst:75
#: ../book/box/authentication.rst:78 ../book/box/box_schema.rst:75
msgid "user"
msgstr ""

#: ../doc/book/box/box_schema.rst:78 ../book/box/box_schema.rst:75
msgid "user name"
msgstr ""

#: ../doc/book/box/box_schema.rst:78 ../book/box/box_schema.rst:75
msgid "current user's name"
msgstr ""

#: ../doc/book/box/box_schema.rst:80 ../book/box/box_schema.rst:77
msgid "format"
msgstr ""

#: ../doc/book/box/box_schema.rst:80 ../book/box/box_schema.rst:77
msgid "field names+types"
msgstr ""

#: ../doc/book/box/box_schema.rst:80 ../book/box/box_schema.rst:77
msgid "(blank)"
msgstr ""

#: ../doc/book/box/box_schema.rst:83 ../book/box/box_schema.rst:80
msgid ""
"There are five :ref:`syntax variations <index-object_reference>` for object "
"references targeting space objects, for example :samp:`box.schema.space."
"drop({space-id})` will drop a space. However, the common approach is to use "
"functions attached to the space objects, for example :ref:`space_object:"
"drop() <box_space-drop>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:89 ../book/box/box_schema.rst:86
msgid "Note re storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/book/box/box_schema.rst:91 ../book/box/box_schema.rst:88
#, fuzzy
msgid "**Example**"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Примеры:**"

#: ../doc/book/box/box_schema.rst:93 ../book/box/box_schema.rst:90
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_schema.rst:111 ../book/box/box_schema.rst:108
msgid ""
"For an illustration with the ``format`` clause, see :ref:`box.space._space "
"<box_space-space>` example."
msgstr ""

#: ../doc/book/box/box_schema.rst:114 ../book/box/box_schema.rst:111
msgid ""
"After a space is created, usually the next step is to :ref:`create an index "
"<box_space-create_index>` for it, and then it is available for insert, "
"select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/book/box/box_schema.rst:121 ../book/box/box_schema.rst:118
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:125 ../book/box/box_schema.rst:122
msgid ""
"name of user, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/book/box/box_schema.rst:127 ../book/box/box_schema.rst:124
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../book/box/box_schema.rst:128 ../book/box/box_schema.rst:145
#: ../book/box/index.rst:667
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/book/box/box_schema.rst:133 ../book/box/box_schema.rst:130
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:141 ../book/box/box_schema.rst:138
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:145 ../doc/book/box/box_schema.rst:159
#: ../doc/book/box/box_schema.rst:176 ../doc/book/box/box_schema.rst:207
#: ../book/box/box_schema.rst:142 ../book/box/box_schema.rst:156
#: ../book/box/box_schema.rst:173 ../book/box/box_schema.rst:204
msgid "the name of the user"
msgstr ""

#: ../doc/book/box/box_schema.rst:146 ../book/box/box_schema.rst:143
msgid "``if_exists``"
msgstr ""

#: ../doc/book/box/box_schema.rst:150 ../book/box/box_schema.rst:147
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:157 ../book/box/box_schema.rst:154
msgid "Return true if a user exists; return false if a user does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:160 ../doc/book/box/box_schema.rst:317
#: ../doc/book/box/box_schema.rst:439
#: ../doc/reference/reference_lua/uuid.rst:134 ../book/box/box_schema.rst:157
#: ../book/box/box_schema.rst:314 ../book/box/box_schema.rst:436
#: ../reference/reference_lua/uuid.rst:131 ../reference_lua/uuid.rst:131
msgid "bool"
msgstr ""

#: ../doc/book/box/box_schema.rst:164 ../book/box/box_schema.rst:161
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/book/box/box_schema.rst:174 ../book/box/box_schema.rst:171
msgid "Grant :ref:`privileges <authentication-privileges>` to a user."
msgstr ""

#: ../doc/book/box/box_schema.rst:177 ../book/box/box_schema.rst:174
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../doc/book/box/box_schema.rst:178 ../book/box/box_schema.rst:175
msgid "'space' or 'function'."
msgstr ""

#: ../doc/book/box/box_schema.rst:179 ../book/box/box_schema.rst:176
msgid "name of object to grant permissions to"
msgstr ""

#: ../doc/book/box/box_schema.rst:180 ../book/box/box_schema.rst:177
msgid "name of role to grant to user."
msgstr ""

#: ../doc/book/box/box_schema.rst:181 ../book/box/box_schema.rst:178
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../doc/book/box/box_schema.rst:183 ../book/box/box_schema.rst:180
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple with "
"that object-name must exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:186 ../doc/book/box/box_schema.rst:215
#: ../doc/book/box/box_schema.rst:337 ../doc/book/box/box_schema.rst:365
#: ../book/box/box_schema.rst:183 ../book/box/box_schema.rst:212
#: ../book/box/box_schema.rst:334 ../book/box/box_schema.rst:362
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'."
msgstr ""

#: ../doc/book/box/box_schema.rst:189 ../doc/book/box/box_schema.rst:218
#: ../book/box/box_schema.rst:186 ../book/box/box_schema.rst:215
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/book/box/box_schema.rst:194 ../book/box/box_schema.rst:191
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/book/box/box_schema.rst:205 ../book/box/box_schema.rst:202
msgid "Revoke :ref:`privileges <authentication-privileges>` from a user."
msgstr ""

#: ../doc/book/box/box_schema.rst:208 ../doc/book/box/box_schema.rst:330
#: ../doc/book/box/box_schema.rst:358 ../book/box/box_schema.rst:205
#: ../book/box/box_schema.rst:327 ../book/box/box_schema.rst:355
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../doc/book/box/box_schema.rst:209 ../doc/book/box/box_schema.rst:331
#: ../doc/book/box/box_schema.rst:359 ../book/box/box_schema.rst:206
#: ../book/box/box_schema.rst:328 ../book/box/box_schema.rst:356
msgid "'space' or 'function'"
msgstr ""

#: ../doc/book/box/box_schema.rst:210 ../doc/book/box/box_schema.rst:332
#: ../doc/book/box/box_schema.rst:360 ../book/box/box_schema.rst:207
#: ../book/box/box_schema.rst:329 ../book/box/box_schema.rst:357
msgid "the name of a function or space"
msgstr ""

#: ../doc/book/box/box_schema.rst:212 ../book/box/box_schema.rst:209
msgid ""
"The user must exist, and the object must exist, but it is not an error if "
"the user does not have the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:223 ../book/box/box_schema.rst:220
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:232 ../book/box/box_schema.rst:229
msgid "Return a hash of a password."
msgstr ""

#: ../doc/book/box/box_schema.rst:234 ../doc/book/box/box_schema.rst:253
#: ../book/box/box_schema.rst:231 ../book/box/box_schema.rst:250
msgid "password"
msgstr ""

#: ../doc/book/box/box_schema.rst:239 ../book/box/box_schema.rst:236
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/book/box/box_schema.rst:245 ../book/box/box_schema.rst:242
msgid ""
"Associate a password with the user who is currently logged in. or with "
"another user. Users who wish to change their own passwords should use box."
"schema.user.passwd(password). Administrators who wish to change passwords of "
"other users should use box.schema.user.passwd(user-name, password)."
msgstr ""

#: ../doc/book/box/box_schema.rst:252 ../book/box/box_schema.rst:249
msgid "user-name"
msgstr ""

#: ../doc/book/box/box_schema.rst:257 ../book/box/box_schema.rst:254
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/book/box/box_schema.rst:264 ../book/box/box_schema.rst:261
msgid "Return a description of a user's privileges."
msgstr ""

#: ../doc/book/box/box_schema.rst:266 ../book/box/box_schema.rst:263
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../doc/book/box/box_schema.rst:274 ../book/box/box_schema.rst:271
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/book/box/box_schema.rst:281 ../book/box/box_schema.rst:278
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:285 ../book/box/box_schema.rst:282
msgid ""
"name of role, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/book/box/box_schema.rst:287 ../book/box/box_schema.rst:284
msgid "``if_not_exists``"
msgstr ""

#: ../doc/book/box/box_schema.rst:293 ../book/box/box_schema.rst:290
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:300 ../book/box/box_schema.rst:297
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:304 ../doc/book/box/box_schema.rst:316
#: ../doc/book/box/box_schema.rst:329 ../doc/book/box/box_schema.rst:357
#: ../book/box/box_schema.rst:301 ../book/box/box_schema.rst:313
#: ../book/box/box_schema.rst:326 ../book/box/box_schema.rst:354
msgid "the name of the role"
msgstr ""

#: ../doc/book/box/box_schema.rst:308 ../book/box/box_schema.rst:305
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:314 ../book/box/box_schema.rst:311
msgid "Return true if a role exists; return false if a role does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:321 ../book/box/box_schema.rst:318
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:327 ../book/box/box_schema.rst:324
msgid "Grant :ref:`privileges <authentication-privileges>` to a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:333 ../book/box/box_schema.rst:330
msgid "{if_not_exists=true} or {if_not_exists=false}"
msgstr ""

#: ../doc/book/box/box_schema.rst:335 ../book/box/box_schema.rst:332
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:340 ../book/box/box_schema.rst:337
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` -- to grant a role to a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:345 ../book/box/box_schema.rst:342
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/book/box/box_schema.rst:355 ../book/box/box_schema.rst:352
msgid "Revoke :ref:`privileges <authentication-privileges>` from a role."
msgstr ""

#: ../doc/book/box/box_schema.rst:362 ../book/box/box_schema.rst:359
msgid ""
"The role must exist, and the object must exist, but it is not an error if "
"the role does not have the privilege."
msgstr ""

#: ../doc/book/box/box_schema.rst:368 ../book/box/box_schema.rst:365
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name``."
msgstr ""

#: ../doc/book/box/box_schema.rst:373 ../book/box/box_schema.rst:370
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:382 ../book/box/box_schema.rst:379
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/book/box/box_schema.rst:384 ../book/box/box_schema.rst:381
msgid "the name of the role."
msgstr ""

#: ../doc/book/box/box_schema.rst:388 ../book/box/box_schema.rst:385
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/book/box/box_schema.rst:396 ../book/box/box_schema.rst:393
msgid ""
"Create a function tuple. This does not create the function itself -- that is "
"done with Lua -- but if it is necessary to grant privileges for a function, "
"box.schema.func.create must be done first. For explanation of how Tarantool "
"maintains function data, see section :ref:`Functions and the _func space "
"<authentication-funcs>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:403 ../book/box/box_schema.rst:400
msgid ""
"name of function, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/book/box/box_schema.rst:405 ../book/box/box_schema.rst:402
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/book/box/box_schema.rst:411 ../book/box/box_schema.rst:408
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/book/box/box_schema.rst:422 ../book/box/box_schema.rst:419
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains function "
"data, see section :ref:`Functions and the _func space <authentication-"
"funcs>`."
msgstr ""

#: ../doc/book/box/box_schema.rst:426 ../doc/book/box/box_schema.rst:438
#: ../book/box/box_schema.rst:423 ../book/box/box_schema.rst:435
msgid "the name of the function"
msgstr ""

#: ../doc/book/box/box_schema.rst:430 ../book/box/box_schema.rst:427
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/book/box/box_schema.rst:436 ../book/box/box_schema.rst:433
msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""

#: ../doc/book/box/box_schema.rst:443 ../book/box/box_schema.rst:440
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../book/box/box_session.rst:28
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/book/box/box_session.rst:33 ../book/box/box_session.rst:30
msgid ""
"The ``box.session`` submodule allows querying the session state, writing to "
"a session-specific temporary Lua table, or setting up triggers which will "
"fire when a session starts or ends. A *session* is an object associated with "
"each client connection."
msgstr ""

#: ../doc/book/box/box_session.rst:42 ../book/box/box_session.rst:39
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"meaning there is no session."
msgstr ""

#: ../doc/book/box/box_session.rst:48 ../book/box/box_session.rst:45
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/book/box/box_session.rst:53 ../book/box/box_session.rst:50
msgid ""
"This function works only if there is a peer, that is, if a connection has "
"been made to a separate server."
msgstr ""

#: ../doc/book/box/box_session.rst:56 ../book/box/box_session.rst:53
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to a "
"separate server, the return is null. The command is executed on the server, "
"so the \"local name\" is the server's host and port, and the \"peer name\" "
"is the client's host and port."
msgstr ""

#: ../doc/book/box/box_session.rst:66 ../book/box/box_session.rst:63
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/book/box/box_session.rst:70 ../book/box/box_session.rst:67
msgid ""
"the value of the :code:`sync` integer constant used in the `binary protocol "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants."
"h>`_."
msgstr ""

#: ../doc/book/box/box_session.rst:80 ../book/box/box_session.rst:77
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends."
msgstr ""

#: ../book/box/atomic.rst:95 ../book/box/box_session.rst:82
#: ../book/box/box_tuple.rst:306 ../book/box/index.rst:159
#: ../book/box/triggers.rst:96 ../book/box/triggers.rst:214
msgid "Example"
msgstr "Пример"

#: ../doc/book/box/box_session.rst:87 ../book/box/box_session.rst:84
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs"
"\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/book/box/box_session.rst:112 ../book/box/box_session.rst:109
msgid ""
"See the section :ref:`Triggers <triggers-box_triggers>` for instructions "
"about defining triggers for connect and disconnect events with ``box.session."
"on_connect()`` and ``box.session.on_disconnect()``. See the section :ref:"
"`Access control <authentication>` for instructions about ``box.session`` "
"functions that affect user identification and security."
msgstr ""

#: ../doc/book/box/box_slab.rst:33 ../book/box/box_introspection.rst:96
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/book/box/box_slab.rst:37
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store tuples. This can be used "
"to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/book/box/box_slab.rst:57
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:74
msgid ""
"Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/book/box/box_slab.rst:76
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are high "
"if both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/book/box/box_slab.rst:79
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the "
"memory is used efficiently)."
msgstr ""

#: ../doc/book/box/box_slab.rst:83
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily "
"fragmentized. Most probably, there is no immediate out-of-memory risk in "
"this case, but generally this is an issue to consider. For example, probable "
"risks are that the entire memory quota is used for tuples, and there is are "
"no slabs left for a piece of an index. Or that all slabs are allocated for "
"storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/book/box/box_slab.rst:93
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/book/box/box_slab.rst:95
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:97
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator can "
"use for both tuples and indexes (as configured in :ref:`slab_alloc_arena "
"<cfg_storage-slab_alloc_arena>` parameter, e.g. the default is 1 gigabyte = "
"2^30 bytes = 1,073,741,824 bytes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/book/box/box_slab.rst:103
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/book/box/box_slab.rst:105
msgid ""
"``quota_used`` is the percentage of :ref:`slab_alloc_arena <cfg_storage-"
"slab_alloc_arena>` that is already distributed to the slab allocator;"
msgstr ""

#: ../doc/book/box/box_slab.rst:108
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together "
"(including allocated, but currently free slabs);"
msgstr ""

#: ../doc/book/box/box_slab.rst:110
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and indexes "
"together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/book/box/box_slab.rst:117
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:141
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. The "
"report is broken down into groups by *data item size* as well as by *slab "
"size* (64-byte, 136-byte, etc). The report includes the memory allocated for "
"storing both tuples and indexes."
msgstr ""

#: ../doc/book/box/box_slab.rst:148
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/book/box/box_slab.rst:149
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/book/box/box_slab.rst:150
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/book/box/box_slab.rst:151
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/book/box/box_slab.rst:152
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/book/box/box_slab.rst:153
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/book/box/box_slab.rst:159
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/book/box/box_slab.rst:161
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/book/box/box_slab.rst:173
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) "
"stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so "
"``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of "
"which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/book/box/box_slab.rst:178
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/book/box/box_slab.rst:180
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/book/box/box_slab.rst:211
msgid ""
"The total ``mem_used`` for all groups in this report equals ``arena_used`` "
"in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../book/box/box_space.rst:30
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/book/box/box_space.rst:35 ../book/box/box_space.rst:32
msgid ""
"The ``box.space`` submodule has the data-manipulation functions ``select``, "
"``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, "
"``put``. It also has members, such as id, and whether or not a space is "
"enabled. Submodule source code is available in file `src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/book/box/box_space.rst:41 ../book/box/box_space.rst:38
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all "
"``box.space`` members."
msgstr ""

#: ../doc/book/box/box_space.rst:46 ../book/box/box_space.rst:43
msgid "**The functions and members of box.space**"
msgstr ""

#: ../doc/book/box/box_space.rst:52 ../book/box/box_space.rst:49
msgid "Use"
msgstr ""

#: ../doc/book/box/box_space.rst:54 ../book/box/box_space.rst:51
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:54 ../book/box/box_space.rst:51
msgid "Create an index"
msgstr ""

#: ../doc/book/box/box_space.rst:57 ../book/box/box_space.rst:54
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:57 ../book/box/box_space.rst:54
msgid "Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:60 ../book/box/box_space.rst:57
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/book/box/box_space.rst:60 ../book/box/box_space.rst:57
msgid "Select one or more tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:63 ../book/box/box_space.rst:60
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/book/box/box_space.rst:63 ../book/box/box_space.rst:60
msgid "Select a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:66 ../book/box/box_space.rst:63
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/book/box/box_space.rst:66 ../book/box/box_space.rst:63
msgid "Destroy a space"
msgstr ""

#: ../doc/book/box/box_space.rst:69 ../book/box/box_space.rst:66
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/book/box/box_space.rst:69 ../book/box/box_space.rst:66
msgid "Rename a space"
msgstr ""

#: ../doc/book/box/box_space.rst:72 ../book/box/box_space.rst:69
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:72 ../doc/book/box/box_space.rst:75
#: ../book/box/box_space.rst:69 ../book/box/box_space.rst:72
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:75 ../book/box/box_space.rst:72
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/book/box/box_space.rst:78 ../book/box/box_space.rst:75
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/book/box/box_space.rst:78 ../doc/book/box/box_space.rst:81
#: ../book/box/box_space.rst:75 ../book/box/box_space.rst:78
msgid "Update a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:81 ../book/box/box_space.rst:78
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84 ../book/box/box_space.rst:81
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/book/box/box_space.rst:84 ../book/box/box_space.rst:81
msgid "Delete a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:87 ../book/box/box_space.rst:84
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:87 ../doc/book/box/box_space.rst:90
#: ../book/box/box_space.rst:84 ../book/box/box_space.rst:87
msgid "Get count of tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:90 ../book/box/box_space.rst:87
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/book/box/box_space.rst:93 ../book/box/box_space.rst:90
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/book/box/box_space.rst:93 ../book/box/box_space.rst:90
msgid "Delete all tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:96 ../book/box/box_space.rst:93
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/book/box/box_space.rst:96 ../book/box/box_space.rst:93
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:99 ../book/box/box_space.rst:96
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:99 ../book/box/box_space.rst:96
msgid "Prepare for iterating"
msgstr ""

#: ../doc/book/box/box_space.rst:102 ../book/box/box_space.rst:99
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/book/box/box_space.rst:102 ../book/box/box_space.rst:99
msgid ".Numeric identifier of space"
msgstr ""

#: ../doc/book/box/box_space.rst:105 ../book/box/box_space.rst:102
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/book/box/box_space.rst:105 ../book/box/box_space.rst:102
msgid ".Flag, true if space is enabled"
msgstr ""

#: ../doc/book/box/box_space.rst:108 ../book/box/box_space.rst:105
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:108 ../book/box/box_space.rst:105
msgid ".Required number of fields"
msgstr ""

#: ../doc/book/box/box_space.rst:111 ../book/box/box_space.rst:108
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../doc/book/box/box_space.rst:111 ../book/box/box_space.rst:108
msgid ".Container of space's indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:114 ../book/box/box_space.rst:111
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/book/box/box_space.rst:114 ../book/box/box_space.rst:111
msgid ".(Metadata) List of schemas"
msgstr ""

#: ../doc/book/box/box_space.rst:117 ../book/box/box_space.rst:114
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/book/box/box_space.rst:117 ../book/box/box_space.rst:114
msgid ".(Metadata) List of spaces"
msgstr ""

#: ../doc/book/box/box_space.rst:120 ../book/box/box_space.rst:117
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/book/box/box_space.rst:120 ../book/box/box_space.rst:117
msgid ".(Metadata) List of indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:123 ../book/box/box_space.rst:120
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/book/box/box_space.rst:123 ../book/box/box_space.rst:120
msgid ".(Metadata) List of users"
msgstr ""

#: ../doc/book/box/box_space.rst:126 ../book/box/box_space.rst:123
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/book/box/box_space.rst:126 ../book/box/box_space.rst:123
msgid ".(Metadata) List of privileges"
msgstr ""

#: ../doc/book/box/box_space.rst:129 ../book/box/box_space.rst:126
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/book/box/box_space.rst:129 ../book/box/box_space.rst:126
msgid ".(Metadata) List of clusters"
msgstr ""

#: ../doc/book/box/box_space.rst:132 ../book/box/box_space.rst:129
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/book/box/box_space.rst:132 ../book/box/box_space.rst:129
msgid ".(Metadata) List of function tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:146 ../book/box/box_space.rst:143
msgid ""
"Create an index. It is mandatory to create an index for a tuple set before "
"trying to insert tuples into it, or select tuples from it. The first created "
"index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:151 ../book/box/box_space.rst:148
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`index_name` (type = string) = name of "
"index, which should not be a number and should not contain special "
"characters; :codeitalic:`options`."
msgstr ""

#: ../doc/book/box/box_space.rst:156 ../book/box/box_space.rst:153
msgid "index object"
msgstr ""

#: ../doc/book/box/box_space.rst:157 ../book/box/box_space.rst:154
msgid "index_object"
msgstr ""

#: ../doc/book/box/box_space.rst:161 ../book/box/box_space.rst:158
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../doc/book/box/box_space.rst:171 ../book/box/box_space.rst:168
msgid "type"
msgstr ""

#: ../doc/book/box/box_space.rst:171 ../book/box/box_space.rst:168
msgid "type of index"
msgstr ""

#: ../doc/book/box/box_space.rst:171 ../book/box/box_space.rst:168
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../doc/book/box/box_space.rst:171 ../book/box/box_space.rst:168
msgid "'TREE'"
msgstr ""

#: ../doc/book/box/box_space.rst:175 ../book/box/box_space.rst:172
msgid "last index's id, +1"
msgstr ""

#: ../doc/book/box/box_space.rst:177 ../book/box/box_space.rst:174
msgid "unique"
msgstr ""

#: ../doc/book/box/box_space.rst:177 ../book/box/box_space.rst:174
msgid "index is unique"
msgstr ""

#: ../doc/book/box/box_space.rst:177 ../book/box/box_space.rst:174
msgid "``true``"
msgstr ""

#: ../doc/book/box/box_space.rst:179 ../book/box/box_space.rst:176
msgid "``false``"
msgstr ""

#: ../doc/book/box/box_space.rst:182 ../book/box/box_space.rst:179
msgid "parts"
msgstr ""

#: ../doc/book/box/box_space.rst:182 ../book/box/box_space.rst:179
msgid "field-numbers  + types"
msgstr ""

#: ../doc/book/box/box_space.rst:182 ../book/box/box_space.rst:179
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'array' or "
"'scalar'}"
msgstr ""

#: ../doc/book/box/box_space.rst:182 ../book/box/box_space.rst:179
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/book/box/box_space.rst:188 ../book/box/box_space.rst:185
msgid ""
"Possible errors: too many parts. Index '...' already exists. Primary key "
"must be unique."
msgstr ""

#: ../doc/book/box/box_space.rst:190 ../book/box/box_space.rst:187
msgid ""
"Note re storage engine: vinyl supports only the TREE index type, and vinyl "
"secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:193 ../book/box/box_space.rst:190
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', "
"2, 'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:204 ../book/box/box_space.rst:201
msgid ""
"Details about index field types: |br| The six index field types (unsigned | "
"string | integer | number | array | scalar) differ depending on what values "
"are allowed, and what index types are allowed. |br| **unsigned**: unsigned "
"integers between 0 and 18446744073709551615, about 18 quintillion. May also "
"be called 'uint' or 'num', but 'num' is deprecated. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes. |br| **string**: any set of octets, "
"up to the :ref:`maximum length <limitations_bytes_in_index_key>`. May also "
"be called 'str'. Legal in memtx TREE or HASH or BITSET indexes, and in vinyl "
"TREE indexes. |br| **integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or HASH "
"indexes, and in vinyl TREE indexes. |br| **number**: integers between "
"-9223372036854775808 and 18446744073709551615, single-precision floating "
"point numbers, or double-precision floating point numbers. Legal in memtx "
"TREE or HASH indexes, and in vinyl TREE indexes. |br| **array**: array of "
"integers between -9223372036854775808 and 9223372036854775807. Legal in "
"memtx RTREE indexes. |br| **scalar**: booleans (true or false), or integers "
"between -9223372036854775808 and 18446744073709551615, or single-precision "
"floating point numbers, or double-precison floating-point numbers, or "
"strings. When there is a mix of types, the key order is: booleans, then "
"numbers, then strings. Legal in memtx TREE or HASH indexes, and in vinyl "
"TREE indexes."
msgstr ""

#: ../doc/book/box/box_space.rst:228 ../book/box/box_space.rst:225
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/book/box/box_space.rst:237 ../book/box/box_space.rst:234
msgid "What can be in it"
msgstr ""

#: ../doc/book/box/box_space.rst:237 ../book/box/box_space.rst:234
msgid "Where is it legal"
msgstr ""

#: ../book/box/box_space.rst:234
msgid "Examples"
msgstr "Примеры:"

#: ../doc/book/box/box_space.rst:239 ../book/box/box_space.rst:236
msgid "**unsigned**"
msgstr ""

#: ../doc/book/box/box_space.rst:239 ../book/box/box_space.rst:236
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:239 ../doc/book/box/box_space.rst:246
#: ../doc/book/box/box_space.rst:250 ../doc/book/box/box_space.rst:262
#: ../book/box/box_space.rst:236 ../book/box/box_space.rst:243
#: ../book/box/box_space.rst:247 ../book/box/box_space.rst:259
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../book/box/box_space.rst:236
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/book/box/box_space.rst:243 ../book/box/box_space.rst:240
msgid "**string**"
msgstr ""

#: ../doc/book/box/box_space.rst:243 ../book/box/box_space.rst:240
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/book/box/box_space.rst:243 ../book/box/box_space.rst:240
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:243 ../book/box/box_space.rst:240
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/book/box/box_space.rst:246 ../book/box/box_space.rst:243
msgid "**integer**"
msgstr ""

#: ../doc/book/box/box_space.rst:246 ../book/box/box_space.rst:243
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/book/box/box_space.rst:246 ../book/box/box_space.rst:243
msgid "-2^63 |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:250 ../book/box/box_space.rst:247
msgid "**number**"
msgstr ""

#: ../doc/book/box/box_space.rst:250 ../book/box/box_space.rst:247
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/book/box/box_space.rst:250 ../book/box/box_space.rst:247
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/book/box/box_space.rst:258 ../book/box/box_space.rst:255
msgid "**array**"
msgstr ""

#: ../doc/book/box/box_space.rst:258 ../book/box/box_space.rst:255
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/book/box/box_space.rst:258 ../book/box/box_space.rst:255
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/book/box/box_space.rst:258 ../book/box/box_space.rst:255
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../book/box/box_space.rst:259
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/book/box/box_space.rst:262 ../book/box/box_space.rst:259
msgid ""
"booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""

#: ../doc/book/box/box_space.rst:262 ../book/box/box_space.rst:259
msgid "true |br| -1 |br| 1.234 |br| '' |br| '俄國'"
msgstr ""

#: ../doc/book/box/box_space.rst:276 ../book/box/box_space.rst:273
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/book/box/box_space.rst:278 ../doc/book/box/box_space.rst:457
#: ../book/box/box_space.rst:275 ../book/box/box_space.rst:454
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`tuple` (type = Lua table or tuple) = tuple "
"to be inserted."
msgstr ""

#: ../doc/book/box/box_space.rst:281 ../book/box/box_space.rst:278
msgid "the inserted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:284 ../book/box/box_space.rst:281
msgid ""
"Possible errors: If a tuple with the same unique-key value already exists, "
"returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../doc/book/box/box_space.rst:289 ../book/box/box_space.rst:286
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:300 ../book/box/box_space.rst:297
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:302
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`search-key-value` (type = Lua table or "
"scalar) = value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/book/box/box_space.rst:306
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed "
"search-key-value. If the number of passed fields is less than the number of "
"fields in the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/book/box/box_space.rst:313 ../doc/book/box/box_space.rst:878
#: ../book/box/box_space.rst:310
msgid "Possible errors: No such space; wrong type."
msgstr ""

#: ../doc/book/box/box_space.rst:315 ../book/box/box_space.rst:312
msgid "**Complexity Factors:** Index size, Index type."
msgstr ""

#: ../doc/book/box/box_space.rst:319 ../book/box/box_space.rst:316
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:364 ../book/box/box_space.rst:361
msgid ""
"For examples of complex ``select`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\") and how many tuples to return, see the later "
"section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/book/box/box_space.rst:373 ../book/box/box_space.rst:370
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/book/box/box_space.rst:379 ../book/box/box_space.rst:376
msgid "the tuple whose index key matches :codeitalic:`key`, or null."
msgstr ""

#: ../doc/book/box/box_space.rst:382 ../doc/book/box/box_space.rst:411
#: ../book/box/box_space.rst:379 ../book/box/box_space.rst:408
msgid "Possible errors: If space_object does not exist."
msgstr ""

#: ../doc/book/box/box_space.rst:384 ../doc/book/box/box_space.rst:413
#: ../doc/book/box/box_space.rst:467 ../doc/book/box/box_space.rst:845
#: ../book/box/box_space.rst:381 ../book/box/box_space.rst:410
#: ../book/box/box_space.rst:464 ../book/box/box_space.rst:846
msgid ""
"**Complexity Factors:** Index size, Index type, Number of indexes accessed, "
"WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:387 ../book/box/box_space.rst:384
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua table; "
"the ``box.space...get`` function returns at most a single tuple. And it is "
"possible to get the first tuple in a tuple set by appending ``[1]``. "
"Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space."
"tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/book/box/box_space.rst:397 ../book/box/box_space.rst:394
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/book/box/box_space.rst:405 ../book/box/box_space.rst:402
msgid "Drop a space."
msgstr ""

#: ../doc/book/box/box_space.rst:407 ../doc/book/box/box_space.rst:690
#: ../doc/book/box/box_space.rst:708 ../doc/book/box/box_space.rst:728
#: ../doc/book/box/box_space.rst:745 ../doc/book/box/box_space.rst:785
#: ../doc/book/box/box_space.rst:807 ../book/box/box_space.rst:404
#: ../book/box/box_space.rst:687 ../book/box/box_space.rst:705
#: ../book/box/box_space.rst:725 ../book/box/box_space.rst:742
#: ../book/box/box_space.rst:782 ../book/box/box_space.rst:804
#: ../book/box/box_space.rst:870
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`."
msgstr ""

#: ../doc/book/box/box_space.rst:418 ../book/box/box_space.rst:415
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/book/box/box_space.rst:426 ../book/box/box_space.rst:423
msgid "Rename a space."
msgstr ""

#: ../doc/book/box/box_space.rst:428 ../book/box/box_space.rst:425
msgid ""
"Parameters::samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`space-name` (type = string) = new name for "
"space."
msgstr ""

#: ../doc/book/box/box_space.rst:433 ../book/box/box_space.rst:430
msgid "Possible errors: space_object does not exist."
msgstr ""

#: ../doc/book/box/box_space.rst:437 ../book/box/box_space.rst:434
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:451 ../book/box/box_space.rst:448
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already "
"exists, ``box.space...:replace()`` replaces the existing tuple with a new "
"one. The syntax variants ``box.space...:replace()`` and ``box.space...:"
"put()`` have the same effect; the latter is sometimes used to show that the "
"effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/book/box/box_space.rst:460 ../doc/book/box/box_space.rst:842
#: ../book/box/box_space.rst:457 ../book/box/box_space.rst:843
msgid "the inserted tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:463 ../book/box/box_space.rst:460
msgid ""
"Possible errors: If a different tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there "
"is a unique secondary index.)"
msgstr ""

#: ../doc/book/box/box_space.rst:472 ../book/box/box_space.rst:469
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/book/box/box_space.rst:482 ../book/box/box_space.rst:479
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined in "
"a single update request, and in this case they are performed atomically and "
"sequentially. Each operation requires specification of a field number. When "
"multiple operations are present, the field number for each operation is "
"assumed to be relative to the most recent state of the tuple, that is, as if "
"all previous operations in a multi-operation update have already been "
"applied. In other words, it is always safe to merge multiple ``update`` "
"invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../doc/book/box/box_space.rst:494 ../book/box/box_space.rst:491
msgid "Possible operators are:"
msgstr ""

#: ../doc/book/box/box_space.rst:496 ../book/box/box_space.rst:493
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:497 ../book/box/box_space.rst:494
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:498 ../book/box/box_space.rst:495
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:499 ../book/box/box_space.rst:496
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:500 ../book/box/box_space.rst:497
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../doc/book/box/box_space.rst:501 ../book/box/box_space.rst:498
msgid "``:`` for string splice"
msgstr ""

#: ../doc/book/box/box_space.rst:502 ../book/box/box_space.rst:499
msgid "``!`` for insertion"
msgstr ""

#: ../doc/book/box/box_space.rst:503 ../book/box/box_space.rst:500
msgid "``#`` for deletion"
msgstr ""

#: ../doc/book/box/box_space.rst:504 ../book/box/box_space.rst:501
msgid "``=`` for assignment"
msgstr ""

#: ../doc/book/box/box_space.rst:506 ../book/box/box_space.rst:503
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning the "
"last field in the tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:509 ../book/box/box_space.rst:506
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = primary-"
"key field values, must be passed as a Lua table if key is multi-part; :"
"codeitalic:`{operator, field_no, value}` (type = table): a group of "
"arguments for each operation, indicating what the operation is, what field "
"the operation will apply to, and what value will be applied. The field "
"number can be negative, meaning the position from the end of tuple (#tuple + "
"negative field number + 1)."
msgstr ""

#: ../doc/book/box/box_space.rst:521 ../book/box/box_space.rst:518
msgid "Possible errors: it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:523 ../book/box/box_space.rst:520
msgid ""
"**Complexity Factors:** Index size, Index type, number of indexes accessed, "
"WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:526 ../book/box/box_space.rst:523
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/book/box/box_space.rst:528 ../book/box/box_space.rst:525
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:532 ../book/box/box_space.rst:529
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to it "
"is ``55``, the second affected field is field ``3`` and the value which will "
"be assigned to it is ``'x'``."
msgstr ""

#: ../doc/book/box/box_space.rst:540 ../book/box/box_space.rst:537
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-key "
"index whose type is ``unsigned``. There is one tuple, with ``field[1]`` = "
"``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/book/box/box_space.rst:544 ../book/box/box_space.rst:541
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| "
"The first argument is ``tester``, that is, the affected space is ``tester``. "
"The second argument is ``999``, that is, the affected tuple is identified by "
"primary key value = 999. The third argument is ``=``, that is, there is one "
"operation — *assignment to a field*. The fourth argument is ``2``, that is, "
"the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, "
"``field[2]`` contents change to ``'B'``. Therefore, after this update, "
"``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/book/box/box_space.rst:555 ../book/box/box_space.rst:552
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| "
"the arguments are the same, except that the key is passed as a Lua table "
"(inside braces). This is unnecessary when the primary key has only one "
"field, but would be necessary if the primary key had more than one field. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'`` (no change)."
msgstr ""

#: ../doc/book/box/box_space.rst:562 ../book/box/box_space.rst:559
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| "
"the arguments are the same, except that the fourth argument is ``3``, that "
"is, the affected field is ``field[3]``. It is okay that, until now, "
"``field[3]`` has not existed. It gets added. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/book/box/box_space.rst:569 ../book/box/box_space.rst:566
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| "
"the arguments are the same, except that the third argument is ``'+'``, that "
"is, the operation is addition rather than assignment. Since ``field[3]`` "
"previously contained ``1``, this means we're adding ``1`` to ``1``. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = "
"``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/book/box/box_space.rst:577 ../book/box/box_space.rst:574
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, "
"'C'}})`` |br| the idea is to modify two fields at once. The formats are "
"``'|'`` and ``=``, that is, there are two operations, OR and assignment. The "
"fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The "
"seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = "
"``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/book/box/box_space.rst:586 ../book/box/box_space.rst:583
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, "
"3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from "
"``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` "
"becomes ``field[2]``` before we subtract ``3`` from it, and that's why the "
"seventh argument is ``2``, not ``3``. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/book/box/box_space.rst:594 ../book/box/box_space.rst:591
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |"
"br| we're making a long string so that splice will work in the next example. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = "
"``'XYZ'``."
msgstr ""

#: ../doc/book/box/box_space.rst:599 ../book/box/box_space.rst:596
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the example "
"of splice. The fourth argument is ``2`` because the change will occur in "
"``field[2]``. The fifth argument is 2 because deletion will begin with the "
"second byte. The sixth argument is 1 because the number of bytes to delete "
"is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at "
"this position. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/book/box/box_space.rst:612 ../book/box/box_space.rst:609
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:614 ../book/box/box_space.rst:611
msgid ""
"If there is an existing tuple which matches the key fields of "
"``tuple_value``, then the request has the same effect as :ref:`space_object:"
"update() <box_space-update>` and the ``{{operator, field_no, value}, ...}`` "
"parameter is used. If there is no existing tuple which matches the key "
"fields of ``tuple_value``, then the request has the same effect as :ref:"
"`space_object:insert() <box_space-insert>` and the ``{tuple_value}`` "
"parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will "
"not read a tuple and perform error checks before returning -- this is a "
"design feature which enhances throughput but requires more caution on the "
"part of the user."
msgstr ""

#: ../doc/book/box/box_space.rst:624 ../book/box/box_space.rst:621
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :samp:`{tuple_value}` (type = Lua table or scalar) = "
"field values, must be passed as a Lua table; :codeitalic:`{operator, "
"field_no, value}` (type = Lua table) = a group of arguments for each "
"operation, indicating what the operation is, what field the operation will "
"apply to, and what value will be applied. The field number can be negative, "
"meaning the position from the end of the tuple (#tuple + negative field "
"number + 1)."
msgstr ""

#: ../doc/book/box/box_space.rst:633 ../book/box/box_space.rst:630
msgid "null."
msgstr ""

#: ../doc/book/box/box_space.rst:635 ../book/box/box_space.rst:632
msgid ""
"Possible errors: it is illegal to modify a primary-key field. It is illegal "
"to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/book/box/box_space.rst:638 ../book/box/box_space.rst:635
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes accessed, "
"WAL settings."
msgstr ""

#: ../doc/book/box/box_space.rst:643 ../book/box/box_space.rst:640
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/book/box/box_space.rst:651 ../book/box/box_space.rst:648
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/book/box/box_space.rst:653 ../book/box/box_space.rst:650
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>` :codeitalic:`key` (type = Lua table or scalar) = key to "
"be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/book/box/box_space.rst:657 ../book/box/box_space.rst:654
msgid "the deleted tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:660 ../book/box/box_space.rst:657
msgid "**Complexity Factors:** Index size, Index type"
msgstr ""

#: ../doc/book/box/box_space.rst:662 ../book/box/box_space.rst:659
msgid ""
"Note re storage engine: vinyl will return ``nil``, rather than the deleted "
"tuple."
msgstr ""

#: ../doc/book/box/box_space.rst:666 ../book/box/box_space.rst:663
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:685 ../book/box/box_space.rst:682
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}"
"`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/book/box/box_space.rst:694 ../book/box/box_space.rst:691
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:705 ../book/box/box_space.rst:702
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space "
"has no index."
msgstr ""

#: ../doc/book/box/box_space.rst:714 ../book/box/box_space.rst:711
msgid ""
"The required field count for all tuples in this space. The field_count can "
"be set initially with:"
msgstr ""

#: ../doc/book/box/box_space.rst:720 ../book/box/box_space.rst:717
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/book/box/box_space.rst:726 ../book/box/box_space.rst:723
msgid ""
"The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/book/box/box_space.rst:732 ../book/box/box_space.rst:729
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:741 ../book/box/box_space.rst:738
msgid ""
"A container for all defined indexes. There is a Lua object of type :ref:`box."
"index <box_index>` with methods to search tuples and iterate over them in "
"predefined order."
msgstr ""

#: ../doc/book/box/box_space.rst:751 ../book/box/box_space.rst:748
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:766 ../book/box/box_space.rst:763
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to "
"be matched against the primary index key, which may be multi-part; :"
"codeitalic:`iterator` = comparison method."
msgstr ""

#: ../doc/book/box/box_space.rst:770 ../book/box/box_space.rst:767
msgid "Number of tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:774 ../book/box/box_space.rst:771
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:787 ../book/box/box_space.rst:784
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/book/box/box_space.rst:791 ../book/box/box_space.rst:788
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:798 ../book/box/box_space.rst:795
msgid ""
"Note re storage engine: vinyl does not support ``len()``.  One possible "
"workaround is to say ``#select(...)``."
msgstr ""

#: ../doc/book/box/box_space.rst:805
msgid "Deletes all tuples."
msgstr ""

#: ../doc/book/box/box_space.rst:809 ../book/box/box_space.rst:806
msgid ""
"**Complexity Factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/book/box/box_space.rst:815 ../book/box/box_space.rst:812
msgid ""
"Note that ``truncate`` must be called only by the user who created the space "
"OR under a `setuid` function created by that user. Read more about `setuid` "
"functions :ref:`here <authentication-funcs>`"
msgstr ""

#: ../doc/book/box/box_space.rst:821 ../book/box/box_space.rst:820
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:835 ../book/box/box_space.rst:834
msgid ""
"Insert a new tuple using an auto-increment primary key. The space specified "
"by space_object must have an ``unsigned`` or ``integer`` or ``numeric`` "
"primary key index of type ``TREE``. The primary-key field will be "
"incremented before the insert."
msgstr ""

#: ../doc/book/box/box_space.rst:839 ../book/box/box_space.rst:840
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`field-value(s)` (type = Lua table or "
"scalar) = tuple's fields, other than the primary-key field."
msgstr ""

#: ../doc/book/box/box_space.rst:848 ../book/box/box_space.rst:849
msgid ""
"Possible errors: index has wrong type or primary-key indexed field is not a "
"number."
msgstr ""

#: ../doc/book/box/box_space.rst:852 ../book/box/box_space.rst:853
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:867
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/book/box/box_space.rst:870
msgid ""
"Parameters: :samp:`{space_object}` = an :ref:`object reference <index-"
"object_reference>`; :codeitalic:`search-key-value` (type = Lua table or "
"scalar) = value to be matched against the index key, which may be multi-"
"part; :samp:`{iterator-type}` = see :ref:`index_object:pairs <box_index-"
"index_pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:882
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""

#: ../doc/book/box/box_space.rst:889 ../book/box/box_space.rst:877
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:920 ../book/box/box_space.rst:908
msgid ""
"``_schema`` is a system tuple set. Its single tuple contains these fields: "
"``'version', major-version-number, minor-version-number``."
msgstr ""

#: ../doc/book/box/box_space.rst:925 ../book/box/box_space.rst:913
msgid ""
"The following function will display all fields in all tuples of ``_schema``:"
msgstr ""

#: ../doc/book/box/box_space.rst:927 ../book/box/box_space.rst:915
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._schema:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      line = line .. v[i] .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:944 ../doc/book/box/box_space.rst:988
#: ../doc/book/box/box_space.rst:1083 ../book/box/box_space.rst:932
#: ../book/box/box_space.rst:976 ../book/box/box_space.rst:1071
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/book/box/box_space.rst:946 ../book/box/box_space.rst:934
msgid ""
"tarantool> example()\n"
"---\n"
"- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
"  - 'max_id 520 '\n"
"  - 'version 1 7 0 '\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:959 ../book/box/box_space.rst:947
msgid ""
"``_space`` is a system tuple set. Its tuples contain these fields: ``id``, "
"``owner`` (= id of user who owns the space), ``name``, ``engine``, "
"``field_count``, ``flags`` (e.g. temporary), ``format``. These fields are "
"established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:967 ../book/box/box_space.rst:955
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../doc/book/box/box_space.rst:969 ../book/box/box_space.rst:957
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:990 ../book/box/box_space.rst:978
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1011 ../book/box/box_space.rst:999
msgid ""
"The following requests will create a space using ``box.schema.space.create`` "
"with a ``format`` clause. Then it retrieves the _space tuple for the new "
"space. This illustrates the typical use of the ``format`` clause, it shows "
"the recommended names and data types for the fields."
msgstr ""

#: ../doc/book/box/box_space.rst:1017 ../book/box/box_space.rst:1005
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1046 ../book/box/box_space.rst:1034
msgid ""
"``_index`` is a system tuple set. Its tuples contain these fields: ``id`` (= "
"id of space), ``iid`` (= index number within space), ``name``, ``type``, "
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-"
"type`` ...]."
msgstr ""

#: ../doc/book/box/box_space.rst:1051 ../book/box/box_space.rst:1039
msgid ""
"The following function will display all fields in all tuples of ``_index``: "
"(notice that the fifth field gets special treatment as a map value and the "
"sixth or later fields get special treatment as arrays):"
msgstr ""

#: ../doc/book/box/box_space.rst:1055 ../book/box/box_space.rst:1043
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line, value\n"
"  for k, v in box.space._index:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"     while v[i] ~= nil do\n"
"      if i < 5 then\n"
"        value = v[i]\n"
"        end\n"
"      if i == 5 then\n"
"        if v[i].unique == true then\n"
"          value = 'true'\n"
"          end\n"
"        end\n"
"      if i > 5 then\n"
"        value = v[i][1][1] .. ' ' .. v[i][1][2]\n"
"        end\n"
"      line = line .. value .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"    end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:1085 ../book/box/box_space.rst:1073
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 0 primary tree true 0 str '\n"
"  - '280 0 primary tree true 0 num '\n"
"  - '280 1 owner tree tree 1 num '\n"
"  - '280 2 name tree true 2 str '\n"
"  - '281 0 primary tree true 0 num '\n"
"  - '281 1 owner tree tree 1 num '\n"
"  - '281 2 name tree true 2 str '\n"
"  - '288 0 primary tree true 0 num '\n"
"  - '288 2 name tree true 0 num '\n"
"  - '289 0 primary tree true 0 num '\n"
"  - '289 2 name tree true 0 num '\n"
"  - '296 0 primary tree true 0 num '\n"
"  - '296 1 owner tree tree 1 num '\n"
"  - '296 2 name tree true 2 str '\n"
"  - '297 0 primary tree true 0 num '\n"
"  - '297 1 owner tree tree 1 num '\n"
"  - '297 2 name tree true 2 str '\n"
"  - '304 0 primary tree true 0 num '\n"
"  - '304 1 owner tree tree 1 num '\n"
"  - '304 2 name tree true 2 str '\n"
"  - '305 0 primary tree true 0 num '\n"
"  - '305 1 owner tree tree 1 num '\n"
"  - '305 2 name tree true 2 str '\n"
"  - '312 0 primary tree true 1 num '\n"
"  - '312 1 owner tree tree 0 num '\n"
"  - '312 2 object tree tree 2 str '\n"
"  - '313 0 primary tree true 1 num '\n"
"  - '313 1 owner tree tree 0 num '\n"
"  - '313 2 object tree tree 2 str '\n"
"  - '320 0 primary tree true 0 num '\n"
"  - '320 1 uuid tree true 1 str '\n"
"  - '512 0 primary tree true 0 num '\n"
"  - '513 0 primary tree true 0 num '\n"
"  - '516 0 primary tree true 0 STR '\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1129 ../book/box/box_space.rst:1117
msgid ""
"``_user`` is a system tuple set for support of the :ref:`authorization "
"feature <authentication>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1136 ../book/box/box_space.rst:1124
msgid ""
"``_priv`` is a system tuple set for support of the :ref:`authorization "
"feature <authentication>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1143 ../book/box/box_space.rst:1131
msgid ""
"``_cluster`` is a system tuple set for support of the :ref:`replication "
"feature <index-box_replication>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1150 ../book/box/box_space.rst:1138
msgid ""
"``_func`` is a system tuple set with function tuples made by :ref:`box."
"schema.func.create <box_schema-func_create>`."
msgstr ""

#: ../doc/book/box/box_space.rst:1155 ../book/box/box_space.rst:1143
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../doc/book/box/box_space.rst:1157 ../book/box/box_space.rst:1145
msgid ""
"This function will illustrate how to look at all the spaces, and for each "
"display: approximately how many tuples it contains, and the first field of "
"its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a "
"scan of the ``_space`` system tuple set, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in "
"the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""

#: ../doc/book/box/box_space.rst:1167 ../book/box/box_space.rst:1155
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/book/box/box_space.rst:1191 ../book/box/box_space.rst:1179
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/book/box/box_space.rst:1193 ../book/box/box_space.rst:1181
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/book/box/box_space.rst:1213 ../book/box/box_space.rst:1201
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/book/box/box_space.rst:1215 ../book/box/box_space.rst:1203
msgid ""
"The objective is to display field names and field types of a system space -- "
"using metadata to find metadata."
msgstr ""

#: ../doc/book/box/box_space.rst:1218 ../book/box/box_space.rst:1206
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/book/box/box_space.rst:1220 ../book/box/box_space.rst:1208
msgid ""
"A simple way is to look at the constants in box.schema, which tell us that "
"there is an item named SPACE_ID == 288, so these statements will retrieve "
"the correct tuple: |br| :codenormal:`box.space._space:select{288}` |br| or |"
"br| :codenormal:`box.space._space:select{box.schema.SPACE_ID}` |br|"
msgstr ""

#: ../doc/book/box/box_space.rst:1227 ../book/box/box_space.rst:1215
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us that "
"there is a secondary index named 'name' for space number 288, so this "
"statement also will retrieve the correct tuple: |br| :codenormal:`box.space."
"_space.index.name:select{'_space'}`"
msgstr ""

#: ../doc/book/box/box_space.rst:1232 ../book/box/box_space.rst:1220
msgid ""
"However, the retrieved tuple is not easy to read: |br| :codenormal:"
"`tarantool>` :codebold:`box.space._space.index.name:select{'_space'}` |br| :"
"codenormal:`---` |br| :codenormal:`- - [280, 1, '_space', 'memtx', 0, '', "
"[{'name': 'id',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': 'num'}, "
"{'name': 'owner','type': 'num'},` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
"`{'name': 'name','type': 'str'}, {'name': 'engine',` |br| |nbsp| |nbsp| |"
"nbsp| :codenormal:`'type': 'str'},{'name': 'field_count', 'type': 'num'},` |"
"br| |nbsp| |nbsp| |nbsp| :codenormal:`{'name': 'flags','type': 'str'}, "
"{'name': 'format',` |br| |nbsp| |nbsp| |nbsp| :codenormal:`'type': '*'}]]` |"
"br| |nbsp| |nbsp| |nbsp| :codenormal:`...`"
msgstr ""

#: ../doc/book/box/box_space.rst:1243 ../book/box/box_space.rst:1231
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-fields? "
"Since it's visible that field number 7 is an array of maps, this `for` loop "
"will do the organizing: |br| :codenormal:`local tuple_of_space, field_name, "
"field_type` |br| :codenormal:`tuple_of_space = box.space._space.index.name:"
"select{'_space'}[1]` |br| :codenormal:`for i = 1, #tuple_of_space[7], 1` |"
"br| :codenormal:`do` |br| |nbsp| |nbsp| |nbsp| :codenormal:`field_name = "
"tuple_of_space[7][i]['name']` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
"`field_type = tuple_of_space[7][i]['type']` |br| |nbsp| |nbsp| |nbsp| :"
"codenormal:`print(field_name .. ',' ..field_type)` |br| :codenormal:`end`"
msgstr ""

#: ../doc/book/box/box_space.rst:1257 ../book/box/box_space.rst:1245
msgid ""
"And here is what happens when one executes the `for` loop: |br| :codenormal:"
"`id,num` |br| :codenormal:`owner,num` |br| :codenormal:`name,str` |br| :"
"codenormal:`engine,str` |br| :codenormal:`field_count,num` |br| :codenormal:"
"`flags,str` |br| :codenormal:`format,*`"
msgstr ""

#: ../doc/book/box/box_stat.rst:33 ../book/box/box_introspection.rst:156
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/book/box/box_stat.rst:35 ../book/box/box_introspection.rst:158
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics. Show the average number of requests per second, and the total "
"number of requests since startup, broken down by request type and network "
"events statistics."
msgstr ""

#: ../doc/book/box/box_stat.rst:39 ../book/box/box_introspection.rst:162
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:30
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/book/box/box_tuple.rst:37 ../book/box/box_tuple.rst:34
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` "
"userdata type. It allows, for a single tuple: selective retrieval of the "
"field contents, retrieval of information about size, iteration over all the "
"fields, and conversion to a Lua table."
msgstr ""

#: ../doc/book/box/box_tuple.rst:46 ../book/box/box_tuple.rst:43
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively, "
"one can get new tuples from tarantool's :ref:`select <box_space-select>` or :"
"ref:`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :"
"ref:`update <box_space-update>` requests, which can be regarded as "
"statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/book/box/box_tuple.rst:53 ../book/box/box_tuple.rst:50
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/book/box/box_tuple.rst:55 ../book/box/box_tuple.rst:52
msgid "a new tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:58 ../book/box/box_tuple.rst:55
msgid ""
"In the following example, ``x`` will be a new table object containing one "
"tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire "
"tuple ``t``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:64 ../book/box/box_tuple.rst:61
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:85 ../book/box/box_tuple.rst:82
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if ``t`` "
"is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/book/box/box_tuple.rst:90 ../book/box/box_tuple.rst:87
msgid ""
"In the following example, a tuple named ``t`` is created and then the number "
"of fields in ``t`` is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:93 ../book/box/box_tuple.rst:90
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:105 ../book/box/box_tuple.rst:102
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes "
"in the tuple. It is useful to check this number when making changes to data, "
"because there is a fixed maximum: one megabyte. Every field has one or more "
"\"length\" bytes preceding the actual contents, so ``bsize()`` returns a "
"value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../doc/book/box/box_tuple.rst:115 ../book/box/box_tuple.rst:112
msgid ""
"In the following example, a tuple named ``t`` is created which has three "
"fields, and for each field it takes one byte to store the length and three "
"bytes to store the contents, and a bit for overhead, so ``bsize()`` returns "
"``3*(1+3)+1``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:120 ../book/box/box_tuple.rst:117
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:132 ../book/box/box_tuple.rst:129
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field "
"numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:135 ../book/box/box_tuple.rst:132
msgid "field value."
msgstr ""

#: ../doc/book/box/box_tuple.rst:136 ../book/box/box_tuple.rst:133
msgid "lua-value"
msgstr ""

#: ../doc/book/box/box_tuple.rst:138 ../book/box/box_tuple.rst:135
msgid ""
"In the following example, a tuple named ``t`` is created and then the second "
"field in ``t`` is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:141 ../book/box/box_tuple.rst:138
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:154 ../book/box/box_tuple.rst:151
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the "
"number of the first field in ``t`` that matches the search value, and ``t:"
"findall(search-value [, search-value ...])`` will return numbers of all "
"fields in ``t`` that match the search value. Optionally one can put a "
"numeric argument ``field-number`` before the search-value to indicate “start "
"searching at field number ``field-number``.”"
msgstr ""

#: ../doc/book/box/box_tuple.rst:161 ../book/box/box_tuple.rst:158
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:164 ../book/box/box_tuple.rst:161
msgid ""
"In the following example, a tuple named ``t`` is created and then: the "
"number of the first field in ``t`` which matches 'a' is returned, then the "
"numbers of all the fields in ``t`` which match 'a' are returned, then the "
"numbers of all the fields in t which match 'a' and are at or after the "
"second field are returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:170 ../book/box/box_tuple.rst:167
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:191 ../book/box/box_tuple.rst:188
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},"
"{fields-to-remove})` will return a tuple where, starting from field ``start-"
"field-number``, a number of fields (``fields-to-remove``) are removed. "
"Optionally one can add more arguments after ``fields-to-remove`` to indicate "
"new values that will replace what was removed."
msgstr ""

#: ../doc/book/box/box_tuple.rst:197 ../book/box/box_tuple.rst:194
msgid "base 1, may be negative"
msgstr ""

#: ../doc/book/box/box_tuple.rst:203 ../book/box/box_tuple.rst:200
msgid ""
"In the following example, a tuple named ``t`` is created and then, starting "
"from the second field, two fields are removed but one new one is added, then "
"the result is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:207 ../book/box/box_tuple.rst:204
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:219 ../book/box/box_tuple.rst:216
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:"
"unpack(1)`` will return all fields starting with field number 1, ``t:"
"unpack(1,5)`` will return all fields between field number 1 and field number "
"5."
msgstr ""

#: ../doc/book/box/box_tuple.rst:223 ../book/box/box_tuple.rst:220
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/book/box/box_tuple.rst:224 ../book/box/box_tuple.rst:221
msgid "lua-value(s)"
msgstr ""

#: ../doc/book/box/box_tuple.rst:226 ../book/box/box_tuple.rst:223
msgid ""
"In the following example, a tuple named ``t`` is created and then all its "
"fields are selected, then the result is returned."
msgstr ""

#: ../doc/book/box/box_tuple.rst:229 ../book/box/box_tuple.rst:226
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:245 ../book/box/box_tuple.rst:242
msgid ""
"In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, "
"``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-"
"value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is "
"useful for Lua iterators, because Lua iterators traverse a value's "
"components until an end marker is reached."
msgstr ""

#: ../doc/book/box/box_tuple.rst:251 ../book/box/box_tuple.rst:248
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/book/box/box_tuple.rst:252 ../book/box/box_tuple.rst:249
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/book/box/box_tuple.rst:254 ../book/box/box_tuple.rst:251
msgid ""
"In the following example, a tuple named ``t`` is created and then all its "
"fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/book/box/box_tuple.rst:257 ../book/box/box_tuple.rst:254
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:279 ../book/box/box_tuple.rst:276
msgid ""
"This function updates a tuple which is not in a space. Compare the function :"
"code:`box.space.`:samp:`{space-name}`:code:`:update{`:samp:`{key}, {format},"
"` :code:`{`:samp:`{field_number}, {value}`:code:`}...)`, which updates a "
"tuple in a space."
msgstr ""

#: ../doc/book/box/box_tuple.rst:283 ../book/box/box_tuple.rst:280
msgid ""
"Parameters: briefly: ``format`` indicates the type of update operation such "
"as '``=``' for 'assign new value', ``field_number`` indicates the field "
"number to change such as 2 for field number 2, ``value`` indicates the "
"string which operates on the field such as 'B' for a new assignable value = "
"'B'."
msgstr ""

#: ../doc/book/box/box_tuple.rst:288 ../book/box/box_tuple.rst:285
msgid ""
"For details: see the description for ``format``, ``field_number``, and "
"``value`` in the section :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."
msgstr ""

#: ../doc/book/box/box_tuple.rst:291 ../book/box/box_tuple.rst:288
msgid "new tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:294 ../book/box/box_tuple.rst:291
msgid ""
"In the following example, a tuple named ``t`` is created and then its second "
"field is updated to equal 'B'."
msgstr ""

#: ../doc/book/box/box_tuple.rst:297 ../book/box/box_tuple.rst:294
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=',2,'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/book/box/box_tuple.rst:311 ../book/box/box_tuple.rst:308
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables and "
"lists of scalars:"
msgstr ""

#: ../doc/book/box/box_tuple.rst:314 ../book/box/box_tuple.rst:311
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua "
"table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/book/box/box_tuple.rst:321 ../book/box/box_tuple.rst:318
msgid ""
"Then it will find the field that contains 'b', remove that field from the "
"tuple, and display how many bytes remain in the tuple. The function uses "
"Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, "
"``transform()``, ``bsize()``."
msgstr ""

#: ../doc/book/box/box_tuple.rst:326 ../book/box/box_tuple.rst:323
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = {tuple1:unpack()}\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1)\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/book/box/box_tuple.rst:342 ../book/box/box_tuple.rst:339
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../book/box/index.rst:30
msgid "Database"
msgstr "Функционал СУБД"

#: ../book/box/index.rst:34
msgid "Data model"
msgstr "Модель данных"

#: ../book/box/index.rst:36
msgid ""
"This section describes how Tarantool stores values and what operations with "
"data it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение "
"данных и какие операции с данным он поддерживает."

#: ../book/box/index.rst:39
msgid ""
"If you tried out the :ref:`Starting Tarantool and making your first database "
"<user_guide_getting_started-first_database>` exercise from the last chapter, "
"then your database looks like this:"
msgstr ""
"Если вы уже выполнили тестовое задание из раздела :ref:`Первичный запуск "
"Tarantool'а и создание базы данных <user_guide_getting_started-"
"first_database>` в предыдущей главе, то ваша база данных имеет следующий вид:"

#: ../doc/book/box/index.rst:50
msgid "Here follow the descriptions of basic concepts."
msgstr ""

#: ../book/box/index.rst:69
msgid "Space"
msgstr "Пространство"

#: ../book/box/index.rst:71
msgid "A *space* -- 'tester' in the example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../book/box/index.rst:73
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. There can be many spaces. Each space has a unique name specified by "
"the user. Each space has a unique numeric identifier which can be specified "
"by the user but usually is assigned automatically by Tarantool. Spaces "
"always contain one tuple set and one or more indexes."
msgstr ""
"Когда Tarantool используется для хранения данных, то он создает по меньшей "
"мере одно пространство (space). В общем же случае пространств может быть "
"много. Каждое пространство имеет уникальное имя, заданное пользователем, а "
"также уникальный числовой идентификатор, который тоже может быть задан "
"пользователем, но обычно назначается автоматически самим Tarantool'ом. "
"Пространство всегда содержит один набор кортежей и один или более индексов."

#: ../book/box/index.rst:81
msgid "Tuple set"
msgstr "Набор кортежей"

#: ../book/box/index.rst:83
msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
msgstr ""
"*Набор кортежей* — в нашем примере он назван 'tester' — это группа кортежей."

#: ../book/box/index.rst:85
msgid ""
"There is always one tuple set in a space. The identifier of a tuple set is "
"the same as the space name -- 'tester' in the example."
msgstr ""
"Каждое пространство всегда содержит один набор кортежей. Идентификатор "
"набора кортежей совпадает с именем самого пространства, в нашем примере — "
"`tester`."

#: ../book/box/index.rst:88
msgid ""
"A tuple fills the same role as a “row” or a “record”, and the components of "
"a tuple (which we call “fields”) fill the same role as a “row column” or "
"“record field”, except that: the fields of a tuple can be composite "
"structures, such as arrays or maps and don't need to have names. That's why "
"there was no need to pre-define the tuple set when creating the space, and "
"that's why each tuple can have a different number of elements. Tuples are "
"stored as `MsgPack`_ arrays."
msgstr ""
"Кортеж (tuple) выполняет ту же роль, что \"строка\" или \"запись\", а "
"компоненты кортежа (его \"полЯ\") выполняют ту же роль, что \"поле столбца, "
"соответствующее данной строке\" или \"поле в записи\" за тем исключением, "
"что поля кортежа могут быть составными (например, они могут быть массивами "
"или отображениями) и им не нужны имена. Поэтому нет необходимости "
"предварительно определять набор кортежей при создании пространства, а каждый "
"кортеж может иметь различное количество элементов. Кортежи хранятся в виде "
"`MsgPack`_-массивов."

#: ../book/box/index.rst:97
msgid ""
"Any given tuple may have any number of fields and the fields may have a "
"variety of types. The identifier of a field is the field's number, base 1. "
"For example “1” can be used in some contexts to refer to the first field of "
"a tuple."
msgstr ""
"Кортеж может иметь любое количество полей, и это могут быть поля разных "
"типов. Идентификатором поля является его номер. Поля нумеруются, начиная с "
"1. Так, например, “1” может использоваться в некоторых контекстах для "
"обозначения первого поля кортежа."

#: ../book/box/index.rst:101
msgid ""
"When Tarantool returns a tuple value, it surrounds strings with single "
"quotes, separates fields with commas, and encloses the tuple inside square "
"brackets. For example: ``[3, 'length', 93]``."
msgstr ""
"Когда Tarantool возвращает значение кортежа, он берет строки в одинарные "
"кавычки, отделяет поля с запятыми и заключает кортеж в квадратные скобки. "
"Например, ``[ 3, 'length', 93 ]``."

#: ../book/box/index.rst:109
msgid "Index"
msgstr "Индекс"

#: ../book/box/index.rst:111
msgid ""
"An *index* -- 'primary' in the example -- is a group of key values and "
"pointers."
msgstr ""
"*Индекс* — в нашем примере он первичный — это совокупность значений ключей и "
"указателей."

#: ../book/box/index.rst:113
msgid ""
"In order for a tuple set to be useful, there must always be at least one "
"index in a space. There can be many indexes. As with spaces, the user can "
"and should specify the index name, and let Tarantool come up with a unique "
"numeric identifier (the \"index id\"). In our example there is one index and "
"its name is “primary”."
msgstr ""
"Чтобы набором кортежей было можно пользоваться, в пространстве необходим по "
"крайней мере один индекс. Вообще же индексов в пространстве может быть "
"много. Как и в случае с пространствами, пользователь может — и должен — "
"указать имя индекса, а Tarantool подставляет уникальный числовой "
"идентификатор (\"идентификатор индекса\"). В нашем примере всего один индекс "
"с именем “primary”."

#: ../doc/book/box/index.rst:103 ../book/box/index.rst:118
#, fuzzy
msgid ""
"An index may be *multi-part*, that is, the user can declare that an index"
" key value is taken from two or more fields in the tuple, in any order. "
"An index may be *unique*, that is, the user can declare that it would be "
"illegal to have the same key value twice. An index may have *one of four "
"types*: HASH which is fast and is best for exact-equality searches with "
"unique keys, TREE which allows partial-key searching and ordered results,"
" BITSET which can be good for searches that contain '=' and multiple "
"ANDed conditions, and RTREE for spatial coordinates. The first index is "
"called the “*primary key*” index and it must be unique; all other indexes"
" are called “secondary” indexes."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Индекс может быть *составным*. Значение ключа в таком индексе составляется "
"из значений двух или более полей кортежа, причем они могут браться в любом "
"порядке. Индекс может быть *уникальным*. В этом случае один и тот же ключ не "
"может встречаться в индексе более одного раза. Также индекс может быть "
"одного из следующих *четырех типов*: HASH (он самый быстрый и самый "
"экономный в плане использования памяти, но он должен быть уникальным), TREE "
"(он позволяет делать поиск по части ключа и получать отсортированные "
"результаты), BITSET (он хорош для поиска с '=' и больших количеством AND-"
"условий) или RTREE (для пространственных координат). Первый индекс "
"называется “*первичным*” (primary) и должен быть уникальным. Все остальные "
"индексы называются “вторичными” (secondary)."

#: ../book/box/index.rst:128
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected types. The allowed types for indexed fields are:"
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и типы данных для этих "
"полей. Индексированные поля могут содержать данные следующих типов:"

#: ../book/box/index.rst:131
msgid ""
"``unsigned`` (unsigned integer between 0 and 18,446,744,073,709,551,615)"
msgstr ""
"``unsigned`` (беззнаковое целое число в диапазоне от 0 до "
"18,446,744,073,709,551,615)"

#: ../book/box/index.rst:132
msgid ""
"``integer`` (signed integer between -9,223,372,036,854,775,808 and "
"9,223,372,036,854,775,807)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 "
"до 9,223,372,036,854,775,807)"

#: ../book/box/index.rst:133
msgid "``number`` (unsigned integer or signed integer or floating-point value)"
msgstr ""
"``number`` (беззнаковое целое число, либо знаковое целое число, либо число с "
"плавающей точкой)"

#: ../book/box/index.rst:134
msgid "``string`` (string, any sequence of octets)"
msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#: ../book/box/index.rst:135
msgid "``scalar`` (boolean or number or string)"
msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#: ../book/box/index.rst:136
msgid ""
"``array`` (a series of numbers for use with :ref:`RTREE indexes <box_index-"
"rtree>`)"
msgstr ""
"``array`` (последовательность чисел для :ref:`RTREE-индексов <box_index-"
"rtree>`)"

#: ../book/box/index.rst:138
msgid "Take our example, which has the request:"
msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#: ../book/box/index.rst:140
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../book/box/index.rst:144
msgid ""
"The effect is that, for all tuples in tester, field number 1 must exist and "
"must contain an unsigned integer."
msgstr ""
"В результате у всех кортежей в пространстве `tester` должно быть поле с "
"номером 1, содержащее беззнаковое целое число."

#: ../doc/book/box/index.rst:132 ../book/box/index.rst:147
#, fuzzy
msgid ""
"Space definitions and index definitions are stored permanently in system "
"spaces. It is possible to add, drop, or alter the definitions at runtime,"
" with some restrictions. See syntax details for defining spaces and "
"indexes in :ref:`reference on Tarantool's \"box\" module <index-"
"box_library>`."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Определения пространств и индексов хранятся в системных пространствах. Можно "
"(с некоторыми ограничениями) на ходу добавлять, удалять и менять эти "
"определения. Правила синтаксиса в определениях пространств и индексов даны в "
"разделе :ref:`Библиотека \"box\" <index-box_library>`."

#: ../book/box/index.rst:154
msgid "Data types"
msgstr "Типы данных"

#: ../book/box/index.rst:156
msgid ""
"Tarantool can work with numbers, strings, booleans, tables, and userdata."
msgstr ""
"Tarantool работает с числами (numbers), строками (strings), логическими "
"значениями (booleans), таблицами (tables) и пользовательскими типами данных "
"(userdata)."

#: ../book/box/index.rst:159
msgid "General type"
msgstr "Общий тип"

#: ../book/box/index.rst:159
msgid "Specific type"
msgstr "Особый тип"

#: ../book/box/index.rst:159
msgid "What Lua ``type()`` would return"
msgstr "Результат Lua type()"

#: ../book/box/index.rst:161 ../book/box/index.rst:163
#: ../book/box/index.rst:165 ../book/box/index.rst:167
msgid "scalar"
msgstr "scalar"

#: ../book/box/index.rst:161
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../book/box/index.rst:161
msgid "12345"
msgstr "12345"

#: ../book/box/index.rst:163
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../book/box/index.rst:163
msgid "'A B C'"
msgstr "'A B C'"

#: ../book/box/index.rst:165
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../book/box/index.rst:165
msgid "true"
msgstr "true"

#: ../book/box/index.rst:167
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../book/box/index.rst:169 ../book/box/index.rst:171
msgid "compound"
msgstr "compound"

#: ../book/box/index.rst:169
msgid "Lua table"
msgstr "Lua table"

#: ../book/box/index.rst:169
msgid "\"`table`_\""
msgstr "\"`table`_\""

#: ../book/box/index.rst:169
msgid "table: 0x410f8b10"
msgstr "table: 0x410f8b10"

#: ../book/box/index.rst:171
msgid "\"`Userdata`_\""
msgstr "\"`Userdata`_\""

#: ../book/box/index.rst:171
msgid "12345: {'A B C'}"
msgstr "12345: {'A B C'}"

#: ../doc/book/box/index.rst:166 ../book/box/index.rst:181
#, fuzzy
msgid ""
"In Lua, a *number* is double-precision floating-point, but Tarantool allows "
"both integer and floating-point values. Tarantool will try to store a number "
"as floating-point if the value contains a decimal point or is very large "
"(greater than 100 billion = 1e14), otherwise Tarantool will store it as an "
"integer. To ensure that even very large numbers will be treated as integers, "
"use the :ref:`tonumber64 <other-tonumber64>` function, or the ``LL`` (Long "
"Long) suffix, or the ``ULL`` (Unsigned Long Long) suffix. Here are examples "
"of numbers using regular notation, exponential notation, the ULL suffix, and "
"the tonumber64 function: ``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В языке Lua тип *number* (число) — это число с плавающей точкой двойной "
"точности, но в Tarantool'е можно использовать как целые числа, так и числа с "
"плавающей запятой. Tarantool по возможности сохраняет числовые значения в "
"виде чисел с плавающей точкой, если числовое значение содержит десятичную "
"запятую или если оно очень велико (более 100 триллионов = 1e14). Если в "
"формате с плавающей точкой сохранить не удается, то Tarantool сохраняет "
"такое значение в виде целого числа. Чтобы даже очень большие величины "
"гарантированно обрабатывались как целые числа, используйте функцию :ref:"
"`tonumber64 <other-tonumber64>`, либо приписывайте в конце суффикс LL (Long "
"Long) или ULL (Unsigned Long Long). Вот примеры записи чисел в различных "
"представлениях (обычном, экспоненциальном, с суффиксом ULL и с "
"использованием функции tonumber64): ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/book/box/index.rst:177 ../book/box/index.rst:192
#, fuzzy
msgid ""
"For database storage, Tarantool uses MsgPack rules. Storage is variable-"
"length, so the smallest number requires only one byte but the largest number "
"requires nine bytes. When a field has an 'unsigned' index, all values must "
"be unsigned integers between 0 and 18,446,744,073,709,551,615."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Для хранения данных в базе Tarantool использует формат MsgPack. Данные при "
"хранении имеют переменную длину, поэтому для самого маленького числа "
"потребуется только один байт, а самое большее число потребует девять байтов. "
"Если поле имеет индекс 'unsigned', то оно может содержать только целые "
"беззнаковые числа со значениями в диапазоне от 0 до "
"18,446,744,073,709,551,615."

#: ../book/box/index.rst:197
msgid ""
"A *string* is a variable-length sequence of bytes, usually represented with "
"alphanumeric characters inside single quotes."
msgstr ""
"Тип *string* (строка) — это последовательность байтов, имеющая переменную "
"длину. Как правило, строки представлены в виде алфавитно-числовых символы, "
"заключенных в одинарные кавычки."

#: ../book/box/index.rst:200
msgid "A *boolean* is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или "
"``false``."

#: ../book/box/index.rst:202
msgid ""
"A *nil* type has only one possible value, also called *nil*, but often "
"displayed as *null*. Nils may be compared to values of any types with == (is-"
"equal) or ~= (is-not-equal), but other operations will not work. Nils may "
"not be used in Lua tables; the workaround is to use :ref:`yaml.NULL <yaml-"
"null>` or :ref:`json.NULL <json-null>` or :ref:`msgpack.NULL <msgpack-null>`."
msgstr ""
"Тип *nil* (нулевой) может иметь только одно значение, также называемое "
"*nil*, но часто отображаемое как *null*. Нулевое значение можно сравнивать "
"со значениями любых типов с помощью операторов == (равен) или ~= (не равен), "
"но никакие другие операции для нулевых значений не доступны. Нулевые "
"значения также нельзя использовать в Lua-таблицах; вместо нулевого значения "
"в таком случае можно указать :ref:`yaml.NULL <yaml-null>`, либо :ref:`json."
"NULL <json-null>`, либо :ref:`msgpack.NULL <msgpack-null>`."

#: ../book/box/index.rst:208
msgid ""
"A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few "
"functions may return tables with multiple tuples. A scalar may be converted "
"to a tuple with only one field. A Lua table may contain all of a tuple's "
"fields, but not nil."
msgstr ""
"Тип *tuple* возвращается в формате YAML, например ``- [120, 'a', 'b', "
"'c']``. Некоторые функции могут возвращать таблицы с несколькими кортежами. "
"Скалярная величина может быть конвертирована в кортеж с 1 полем. Lua-таблица "
"может содержать все типы полей, допустимые для кортежей, кроме нулевого типа "
"(nil)."

#: ../book/box/index.rst:213
msgid ""
"Some of the data types may be used in :ref:`indexed fields "
"<details_about_index_field_types>`."
msgstr ""
"Некоторые из этих типов данных подходят для :ref:`индексируемых полей "
"<details_about_index_field_types>`."

#: ../book/box/index.rst:215
msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
msgstr ""
"См. также примеры кортежей в разделе про модуль :ref:`box.tuple <box_tuple>`."

#: ../book/box/index.rst:219
msgid "Operations"
msgstr "Операции"

#: ../book/box/index.rst:221
msgid ""
"The basic operations are: the five data-change operations (``insert``, "
"``update``, ``upsert``, ``delete``, ``replace``), and the data-retrieval "
"operation (``select``). There are also minor operations like “ping” which "
"can only be used with the binary protocol. Also, there are :ref:`index "
"iterator <box_index-index_pairs>` operations, which can only be used with "
"Lua code. (Index iterators are for traversing indexes one key at a time, "
"taking advantage of features that are specific to an index type, for example "
"evaluating Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes.)"
msgstr ""
"Основные операции — это пять операций для изменения данных (INSERT, UPDATE, "
"UPSERT, DELETE, REPLACE) и одна операция для возвращения данных (SELECT). "
"Также в Tarantool'е поддерживаются второстепенные операции типа PING, "
"которые можно использовать только в рамках бинарного протокола. Кроме того, "
"в Tarantool'е есть операции для :ref:`индекс-итераторов <box_index-"
"index_pairs>`, которые можно использовать только в коде на языке Lua. "
"(Индекс-итераторы нужны для обхода индексов от одного ключа к другому и дают "
"возможность пользоваться преимуществами разных типов индексов, например "
"вычислять значение выражений логического типа при обходе BITSET-индексов или "
"двигаться в порядке убывания значений при обходе TREE-индексов.)"

#: ../book/box/index.rst:231
msgid "Six examples of basic operations:"
msgstr "Шесть примеров основных операций:"

#: ../book/box/index.rst:233
msgid ""
"-- Add a new tuple to tuple set tester.\n"
"-- The first field, field[1], will be 999 (type is unsigned).\n"
"-- The second field, field[2], will be 'Taranto' (type is string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Update the tuple, changing field field[2].\n"
"-- The clause \"{999}\", which has the value to look up in\n"
"-- the index of the tuple's primary-key field, is mandatory\n"
"-- because update() requests must always have a clause that\n"
"-- specifies the primary key, which in this case is field[1].\n"
"-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
"-- will happen to field[2] with the new value.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Upsert the tuple, changing field field[2] again.\n"
"-- The syntax of upsert is similar to the syntax of update,\n"
"-- but the return value will be different.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Replace the tuple, adding a new field.\n"
"-- This is also possible with the update() request but\n"
"-- the update() request is usually more complicated.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Retrieve the tuple.\n"
"-- The clause \"{999}\" is still mandatory, although it does not have to\n"
"-- mention the primary key.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Delete the tuple.\n"
"-- Once again the clause to identify the primary-key field is mandatory.\n"
"tarantool> box.space.tester:delete{999}"
msgstr ""
"-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
"-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
"-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Обновляем кортеж, меняем значение поля field[2].\n"
"-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
"-- искать в первичном индексе, построенном по первому полю\n"
"-- кортежа, является обязательным, поскольку запросам update()\n"
"-- всегда требуется условие, определяющее значение первичного\n"
"-- ключа, в данном случае field[1].\n"
"-- Условие \"{{'=', 2, 'Tarantino'}}\" определяет, что полю field[2] нужно \n"
"-- присвоить новое значение.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Выполняем операцию upsert() для кортежа и снова меняем\n"
"-- значение поля field[2].\n"
"-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
"-- но возвращаемые значения у этих запросов разные.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Производим замену кортежа с помощью replace(), добавляем новое поле.\n"
"-- Это можно сделать и с помощью запроса update(),\n"
"-- но такой вариант часто оказывается более сложным.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Возвращаем значение кортежа.\n"
"-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
"-- содержать значение первичного ключа.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Удаляем кортеж.\n"
"-- Условие, определяющее значение первичного ключа,\n"
"-- снова является обязательным.\n"
"tarantool> box.space.tester:delete{999}"

#: ../book/box/index.rst:268
msgid "How does Tarantool do a basic operation? Let's take this example:"
msgstr ""
"Как Tarantool выполняет основные операции? Давайте рассмотрим это на "
"следующем примере:"

#: ../book/box/index.rst:270
msgid ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""
"tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../book/box/index.rst:274
msgid "which, for those who know SQL, is equivalent to a statement like"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../book/box/index.rst:276
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[[1]\" = 3"

#: ../doc/book/box/index.rst:265 ../book/box/index.rst:280
#, fuzzy
msgid ""
"If this is happening on a remote client, then the client parses the "
"statement and changes it to a binary-protocol instruction which has already "
"been checked, and which the server can understand without needing to parse "
"everything again. The client ships a packet to the server."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Если запрос делается с удаленного клиента, то клиент разбирает введенное "
"выражение, проверяет на корректность и переводит его в формат инструкций "
"бинарного протокола, которые Tarantool-сервер сможет понять без повторного "
"разбора. Затем клиент отправляет всё в виде пакета на сторону сервера."

#: ../doc/book/box/index.rst:270 ../book/box/index.rst:285
#, fuzzy
msgid ""
"The server's “transaction processor” thread uses the primary-key index on "
"field[1] to find the location of the tuple in memory. It determines that the "
"tuple can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Поток, выполняющий обработку транзакций на стороне сервера, использует "
"первичный индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он "
"проверяет, что данный кортеж можно обновить (мы хотим лишь изменить значение "
"не индексированного поля, и вряд ли что-то пойдет не так в таком простом "
"случае)."

#: ../doc/book/box/index.rst:275 ../book/box/index.rst:290
#, fuzzy
msgid ""
"The transaction processor thread sends a message to the write-ahead logging "
"(WAL) thread."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Поток обработки транзакций посылает сообщение другому потоку, который "
"занимается записью в WAL."

#: ../doc/book/box/index.rst:278 ../book/box/index.rst:293
#, fuzzy
msgid ""
"At this point, a *yield* takes place. To know the significance of that -- "
"and it's quite significant -- you have to know a few facts and a few new "
"words."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В этот момент происходит *передача управления* (yield). Чтобы понять "
"важность этого события — а оно действительно важно, — нужно пояснить "
"несколько фактов и ввести ряд новых терминов."

#: ../book/box/index.rst:296
msgid "FACT 1:"
msgstr "ФАКТ #1:"

#: ../doc/book/box/index.rst:284 ../book/box/index.rst:299
#, fuzzy
msgid ""
"There is only one transaction processor thread. Some people are used to the "
"idea that there can be multiple threads operating on the database, with "
"(say) thread #1 reading row #x while thread #2 writes row #y. With Tarantool "
"no such thing ever happens. Only the transaction processor thread can access "
"the database, and there is only one transaction processor thread for each "
"instance of the server."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"В Tarantool'е есть только один поток обработки транзакций. Многие люди уже "
"привыкли к мысли, что потоков для обработки данных может быть много "
"(например, поток #1 читает данные из строки #x, в то время как поток #2 "
"записывает данные в столбец #y). В случае с Tarantool'ом такого не "
"происходит. доступ к базе есть только у потока обработки транзакций, и на "
"каждый экземпляр Tarantool'а есть только один такой поток."

#: ../book/box/index.rst:306
msgid "FACT 2:"
msgstr "ФАКТ #2:"

#: ../doc/book/box/index.rst:294 ../book/box/index.rst:309
#, fuzzy
msgid ""
"The transaction processor thread can handle many *fibers*. A fiber is a set "
"of computer instructions that may contain \"yield\" signals. The transaction "
"processor thread will execute all computer instructions until a yield, then "
"switch to execute the instructions of a different fiber. Thus (say) the "
"thread reads row #x for the sake of fiber #1, then writes row #y for the "
"sake of fiber #2."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Поток обработки транзакций может управлять множеством *файберов*. Файбер — "
"это набор инструкций, среди которых могут быть и сигналы \"передать "
"управление\". Поток обработки транзакций выполняет инструкции, пока не "
"увидит такой сигнал, и тогда он переключается на выполнение инструкций из "
"другого файбера. Например, таким образом поток обработки транзакций сначала "
"выполняет чтение данных из строки #x для файбера #1, а затем выполняет "
"запись в строку #y для файбер #2."

#: ../book/box/index.rst:317
msgid "FACT 3:"
msgstr "ФАКТ #3:"

#: ../doc/book/box/index.rst:305 ../book/box/index.rst:320
#, fuzzy
msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are :ref:`implicit yields <atomic-"
"the_implicit_yield_rules>`: every data-change operation or network-access "
"causes an implicit yield, and every statement that goes through the "
"tarantool client causes an implicit yield. And there are explicit yields: in "
"a Lua function one can and should add “yield” statements to prevent hogging. "
"This is called *cooperative multitasking*."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Без передачи управления не обойтись, т.к. иначе поток обработки транзакций "
"сможет выполнять инструкции только для одного файбера. Передача управления "
"может осуществляться один их двух способов. Первый — это :ref:`неявная "
"передача <atomic-the_implicit_yield_rules>`. Она делается при каждой "
"операции, связанной с изменением данных, при каждом обращении к сетевому "
"соединению, а также при каждом запросе, который передается через Tarantool-"
"клиент. Второй способ передачи управления — это явная передача. Ее можно — и "
"нужно — вызывать внутри Lua-функций с помощью инструкции “yield”, чтобы не "
"допустить захвата процессора одним файбером. Это называется *взаимная "
"многозадачность*."

#: ../book/box/index.rst:327
msgid ""
"Since all data-change operations end with an implicit yield and an implicit "
"commit, and since no data-change operation can change more than one tuple, "
"there is no need for any locking. Consider, for example, a Lua function that "
"does three Tarantool operations:"
msgstr ""
"Поскольку все операции, связанные с изменением данных, заканчиваются неявной "
"передачей управления и неявным коммитом, и поскольку каждая такая операция "
"может затрагивать не более одного кортежа, то не возникает нужды в "
"блокировках. Для примера рассмотрим следующую Lua-функцию, которая "
"осуществляет три операции в Tarantool'е:"

#: ../book/box/index.rst:332
msgid ""
"s:select{999}             -- this does not yield and does not commit\n"
"s:update({...},{{...}})   -- this yields and commits\n"
"s:select{999}             -- this does not yield and does not commit"
msgstr ""
"s:select{999}             -- не происходит ни передачи управления, ни "
"коммита\n"
"s:update({...},{{...}})   -- происходит и передача управления, и коммит\n"
"s:select{999}             -- не происходит ни передачи управления, ни коммита"

#: ../book/box/index.rst:338
msgid ""
"The combination “SELECT plus UPDATE” is an atomic transaction: the function "
"holds a consistent view of the database until the UPDATE ends. For the "
"combination “UPDATE plus SELECT” the view is not consistent, because after "
"the UPDATE the transaction processor thread can switch to another fiber, and "
"delete the tuple that was just updated."
msgstr ""
"Последовательность операций “SELECT + UPDATE” является атомарной "
"транзакцией: функция сохраняет базу данных в согласованном виде, пока не "
"отработает UPDATE. А в случае “UPDATE + SELECT” согласованности нет, "
"поскольку после операции UPDATE поток обработки транзакций может "
"переключится на другой файбер и удалить тот кортеж, что был обновлен в "
"рамках предыдущей операции UPDATE."

#: ../book/box/index.rst:344
msgid ""
"Note re storage engine: vinyl handles yields differently, see :ref:"
"`differences between memtx and vinyl <vinyl_diff>`."
msgstr ""
"Примечание про движок: в движке vinyl передача управления происходит по-"
"другому, см. раздел про :ref:`различия между движками memtx и vinyl "
"<vinyl_diff>`."

#: ../book/box/index.rst:347
msgid "Note re multi-request transactions"
msgstr "Примечание про составные транзакции:"

#: ../doc/book/box/index.rst:334 ../book/box/index.rst:349
msgid ""
"There is a way to delay yields. Read about execution atomicity in section :"
"ref:`Transaction control <transaction_control>`."
msgstr ""

#: ../book/box/index.rst:352
msgid ""
"Since locks don't exist, and disk writes only involve the write-ahead log, "
"transactions are usually fast. Also the Tarantool server may not be using up "
"all the threads of a powerful multi-core processor, so advanced users may be "
"able to start a second Tarantool server on the same processor without ill "
"effects."
msgstr ""
"Посколько блокировки не используются, а запись на диск производится только "
"при работе с WAL-файлом, то транзакции в Tarantool'е обычно совершаются "
"быстро. Кроме того, если мы имеем дело с мощным многоядерным процессором, то "
"Tarantool-сервер может задействовать для работы не все потоки такого "
"процессора, и продвинутые пользователи могут безболезненно запускать второй "
"Tarantool-сервер на том же процессоре."

#: ../book/box/index.rst:357
msgid ""
"Additional examples of requests can be found in the Tarantool regression "
"test suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A "
"complete grammar of supported data-manipulation functions will come later in "
"this chapter."
msgstr ""
"См. также примеры с запросами в регрессионных тестах для Tarantool'а "
"(https://github.com/tarantool/tarantool/tree/1.7/test/box). Полное описание "
"грамматики поддерживаемых в Tarantool'е функций для манипулирования данными "
"см. далее в этой главе."

#: ../book/box/index.rst:361
msgid ""
"Since not all Tarantool operations can be expressed with the data-"
"manipulation functions, or with Lua, to gain complete access to data "
"manipulation functionality one must use a :ref:`Perl, PHP, Python or other "
"programming language connector <index-box_connectors>`. The client/server "
"protocol is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""
"Не все операции в Tarantool'е можно выразить с помощью функций по "
"манипулированию данными или с помощью языка Lua. Чтобы получить доступ ко "
"всем возможностями манипулирования данными, вам понадобится :ref:`коннектор "
"для Perl, PHP, Python или другого языка программирования <index-"
"box_connectors>`. Бинарный клиент-серверный протокол для коннекторов "
"является открытым. Документация по нему доступна в виде аннотированных :ref:"
"`BNF-диаграмм <box_protocol-iproto_protocol>`."

#: ../doc/book/box/index.rst:355 ../book/box/index.rst:370
msgid "Persistence"
msgstr ""

#: ../book/box/index.rst:372
msgid ""
"Tarantool maintains a set of write-ahead log (WAL) files. There is a "
"separate thread -- the WAL writer -- which catches all requests that can "
"change a database, such as ``box.schema.create`` or ``box.space.insert``. "
"Ordinarily the WAL writer writes the request, along with administrative "
"fields and flags, to a WAL file immediately. This ensures data persistence, "
"because, even if an in-memory database is lost when the power goes off, "
"Tarantool recovers it automatically when it starts up again, by reading the "
"WAL files and redoing the requests (this is called the \"recovery process"
"\"). Users can change the timing of the WAL writer, or turn it off, by "
"setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""
"Tarantool сохраняет данные и информацию об изменениях в нескольких WAL-"
"файлах (write-ahead log). Записью в WAL занимается отдельный поток. Он ловит "
"все запросы, которые могут привести к изменению данных в базе, например "
"``box.schema.create`` или ``box.space.insert``. Как правило, запись о "
"запросе, включая служебные поля и флаги, делается в WAL-файл немедленно. Это "
"обеспечивает сохранность данных, поскольку, даже если данные из памяти "
"утеряны вследствие перебоя в электроснабжении, Tarantool восстановит их "
"автоматически при следующем старте: он загрузит данные из WAL-файлов, а "
"затем применит все записанные в WAL-файлах запросы (это называется \"процесс "
"восстановления\"). Пользователи могут менять частоту записи или вовсе "
"отключать запись в WAL с помощью параметра :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`."

#: ../book/box/index.rst:383
msgid ""
"Tarantool also maintains a set of snapshot files. A snapshot file is an on-"
"disk copy of the entire data set for a given moment. Instead of reading "
"every WAL file since the databases were created, the recovery process can "
"load the latest snapshot and then read only the WAL files that were produced "
"after the snapshot was made. A snapshot can be made even if there is no WAL "
"file. Some snapshots are automatic, or users can make them at any time with "
"the :ref:`box.snapshot() <admin-snapshot>` request."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(snapshots). Файл со снимком — это дисковая копия всех данных в базе на "
"какой-то момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с "
"момента создания базы, Tarantool в процессе восстановления может загрузить "
"самый свежий снимок и затем зачитать только те WAL-файлы, которые были "
"сделаны с момента сохранения снимка. Снимки могут делаться автоматически, "
"или же пользователи могут создавать их сами в любой момент с помощью "
"запроса :ref:`box.snapshot() <admin-snapshot>`."

#: ../doc/book/box/index.rst:376
msgid ""
"Details about the WAL writer and the recovery process are in the :ref:"
"`Internals <internals>` section."
msgstr ""

#: ../book/box/index.rst:396
msgid "Data manipulation"
msgstr "Манипулирование данными"

#: ../book/box/index.rst:398
msgid ""
"The basic *data-manipulation* requests are: ``insert``, ``replace``, "
"``update``, ``upsert``, ``delete``, ``select``. All of them are part of the "
"``box`` library. Most of them may return data. Usually both inputs and "
"outputs are Lua tables."
msgstr ""
"Основные запросы для *манипулирования данными* — это ``insert``, "
"``replace``, ``update``, ``upsert``, ``delete``, ``select``. Все они "
"реализованы в библиотеке ``box``. Многие из этих запросов могут возвращать "
"данные. Как правило, и вводимые, и возвращаемые значения являются Lua-"
"таблицами."

#: ../book/box/index.rst:402
msgid ""
"The Lua syntax for data-manipulation functions can vary. Here are examples "
"of the variations with ``select`` requests; the same rules exist for the "
"other data-manipulation functions. Every one of the examples does the same "
"thing: select a tuple set from a space named 'tester' where the primary-key "
"field value equals 1. For the examples there is an assumption that the "
"numeric id of 'tester' is 512, which happens to be the case in our sandbox "
"example only."
msgstr ""
"Lua-синтаксис в данных функциях может различаться. Далее приводятся варианты "
"таких различий на примере SELECT-запросов. Аналогичные правила существуют и "
"для остальных функций. В каждом из приведенных примеров выполняются "
"следующие действия: производится выборка по набору кортежей из пространства "
"с именем 'tester', где значение поля, которое соответствует ключу в "
"первичном индексе, равно 1. Также во всех примерах мы подразумеваем, что "
"числовой идентификатор пространства 'tester' равен 512, но это верно только "
"для нашей тестовой базы."

#: ../book/box/index.rst:411
msgid "First, there are five *object reference variations*:"
msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#: ../book/box/index.rst:413
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 replace name with a numeric id in square brackets\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 use a variable instead of a literal for the name\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""
"-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 вместо имени объекта указываем числовой идентификатор в квадратных "
"скобках\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 вместо литерала, обозначающего имя объекта, указываем переменную\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 указываем переменную вместо ссылки на весь объект\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"

#: ../book/box/index.rst:428
msgid ""
"Later examples in this manual will usually have the \":samp:`box.space."
"{tester}:`\" form (#1); however, this is a matter of user preference and all "
"the variations exist in the wild."
msgstr ""
"Для примеров в остальной части документации мы будем, как правило, "
"использовать вариант синтаксиса #1, например \":samp:`box.space.{tester}:`"
"\". Но вы можете с тем же успехом пользоваться любым из пяти описанных выше "
"вариантов."

#: ../book/box/index.rst:432
msgid ""
"Later descriptions in this manual will use the syntax \"``space_object:``\" "
"for references to objects which are spaces as in the above examples, and "
"\"``index_object:``\" for references to objects which are indexes (for "
"example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""
"Также мы в дальнейшем будем использовать синтаксис типа  \":code:"
"`space_object:`\" для ссылки на пространства (как в приведенных выше "
"примерах) и \":code:`index_object:`\" для ссылки на индексы (например, :samp:"
"`box.space.{tester}.index.{primary}:`)."

#: ../book/box/index.rst:437
msgid "Then, there are seven *parameter variations*:"
msgstr "Во-вторых, есть семь *способов задания параметров*:"

#: ../book/box/index.rst:439
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"

#: ../book/box/index.rst:458
msgid ""
"The primary-key value is enclosed in braces, and if it was a multi-part "
"primary key then the value would be multi-part, for example ``..."
"select{1,2,3}``. The braces can be enclosed inside parentheses — ``..."
"select({...})`` — which are optional unless it is necessary to pass "
"something besides the primary-key value, as in example #5. Literal values "
"such as 1 (a scalar value) or {1} (a Lua table value) may be replaced by "
"variable names, as in examples #6 and #7. Although there are special cases "
"where braces can be omitted, they are preferable because they signal \"Lua "
"table\". Examples and descriptions in this manual have the \"{1}\" form; "
"however, this too is a matter of user preference and all the variations "
"exist in the wild."
msgstr ""
"Значение первичного ключа заключается в фигурные скобки. Если же этот "
"первичный ключ является составным, то и значение будет составным, например "
"``...select{1,2,3}``. Фигурные скобки в свою очередь могут заключаться в "
"круглые скобки — например, ``...select({...})``. Это опциональный вариант "
"синтаксиса, и он необходим только в том случае, если нужно передать что-то "
"помимо первичного ключа, как в примере #5. Вместо значений-литералов — "
"например, 1 (скалярное значение) или {1} (Lua-таблица) — можно использовать "
"имена переменных, как в примерах #6 и #7. Хотя в некоторых случаях фигурные "
"скобки можно опускать, мы рекомендуем всегда их использовать. Так вы явно "
"обозначите, что значение имеет тип \"Lua-таблица\". В примерах и описаниях в "
"документации мы везде используем фигурные скобки, например \"{1}\".  Но как "
"и в случае со ссылками на объект, вы можете пользоваться любым допустимым "
"вариантом синтаксиса."

#: ../book/box/index.rst:469
msgid ""
"All the data-manipulation functions operate on tuple sets but, since primary "
"keys are unique, the number of tuples in the tuple set is always 0 or 1. The "
"only exception is ``box.space...select``, which may accept either a primary-"
"key value or a secondary-key value."
msgstr ""
"Все функции для манипулирования данными оперируют наборами кортежей. Однако, "
"поскольку первичные ключи всегда уникальны, количество кортежей в таком "
"наборе всегда равно 0 или 1. Единственным исключением является функция ``box."
"space...select``, которая может брать на вход как первичный, так и вторичный "
"ключ."

#: ../doc/book/box/index.rst:462 ../book/box/index.rst:477
#, fuzzy
msgid "**Complexity factors that may affect data-manipulation functions**"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"**Факторы, которые могут влиять на быстродействие функций для "
"манипулирования данными из библиотеки box**"

#: ../book/box/index.rst:483
msgid "Index size"
msgstr "Размер индекса"

#: ../book/box/index.rst:483
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys then the lookup time will be "
"greater, although of course the effect is not linear. For a HASH index, if "
"there are more keys then there is more RAM use, but the number of low-level "
"steps tends to remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В "
"случае с TREE-индексом: с ростом количества ключей увеличивается время "
"поиска, хотя зависимость здесь, конечно же, не линейная. В случае с HASH-"
"индексом: с ростом количества ключей увеличивается объем используемой "
"памяти, но количество низкоуровневых шагов остается примерно тем же."

#: ../book/box/index.rst:491
msgid "Index type"
msgstr "Тип индекса"

#: ../book/box/index.rst:491
msgid ""
"Typically a HASH index is faster than a TREE index if the number of tuples "
"in the tuple set is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу, "
"если в наборе есть более одного кортежа."

#: ../book/box/index.rst:495
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../book/box/index.rst:495
msgid ""
"Ordinarily only one index is accessed to retrieve one tuple. But to update "
"the tuple, there must be N accesses if the tuple set has N different indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один индекс. "
"Но при обновлении значений в кортеже требуется N обращений, если у набора "
"кортежей есть N индексов."

#: ../book/box/index.rst:499
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../book/box/index.rst:499
msgid ""
"A few requests, for example select, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как "
"правило, это наименее важный фактор из всех."

#: ../book/box/index.rst:503
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../book/box/index.rst:503
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing "
"or delayed writing, this factor is unimportant. If the setting causes every "
"data-change request to wait for writing to finish on a slow device, this "
"factor is more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или "
"задана запись с задержкой, но этот фактор не так важен. Если же запись в WAL "
"производится при каждом запросе на изменение данных, то при каждом таком "
"запросе приходится ждать, пока отработает обращение к более медленному "
"диску, и данный фактор становится важнее всех остальных."

#: ../doc/book/box/index.rst:497 ../book/box/index.rst:512
#, fuzzy
msgid ""
"In the discussion of each data-manipulation function, there will be a note "
"about which complexity factors might affect the function's resource usage."
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Далее в описании каждой функции для манипулирования данными будет дано "
"примечание, какие из перечисленных выше факторов могут влиять на ее "
"быстродействие."

#: ../book/box/index.rst:517
msgid "Index operations"
msgstr "Операции с индексами"

#: ../book/box/index.rst:519
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple. Therefore "
"the user only needs to know how and why to define."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по "
"манипулированию данными меняет данные в кортеже, то меняются и ключи в "
"индексе для данного кортежа. Поэтому пользователю нужно знать только как и "
"зачем задавать индексы."

#: ../book/box/index.rst:523
msgid ""
"The simple index-creation operation which has been illustrated before is"
msgstr ""
"Простая операция для создания индекса, которую мы рассматривали ранее, имела "
"следующий вид:"

#: ../book/box/index.rst:528
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../book/box/index.rst:530
msgid ""
"By default, this creates a unique \"tree\" index on the first field of all "
"tuples (often called \"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю (обычно его "
"называют \"Field#1\") для всех кортежей в пространстве. Предполагается, что "
"индексируемое поле является числовым."

#: ../book/box/index.rst:533 ../book/box/index.rst:600
msgid "These variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../book/box/index.rst:535
msgid "An indexed field may be a string rather than a number."
msgstr "Индексируемое поле может быть строкой, а не числом."

#: ../book/box/index.rst:542
msgid ""
"For an ordinary index, the most common data types are 'unsigned' = any non-"
"negative integer, or 'string' = any series of bytes. Numbers are ordered "
"according to their point on the number line -- so 2345 is greater than 500 "
"-- while strings are ordered according to the encoding of the first byte "
"then the encoding of the second byte then the encoding of the third byte and "
"so on -- so '2345' is less than '500'."
msgstr ""
"Обычный индекс, как правило, строится по полям одного из двух типов: 'NUM' = "
"числовой (numeric) = любое неотрицательное целое число, либо 'STR' = строка "
"(string) = любая последовательность байтов. Числа в индексе упорядочены по "
"числовой прямой (например, число 2345 больше, чем число 500), а строки — по "
"коду первого байта, затем по коду второго, третьего и т.д. (и теперь строка "
"'2345' будет меньше, чем строка '500')."

#: ../book/box/index.rst:549
msgid ""
"For details about other index types see :ref:`create_index <box_space-"
"create_index>`."
msgstr ""
"Подробнее о других типах индексов см. в описании функции :ref:`create_index "
"<box_space-create_index>`."

#: ../book/box/index.rst:551
msgid "There may be more than one field."
msgstr "Индекс может строиться по нескольким полям."

#: ../book/box/index.rst:560
msgid ""
"For an ordinary index, the maximum number of parts is 255. The specification "
"of each part consists of a field number and a type."
msgstr ""
"В обычном индексе может быть максимум 255 частей. Каждая часть "
"характеризуется номером поля и его типом."

#: ../book/box/index.rst:563
msgid "The index does not have to be unique."
msgstr "Индекс может быть неуникальным."

#: ../book/box/index.rst:570
msgid ""
"The first index of a tuple set must be unique, but other indexes (\"secondary"
"\" indexes) may be non-unique."
msgstr ""
"Первичный индекс для кортежа должен строиться по уникальным значениям полей, "
"но остальные (вторичные) индексы могут строиться по неуникальным значениям."

#: ../book/box/index.rst:573
msgid "The index does not have to be a tree."
msgstr "Индекс может представлять собой не только дерево."

#: ../doc/book/box/index.rst:565 ../book/box/index.rst:580
msgid ""
"The two ordinary index types are 'tree' which is the default, and 'hash' "
"which must be unique and which may be faster. The third type is 'bitset' "
"which is not unique and which works best for combinations of binary values. "
"The fourth type is 'rtree' which is not unique and which works with arrays, "
"instead of 'string' or 'unsigned' values."
msgstr ""

#: ../book/box/index.rst:586
msgid ""
"The existence of indexes does not affect the syntax of data-change requests, "
"but does cause select requests to have more variety."
msgstr ""
"Наличие индексов никак не влияет на синтаксис запросов на изменение данных. "
"А вот SELECT-запросы, благодаря индексам, становятся более разнообразными."

#: ../book/box/index.rst:589
msgid "The simple select request which has been illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../book/box/index.rst:594
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../book/box/index.rst:596
msgid ""
"By default, this looks for a single tuple via the first index. Since the "
"first index is always unique, the maximum number of returned tuples will be: "
"one."
msgstr ""
"По умолчанию, такой запрос ищет нужный кортеж по значению в первом "
"(первичном) индексе. Поскольку первичный индекс всегда уникален, то данный "
"запрос вернет не более одного кортежа."

#: ../book/box/index.rst:602
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие условия "
"сравнения."

#: ../book/box/index.rst:609
msgid ""
"The comparison operators are LT, LE, EQ, REQ, GE, GT for \"less than\", "
"\"less than or equal\", \"equal\", \"reversed equal\", \"greater than or "
"equal\", \"greater than\" respectively. Comparisons make sense if and only "
"if the index type is 'tree'."
msgstr ""
"Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше "
"или равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). "
"Сравнения имеют смысл только для индексов типа 'tree'."

#: ../book/box/index.rst:614
msgid ""
"This type of search may return more than one tuple; if so, the tuples will "
"be in descending order by key when the comparison operator is LT or LE or "
"REQ, otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае "
"кортежи будут отсортированы в порядке убывания по ключу (если использовался "
"оператор LT, LE или REQ), либо в порядке возрастания (во всех остальных "
"случаях)."

#: ../book/box/index.rst:618
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../book/box/index.rst:625
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При поиске "
"же по вторичному индексу имя индекса указывать необходимо."

#: ../book/box/index.rst:628
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../book/box/index.rst:649
msgid "The search can be for all fields, using a table for the value:"
msgstr ""
"Поиск может производиться по всем полям (в этом случае используется таблица "
"значений):"

#: ../book/box/index.rst:656
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"Либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../book/box/index.rst:663
msgid ""
"in the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, "
"'B'}``. It's even possible to specify zero fields, causing all three tuples "
"to be returned."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, 'B'}``. "
"При необходимости можно задать даже нулевые поля, в результате чего "
"Tarantool вернет все три кортежа."

#: ../book/box/index.rst:669
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../book/box/index.rst:671
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../book/box/index.rst:682 ../book/box/index.rst:707
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../book/box/index.rst:684
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../book/box/index.rst:691
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../book/box/index.rst:693
msgid ""
"Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, "
"BITS_ALL_NOT_SET, EQ, or ALL."
msgstr ""
"При поиске по BITSET-индексам можно использовать операторы BITS_ANY_SET, "
"BITS_ALL_SET, BITS_ALL_NOT_SET, EQ и ALL."

#: ../book/box/index.rst:696
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../book/box/index.rst:698
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"

#: ../book/box/index.rst:709
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../book/box/index.rst:715
msgid ""
"because a rectangle whose corners are at coordinates 4,7,5,9 is entirely "
"within a rectangle whose corners are at coordinates 3,5,9,10."
msgstr ""
"поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком внутри "
"прямоугольника с углами в координатах 3,5,9,10."

#: ../book/box/index.rst:718
msgid ""
"Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
msgstr ""
"При поиске по RTREE-индексам можно использовать операторы GT, GE, LT, LE, "
"OVERLAPS и NEIGHBOR."

#: ../book/box/index.rst:724
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/book/box/atomic.rst:3 ../book/box/atomic.rst:3
msgid ""
"In several places in this manual, it's been noted that Lua processes occur "
"in fibers on a single thread. That is why there can be a guarantee of "
"execution atomicity. That requires emphasis."
msgstr ""

#: ../book/box/atomic.rst:11
msgid "Cooperative multitasking environment"
msgstr "Среда взаимной многозадачности"

#: ../doc/book/box/atomic.rst:13 ../book/box/atomic.rst:13
msgid ""
"Tarantool uses cooperative multitasking: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running fiber "
"will deliberately yield when it encounters a \"yield point\": an explicit "
"`yield()` request, or an implicit yield due to an operating-system call. Any "
"system call which can block will be performed asynchronously, and any "
"running fiber which must wait for a system call will be preempted so that "
"another ready-to-run fiber takes its place and becomes the new running "
"fiber. This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource, no "
"race conditions, and no memory consistency issues."
msgstr ""

#: ../doc/book/box/atomic.rst:24 ../book/box/atomic.rst:24
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the "
"request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../doc/book/box/atomic.rst:28 ../book/box/atomic.rst:28
msgid ""
"However, a function might perform complex computations or might be written "
"in such a way that yields do not occur for a long time. This can lead to "
"unfair scheduling, when a single client throttles the rest of the system, or "
"to apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function's author. For the default memtx storage "
"engine some of the box calls, including the data-change requests :ref:`box."
"space...insert <box_space-insert>` or :ref:`box.space...update <box_space-"
"update>` or :ref:`box.space...delete <box_space-delete>`, will usually cause "
"yielding; however, :ref:`box.space...select <box_space-select>` will not. A "
"fuller description will appear in section :ref:`Implicit yields <atomic-"
"the_implicit_yield_rules>`."
msgstr ""

#: ../doc/book/box/atomic.rst:41 ../book/box/atomic.rst:41
msgid ""
"Note re storage engine: vinyl has different rules: insert or update or "
"delete will very rarely cause a yield, but select can cause a yield."
msgstr ""

#: ../doc/book/box/atomic.rst:45 ../book/box/atomic.rst:45
msgid ""
"In the absence of transactions, any function that contains yield points may "
"see changes in the database state caused by fibers that preempt. Then the "
"only safe atomic functions for memtx databases would be functions which "
"contain only one database request, or functions which contain a select "
"request followed by a data-change request."
msgstr ""

#: ../doc/book/box/atomic.rst:51 ../book/box/atomic.rst:51
msgid ""
"At this point an objection could arise: \"It's good that a single data-"
"change request will commit and yield, but surely there are times when "
"multiple data-change requests must happen without yielding.\" The standard "
"example is the money-transfer, where $1 is withdrawn from account #1 and "
"deposited into account #2. If something interrupted after the withdrawal, "
"then the institution would be out of balance. For such cases, the "
"``begin ... commit|rollback`` block was designed."
msgstr ""

#: ../doc/book/box/atomic.rst:63 ../book/box/atomic.rst:63
msgid ""
"Begin the transaction. Disable implicit yields until the transaction ends. "
"Signal that writes to the write-ahead log will be deferred until the "
"transaction ends. In effect the fiber which executes ``box.begin()`` is "
"starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../doc/book/box/atomic.rst:72 ../book/box/atomic.rst:72
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/book/box/atomic.rst:79 ../book/box/atomic.rst:79
msgid ""
"End the transaction, but cancel all its data-change operations. An explicit "
"call to functions outside ``box.space`` that always yield, such as ``fiber."
"yield`` or ``fiber.sleep``, will have the same effect."
msgstr ""

#: ../doc/book/box/atomic.rst:83 ../book/box/atomic.rst:83
msgid ""
"The **requests in a transaction must be sent to the server as a single "
"block**. It is not enough to enclose them between ``begin`` and ``commit`` "
"or ``rollback``. To ensure they are sent as a single block: put them in a "
"function, or put them all on one line, or use a delimiter so that multi-line "
"requests are handled together."
msgstr ""

#: ../doc/book/box/atomic.rst:88 ../book/box/atomic.rst:88
msgid ""
"**All database operations in a transaction should use the same storage "
"engine**. It is not safe to access tuple sets that are defined with "
"``{engine='vinyl'}`` and also access tuple sets that are defined with "
"``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../doc/book/box/atomic.rst:97 ../book/box/atomic.rst:97
msgid ""
"Assuming that in tuple set 'tester' there are tuples in which the third "
"field represents a positive dollar amount ... Start a transaction, withdraw "
"from tuple#1, deposit in tuple#2, and end the transaction, making its "
"effects permanent."
msgstr ""

#: ../doc/book/box/atomic.rst:101 ../book/box/atomic.rst:101
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/book/box/atomic.rst:121 ../book/box/atomic.rst:121
#, fuzzy
msgid "Implicit yields"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Правила неявной передачи управления"

#: ../doc/book/box/atomic.rst:123 ../book/box/atomic.rst:123
msgid ""
"The only explicit yield requests are :ref:`fiber.sleep() <fiber-sleep>` and :"
"ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply\" yields "
"because Tarantool is designed to avoid blocking."
msgstr ""

#: ../doc/book/box/atomic.rst:127 ../book/box/atomic.rst:127
msgid ""
"The implicit yield requests are: :ref:`insert <box_space-insert>` :ref:"
"`replace <box_space-replace>` :ref:`update <box_space-update>` :ref:`upsert "
"<box_space-upsert>` :ref:`delete <box_space-delete>` (the \"data-change\" "
"requests), and functions in module :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>`, or :ref:`socket <socket-"
"module>` (the \"os\" and \"network\" requests)."
msgstr ""

#: ../doc/book/box/atomic.rst:134 ../book/box/atomic.rst:134
msgid ""
"Note re storage engine: vinyl causes :ref:`select <box_space-select>` to be "
"an implicit yield request, but data-change requests may not be."
msgstr ""

#: ../doc/book/box/atomic.rst:137 ../book/box/atomic.rst:137
msgid ""
"The yield occurs just before a blocking syscall, such as a write to the "
"Write-Ahead Log (WAL) or a network message reception."
msgstr ""

#: ../doc/book/box/atomic.rst:140 ../book/box/atomic.rst:140
msgid ""
"Implicit yield requests are disabled by :ref:`box.begin <atomic-box_begin>`, "
"and enabled again by :ref:`commit <atomic-box_commit>`. Therefore the "
"sequence"
msgstr ""

#: ../doc/book/box/atomic.rst:859 ../book/box/atomic.rst:874
msgid ""
"begin\n"
"implicit yield request #1\n"
"implicit yield request #2\n"
"implicit yield request #3\n"
"commit"
msgstr ""

#: ../doc/book/box/atomic.rst:152 ../book/box/atomic.rst:152
msgid ""
"will not cause implicit yield until the commit occurs (specifically: just "
"before the writes to the WAL, which are delayed until commit time). The "
"commit request is not itself an implicit yield request, it only enables "
"yields caused by earlier implicit yield requests."
msgstr ""

#: ../doc/book/box/atomic.rst:157
msgid ""
"Despite their resemblance to implicit yield requests, :ref:`truncate "
"<box_space-truncate>` and :ref:`drop <box_space-drop>` do not cause implicit "
"yield. Despite their resemblance to functions of the fio module, functions "
"of the standard Lua module `os <http://www.lua.org/manual/5.1/manual."
"html#5.8>`_ do not cause implicit yield. Despite its resemblance to commit, :"
"ref:`rollback <atomic-box_rollback>` does not enable yields."
msgstr ""

#: ../doc/book/box/atomic.rst:167 ../book/box/atomic.rst:164
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = 'none', then "
"implicit yielding is disabled, because there are no writes to the WAL."
msgstr ""

#: ../doc/book/box/atomic.rst:170 ../book/box/atomic.rst:167
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an implicit "
"yield, even if the request that is sent to the server is not itself an "
"implicit yield request. Therefore the sequence"
msgstr ""

#: ../doc/book/box/atomic.rst:891 ../book/box/atomic.rst:903
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../doc/book/box/atomic.rst:182 ../book/box/atomic.rst:179
msgid ""
"causes blocking if it is inside a function or Lua program being executed on "
"the server, but causes yielding if it is done as a series of transmissions "
"from a client, including a client which operates via telnet, via one of the "
"connectors, or via the MySQL and PostgreSQL rocks, or via the interactive "
"mode when :ref:`\"Using tarantool as a client\" <administration-"
"using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/book/box/atomic.rst:188 ../book/box/atomic.rst:185
msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../book/box/index.rst:730
msgid "Access control"
msgstr "Ограничение доступа"

#: ../doc/book/box/authentication.rst:3 ../book/box/authentication.rst:3
msgid ""
"Understanding the details of security is primarily an issue for "
"administrators, but ordinary users should at least skim this section so that "
"they will have an idea of how Tarantool makes it possible for administrators "
"to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../doc/book/box/authentication.rst:8 ../book/box/authentication.rst:8
msgid ""
"Briefly: there is a method to guarantee with password checks that users "
"really are who they say they are (\"authentication\"). There is a _user "
"space where user names and password-hashes are stored. There are functions "
"for saying that certain users are allowed to do certain things (\"privileges"
"\"). There is a _priv space where privileges are stored. Whenever a user "
"tries to do an operation, there is a check whether the user has the "
"privilege to do the operation (\"access control\")."
msgstr ""

#: ../doc/book/box/authentication.rst:18 ../book/box/authentication.rst:18
msgid "Passwords"
msgstr ""

#: ../doc/book/box/authentication.rst:20 ../book/box/authentication.rst:20
msgid ""
"Each user may have a password. The password is any alphanumeric string. "
"Administrators should advise users to choose long unobvious passwords, but "
"it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../doc/book/box/authentication.rst:24 ../book/box/authentication.rst:24
msgid ""
"Tarantool passwords are stored in the _user space with a `Cryptographic hash "
"function`_ so that, if the password is 'x', the stored hashed-password is a "
"long string like '``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client connects "
"to a Tarantool server, the server sends a random `Salt Value`_ which the "
"client must mix with the hashed-password before sending to the server. Thus "
"the original value 'x' is never stored anywhere except in the user's head, "
"and the hashed value is never passed down a network wire except when mixed "
"with a random salt. This system prevents malicious onlookers from finding "
"passwords by snooping in the log files or snooping on the wire. It is the "
"same system that `MySQL introduced several years ago`_ which has proved "
"adequate for medium-security installations. Nevertheless administrators "
"should warn users that no system is foolproof against determined long-term "
"attacks, so passwords should be guarded and changed occasionally."
msgstr ""

#: ../doc/book/box/authentication.rst:39 ../book/box/authentication.rst:39
msgid ""
"To get the hash-password of a string 'X', say ``box.schema.user."
"password('X')``. To see more about the details of the algorithm for the "
"purpose of writing a new client application, read the `scramble.h`_ header "
"file."
msgstr ""

#: ../doc/book/box/authentication.rst:53 ../book/box/authentication.rst:53
msgid "Users and the _user space"
msgstr ""

#: ../doc/book/box/authentication.rst:55 ../book/box/authentication.rst:55
msgid "The fields in the _user space are:"
msgstr ""

#: ../doc/book/box/authentication.rst:57 ../book/box/authentication.rst:57
msgid "the numeric id of the tuple"
msgstr ""

#: ../doc/book/box/authentication.rst:58 ../book/box/authentication.rst:58
msgid "the numeric id of the tuple's creator"
msgstr ""

#: ../doc/book/box/authentication.rst:59 ../book/box/authentication.rst:59
msgid "the user name"
msgstr ""

#: ../doc/book/box/authentication.rst:60 ../book/box/authentication.rst:60
msgid "the type"
msgstr ""

#: ../doc/book/box/authentication.rst:61 ../book/box/authentication.rst:61
msgid "optional password"
msgstr ""

#: ../doc/book/box/authentication.rst:63 ../book/box/authentication.rst:63
msgid ""
"There are four special tuples in the _user space: 'guest', 'admin', "
"'public', and 'replication'."
msgstr ""

#: ../doc/book/box/authentication.rst:73 ../book/box/authentication.rst:73
msgid "ID"
msgstr ""

#: ../doc/book/box/authentication.rst:75 ../book/box/authentication.rst:75
msgid "guest"
msgstr ""

#: ../doc/book/box/authentication.rst:75 ../book/box/authentication.rst:75
msgid "0"
msgstr ""

#: ../doc/book/box/authentication.rst:75 ../book/box/authentication.rst:75
msgid ""
"Default when connecting remotely. Usually an untrusted user with few "
"privileges."
msgstr ""

#: ../doc/book/box/authentication.rst:78 ../book/box/authentication.rst:78
msgid "admin"
msgstr ""

#: ../doc/book/box/authentication.rst:78 ../book/box/authentication.rst:78
msgid "1"
msgstr ""

#: ../doc/book/box/authentication.rst:78 ../book/box/authentication.rst:78
msgid ""
"Default when using ``tarantool`` as a console. Usually an administrative "
"user with all privileges."
msgstr ""

#: ../doc/book/box/authentication.rst:81 ../book/box/authentication.rst:81
msgid "public"
msgstr ""

#: ../doc/book/box/authentication.rst:81 ../book/box/authentication.rst:81
msgid "2"
msgstr ""

#: ../doc/book/box/authentication.rst:81 ../doc/book/box/authentication.rst:84
#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "role"
msgstr ""

#: ../doc/book/box/authentication.rst:81 ../doc/book/box/authentication.rst:84
#: ../book/box/authentication.rst:81 ../book/box/authentication.rst:84
msgid "Not a user in the usual sense. Described later in section `Roles`_."
msgstr ""

#: ../doc/book/box/authentication.rst:84 ../book/box/authentication.rst:84
msgid "replication"
msgstr ""

#: ../doc/book/box/authentication.rst:84 ../book/box/authentication.rst:84
msgid "3"
msgstr ""

#: ../doc/book/box/authentication.rst:89 ../book/box/authentication.rst:89
msgid ""
"To select a row from the _user space, use ``box.space._user:select``. For "
"example, here is what happens with a select for user id = 0, which is the "
"'guest' user, which by default has no password:"
msgstr ""

#: ../doc/book/box/authentication.rst:93 ../book/box/authentication.rst:93
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/book/box/authentication.rst:100 ../book/box/authentication.rst:100
msgid ""
"To change tuples in the _user space, do not use ordinary ``box.space`` "
"functions for insert or update or delete - the _user space is special so "
"there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/book/box/authentication.rst:104 ../book/box/authentication.rst:104
msgid "To create a new user, say:"
msgstr ""

#: ../doc/book/box/authentication.rst:1019 ../book/box/authentication.rst:1031
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})."
msgstr ""

#: ../doc/book/box/authentication.rst:113 ../book/box/authentication.rst:113
msgid ""
"The :samp:`password={password}` specification is good because in a :ref:`URI "
"<index-uri>` (Uniform Resource Identifier) it is usually illegal to include "
"a user-name without a password."
msgstr ""

#: ../doc/book/box/authentication.rst:116 ../book/box/authentication.rst:116
msgid "To change the user's password, say:"
msgstr ""

#: ../doc/book/box/authentication.rst:1031 ../book/box/authentication.rst:1043
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/book/box/authentication.rst:127 ../book/box/authentication.rst:127
msgid ""
"(Usually it is only the admin user who can change a different user's "
"password.)"
msgstr ""

#: ../doc/book/box/authentication.rst:129 ../book/box/authentication.rst:129
msgid "To drop a user, say:"
msgstr ""

#: ../doc/book/box/authentication.rst:1044 ../book/box/authentication.rst:1056
msgid "box.schema.user.drop(*user-name*)."
msgstr ""

#: ../doc/book/box/authentication.rst:136 ../book/box/authentication.rst:136
msgid "To check whether a user exists, say:"
msgstr ""

#: ../doc/book/box/authentication.rst:1051 ../book/box/authentication.rst:1063
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/book/box/authentication.rst:143 ../book/box/authentication.rst:143
msgid "which returns true or false."
msgstr ""

#: ../doc/book/box/authentication.rst:145 ../book/box/authentication.rst:145
msgid "To find what privileges a user has, say:"
msgstr ""

#: ../doc/book/box/authentication.rst:1060 ../book/box/authentication.rst:1072
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/book/box/authentication.rst:154 ../book/box/authentication.rst:154
msgid ""
"Here is a session which creates a new user with a strong password, selects a "
"tuple in the _user space, and then drops the user."
msgstr ""

#: ../doc/book/box/authentication.rst:157 ../book/box/authentication.rst:157
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$"
"$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O"
"+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/authentication.rst:172 ../book/box/authentication.rst:172
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/book/box/authentication.rst:178 ../book/box/authentication.rst:178
msgid "Privileges and the _priv space"
msgstr ""

#: ../doc/book/box/authentication.rst:180 ../book/box/authentication.rst:180
msgid "The fields in the _priv space are:"
msgstr ""

#: ../doc/book/box/authentication.rst:182 ../book/box/authentication.rst:182
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/book/box/authentication.rst:183 ../book/box/authentication.rst:183
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/book/box/authentication.rst:184 ../book/box/authentication.rst:184
msgid "the type of object - \"space\" or \"function\" or \"universe\","
msgstr ""

#: ../doc/book/box/authentication.rst:185 ../book/box/authentication.rst:185
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/book/box/authentication.rst:186 ../book/box/authentication.rst:186
msgid ""
"the type of operation - \"read\" = 1, or \"write\" = 2, or \"execute\" = 4, "
"or a combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/book/box/authentication.rst:189 ../book/box/authentication.rst:189
msgid "The function for granting a privilege is:"
msgstr ""

#: ../doc/book/box/authentication.rst:1104 ../book/box/authentication.rst:1116
msgid ""
"box.schema.user.grant(*grantee*, *operation*, *object-type*, *object-name*[, "
"*options*])\n"
"-- OR\n"
"box.schema.user.grant(*grantee*, *operation*, 'universe' [, nil, *options*])"
msgstr ""

#: ../doc/book/box/authentication.rst:198
#: ../doc/book/box/authentication.rst:211 ../book/box/authentication.rst:198
#: ../book/box/authentication.rst:211
msgid ""
"where 'universe' means 'all objects', and the optional grant-option can be:"
msgstr ""

#: ../doc/book/box/authentication.rst:200 ../book/box/authentication.rst:200
msgid ""
":samp:`grantor={grantor_name_or_id}` - string or number, for custom grantor"
msgstr ""

#: ../doc/book/box/authentication.rst:201 ../book/box/authentication.rst:201
msgid ""
":samp:`if_not_exists=true|false` - bool, do not throw error if user already "
"has the privilege"
msgstr ""

#: ../doc/book/box/authentication.rst:203 ../book/box/authentication.rst:203
msgid "The function for revoking a privilege is:"
msgstr ""

#: ../doc/book/box/authentication.rst:1118 ../book/box/authentication.rst:1130
msgid ""
"box.schema.user.revoke(*grantee*, *operation*, *object-type*, *object-"
"name*[, *options*])\n"
"box.schema.user.revoke(*grantee*, *operation*, 'universe'[, nil, *options*])"
msgstr ""

#: ../doc/book/box/authentication.rst:213 ../book/box/authentication.rst:213
msgid ""
":samp:`if_not_exists=true|false` - bool, do not throw error if user already "
"lacks the privilege"
msgstr ""

#: ../doc/book/box/authentication.rst:215 ../book/box/authentication.rst:215
msgid ""
"For example, here is a session where the admin user gave the guest user the "
"privilege to read from a space named ``space55``, and then took the "
"privilege away:"
msgstr ""

#: ../doc/book/box/authentication.rst:218 ../book/box/authentication.rst:218
msgid ""
"tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'read', 'space', 'space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/authentication.rst:229 ../book/box/authentication.rst:229
msgid ""
"Generally privileges are granted or revoked by the owner of the object (the "
"user who created it), or by the 'admin' user. Before dropping any objects or "
"users, steps should be taken to ensure that all their associated privileges "
"have been revoked."
msgstr ""

#: ../doc/book/box/authentication.rst:236 ../book/box/authentication.rst:236
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../doc/book/box/authentication.rst:240 ../book/box/authentication.rst:240
msgid ""
"Only the creator of a space can drop, alter, or truncate the space. Only the "
"creator of a user can change a different user's password."
msgstr ""

#: ../doc/book/box/authentication.rst:247 ../book/box/authentication.rst:247
msgid "Functions and the _func space"
msgstr ""

#: ../doc/book/box/authentication.rst:249 ../book/box/authentication.rst:249
msgid "The fields in the _func space are:"
msgstr ""

#: ../doc/book/box/authentication.rst:251 ../book/box/authentication.rst:251
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/book/box/authentication.rst:252 ../book/box/authentication.rst:252
msgid "the function name"
msgstr ""

#: ../doc/book/box/authentication.rst:253 ../book/box/authentication.rst:253
msgid "flag"
msgstr ""

#: ../doc/book/box/authentication.rst:254 ../book/box/authentication.rst:254
msgid "possibly a language name."
msgstr ""

#: ../doc/book/box/authentication.rst:256 ../book/box/authentication.rst:256
msgid ""
"The _func space does not include the function's body. One continues to "
"create Lua functions in the usual way, by saying \":samp:`function "
"{function_name} () ... end`\", without adding anything in the _func space. "
"The _func space only exists for storing function tuples so that their names "
"can be used within grant/revoke functions."
msgstr ""

#: ../doc/book/box/authentication.rst:262 ../book/box/authentication.rst:262
msgid "The function for creating a _func tuple is:"
msgstr ""

#: ../doc/book/box/authentication.rst:1177 ../book/box/authentication.rst:1189
msgid "box.schema.func.create(*function-name* [, *options*])"
msgstr ""

#: ../doc/book/box/authentication.rst:269 ../book/box/authentication.rst:269
msgid "The possible options are:"
msgstr ""

#: ../doc/book/box/authentication.rst:271 ../book/box/authentication.rst:271
msgid ":samp:`if_not_exists = {true|false}` - default = false,"
msgstr ""

#: ../doc/book/box/authentication.rst:272 ../book/box/authentication.rst:272
msgid ":samp:`setuid = {true|false}` - default = false,"
msgstr ""

#: ../doc/book/box/authentication.rst:273 ../book/box/authentication.rst:273
msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
msgstr ""

#: ../doc/book/box/authentication.rst:277 ../book/box/authentication.rst:277
msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
msgstr ""

#: ../doc/book/box/authentication.rst:281 ../book/box/authentication.rst:281
msgid ""
"Specifying :code:`if_not_exists=false` would cause ``error: Function '...' "
"already exists`` if the _func tuple already exists."
msgstr ""

#: ../doc/book/box/authentication.rst:284 ../book/box/authentication.rst:284
msgid ""
"Specifying :code:`setuid=true` would cause the setuid flag (the fourth field "
"in the _func tuple) to have a value meaning \"true\", and the effect of that "
"is that the function's caller is treated as the function's creator, with "
"full privileges. The setuid behavior does not apply for users who connect "
"via :code:`console.connect`."
msgstr ""

#: ../doc/book/box/authentication.rst:289 ../book/box/authentication.rst:289
msgid ""
"Specifying :code:`language='C'` would cause the language field (the fifth "
"field in the _func tuple) to have a value 'C', which means the function was "
"written in C. Tarantool functions are normally written in Lua but can be "
"written in C as well."
msgstr ""

#: ../doc/book/box/authentication.rst:293 ../book/box/authentication.rst:293
msgid "The function for dropping a _func tuple is:"
msgstr ""

#: ../doc/book/box/authentication.rst:1208 ../book/box/authentication.rst:1220
msgid "box.schema.func.drop(*function-name*)"
msgstr ""

#: ../doc/book/box/authentication.rst:300 ../book/box/authentication.rst:300
msgid "The function for checking whether a _func tuple exists is:"
msgstr ""

#: ../doc/book/box/authentication.rst:1215 ../book/box/authentication.rst:1227
msgid "box.schema.func.exists(*function-name*)"
msgstr ""

#: ../doc/book/box/authentication.rst:307 ../book/box/authentication.rst:307
msgid ""
"In the following example, a function named 'f7' is created, then it is put "
"in the _func space, then it is used in a ``box.schema.user.grant`` function, "
"then it is dropped:"
msgstr ""

#: ../doc/book/box/authentication.rst:311 ../book/box/authentication.rst:311
msgid ""
"tarantool> function f7()\n"
"         >   box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.func.drop('f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/authentication.rst:333 ../book/box/authentication.rst:333
msgid "box.session and security"
msgstr ""

#: ../doc/book/box/authentication.rst:335 ../book/box/authentication.rst:335
msgid ""
"After a connection has taken place, the user has access to a \"session\" "
"object which has several functions. The ones which are of interest for "
"security purposes are:"
msgstr ""

#: ../doc/book/box/authentication.rst:1252 ../book/box/authentication.rst:1264
msgid ""
"box.session.uid()         -- returns the id of the current user\n"
"box.session.user()        -- returns the name of the current user\n"
"box.session.su(*user-name*) -- allows changing current user to 'user-name'"
msgstr ""

#: ../doc/book/box/authentication.rst:346 ../book/box/authentication.rst:346
msgid ""
"If a user types requests directly on the Tarantool server in its :ref:"
"`interactive mode <administration-using_tarantool_as_a_client>`, or if a "
"user connects to the :ref:`admin port <administration-admin_ports>`, then "
"the user by default is 'admin' and has many privileges. If a user connects "
"from an application program via one of the :ref:`connectors <index-"
"box_connectors>`, then the user by default is 'guest' and has few "
"privileges. Typically an admin user will set up and configure objects, then "
"grant privileges to appropriate non-admin users. Typically a guest user will "
"use ``box.session.su()`` to change into a non-generic user to whom admin has "
"granted more than the default privileges. For example, admin might say:"
msgstr ""

#: ../doc/book/box/authentication.rst:359 ../book/box/authentication.rst:359
msgid ""
"box.space._user:insert{123456,0,'manager','user'}\n"
"box.schema.user.grant('manager', 'read', 'space', '_space')\n"
"box.schema.user.grant('manager', 'read', 'space', 'payroll')"
msgstr ""

#: ../doc/book/box/authentication.rst:365 ../book/box/authentication.rst:365
msgid "and later a guest user, who wishes to see the payroll, might say:"
msgstr ""

#: ../doc/book/box/authentication.rst:367 ../book/box/authentication.rst:367
msgid ""
"box.session.su('manager')\n"
"box.space.payroll:select{'Jones'}"
msgstr ""

#: ../doc/book/box/authentication.rst:376 ../book/box/authentication.rst:376
msgid "Roles"
msgstr ""

#: ../doc/book/box/authentication.rst:378 ../book/box/authentication.rst:378
msgid ""
"A role is a container for privileges which can be granted to regular users. "
"Instead of granting and revoking individual privileges, one can put all the "
"privileges in a role and then grant or revoke the role. Role information is "
"in the _user space but the third field - the type field - is 'role' rather "
"than 'user'."
msgstr ""

#: ../doc/book/box/authentication.rst:386 ../book/box/authentication.rst:386
msgid ""
"If a role R1 is granted a privilege X, and user U1 is granted a privilege "
"\"role R1\", then user U1 in effect has privilege X. Then if a role R2 is "
"granted a privilege Y, and role R1 is granted a privilege \"role R2\", then "
"user U1 in effect has both privilege X and privilege Y. In other words, a "
"user gets all the privileges that are granted to a user's roles, directly or "
"indirectly."
msgstr ""

#: ../doc/book/box/authentication.rst:397 ../book/box/authentication.rst:397
msgid "Create a new role."
msgstr ""

#: ../doc/book/box/authentication.rst:401 ../book/box/authentication.rst:401
msgid "Put a privilege in a role."
msgstr ""

#: ../doc/book/box/authentication.rst:405 ../book/box/authentication.rst:405
msgid "Take a privilege out of a role."
msgstr ""

#: ../doc/book/box/authentication.rst:409 ../book/box/authentication.rst:409
msgid "Drop a role."
msgstr ""

#: ../doc/book/box/authentication.rst:413 ../book/box/authentication.rst:413
msgid "Grant a role to a role."
msgstr ""

#: ../doc/book/box/authentication.rst:417 ../book/box/authentication.rst:417
msgid "Revoke a role from a role."
msgstr ""

#: ../doc/book/box/authentication.rst:421 ../book/box/authentication.rst:421
msgid ""
"Check whether a role exists. Returns (type = boolean) true if role-name "
"identifies a role, otherwise false."
msgstr ""

#: ../doc/book/box/authentication.rst:428 ../book/box/authentication.rst:428
msgid "Grant a role to a user."
msgstr ""

#: ../doc/book/box/authentication.rst:432 ../book/box/authentication.rst:432
msgid "Revoke a role from a user."
msgstr ""

#: ../doc/book/box/authentication.rst:434 ../book/box/authentication.rst:434
msgid ""
"There are two predefined roles. The first predefined role, named 'public', "
"is automatically assigned to new users when they are created with :samp:`box."
"schema.user.create({user-name})` - Therefore a convenient way to grant "
"'read' on space 't' to every user that will ever exist is: :code:`box.schema."
"role.grant('public','read','space','t')`. The second predefined role, named "
"'replication', can be assigned by the 'admin' user to users who need to use "
"replication features."
msgstr ""

#: ../doc/book/box/authentication.rst:444 ../book/box/authentication.rst:444
msgid "Example showing a role within a role"
msgstr ""

#: ../doc/book/box/authentication.rst:446 ../book/box/authentication.rst:446
msgid ""
"In this example, a new user named U1 will insert a new tuple into a new "
"space named T, and will succeed even though user U1 has no direct privilege "
"to do such an insert -- that privilege is inherited from role R1, which in "
"turn inherits from role R2."
msgstr ""

#: ../doc/book/box/authentication.rst:451 ../book/box/authentication.rst:451
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create a user U1 so that later it's possible to say box.session.su('U1')\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read and execute privileges to R2 (but not to R1 and not to U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"box.schema.role.grant('R2', 'execute', 'universe')\n"
"-- Use box.session.su to say \"now become user U1\"\n"
"box.session.su('U1')\n"
"-- Next insert succeeds because U1 in effect has write privilege on T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../book/box/index.rst:736
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/book/box/triggers.rst:4 ../book/box/triggers.rst:4
msgid ""
"*Triggers*, also known as *callbacks*, are functions which the server "
"executes when certain events happen. Currently the main types of triggers "
"are :ref:`connection triggers <triggers-connection_triggers>`, which are "
"executed when a session begins or ends, and :ref:`replace triggers <triggers-"
"replace_triggers>`, which are for database events."
msgstr ""

#: ../doc/book/box/triggers.rst:11 ../book/box/triggers.rst:11
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/book/box/triggers.rst:13 ../book/box/triggers.rst:13
msgid ""
"They associate a `function` with an `event`. The request to \"define a "
"trigger\" consists of passing the name of the trigger's function to one of "
"the \":samp:`on_{event-name}()`\" functions: :code:`on_connect()`, :code:"
"`on_auth()`, :code:`on_disconnect()`, or :code:`on_replace()`."
msgstr ""

#: ../doc/book/box/triggers.rst:17 ../book/box/triggers.rst:17
msgid ""
"They are `defined by any user`. There are no privilege requirements for "
"defining triggers."
msgstr ""

#: ../doc/book/box/triggers.rst:19 ../book/box/triggers.rst:19
msgid ""
"They are called `after` the event. They are not called if the event ends "
"prematurely due to an error. (Exception: :code:`on_auth()` is called before "
"the event.)"
msgstr ""

#: ../doc/book/box/triggers.rst:21 ../book/box/triggers.rst:21
msgid ""
"They are in `server memory`. They are not stored in the database. Triggers "
"disappear when the server is shut down. If there is a requirement to make "
"them permanent, then the function definitions and trigger settings should be "
"part of an initialization script."
msgstr ""

#: ../doc/book/box/triggers.rst:25 ../book/box/triggers.rst:25
msgid ""
"They have `low overhead`. If a trigger is not defined, then the overhead is "
"minimal: merely a pointer dereference and check. If a trigger is defined, "
"then its overhead is equivalent to the overhead of calling a stored "
"procedure."
msgstr ""

#: ../doc/book/box/triggers.rst:28 ../book/box/triggers.rst:28
msgid ""
"They can be `multiple` for one event. Triggers are executed in the reverse "
"order that they were defined in."
msgstr ""

#: ../doc/book/box/triggers.rst:30 ../book/box/triggers.rst:30
msgid ""
"They must work `within the event context`. If the function contains requests "
"which normally could not occur immediately after the event but before the "
"return from the event, effects are undefined. For example, putting ``os."
"exit()`` or ``box.rollback()`` in a trigger function would be bringing in "
"requests outside the event context."
msgstr ""

#: ../doc/book/box/triggers.rst:35 ../book/box/triggers.rst:35
msgid ""
"They are `replaceable`. The request to \"redefine a trigger\" consists of "
"passing the names of a new trigger function and an old trigger function to "
"one of the \"on `event-name` ...\" functions."
msgstr ""

#: ../doc/book/box/triggers.rst:43 ../book/box/triggers.rst:43
msgid "Connection triggers"
msgstr ""

#: ../doc/book/box/triggers.rst:47 ../book/box/triggers.rst:47
msgid ""
"Define a trigger for execution when a new session is created due to an event "
"such as :ref:`console.connect <console-connect>`. The trigger function will "
"be the first thing executed after a new session is created. If the trigger "
"fails by raising an error, the error is sent to the client and the "
"connection is closed."
msgstr ""

#: ../doc/book/box/triggers.rst:52 ../doc/book/box/triggers.rst:79
#: ../doc/book/box/triggers.rst:151 ../doc/book/box/triggers.rst:182
#: ../book/box/triggers.rst:52 ../book/box/triggers.rst:79
#: ../book/box/triggers.rst:151 ../book/box/triggers.rst:182
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/book/box/triggers.rst:53 ../doc/book/box/triggers.rst:80
#: ../doc/book/box/triggers.rst:152 ../doc/book/box/triggers.rst:183
#: ../book/box/triggers.rst:53 ../book/box/triggers.rst:80
#: ../book/box/triggers.rst:152 ../book/box/triggers.rst:183
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/book/box/triggers.rst:54 ../doc/book/box/triggers.rst:81
#: ../doc/book/box/triggers.rst:184 ../book/box/triggers.rst:54
#: ../book/box/triggers.rst:81 ../book/box/triggers.rst:184
msgid "nil or function list"
msgstr ""

#: ../doc/book/box/triggers.rst:56 ../doc/book/box/triggers.rst:83
#: ../doc/book/box/triggers.rst:155 ../doc/book/box/triggers.rst:186
#: ../book/box/triggers.rst:56 ../book/box/triggers.rst:83
#: ../book/box/triggers.rst:155 ../book/box/triggers.rst:186
msgid ""
"If the parameters are (nil, old-trigger-function-name), then the old trigger "
"is deleted."
msgstr ""

#: ../doc/book/box/triggers.rst:60 ../book/box/triggers.rst:60
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/book/box/triggers.rst:69 ../book/box/triggers.rst:69
msgid ""
"If a trigger always results in an error, it may become impossible to connect "
"to the server to reset it."
msgstr ""

#: ../doc/book/box/triggers.rst:74 ../book/box/triggers.rst:74
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the client "
"still exists and can access session properties, such as box.session.id."
msgstr ""

#: ../doc/book/box/triggers.rst:87 ../book/box/triggers.rst:87
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/book/box/triggers.rst:98 ../book/box/triggers.rst:98
msgid ""
"After the following series of requests, the server will write a message "
"using the :ref:`log <log>` module whenever any user connects or disconnects."
msgstr ""

#: ../doc/book/box/triggers.rst:101 ../book/box/triggers.rst:101
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/book/box/triggers.rst:116 ../book/box/triggers.rst:116
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/book/box/triggers.rst:118 ../book/box/triggers.rst:118
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/book/box/triggers.rst:129 ../book/box/triggers.rst:129
msgid "Authentication triggers"
msgstr ""

#: ../doc/book/box/triggers.rst:133 ../book/box/triggers.rst:133
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../doc/book/box/triggers.rst:135 ../book/box/triggers.rst:135
msgid ""
"The on_auth trigger function is invoked in these circumstances: (1) The :ref:"
"`console.connect <console-connect>` function includes an authentication "
"check for all users except 'guest'; for this case the on_auth trigger "
"function is invoked after the on_connect trigger function, if and only if "
"the connection has succeeded so far. (2) The binary protocol has a separate :"
"ref:`authentication packet <box_protocol-authentication>` -- for this case, "
"connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/book/box/triggers.rst:142 ../book/box/triggers.rst:142
msgid ""
"Unlike other trigger types, on_auth trigger functions are invoked `before` "
"the event. Therefore a trigger function like :code:`function auth_function "
"() v = box.session.user(); end` will set :code:`v` to \"guest\", the user "
"name before the authentication is done. To get the user name after the "
"authentication is done, use the special syntax: :code:`function "
"auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/book/box/triggers.rst:148 ../book/box/triggers.rst:148
msgid ""
"If the trigger fails by raising an error, the error is sent to the client "
"and the connection is closed."
msgstr ""

#: ../doc/book/box/triggers.rst:159 ../book/box/triggers.rst:159
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/book/box/triggers.rst:170 ../book/box/triggers.rst:170
msgid "Replace triggers"
msgstr ""

#: ../doc/book/box/triggers.rst:178 ../book/box/triggers.rst:178
msgid ""
"Create a \"``replace trigger``\". The ``function-name`` will be executed "
"whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or "
"``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/book/box/triggers.rst:190 ../book/box/triggers.rst:190
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/book/box/triggers.rst:199 ../book/box/triggers.rst:199
msgid ""
"At the time that a trigger is defined, it is automatically enabled - that "
"is, it will be executed. Replace triggers can be disabled with :samp:`box."
"space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space."
"{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/book/box/triggers.rst:208 ../book/box/triggers.rst:208
msgid "tarantool> box.space.X:run_triggers(false)"
msgstr ""

#: ../doc/book/box/triggers.rst:216 ../book/box/triggers.rst:216
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, because "
"the function is executed once after each insert."
msgstr ""

#: ../doc/book/box/triggers.rst:221 ../book/box/triggers.rst:221
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/book/box/triggers.rst:237 ../book/box/triggers.rst:237
#, fuzzy
msgid "Another example"
msgstr ""
"#-#-#-#-#  doc.po (Tarantool 1.7)  #-#-#-#-#\n"
"#-#-#-#-#  book.po (Tarantool 1.7)  #-#-#-#-#\n"
"Например:"

#: ../doc/book/box/triggers.rst:239 ../book/box/triggers.rst:239
msgid ""
"The following series of requests will associate an existing function named F "
"with an existing space named T, associate the function a second time with "
"the same space (so it will be called twice), disable all triggers of T, and "
"delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/book/box/triggers.rst:244 ../book/box/triggers.rst:244
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/book/box/triggers.rst:256 ../book/box/triggers.rst:256
msgid "Getting a list of triggers"
msgstr ""

#: ../doc/book/box/triggers.rst:258 ../book/box/triggers.rst:258
msgid "You can use:"
msgstr ""

#: ../doc/book/box/triggers.rst:260 ../book/box/triggers.rst:260
msgid ""
":code:`on_connect()` -- with no arguments -- to return a table of all "
"connect-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:262 ../book/box/triggers.rst:262
msgid ":code:`on_auth()` to return all authentication-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:263 ../book/box/triggers.rst:263
msgid ":code:`on_disconnect()` to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/book/box/triggers.rst:264 ../book/box/triggers.rst:264
msgid ":code:`on_replace()` to return all replace-trigger functions."
msgstr ""

#: ../doc/book/box/triggers.rst:266 ../book/box/triggers.rst:266
msgid ""
"In the following example, we find that there are three functions associated "
"with :code:`on_connect` triggers, and execute the third function, which "
"happens to contain the line \"print('function #3')\". Then we delete the "
"third trigger."
msgstr ""

#: ../doc/book/box/triggers.rst:272 ../book/box/triggers.rst:272
msgid ""
"tarantool> box.session.on_connect()\n"
"---\n"
"- - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ad800'\n"
"...\n"
"\n"
"tarantool> box.session.on_connect()[3]()\n"
"function #3\n"
"---\n"
"...\n"
"tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
"---\n"
"..."
msgstr ""

#: ../doc/book/box/limitations.rst:3 ../doc/book/box/limitations.rst:31
#: ../book/box/limitations.rst:3 ../book/box/limitations.rst:28
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/book/box/limitations.rst:5 ../doc/book/box/limitations.rst:33
#: ../book/box/limitations.rst:5 ../book/box/limitations.rst:30
msgid ""
"For TREE or HASH indexes, the maximum is 255 (``box.schema."
"INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but the field is an "
"ARRAY. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../doc/book/box/limitations.rst:11 ../doc/book/box/limitations.rst:39
#: ../book/box/limitations.rst:11 ../book/box/limitations.rst:36
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/book/box/limitations.rst:13 ../doc/book/box/limitations.rst:41
#: ../book/box/limitations.rst:13 ../book/box/limitations.rst:38
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:17 ../doc/book/box/limitations.rst:45
#: ../book/box/limitations.rst:17 ../book/box/limitations.rst:42
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/book/box/limitations.rst:19 ../doc/book/box/limitations.rst:47
#: ../book/box/limitations.rst:19 ../book/box/limitations.rst:44
msgid ""
"The theoretical maximum is 2147483647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's :ref:`field_count "
"<box_space-field_count>` member, or the maximum tuple length."
msgstr ""

#: ../doc/book/box/limitations.rst:26 ../doc/book/box/limitations.rst:54
#: ../book/box/limitations.rst:26 ../book/box/limitations.rst:51
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/book/box/limitations.rst:28 ../doc/book/box/limitations.rst:56
#: ../book/box/limitations.rst:28 ../book/box/limitations.rst:53
msgid ""
"By default the value of :ref:`slab_alloc_maximal <cfg_storage-"
"slab_alloc_maximal>` is 1048576, and the maximum tuple length is "
"approximately one quarter of that: approximately 262,000 bytes. To increase "
"it, when starting the server, specify a larger value. For example :code:`box."
"cfg{slab_alloc_maximal=2*1048576}`."
msgstr ""

#: ../doc/book/box/limitations.rst:36 ../doc/book/box/limitations.rst:64
#: ../book/box/limitations.rst:36 ../book/box/limitations.rst:61
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/book/box/limitations.rst:38 ../doc/book/box/limitations.rst:66
#: ../book/box/limitations.rst:38 ../book/box/limitations.rst:63
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can "
"contain a million bytes, so the maximum is determined by factors such as :"
"ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the "
"index support."
msgstr ""

#: ../doc/book/box/limitations.rst:45 ../doc/book/box/limitations.rst:73
#: ../book/box/limitations.rst:45 ../book/box/limitations.rst:70
msgid "**Number of spaces**"
msgstr ""

#: ../doc/book/box/limitations.rst:47 ../doc/book/box/limitations.rst:75
#: ../book/box/limitations.rst:47 ../book/box/limitations.rst:72
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:51 ../doc/book/box/limitations.rst:79
#: ../book/box/limitations.rst:51 ../book/box/limitations.rst:76
msgid "**Number of connections**"
msgstr ""

#: ../doc/book/box/limitations.rst:53 ../doc/book/box/limitations.rst:81
#: ../book/box/limitations.rst:53 ../book/box/limitations.rst:78
msgid ""
"The practical limit is the number of file descriptors that one can set with "
"the operating system."
msgstr ""

#: ../doc/book/box/limitations.rst:58 ../doc/book/box/limitations.rst:86
#: ../book/box/limitations.rst:58 ../book/box/limitations.rst:83
msgid "**Space size**"
msgstr ""

#: ../doc/book/box/limitations.rst:60 ../doc/book/box/limitations.rst:88
#: ../book/box/limitations.rst:60 ../book/box/limitations.rst:85
msgid ""
"The total maximum size for all spaces is in effect set by :ref:"
"`slab_alloc_arena <cfg_storage-slab_alloc_arena>`, which in turn is limited "
"by the total available memory."
msgstr ""

#: ../doc/book/box/limitations.rst:66 ../doc/book/box/limitations.rst:94
#: ../book/box/limitations.rst:66 ../book/box/limitations.rst:91
msgid "**Update operations count**"
msgstr ""

#: ../doc/book/box/limitations.rst:68 ../doc/book/box/limitations.rst:96
#: ../book/box/limitations.rst:68 ../book/box/limitations.rst:93
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:73 ../doc/book/box/limitations.rst:101
#: ../book/box/limitations.rst:73 ../book/box/limitations.rst:98
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/book/box/limitations.rst:75 ../doc/book/box/limitations.rst:103
#: ../book/box/limitations.rst:75 ../book/box/limitations.rst:100
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../doc/book/box/limitations.rst:79 ../doc/book/box/limitations.rst:107
#: ../book/box/limitations.rst:79 ../book/box/limitations.rst:104
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/book/box/limitations.rst:81 ../doc/book/box/limitations.rst:109
#: ../book/box/limitations.rst:81 ../book/box/limitations.rst:106
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:85 ../doc/book/box/limitations.rst:113
#: ../book/box/limitations.rst:85 ../book/box/limitations.rst:110
msgid "**Number of replicas in a cluster**"
msgstr ""

#: ../doc/book/box/limitations.rst:87 ../doc/book/box/limitations.rst:115
#: ../book/box/limitations.rst:87 ../book/box/limitations.rst:112
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../doc/book/box/limitations.rst:91 ../doc/book/box/limitations.rst:119
#: ../book/box/limitations.rst:91 ../book/box/limitations.rst:116
msgid ""
"For additional limitations which apply only to the vinyl storage engine, see "
"section :ref:`Differences between memtx and vinyl <vinyl_diff>`."
msgstr ""

#: ../book/box/index.rst:750
msgid "Vinyl storage engine"
msgstr "Дисковый движок vinyl"

#: ../doc/book/box/vinyl.rst:3 ../book/box/vinyl.rst:3
msgid ""
"A storage engine is a set of very-low-level routines which actually store "
"and retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../doc/book/box/vinyl.rst:6 ../book/box/vinyl.rst:6
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to "
"arrive."
msgstr ""

#: ../doc/book/box/vinyl.rst:9 ../book/box/vinyl.rst:9
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will "
"especially appeal to users who like to see data go directly to disk, so that "
"recovery time might be shorter and database size might be larger. On the "
"other hand, vinyl lacks some functions and options that are available with "
"memtx. Where that is the case, the relevant description in this manual will "
"contain a note beginning with the words \"Note re storage engine\". See also "
"a coverage for all :ref:`the differences between memtx and vinyl "
"<vinyl_diff>` further on this page."
msgstr ""

#: ../doc/book/box/vinyl.rst:18 ../book/box/vinyl.rst:18
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = "
"'vinyl'`` when creating a space, for example: ``space = box.schema.space."
"create('name', {engine='vinyl'})``."
msgstr ""

#: ../book/box/vinyl.rst:26
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../doc/book/box/vinyl.rst:28 ../book/box/vinyl.rst:28
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-"
"memory\" engine while vinyl is an \"on-disk\" engine. An in-memory storage "
"engine is generally faster, and the memtx engine is justifiably the default "
"for Tarantool, but there are two situations where an on-disk engine such as "
"vinyl would be preferable:"
msgstr ""

#: ../doc/book/box/vinyl.rst:34 ../book/box/vinyl.rst:34
msgid ""
"when the database is larger than the available memory and adding more memory "
"is not a realistic option;"
msgstr ""

#: ../doc/book/box/vinyl.rst:36 ../book/box/vinyl.rst:36
msgid ""
"when the server frequently goes down due to errors or a simple desire to "
"save power -- bringing the server back up and restoring a memtx database "
"into memory takes time."
msgstr ""

#: ../doc/book/box/vinyl.rst:40 ../book/box/vinyl.rst:40
msgid ""
"Here are behavior differences which affect programmers. All of these "
"differences have been noted elsewhere in sentences that begin with the words "
"\"Note re storage engine: vinyl\"."
msgstr ""

#: ../doc/book/box/vinyl.rst:44 ../book/box/vinyl.rst:44
msgid ""
"With memtx, the index type can be TREE or HASH or RTREE or BITSET. |br| With "
"vinyl, the only index type is TREE."
msgstr ""

#: ../doc/book/box/vinyl.rst:47 ../book/box/vinyl.rst:47
msgid ""
"With memtx, :ref:`create_index <box_space-create_index>` can be done at any "
"time. |br| With vinyl, secondary indexes must be created before tuples are "
"inserted."
msgstr ""

#: ../doc/book/box/vinyl.rst:50
msgid ""
"With memtx, for index searches, ``nil`` may be allowed within a search key. |"
"br| With vinyl, ``nil`` is only allowed at the end of a search key."
msgstr ""

#: ../doc/book/box/vinyl.rst:53 ../book/box/vinyl.rst:53
msgid ""
"With memtx, temporary spaces are supported. |br| With vinyl, they are not."
msgstr ""

#: ../doc/book/box/vinyl.rst:56
msgid ""
"With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-"
"len>` and :ref:`random() <box_index-random>` functions are supported. |br| "
"With vinyl, they are not."
msgstr ""

#: ../doc/book/box/vinyl.rst:61 ../book/box/vinyl.rst:61
msgid ""
"With memtx, the :ref:`count() <box_index-count>` function takes a constant "
"amount of time. |br| With vinyl, it takes a variable amount of time "
"depending on index size."
msgstr ""

#: ../doc/book/box/vinyl.rst:65 ../book/box/vinyl.rst:65
msgid ""
"With memtx, delete will return deleted tuple, if any. |br| With vinyl, "
"delete will always return nil."
msgstr ""

#: ../doc/book/box/vinyl.rst:68 ../book/box/vinyl.rst:68
msgid ""
"It was explained :ref:`earlier <index-yields_must_happen>` that memtx does "
"not \"yield\" on a select request, it yields only on data-change requests. "
"However, vinyl does yield on a select request, or on an equivalent such as "
"``get()`` or ``pairs()``. This has significance for :ref:`cooperative "
"multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/book/box/vinyl.rst:76 ../book/box/vinyl.rst:76
msgid "Vinyl features"
msgstr ""

#: ../doc/book/box/vinyl.rst:78 ../book/box/vinyl.rst:78
msgid "Full ACID compliance"
msgstr ""

#: ../doc/book/box/vinyl.rst:79 ../book/box/vinyl.rst:79
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../doc/book/box/vinyl.rst:80 ../book/box/vinyl.rst:80
msgid "Pure Append-Only"
msgstr ""

#: ../doc/book/box/vinyl.rst:81 ../book/box/vinyl.rst:81
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../doc/book/box/vinyl.rst:82 ../book/box/vinyl.rst:82
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../doc/book/box/vinyl.rst:83 ../book/box/vinyl.rst:83
msgid ""
"Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), "
"multi-databases)"
msgstr ""

#: ../doc/book/box/vinyl.rst:85 ../book/box/vinyl.rst:85
msgid ""
"Asynchronous or synchronous transaction execution (Callback triggered versus "
"blocking)"
msgstr ""

#: ../doc/book/box/vinyl.rst:87 ../book/box/vinyl.rst:87
msgid ""
"Separate storage formats: key-value (Default), or document (Keys are part of "
"value)"
msgstr ""

#: ../doc/book/box/vinyl.rst:89 ../book/box/vinyl.rst:89
msgid "Update without read"
msgstr ""

#: ../doc/book/box/vinyl.rst:90 ../book/box/vinyl.rst:90
msgid "Consistent Cursors"
msgstr ""

#: ../doc/book/box/vinyl.rst:91 ../book/box/vinyl.rst:91
msgid "Prefix search"
msgstr ""

#: ../doc/book/box/vinyl.rst:92 ../book/box/vinyl.rst:92
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../doc/book/box/vinyl.rst:93 ../book/box/vinyl.rst:93
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../doc/book/box/vinyl.rst:94 ../book/box/vinyl.rst:94
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../doc/book/box/vinyl.rst:95 ../book/box/vinyl.rst:95
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../doc/book/box/vinyl.rst:96 ../book/box/vinyl.rst:96
msgid "Metadata Compression (By default)"
msgstr ""

#: ../doc/book/box/vinyl.rst:97 ../book/box/vinyl.rst:97
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../doc/book/box/vinyl.rst:98 ../book/box/vinyl.rst:98
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../doc/book/box/vinyl.rst:99 ../book/box/vinyl.rst:99
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../doc/book/box/vinyl.rst:100 ../book/box/vinyl.rst:100
msgid ""
"Easy to write bindings (Very FFI-friendly, API designed to be stable in "
"future)"
msgstr ""

#: ../doc/book/box/vinyl.rst:101 ../book/box/vinyl.rst:101
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../doc/book/box/vinyl.rst:102 ../book/box/vinyl.rst:102
msgid "Event loop friendly"
msgstr ""

#: ../doc/book/box/vinyl.rst:103 ../book/box/vinyl.rst:103
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../doc/book/box/vinyl.rst:104 ../book/box/vinyl.rst:104
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../doc/book/box/vinyl.rst:105 ../book/box/vinyl.rst:105
msgid "BSD Licensed"
msgstr ""

#: ../doc/book/box/vinyl.rst:107 ../book/box/vinyl.rst:107
msgid ""
"It is appropriate for databases that cannot fit in memory, where access via "
"secondary keys is not required."
msgstr ""

#: ../doc/book/box/vinyl.rst:110 ../book/box/vinyl.rst:110
msgid "In vinyl terminology:"
msgstr ""

#: ../doc/book/box/vinyl.rst:112 ../book/box/vinyl.rst:112
msgid "There is one **Environment**."
msgstr ""

#: ../doc/book/box/vinyl.rst:113 ../book/box/vinyl.rst:113
msgid ""
"An Environment has N **Databases** - a vinyl database is like a Tarantool "
"`space`."
msgstr ""

#: ../doc/book/box/vinyl.rst:114 ../book/box/vinyl.rst:114
msgid "A Database has N **Ranges**."
msgstr ""

#: ../doc/book/box/vinyl.rst:115 ../book/box/vinyl.rst:115
msgid "A Range has one **Range File**."
msgstr ""

#: ../doc/book/box/vinyl.rst:116 ../book/box/vinyl.rst:116
msgid "A Range File has N **Runs**."
msgstr ""

#: ../doc/book/box/vinyl.rst:117 ../book/box/vinyl.rst:117
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../doc/book/box/vinyl.rst:118 ../book/box/vinyl.rst:118
msgid ""
"A Region has **keys** and **values** - a vinyl key-value is like a Tarantool "
"`tuple`."
msgstr ""

#: ../doc/book/box/vinyl.rst:120 ../book/box/vinyl.rst:120
msgid ""
"A key and its associated value are together, so when one accesses a key one "
"gets the whole tuple. In other words, in vinyl the data is stored in the "
"index. There are up to two in-memory copies of an index, as well as the copy "
"in the Range File."
msgstr ""

#: ../doc/book/box/vinyl.rst:124 ../book/box/vinyl.rst:124
msgid ""
"For operations that insert or update tuples - called Set operations in vinyl "
"- vinyl makes changes to in-memory copies of the index, and writes to "
"Tarantool's Write-ahead Log. A scheduler assigns tasks to multiple "
"background threads for transferring index data from memory to disk, and for "
"reorganizing Runs. To support transactions, Set operations can be delayed "
"until an explicit commit. If multiple users access the same tuples "
"simultaneously, the concurrency control method is `MVCC`_ and the isolation "
"level is `Snapshot`_."
msgstr ""

#: ../doc/book/box/vinyl.rst:135 ../book/box/vinyl.rst:135
msgid ""
"Formally, in terms of disk accesses, vinyl has the following algorithmic "
"complexity:"
msgstr ""

#: ../doc/book/box/vinyl.rst:137 ../book/box/vinyl.rst:137
msgid ""
"**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead "
"Log + in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../doc/book/box/vinyl.rst:139 ../book/box/vinyl.rst:139
msgid ""
"**Delete** - the worst case is O(*1*) key writes and in-memory index inserts "
"(the same as **Set**)"
msgstr ""

#: ../doc/book/box/vinyl.rst:141 ../book/box/vinyl.rst:141
msgid ""
"**Get** - the worst case is `amortized`_ O(*max\\_run\\_count\\_per\\_node*) "
"random Region reads from a single Range file, which itself does in-memory "
"index search + in-memory Region search"
msgstr ""

#: ../doc/book/box/vinyl.rst:144 ../book/box/vinyl.rst:144
msgid ""
"**Range** - queries, the worst case of full Database scan is amortized "
"O(*total\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../book/box/vinyl.rst:151
msgid "Under the hood"
msgstr "А что там \"под капотом\"?"

#: ../doc/book/box/vinyl.rst:153 ../book/box/vinyl.rst:153
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../doc/book/box/vinyl.rst:155 ../book/box/vinyl.rst:155
msgid ""
"filling an empty database with one million tuples (we'll call them \"keys\" "
"to emphasize the indexed nature)"
msgstr ""

#: ../doc/book/box/vinyl.rst:157 ../book/box/vinyl.rst:157
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../doc/book/box/vinyl.rst:161 ../book/box/vinyl.rst:161
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../doc/book/box/vinyl.rst:163 ../book/box/vinyl.rst:163
msgid ""
"During the first 200,000 Set operations, inserted keys first go to the in-"
"memory index. To maintain persistence, information about each Set operation "
"is written to Tarantool's Write-ahead Log."
msgstr ""

#: ../doc/book/box/vinyl.rst:171 ../book/box/vinyl.rst:171
msgid ""
"At this point, we have keys in an in-memory index and records in the Write-"
"ahead Log."
msgstr ""

#: ../doc/book/box/vinyl.rst:175 ../book/box/vinyl.rst:175
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../doc/book/box/vinyl.rst:177 ../book/box/vinyl.rst:177
msgid ""
"As the in-memory index becomes too large for available memory, the index "
"must be copied from memory to disk. The on-disk copy of the in-memory index "
"is called a Run. To save the Run, a new file is created, the Range File. We "
"will call it **db file** for this example."
msgstr ""

#: ../doc/book/box/vinyl.rst:182 ../book/box/vinyl.rst:182
msgid ""
"The scheduler wakes a worker thread in the background, a Run Creation "
"Thread. The thread creates a second in-memory index. If there are Set "
"operations taking place while the thread is working, their contention effect "
"will be small because they will operate on the second in-memory index."
msgstr ""

#: ../doc/book/box/vinyl.rst:191 ../book/box/vinyl.rst:191
msgid ""
"When the Run Creation Thread finishes the task, the first in-memory index is "
"freed."
msgstr ""

#: ../doc/book/box/vinyl.rst:200 ../book/box/vinyl.rst:200
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../doc/book/box/vinyl.rst:202 ../book/box/vinyl.rst:202
msgid ""
"Several times, the in-memory index becomes too large and a Run Creation "
"Thread transfers the keys to a Run. The Runs have been appended to the end "
"of db file. The number of created Runs becomes large."
msgstr ""

#: ../doc/book/box/vinyl.rst:210 ../book/box/vinyl.rst:210
msgid ""
"There is a user-settable maximum number of Runs per Range. When the number "
"of Runs reaches this maximum, the vinyl scheduler wakes a **Compaction "
"Thread** for the db file. The Compaction Thread merges the keys in all the "
"Runs, and creates one or more new db files."
msgstr ""

#: ../doc/book/box/vinyl.rst:219 ../book/box/vinyl.rst:219
msgid ""
"Now there are multiple pairs of in-memory indexes, and each pair has an "
"associated db file. The combination of the in-memory indexes and the db file "
"is called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../doc/book/box/vinyl.rst:227 ../book/box/vinyl.rst:227
msgid ""
"Thus the contents of a Range are: a range of sorted key values, stored in "
"Runs of a Range File and (when necessary) in memory. Since the ranges do not "
"overlap, each Range can be handled independently. Therefore, while one of "
"the background threads is working on Range 1, another background thread can "
"be working on Range 2, without contention. That means that all the "
"background operations (Run Creation, Compaction, Garbage Collection, and "
"Backup) can take place in parallel on multiple threads."
msgstr ""

#: ../doc/book/box/vinyl.rst:235 ../book/box/vinyl.rst:235
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../doc/book/box/vinyl.rst:237 ../book/box/vinyl.rst:237
msgid ""
"Before the Compaction there was one Range, which was created automatically "
"when the Database was initialized. The Range had:"
msgstr ""

#: ../doc/book/box/vinyl.rst:240 ../book/box/vinyl.rst:240
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../doc/book/box/vinyl.rst:241 ../book/box/vinyl.rst:241
msgid "a Range File with several Runs,"
msgstr ""

#: ../doc/book/box/vinyl.rst:242 ../book/box/vinyl.rst:242
msgid ""
"a Write-Ahead Log file recording the Set operations, in the order they "
"happened."
msgstr ""

#: ../doc/book/box/vinyl.rst:244 ../book/box/vinyl.rst:244
msgid ""
"The number of Runs became too big, so the vinyl scheduler starts the "
"Compaction Thread and creates two new Ranges."
msgstr ""

#: ../doc/book/box/vinyl.rst:251 ../book/box/vinyl.rst:251
msgid ""
"So, each of the two new Range Files contains half of the keys that were in "
"the original Range. The Range's in-memory indexes are split in the same way."
msgstr ""

#: ../doc/book/box/vinyl.rst:254 ../book/box/vinyl.rst:254
msgid ""
"After the splitting, vinyl must take into account that: while the Compaction "
"was going on in the background, there might have been more Set operations "
"taking place in parallel. These Set operations would have changed one of the "
"in-memory indexes, and these changes too will be merged."
msgstr ""

#: ../doc/book/box/vinyl.rst:259 ../book/box/vinyl.rst:259
msgid ""
"When the Compaction Thread finishes, the original Range is deleted, and "
"information about the new Ranges is inserted into an in-memory **Range "
"Index**."
msgstr ""

#: ../doc/book/box/vinyl.rst:266 ../book/box/vinyl.rst:266
msgid ""
"This Range Index is used for all Set operations and all searches. Since the "
"Range Index has the minimum and maximum key values that are in each Range, "
"it is straightforward to scan it to find what Range would contain a "
"particular key value."
msgstr ""

#: ../doc/book/box/vinyl.rst:276 ../book/box/vinyl.rst:276
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../doc/book/box/vinyl.rst:278 ../book/box/vinyl.rst:278
msgid ""
"The final 300,000 Set operations take place; the background threads continue "
"to create new Runs and do more Compactions. After the millionth insertion, "
"the Database has four Ranges."
msgstr ""

#: ../doc/book/box/vinyl.rst:286 ../book/box/vinyl.rst:286
msgid ""
"The inserting is done. Now, because the words \"memory\" and \"disk\" have "
"appeared in this explanation several times, here are a few words about how "
"vinyl is designed to use these resources most efficiently:"
msgstr ""

#: ../doc/book/box/vinyl.rst:290 ../book/box/vinyl.rst:290
msgid ""
"If there is more memory available, then Run Creation and Compaction will be "
"less frequent, and there will be fewer disk accesses."
msgstr ""

#: ../doc/book/box/vinyl.rst:292 ../book/box/vinyl.rst:292
msgid ""
"The best vinyl performance will occur if there is no setting of a memory "
"limit, but this must be balanced against other considerations, such as "
"requirements for the memtx storage engine. If there is a setting of a memory "
"limit, the vinyl scheduler will give priority to the Ranges that have the "
"largest in-memory indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../doc/book/box/vinyl.rst:297 ../book/box/vinyl.rst:297
msgid ""
"To make the most of hard drives and Flash, vinyl will delay operations that "
"require disk access (except the writing of the Write-ahead Log which is "
"specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../doc/book/box/vinyl.rst:300 ../book/box/vinyl.rst:300
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../doc/book/box/vinyl.rst:304 ../book/box/vinyl.rst:304
msgid "Reading million keys"
msgstr ""

#: ../doc/book/box/vinyl.rst:306 ../book/box/vinyl.rst:306
msgid ""
"We will now start to read the million rows in the order that they were "
"inserted, which was random."
msgstr ""

#: ../doc/book/box/vinyl.rst:313 ../book/box/vinyl.rst:313
msgid ""
"During the Get (search), vinyl first finds the correct Range by looking in "
"the Range Index. Then it searches the Range's first in-memory index, and/or "
"the Range's second in-memory index, and/or each Run of the Range, starting "
"from the end of the Range File."
msgstr ""

#: ../doc/book/box/vinyl.rst:318 ../book/box/vinyl.rst:318
msgid ""
"Remember that a Run is divided into Regions, which are like what would be "
"called \"pages\" or \"blocks\" in a B-tree. For each Run, there is a list of "
"the Regions and their minimum/maximum key values - the Region Index - as "
"well as some metadata."
msgstr ""

#: ../doc/book/box/vinyl.rst:327 ../book/box/vinyl.rst:327
msgid ""
"Region Indexes are loaded into memory when the Database is opened. Since the "
"Database's Range Index and the Region Indexes are normally in-memory, "
"searching and retrieving a tuple might require only zero or one disk "
"accesses. However, when memory is limited and there are many Runs, search "
"time may rise. For each additional Run there is a possible additional disk "
"access during a search. Also, it is impossible to maintain memory limits "
"without doing a Run Creation process, because new Set operations might occur "
"more quickly than the Compaction process can run."
msgstr ""

#: ../doc/book/box/vinyl.rst:340 ../book/box/vinyl.rst:340
msgid ""
"Vinyl is read optimized. It is very likely that the most recently created "
"Runs (hot data) will be in the file system cache. The scheduler will give "
"priority to the Ranges which have the largest in-memory indexes and the most "
"Runs."
msgstr ""

#: ../doc/book/box/vinyl.rst:345 ../book/box/vinyl.rst:345
msgid ""
"The scheduler may also try to arrange that a Range will have only one Run, "
"which will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../book/connectors/index.rst:30
msgid "Connectors"
msgstr "Коннекторы"

#: ../book/connectors/index.rst:32
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../book/connectors/index.rst:36
msgid "Protocol"
msgstr "Протокол"

#: ../book/connectors/index.rst:38
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O "
"and easy integration with proxies. Each client request starts with a "
"variable-length binary header, containing request id, request type, server "
"id, log sequence number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом "
"потребностей асинхронного ввода-вывода. Основная его задача — облегчить "
"интеграцию Tarantool'а с клиентскими приложениями. Клиентский запрос в "
"Tarantool-протоколе начинается с бинарного заголовка переменной длины. В "
"заголовке указывается идентификатор и тип запроса, идентификатор сервера, "
"номер записи в журнале и т.д."

#: ../book/connectors/index.rst:43
msgid ""
"The mandatory length, present in request header simplifies client or proxy I/"
"O. A response to a request is sent to the client as soon as it is ready. It "
"always carries in its header the same type and id as in the request. The id "
"makes it possible to match a request to a response, even if the latter "
"arrived out of order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает "
"обработку данных. Ответ на запрос посылается по мере готовности. В заголовке "
"ответа указывается тот же идентификатор и тип запроса, что и в изначальном "
"запросе. По идентификатору можно легко соотнести запрос с ответом, даже если "
"ответ был получен не в порядке отсылки запросов."

#: ../book/connectors/index.rst:49
msgid ""
"Unless implementing a client driver, you needn't concern yourself with the "
"complications of the binary protocol. Language-specific drivers provide a "
"friendly way to store domain language data structures in Tarantool. A "
"complete description of the binary protocol is maintained in annotated "
"Backus-Naur form in the source tree: please see the page about :ref:"
"`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при "
"разработке нового коннектора для Tarantool'а — см. :ref:`полное описание "
"бинарного протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде "
"аннотированных BNF-диаграмм (Backus-Naur Form). В остальных случаях "
"достаточно взять уже существующий коннектор для нужного вам языка "
"программирования. Такие коннекторы позволяют легко хранить структуры данных "
"из разных языков в формате Tarantool'а."

#: ../book/connectors/index.rst:58
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../book/connectors/index.rst:60
msgid ""
"The Tarantool API exists so that a client program can send a request packet "
"to the server, and receive a response. Here is an example of a what the "
"client would send for :samp:`box.space[513]:insert{'A', 'BB'}`. The BNF "
"description of the components is on the page about :ref:`Tarantool's binary "
"protocol <box_protocol-iproto_protocol>`."
msgstr ""
"С помощью Tarantool API клиентские программы могут посылать в адрес "
"Tarantool-сервера пакеты с запросами и получать на них ответы. Вот пример "
"исходящего пакета, который будет сформирован для запроса :code:`box."
"space[513]:insert{'A', 'BB'}`. Описания компонентов запроса (в виде BNF-"
"диаграмм) вы найдете на странице о :ref:`бинарном протоколе в Tarantool'е "
"<box_protocol-iproto_protocol>`."

#: ../book/connectors/index.rst:76
msgid "Component"
msgstr "Компонент"

#: ../book/connectors/index.rst:76
msgid "Byte #0"
msgstr "Байт #0"

#: ../book/connectors/index.rst:76
msgid "Byte #1"
msgstr "Байт #1"

#: ../book/connectors/index.rst:76
msgid "Byte #2"
msgstr "Байт #2"

#: ../book/connectors/index.rst:76
msgid "Byte #3"
msgstr "Байт #3"

#: ../book/connectors/index.rst:78
msgid "code for insert"
msgstr "код для вставки"

#: ../book/connectors/index.rst:78 ../book/connectors/index.rst:82
msgid "02"
msgstr "02"

#: ../book/connectors/index.rst:80
msgid "rest of header"
msgstr "остаток заголовка"

#: ../book/connectors/index.rst:80
msgid "..."
msgstr "..."

#: ../book/connectors/index.rst:82
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../book/connectors/index.rst:82
msgid "cd"
msgstr "cd"

#: ../book/connectors/index.rst:82
msgid "01"
msgstr "01"

#: ../book/connectors/index.rst:84
msgid "code for tuple"
msgstr "код для кортежа"

#: ../book/connectors/index.rst:84
msgid "21"
msgstr "21"

#: ../book/connectors/index.rst:86
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../book/connectors/index.rst:86
msgid "92"
msgstr "92"

#: ../book/connectors/index.rst:88
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../book/connectors/index.rst:88
msgid "a1"
msgstr "a1"

#: ../book/connectors/index.rst:88
msgid "41"
msgstr "41"

#: ../book/connectors/index.rst:90
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../book/connectors/index.rst:90
msgid "a2"
msgstr "a2"

#: ../book/connectors/index.rst:90
msgid "42"
msgstr "42"

#: ../book/connectors/index.rst:93
msgid ""
"Now, you could send that packet to the Tarantool server, and interpret the "
"response (the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>` has a description of the packet format for responses as "
"well as requests). But it would be easier, and less error-prone, if you "
"could invoke a routine that formats the packet according to typed "
"parameters. Something like :samp:`response=tarantool_routine(\"insert\",513,"
"\"A\",\"B\");`. And that is why APIs exist for drivers for Perl, Python, "
"PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать Tarantool-серверу и затем "
"проинтерпретировать полученный ответ (описания компонентов ответа вы найдете "
"на той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`). Но более простым и верным способом будет вызвать "
"процедуру, которая за вас сформирует готовый пакет с заданными параметрами. "
"Что-то вроде :samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");"
"`. Для этого в Tarantool'е существуют API для Perl, Python, PHP и других "
"программных языков."

#: ../book/connectors/index.rst:106
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/book/connectors/index.rst:111
msgid ""
"This chapter has examples that show how to connect to the Tarantool server "
"via the Perl, PHP, Python, node.js, and C connectors. The examples contain "
"hard code that will work if and only if the following conditions are met:"
msgstr ""

#: ../book/connectors/index.rst:112
msgid ""
"the server (tarantool) is running on localhost (127.0.0.1) and is listening "
"on port 3301 (:samp:`box.cfg.listen = '3301'`),"
msgstr ""
"Tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``), а "
"прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen = "
"'3301'`),"

#: ../book/connectors/index.rst:115
msgid ""
"space ``examples`` has id = 999 (:samp:`box.space.examples.id = 999`) and "
"has a primary-key index for a numeric field (:samp:`box.space[999].index[0]."
"parts[1].type = \"unsigned\"`),"
msgstr ""
"в базе есть пространство ``examples`` с идентификатором 999 (:samp:`box."
"space.examples.id = 999`) и у него есть первичный индекс, построенный по "
"ключу числового типа (:samp:`box.space[999].index[0].parts[1].type = "
"\"unsigned\"`),"

#: ../book/connectors/index.rst:119
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../book/connectors/index.rst:121
msgid ""
"It is easy to meet all the conditions by starting the server and executing "
"this script:"
msgstr ""
"Такое тестовое окружение легко настроить, запустив Tarantool-сервер локально "
"и выполнив следующие запросы:"

#: ../book/connectors/index.rst:124
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../book/connectors/__java.rst:3
msgid "Java"
msgstr "Java"

#: ../book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../book/connectors/__go.rst:3
msgid "Go"
msgstr "Go"

#: ../book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../book/connectors/__r.rst:3
msgid "R"
msgstr "R"

#: ../book/connectors/__r.rst:5
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/book/connectors/index.rst:143
msgid "Erlang"
msgstr ""

#: ../doc/book/connectors/index.rst:145
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../book/connectors/__perl.rst:3
msgid "Perl"
msgstr "Perl"

#: ../book/connectors/__perl.rst:5
msgid ""
"The most commonly used Perl driver is `DR::Tarantool <http://search.cpan.org/"
"~unera/DR-Tarantool/>`_. It is not supplied as part of the Tarantool "
"repository; it must be installed separately. The most common way to install "
"it is with `CPAN, the Comprehensive Perl Archive Network <https://en."
"wikipedia.org/wiki/Cpan>`_. ``DR::Tarantool`` requires other modules which "
"should be installed first. For example, on Ubuntu, the installation could "
"look like this:"
msgstr ""
"Наиболее популярным Tarantool-коннектором для языка Perl является `DR::"
"Tarantool <http://search.cpan.org/~unera/DR-Tarantool/>`_. Он "
"устанавливается отдельно от Tarantool'а, например с помощью :program:`cpan` "
"(см. `CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/"
"wiki/Cpan>`_), и требует предварительной установки еще несколько зависимых "
"модулей. Вот пример установки этого коннектора под Ubuntu:"

#: ../book/connectors/__perl.rst:13
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"

#: ../book/connectors/__perl.rst:24
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the server "
"is listening at ``localhost:3301`` and that the space ``examples`` exists, "
"as :ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.pl` and say :samp:`perl example.pl`. "
"The program will connect using an application-specific definition of the "
"space. The program will open a socket connection with the Tarantool server "
"at ``localhost:3301``, then send an INSERT request, then — if all is well — "
"end without displaying any messages. If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connection "
"refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` "
"с помощью Tarantool API для языка Perl. Перед запуском данной программы "
"проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше "
"<index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания "
"и в базе создано пространство ``examples``). Чтобы запустить тестовую "
"программу, сохраните ее исходный код в файл с именем :file:`example.pl` и "
"выполните команду :samp:`perl example.pl`. Программа установит соединение, "
"используя указанное в ней описание пространства, откроет сокет для "
"соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-"
"запрос, а затем — если всё хорошо — закончит работу без каких-либо "
"сообщений. Если окажется, что Tarantool-сервер не запущен на прослушивание "
"по указанному адресу, то программа выдаст сообщение об ошибке “Connection "
"refused”."

#: ../book/connectors/__perl.rst:36
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also "
"say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of "
"space[999] ...\n"
"      name => 'examples',                      #   space[999] name = "
"'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is "
"'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999]."
"fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] "
"indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера по "
"адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь же "
"можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства "
"space[999] ...\n"
"      name => 'examples',                      # имя пространства space[999] "
"= 'examples'\n"
"      default_type => 'STR',                   # если тип поля в space[999] "
"не задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля space[999]."
"field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../book/connectors/__perl.rst:60
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of "
"'string' and 'unsigned', due to a temporary Perl limitation."
msgstr ""
"Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и "
"'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../book/connectors/__perl.rst:63
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `DR::Tarantool CPAN "
"repository <http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, обратитесь "
"к документации из `CPAN-репозитория DR::Tarantool <http://search.cpan.org/"
"~unera/DR-Tarantool/>`_."

#: ../book/connectors/__php.rst:3
msgid "PHP"
msgstr "PHP"

#: ../doc/book/connectors/__php.rst:5
msgid ""
"The most commonly used PHP driver is `tarantool-php <https://github.com/"
"tarantool/tarantool-php>`_. It is not supplied as part of the Tarantool "
"repository; it must be installed separately, for example with :program:"
"`git`. See `installation instructions <https://github.com/tarantool/"
"tarantool-php/blob/master/#installing-and-building>`_. in the driver's :file:"
"`README` file."
msgstr ""

#: ../doc/book/connectors/__php.rst:12
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space "
"named ``examples`` via the PHP API. Before trying to run, check that the "
"server is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste "
"the code into a file named :file:`example.php` and say ``php -d extension=~/"
"tarantool-php/modules/tarantool.so example.php``. The program will open a "
"socket connection with the Tarantool server at ``localhost:3301``, then send "
"an INSERT request, then — if all is well — print \"Insert succeeded\". If "
"the tuple already exists, the program will print “Duplicate key exists in "
"unique index 'primary' in space 'examples'”."
msgstr ""

#: ../book/connectors/__php.rst:41
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/book/connectors/__php.rst:35
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-php "
"<https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""

#: ../doc/book/connectors/__php.rst:40
msgid ""
"Besides, you can use an alternative PHP driver from another GitHub project: "
"it includes a *client* (see `tarantool-php/client <https://github.com/"
"tarantool-php/client>`_) and a *mapper* for that client (see `tarantool-php/"
"mapper <https://github.com/tarantool-php/mapper>`_)."
msgstr ""

#: ../book/connectors/__python.rst:3
msgid "Python"
msgstr "Python"

#: ../book/connectors/__python.rst:5
msgid ""
"Here is a complete Python program that inserts ``[99999,'Value','Value']`` "
"into space ``examples`` via the high-level Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство "
"``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../book/connectors/__python.rst:8
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../book/connectors/__python.rst:17
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and install "
"the ``tarantool-python`` connector with either :samp:`pip install tarantool"
"\\>0.4` to install in :file:`/usr` (requires **root** privilege) or :samp:"
"`pip install tarantool\\>0.4 --user` to install in :file:`~` i.e. user's "
"default directory. Before trying to run, check that the server is listening "
"at ``localhost:3301`` and that the space ``examples`` exists, as :ref:"
"`described earlier <index-connector_setting>`. To run the program, say :samp:"
"`python example.py`. The program will connect to the server, will send the "
"request, and will not throw any exception if all went well. If the tuple "
"already exists, the program will throw ``tarantool.error.DatabaseError: (3, "
"\"Duplicate key exists in unique index 'primary' in space 'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что ваше тестовое окружение "
"настроено так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано пространство "
"``examples``), и установите коннектор ``tarantool-python``. Для установки "
"коннектора воспользуйтесь либо командой :samp:`pip install tarantool\\>0.4` "
"(для установки в директорию :file:`/usr`; вам потребуются права уровня  "
"**root**), либо командой :samp:`pip install tarantool\\>0.4 --user` (для "
"установки в директорию :file:`~`, т.е. в используемую по умолчанию "
"директорию текущего пользователя). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.py` и выполните "
"команду :samp:`python example.py`. Программа установит соединение с "
"Tarantool-сервером, пошлет запрос и не сгенерирует никакого исключения, если "
"всё прошло хорошо. Если окажется, что такой кортеж уже существует, то "
"программа сгенерирует исключение :samp:`tarantool.error.DatabaseError: (3, "
"\"Duplicate key exists in unique index 'primary' in space 'examples'\")`."

#: ../doc/book/connectors/__python.rst:29
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python <http://"
"github.com/tarantool/tarantool-python>`_ project at GitHub. For an example "
"of using Python API with `queue managers for Tarantool <https://github.com/"
"tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-"
"python>`_ project at GitHub."
msgstr ""

#: ../doc/book/connectors/index.rst:155
msgid "node.js"
msgstr ""

#: ../doc/book/connectors/index.rst:157
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver <https://"
"github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of "
"the Tarantool repository; it must be installed separately. The most common "
"way to install it is with `npm <https://www.sitepoint.com/beginners-guide-"
"node-package-manager/>`_. For example, on Ubuntu, the installation could "
"look like this after npm has been installed:"
msgstr ""

#: ../doc/book/connectors/index.rst:166
msgid "$ npm install tarantool-driver --global"
msgstr ""

#: ../doc/book/connectors/index.rst:170
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the "
"server is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste "
"the code into a file named :file:`example.rs` and say :samp:`node example."
"rs`. The program will connect using an application-specific definition of "
"the space. The program will open a socket connection with the Tarantool "
"server at ``localhost:3301``, then send an INSERT request, then — if all is "
"well — end after saying \"Insert succeeded\". If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connect "
"failed”. If user ``guest`` does not have authorization to connect, the "
"program will print \"Auth failed\". If the insert request fails for any "
"reason, for example because the tuple already exists, the program will print "
"\"Insert failed\"."
msgstr ""

#: ../doc/book/connectors/index.rst:184
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function(){\n"
"    conn.auth(\"guest\", \"\").then(function(){\n"
"        conn.insert(999, insertTuple).then(function(){\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e){ console.log(\"Insert failed\"); process.exit(1); });\n"
"    }, function(e){ console.log(\"Auth failed\"); process.exit(1); });\n"
"    }, function(e){ console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/book/connectors/index.rst:198
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""

#: ../book/connectors/__c.rst:3
msgid "C"
msgstr "C"

#: ../book/connectors/__c.rst:5
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../book/connectors/__c.rst:9
msgid "Example 1"
msgstr "Пример 1"

#: ../book/connectors/__c.rst:11
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space :"
"code:`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая "
"осуществляет вставку кортежа ``[99999,'B']`` в пространство ``examples`` с "
"помощью высокоуровневого Tarantool API для языка C. "

#: ../book/connectors/__c.rst:14
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT "
"*/\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE "
"REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND "
"REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY "
"*/\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN "
"*/\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА "
"*/\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ "
"*/\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА "
"ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ "
"*/\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:44
msgid ""
"Paste the code into a file named :file:`example.c` and install ``tarantool-"
"c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и "
"установите коннектор ``tarantool-c``. Вот один из способов установки "
"``tarantool-c`` (под Ubuntu):"

#: ../book/connectors/__c.rst:47
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../book/connectors/__c.rst:57 ../book/connectors/__c.rst:288
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую "
"команду:"

#: ../book/connectors/__c.rst:59
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../book/connectors/__c.rst:65
msgid ""
"Before trying to run, check that the server is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as :ref:"
"`described earlier <index-connector_setting>`. To run the program, say :samp:"
"`./example`. The program will connect to the server, and will send the "
"request. If Tarantool is not running on localhost with listen address = "
"3301, the program will print “Connection refused”. If the insert fails, the "
"program will print \"Insert failed\" and an error number (see all error "
"codes in the source file `/src/box/errcode.h <https://github.com/tarantool/"
"tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr ""
"Перед запуском программы проверьте, что ваше тестовое окружение настроено "
"так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``). "
"Чтобы запустить тестовую программу, выполните команду :samp:`./example`. "
"Программа установит соединение с Tarantool-сервером и пошлет запрос. Если "
"окажется, что Tarantool-сервер не запущен на прослушивание по указанному "
"адресу, то программа выдаст сообщение об ошибке “Connection refused”. А если "
"не пройдет INSERT-запрос, то программа выдаст сообщение \"Insert failed\" и "
"код ошибки (все коды ошибок в Tarantool'е см. в исходном файле `/src/box/"
"errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode."
"h>`_)."

#: ../book/connectors/__c.rst:77
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к исходному "
"коду тестовой программы."

#: ../book/connectors/__c.rst:79
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""
"**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../book/connectors/__c.rst:81
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../book/connectors/__c.rst:86
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on the "
"``tnt`` stream, some options may have to be set. The most important option "
"is TNT_OPT_URI. In this program, the URI is ``localhost:3301``, since that "
"is where the Tarantool server is supposed to be listening."
msgstr ""
"В нашей тестовой программе поток назван ``tnt``. Перед установкой соединения "
"нужно задать ряд настроечных опций. Самая важная из них — TNT_OPT_URI. Для "
"этой опции указана URI-строка ``localhost:3301``, т.е. адрес, по которому "
"должно быть настроено прослушивание на стороне Tarantool-сервера."

#: ../book/connectors/__c.rst:92 ../book/connectors/__c.rst:108
#: ../book/connectors/__c.rst:136 ../book/connectors/__c.rst:156
#: ../book/connectors/__c.rst:181 ../book/connectors/__c.rst:200
msgid "Function description:"
msgstr "Описание функции:"

#: ../book/connectors/__c.rst:425
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../book/connectors/__c.rst:100
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated with "
"a URI, this example program can connect to the server."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его "
"с конкретным URI, наша программа может устанавливать соединение с Tarantool-"
"сервером."

#: ../book/connectors/__c.rst:103
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../book/connectors/__c.rst:441
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:115
msgid ""
"The connection might fail for a variety of reasons, such as: the server is "
"not running, or the URI contains an invalid password. If the connection "
"fails, the return value will be -1."
msgstr ""
"Попытка соединения может и не удаться, например если Tarantool-сервер не "
"запущен или в URI-строке указан неверный пароль. В случае неудачи функция "
"``tnt_connect()`` вернет -1."

#: ../book/connectors/__c.rst:119
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such as "
"the contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../book/connectors/__c.rst:122
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../book/connectors/__c.rst:127
#, python-format
msgid ""
"In this program, the request will be an INSERT, and the tuple contents will "
"be an integer and a string. This is a simple serial set of values, that is, "
"there are no sub-structures or arrays. Therefore it is easy in this case to "
"format what will be passed using the same sort of arguments that one would "
"use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the "
"string, then the integer value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос INSERT, а кортеж содержит целое "
"число и строку.  Это простой набор значений без каких-либо вложенных "
"структур или массивов. И передаваемые значения мы можем указать самым "
"простым образом — аналогично тому, как это сделано в стандартной C-функции "
"``printf()``: ``%d`` для обозначения целого числа, ``%s`` для обозначения "
"строки, затем числовое значение, затем указатель на строковое значение."

#: ../book/connectors/__c.rst:469
msgid ""
"ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr ""
"ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../book/connectors/__c.rst:143
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the "
"requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается "
"аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../book/connectors/__c.rst:146
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../book/connectors/__c.rst:151
msgid ""
"In this program, the choice is to do an INSERT request, so the program "
"passes the ``tnt_stream`` that was used for connection (``tnt``) and the "
"``tnt_stream`` that was set up with :c:func:`tarantoolc:tnt_object_format` "
"(``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток "
"``tnt``, который ранее использовали для установки соединения, и поток :code:"
"`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:"
"tnt_object_format`."

#: ../book/connectors/__c.rst:489
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../book/connectors/__c.rst:169
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply containing "
"some indication whether the result was successful, and a set of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который "
"содержит информацию о том, был ли данный запрос успешно выполнен, а также "
"содержит набор кортежей."

#: ../book/connectors/__c.rst:172
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../book/connectors/__c.rst:179
msgid ""
"This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../book/connectors/__c.rst:514
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../book/connectors/__c.rst:190
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with :c:func:"
"`tarantoolc:tnt_connect()` should be closed, and the objects that were made "
"in the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное "
"с помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить объекты, "
"созданные на этапе настройки."

#: ../book/connectors/__c.rst:194
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../book/connectors/__c.rst:533
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../book/connectors/__c.rst:210
msgid "Example 2"
msgstr "Пример 2"

#: ../book/connectors/__c.rst:212
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, from "
"space ``examples`` via the high-level C API. To display the results, the "
"program uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ "
"library which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/"
"MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, которая "
"осуществляет выборку по индекс-ключу ``[99999]`` из пространства "
"``examples`` с помощью высокоуровневого Tarantool API для языка C. Для "
"вывода результатов в этой программе используются функции из библиотеки "
"`MsgPuck <http://rtsisyk.github.io/msgpuck/>`_. Эти функции нужны для "
"декодирования массивов значений в формате `MessagePack <https://en.wikipedia."
"org/wiki/MessagePack>`_."

#: ../book/connectors/__c.rst:218
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для "
"поиска */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__c.rst:285
msgid ""
"Similarly to the first example, paste the code into a file named :file:"
"`example2.c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с "
"именем :file:`example2.c`."

#: ../book/connectors/__c.rst:290
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../book/connectors/__c.rst:294
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../book/connectors/__c.rst:296
msgid ""
"The two example programs only show a few requests and do not show all that's "
"necessary for good practice. See more in the `tarantool-c documentation at "
"GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух запросов. "
"Для полноценной работы с Tarantool'ом с помощью C API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-c на GitHub <http://github."
"com/tarantool/tarantool-c>`_."

#: ../book/connectors/__results.rst:4
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../book/connectors/__results.rst:6
msgid ""
"For all connectors, calling a function via Tarantool causes a return in the "
"MsgPack format. If the function is called using the connector's API, some "
"conversions may occur. All scalar values are returned as tuples (with a "
"MsgPack type-identifier followed by a value); all non-scalar values are "
"returned as a group of tuples (with a MsgPack array-identifier followed by "
"the scalar values). If the function is called via the binary protocol "
"command layer -- \"eval\" -- rather than via the connector's API, no "
"conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была "
"вызвана через API коннектора, то формат возвращаемых значений будет "
"следующим: скалярные значения возвращаются в виде кортежей (сначала идет "
"идентификатор типа из формата MsgPack, а затем идет значение); все прочие "
"(не скалярные) значения возвращаются в виде групп кортежей (сначала идет "
"идентификатор массива в формате MsgPack, а затем идут скалярные значения). "
"Но если функция была вызвана в рамках бинарного протокола (с помощью команды "
"``eval``), а не через API коннектора, то подобных изменений формата "
"возвращаемых значений не происходит."

#: ../book/connectors/__results.rst:14
msgid ""
"In the following example, a Lua function will be created. Since it will be "
"accessed externally by a 'guest' user, a ``grant`` of an execute privilege "
"will be necessary. The function returns an empty array, a scalar string, two "
"booleans, and a short integer. The values are the ones described in the "
"table :ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет "
"вызывать внешний пользователь 'guest', то нужно настроить привилегии на "
"исполнение с помощью ``grant``. Эта функция возвращает пустой массив, строку-"
"скаляр, два логических значения и короткое целое число. Значение будут теми "
"же, что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в "
"MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../book/connectors/__results.rst:20
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../book/connectors/__results.rst:36
msgid ""
"Here is a C program which calls the function. Although C is being used for "
"the example, the result would be precisely the same if the calling program "
"was written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию. "
"Хотя в примере использован код на C, результат будет одинаковым, на каком бы "
"языке ни была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../book/connectors/__results.rst:40
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* MAKE REQUEST */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* CALL function f() "
"*/\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА "
"*/\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() "
"*/\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА "
"*/\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА "
"*/\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../book/connectors/__results.rst:80
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../book/connectors/__results.rst:82
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../book/connectors/__results.rst:86
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-"
"bit array header with value 5\" (see `MsgPack specification <http://github."
"com/msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in "
"the table :ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, "
"означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию "
"на формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec."
"md>`_). Остальные значения описаны в таблице :ref:`Стандартные типы в "
"MsgPack-кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../book/faq.rst:30 ../faq.rst:28
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../book/faq.rst:41 ../book/faq.rst:46 ../book/faq.rst:53 ../book/faq.rst:64
#: ../book/faq.rst:70 ../book/faq.rst:77 ../book/faq.rst:82 ../faq.rst:39
#: ../faq.rst:44 ../faq.rst:51 ../faq.rst:62 ../faq.rst:68 ../faq.rst:74
#: ../faq.rst:79
msgid "Q: |br| A: |br|"
msgstr "Вопрос: |br| Ответ: |br|"

#: ../book/faq.rst:41 ../faq.rst:39
msgid ""
"Why Tarantool? |br| Tarantool is the latest generation of a family of in-"
"memory data servers developed for web applications. It is the result of "
"practical experience and trials within Mail.Ru since development began in "
"2008."
msgstr ""
"Почему Tarantool? |br| Tarantool — это in-memory сервер баз данных "
"последнего поколения, предназначенный для работы с веб-приложениями. "
"Разработка ведется с учетом многолетнего опыта использования Tarantool'а в "
"стенах Mail.Ru. Первый релиз состоялся в 2008 году."

#: ../book/faq.rst:46 ../faq.rst:44
msgid ""
"Why Lua? |br| Lua is a lightweight, fast, extensible multi-paradigm "
"language. Lua also happens to be very easy to embed. Lua coroutines relate "
"very closely to Tarantool fibers, and Lua architecture works well with "
"Tarantool internals. Lua acts well as a stored program language for "
"Tarantool, although connecting with other languages is also easy."
msgstr ""
"Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, позволяющий "
"использовать различные парадигмы программирования. Lua также легко "
"встраивается в различные приложения. Ко-рутины (coroutines) в Lua близко "
"соотносятся с файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко "
"ложится на его внутреннюю реализацию. Lua — это первый язык, на котором "
"можно писать хранимые процедуры для Tarantool'а. В будущем список "
"поддерживаемых языков планируется расширить."

#: ../book/faq.rst:53 ../faq.rst:51
msgid ""
"What's the key advantage of Tarantool? |br| Tarantool provides a rich "
"database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, "
"composite indexes, transactions, triggers, asynchronous replication) in a "
"flexible environment of a Lua interpreter. |br| These two properties make it "
"possible to be a fast, atomic and reliable in-memory data server which "
"handles non-trivial application-specific logic. The advantage over "
"traditional SQL servers is in performance: low-overhead, lock-free "
"architecture means Tarantool can serve an order of magnitude more requests "
"per second, on comparable hardware. The advantage over NoSQL alternatives is "
"in flexibility: Lua allows flexible processing of data stored in a compact, "
"denormalized format."
msgstr ""
"В чем состоит главное преимущество Tarantool'а? |br| Tarantool предоставляет "
"богатый набор функций по работе с базами данных (HASH, TREE, RTREE, BitSet-"
"индексы, вторичные индексы, составные индексы, транзакции, триггеры, "
"асинхронная репликация), и всё это — в гибкой среде Lua-интерпретатора. |br| "
"Эти два обстоятельства делают Tarantool быстрым и надежным in-memory "
"сервером баз данных с атомарными операциями и сложной логикой на стороне "
"сервера. Преимуществом Tarantool'а по сравнению с традиционными SQL СУБД "
"является его высокая производительность: низкие накладные расходы и "
"безблокировочная архитектура позволяют Tarantool'у обрабатывать на порядок "
"больше запросов в секунду на аналогичном оборудовании. Преимущество же перед "
"другими NoSQL СУБД заключается в большей гибкости Tarantool'а: язык Lua "
"позволяет гибко обрабатывать данные, хранящиеся в компактном, "
"ненормализованном формате."

#: ../book/faq.rst:64 ../faq.rst:62
msgid ""
"What are your development plans? |br| We continuously improve server "
"performance. On the feature front, automatic sharding and synchronous "
"replication, and a subset of SQL are the major goals for 2016-2018. We have "
"an open roadmap to which we encourage anyone to add feature requests."
msgstr ""
"Каковы ваши планы по развитию? |br| Мы постоянно улучшаем производительность "
"серверной части. Наши главные цели на 2016-2018 год — это автоматический "
"шардинг и синхронная репликация, а также частичная поддержка SQL. План работ "
"находится в открытом доступе, и все желающие могут оставлять запросы на "
"добавление функционала."

#: ../book/faq.rst:70
msgid ""
"Who is developing Tarantool? |br| There is an engineering team employed by "
"Mail.Ru -- check out our commit logs on `github.com/tarantool <http://github."
"com/tarantool/>`_. The development is fully open. Most of the connectors' "
"authors, and the maintainers for different distributions, come from the "
"wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда "
"разработки в Mail.Ru — см. историю коммитов на `github.com/tarantool <http://"
"github.com/tarantool/>`_. Вся разработка ведется открытым образом. Кроме "
"того, активную роль играют члены сообщества разработчиков Tarantool'а. Их "
"силами было создано большинство коннекторов и ведутся доработки под разные "
"дистрибутивы."

#: ../book/faq.rst:77 ../faq.rst:74
msgid ""
"How serious is Mail.Ru about Tarantool? |br| Tarantool is an open source "
"project, distributed under a BSD license, so it does not depend on any one "
"sponsor. However, it is an integral part of the Mail.Ru backbone, so it gets "
"a lot of support from Mail.Ru."
msgstr ""
"Насколько серьезны планы Mail.Ru в отношении Tarantool'а? |br| Tarantool — "
"это проект с открытым кодом, распространяемый под лицензией BSD, поэтому он "
"не зависит от внешних спонсоров. В то же время, Tarantool — это часть "
"технологического \"костяка\" Mail.Ru, и поэтому он пользуется сильной "
"поддержкой со стороны Mail.Ru."

#: ../book/faq.rst:82 ../faq.rst:79
msgid ""
"Are there problems associated with being an in-memory server? |br| The "
"principal storage engine is designed for RAM plus persistent storage. It is "
"immune to data loss because there is a write-ahead log. Its memory-"
"allocation and compression techniques ensure there is no waste. And if "
"Tarantool runs out of memory, then it will stop accepting updates until more "
"memory is available, but will continue to handle read and delete requests "
"without difficulty. However, for databases which are much larger than the "
"available RAM space, Tarantool has a second storage engine which is only "
"limited by the available disk space."
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory решением? "
"|br| Основной движок баз данных в Tarantool'е работает с оперативной "
"памятью, но при этом он гарантирует сохранность данных благодаря механизму "
"WAL (write ahead log), т.е. журналу упреждающей записи. Также в Tarantool'е "
"используются технологии сжатия и распределения данных, которые позволяют "
"использовать все виды памяти наиболее эффективно. Если Tarantool "
"сталкивается с нехваткой оперативной памяти, то он приостанавливает прием "
"запросов на изменение данных до тех пор, пока не появится свободная память, "
"но при этом с успехом продолжает обработку запросов на чтение и удаление "
"данных. А для больших баз, где объем данных значительно превосходит "
"имеющийся объем оперативной памяти, у Tarantool'а есть второй движок, чьи "
"возможности ограничены лишь размером жесткого диска."

#: ../book/intro.rst:28
msgid "Preface"
msgstr "Предисловие"

#: ../book/intro.rst:30
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it "
"first, and consulting :ref:`Reference <reference>` materials for more detail "
"afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство "
"пользователя\". Мы советуем начинать именно с него, а затем переходить к :"
"ref:`\"Справочникам\" <reference>`, если вам понадобятся более подробные "
"сведения."

#: ../book/intro.rst:36
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../book/intro.rst:38
msgid ""
"To get started, you can either *download the whole Tarantool package* as "
"described in the first part of :ref:`Chapter 2 \"Getting Started\" "
"<user_guide_getting_started>`, or you can skip the download and *connect to "
"the online Tarantool server* running on the web at http://try.tarantool.org. "
"Either way, as the first tryout, you can follow the introductory example "
"\"Starting Tarantool and making your first database\" from :ref:`the second "
"part of Chapter 2 <user_guide_getting_started-first_database>`. If you want "
"more hands-on experience, proceed to the :ref:`\"Tutorials\" <tutorials>` "
"part after you are through with Chapter 2."
msgstr ""
"Знакомство с Tarantool'ом вы можете начать с того, что скачаете готовый "
"установочный пакет (как описано в начале :ref:`главы 2 \"Начало работы\" "
"<user_guide_getting_started>`) или воспользуетесь нашим онлайн-стендом на "
"http://try.tarantool.org. В любом случае для первого знакомства вы можете "
"выполнить тренировочный пример \"Первичный запуск Tarantool'а и создание "
"базы данных\" из второй части главы 2. После этого вы можете заглянуть в "
"наш :ref:`\"Практикум\" <tutorials>`, где содержится еще больше практических "
"заданий."

#: ../book/intro.rst:50
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as "
"a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` "
"is about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о "
"возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер "
"приложений\" <app_server>` — о возможностях Tarantool'а как сервера "
"приложений Lua."

#: ../book/intro.rst:54
msgid ""
":ref:`Chapter 5 \"Server administration\" <server_admin>` is primarily for "
"administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` "
"предназначена в первую очередь для системных администраторов."

#: ../book/intro.rst:57
msgid ""
":ref:`Chapter 6 \"Connectors\" <index-box_connectors>` is strictly for users "
"who are connecting from a different language such as C or Perl or Python — "
"other users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для "
"тех пользователей, которые хотят устанавливать соединение с Tarantool'ом с "
"помощью программ на других языках программирования (например C, Perl или "
"Python) — для прочих пользователей эта глава неактуальна."

#: ../book/intro.rst:61
msgid ""
":ref:`Chapter 7 \"FAQ\" <faq>` gives answers to some frequently asked "
"questions about Tarantool."
msgstr ""
":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто "
"задаваемые вопросы о Tarantool'е."

#: ../book/intro.rst:64
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` "
"materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive set "
"of comments in the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" <reference>`, :"
"ref:`\"Руководство участника проекта\" <contrib_guide>` и комментарии в "
"исходном коде."

#: ../book/intro.rst:70
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../book/intro.rst:72
msgid ""
"Please report bugs or make feature requests at http://github.com/tarantool/"
"tarantool/issues."
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый "
"функционал можно тут: http://github.com/tarantool/tarantool/issues"

#: ../book/intro.rst:74
msgid ""
"You can contact developers directly in `telegram <http://telegram.me/"
"tarantool>`_ or in a Tarantool discussion group (`English <https://groups."
"google.com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/"
"group/tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram "
"<http://telegram.me/tarantool>`_ или на форумах (`англоязычном <https://"
"groups.google.com/forum/#!forum/tarantool>`_ или `русскоязычном <https://"
"googlegroups.com/group/tarantool-ru>`_)."

#: ../book/user_guide_getting_started.rst:30
msgid "Getting started"
msgstr "Начало работы"

#: ../book/user_guide_getting_started.rst:32
msgid ""
"This chapter shows how to download, how to install, and how to start "
"Tarantool for the first time."
msgstr ""
"В этой главе рассказывается, как скачать, установить и начать работать с "
"Tarantool'ом с нуля."

#: ../book/user_guide_getting_started.rst:35
msgid ""
"For production, if possible, you should download a binary (executable) "
"package. This will ensure that you have the same build of the same version "
"that the developers have. That makes analysis easier if later you need to "
"report a problem, and avoids subtle problems that might happen if you used "
"different tools or different parameters when building from source. The "
"section about binaries is \":ref:`user_guide_getting_started-"
"downloading_and_installing_a_binary_package`\"."
msgstr ""
"Для промышленной эксплуатации рекомендуется скачать бинарный (исполняемый) "
"пакет. Тогда вы гарантированно получите сборку той же версии, что и у "
"разработчиков. Это существенно упростит поиск ошибок, если вам в будущем "
"понадобится помощь, а также позволит избежать проблем из-за того, что вы "
"использовали инструменты или параметры отличные от тех, что использовали при "
"сборке сами разработчики. См. раздел “:ref:`user_guide_getting_started-"
"downloading_and_installing_a_binary_package`”."

#: ../book/user_guide_getting_started.rst:42
msgid ""
"For development, you will want to download a source package and make the "
"binary by yourself using a C/C++ compiler and common tools. Although this is "
"a bit harder, it gives more control. And the source packages include "
"additional files, for example the Tarantool test suite. The section about "
"source is \":ref:`Building from source <building_from_source>`\" in :ref:"
"`Contributor's Guide <contrib_guide>`."
msgstr ""
"Для разработческих целей вы можете скачать исходные файлы и собрать бинарный "
"пакет самостоятельно с помощью компилятора C/C++ и обычных инструментов для "
"сборки. Хотя это и более трудный способ получить бинарный пакет, но он дает "
"вам больший контроль над результатом. Также в состав исходных файлов входят "
"дополнительные пакеты, например набор тестов для Tarantool'а. См. раздел \":"
"ref:`Сборка из исходных файлов <building_from_source>`\" в \":ref:"
"`Руководстве участника проекта <contrib_guide>`\"."

#: ../book/user_guide_getting_started.rst:49
msgid ""
"If the installation has already been done, then you should try it out. So "
"we've provided some instructions that you can use to make a temporary "
"“sandbox”. In a few minutes you can start the server and type in some "
"database-manipulation statements. The section about the sandbox is \":ref:"
"`user_guide_getting_started-first_database`\"."
msgstr ""
"После установки вы можете сразу опробовать Tarantool в действии. Ниже вы "
"найдете инструкции по созданию безопасной тестовой среды. Всего за несколько "
"минут вы сможете запустить Tarantool-сервер и задать несколько инструкций по "
"манипулированию данными. См. раздел \":ref:`user_guide_getting_started-"
"first_database`”."

#: ../book/user_guide_getting_started.rst:59
msgid "Downloading and installing a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../book/user_guide_getting_started.rst:61
msgid ""
"Binary packages for two Tarantool versions -- for the stable 1.6 and the "
"latest 1.7 -- are provided at http://tarantool.org/download.html. An "
"automatic build system creates, tests and publishes packages for every push "
"into the 1.7 branch."
msgstr ""
"Бинарные пакеты для двух версий Tarantool'а — стабильной 1.6 и самой свежей "
"1.7 — выложены на странице http://tarantool.org/download.html. При каждом "
"изменении исходного кода на GitHub (репозиторий http://github.com/tarantool/"
"tarantool, ветка \"1.7\") происходит сборка, автоматическое тестирование и "
"выкладка бинарных пакетов на вышеуказанную страницу."

#: ../book/user_guide_getting_started.rst:65
msgid ""
"To download and install the package that's appropriate for your OS, start a "
"shell (terminal) and enter the command-line instructions provided for your "
"OS at http://tarantool.org/download.html."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы, "
"откройте терминал с командной строкой и введите инструкции, которые даны для "
"вашей операционной системы на странице http://tarantool.org/download.html."

#: ../book/user_guide_getting_started.rst:73
msgid "Starting Tarantool and making your first database"
msgstr "Первичный запуск Tarantool'а и создание базы данных"

#: ../book/user_guide_getting_started.rst:75
#: ../book/user_guide_getting_started.rst:85
msgid "Here is how to create a simple test database after installing."
msgstr ""
"Далее рассказывается, как создать простую тестовую базу данных после "
"установки Tarantool'а."

#: ../book/user_guide_getting_started.rst:77
msgid ""
"Create a new directory. It's just for tests, you can delete it when the "
"tests are over."
msgstr ""
"Создайте новую директорию. Она понадобится только для тестовых целей, и ее "
"можно будет удалить по окончании экспериментов."

#: ../book/user_guide_getting_started.rst:80
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../book/user_guide_getting_started.rst:87
msgid "Start the server. The server name is tarantool."
msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#: ../book/user_guide_getting_started.rst:89
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary\n"
"$ # tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../book/user_guide_getting_started.rst:99
msgid ""
"The server starts in interactive mode and outputs a command prompt. To turn "
"on the database, :ref:`configure <box_introspection-box_cfg>` it. This "
"minimal example is sufficient:"
msgstr ""
"Tarantool-сервер запускается в интерактивном режиме и выводит приглашение "
"командной строки. Чтобы создать базу данных, задайте ее настройки с помощью "
"вызова :ref:`box.cfg <box_introspection-box_cfg>`. Вот пример минимальной "
"конфигурации:"

#: ../book/user_guide_getting_started.rst:103
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../book/user_guide_getting_started.rst:107
msgid ""
"If all goes well, you will see the server displaying progress as it "
"initializes, something like this:"
msgstr ""
"Если все в порядке, то Tarantool-сервер начнет в прогрессе отображать "
"процесс инициализации, например:"

#: ../book/user_guide_getting_started.rst:110
msgid ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"
msgstr ""
"tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
"inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"

#: ../book/user_guide_getting_started.rst:124
msgid ""
"Now that the server is up, you could start up a different shell and connect "
"to its primary port with:"
msgstr ""
"Поскольку Tarantool-сервер уже запущен, вы можете запустить новый терминал и "
"присоединиться к основному порту Tarantool-сервера, введя следующую команду:"

#: ../book/user_guide_getting_started.rst:127
msgid "$ telnet 0 3301"
msgstr "$ telnet 0 3301"

#: ../book/user_guide_getting_started.rst:131
msgid ""
"but for example purposes it is simpler to just leave the server running in "
"\"interactive mode\". On production machines the :ref:`interactive mode "
"<administration-using_tarantool_as_a_client>` is just for administrators, "
"but because it's convenient for learning it will be used for most examples "
"in this manual. Tarantool is waiting for the user to type instructions."
msgstr ""
"но пока что будет лучше оставить Tarantool-сервер работать в интерактивном "
"режиме. На промышленных серверах :ref:`интерактивный режим <administration-"
"using_tarantool_as_a_client>` нужен лишь для администрирования, однако для "
"наглядности большинство примеров в данном руководстве даны именно в "
"интерактивном режиме. Итак, Tarantool ждет от вас ввода инструкций."

#: ../book/user_guide_getting_started.rst:138
msgid ""
"To create the first space and the first :ref:`index <box_index>`, try this:"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../book/user_guide_getting_started.rst:140
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../book/user_guide_getting_started.rst:148
msgid ""
"To insert three “tuples” (our name for “records”) into the first “space” of "
"the database try this:"
msgstr ""
"Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство"
"\" (space) из вашей базы данных:"

#: ../book/user_guide_getting_started.rst:151
msgid ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../book/user_guide_getting_started.rst:157
msgid ""
"To select a tuple from the first space of the database, using the first "
"defined key, try this:"
msgstr ""
"Произведите выборку кортежа из первого пространства в базе по первому "
"указанному ключу:"

#: ../book/user_guide_getting_started.rst:160
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../book/user_guide_getting_started.rst:164
msgid "Your terminal screen should now look like this:"
msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#: ../book/user_guide_getting_started.rst:166
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog."
"inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog."
"inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../book/user_guide_getting_started.rst:190
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""
"Далее, чтобы подготовиться к тестовому примеру в следующем разделе, введите:"

#: ../book/user_guide_getting_started.rst:192
msgid ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../book/user_guide_getting_started.rst:198
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../book/user_guide_getting_started.rst:200
msgid ""
"In the previous section the first request was with ``box.cfg{listen = 3301}"
"``. The ``listen`` value can be any form of URI (uniform resource "
"identifier); in this case it's just a local port: port 3301. It's possible "
"to send requests to the listen URI via:"
msgstr ""
"В предыдущем разделе ваш первый запрос был :samp:`box.cfg{listen = 3301}`. "
"Значением ``listen`` может быть любой URI (универсальный код ресурса), в "
"данном случае — просто номер локального порта (3301). Вы можете отправлять "
"запросы на URI для прослушивания с помощью:"

#: ../book/user_guide_getting_started.rst:205
msgid "telnet,"
msgstr "telnet,"

#: ../book/user_guide_getting_started.rst:206
msgid ""
"a connector (which will be the subject of the \":ref:`index-box_connectors`"
"\" chapter),"
msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#: ../book/user_guide_getting_started.rst:208
msgid ""
"another instance of Tarantool via the :ref:`console module <console-module>`,"
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-"
"module>`, либо"

#: ../book/user_guide_getting_started.rst:209
msgid "``tarantoolctl connect``."
msgstr "``tarantoolctl connect``."

#: ../doc/book/user_guide_getting_started.rst:214
msgid "Let's try (4)."
msgstr ""

#: ../book/user_guide_getting_started.rst:213
msgid ""
"Switch to another terminal. On Linux, for example, this means starting "
"another instance of a Bash shell. There is no need to use cd to switch to "
"the ``~/tarantool_sandbox`` directory."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого нужно "
"запустить новый экземпляр Bash. При этом вам не потребуется вызывать cd, "
"чтобы переключиться на директорию :code:`~/tarantool_sandbox`."

#: ../doc/book/user_guide_getting_started.rst:220
msgid "Start the ``tarantoolctl`` utility:"
msgstr ""

#: ../book/user_guide_getting_started.rst:222
msgid ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"
msgstr ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"

#: ../doc/book/user_guide_getting_started.rst:227
msgid ""
"This means \"use :ref:`tarantoolctl connect <administration-"
"tarantoolctl_connect>` to connect to the Tarantool server that's listening "
"on ``localhost:3301``\"."
msgstr ""

#: ../book/user_guide_getting_started.rst:227
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../book/user_guide_getting_started.rst:232
msgid "tarantool> {**{box.space.tester:select{2}}**}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../book/user_guide_getting_started.rst:234
msgid ""
"This means \"send a request to that Tarantool server, and display the result"
"\". The result in this case is one of the tuples that was inserted earlier. "
"Your terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат на "
"экран.\" Результатом в данном случае будет один из кортежей, что вы "
"вставляли ранее. На терминале теперь должно отображаться примерно следующее:"

#: ../book/user_guide_getting_started.rst:238
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../doc/book/user_guide_getting_started.rst:252
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:255
msgid "When the testing is over:"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:257
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:258
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:259
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:261
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:262
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/book/user_guide_getting_started.rst:264
#: ../book/user_guide_getting_started.rst:256
msgid ""
"**To review...** If you followed all the instructions in this chapter, then "
"so far you have: installed Tarantool from a binary repository, started up "
"the Tarantool server, inserted and selected tuples."
msgstr ""

#: ../dev_guide/build_contribute_index.rst:28
msgid "Build and contribute"
msgstr "Сборка и участие в проекте"

#: ../dev_guide/building_documentation.rst:30
msgid "Building documentation"
msgstr "Сборка документации"

#: ../doc/dev_guide/building_documentation.rst:35
#: ../dev_guide/building_documentation.rst:32
msgid ""
"This documentation is built using a simplified markup system named "
"``Sphinx`` (see http://sphinx-doc.org). You can build a local version of "
"this documentation and contribute to it."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:39
#: ../dev_guide/building_documentation.rst:36
msgid "You need to install:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:41
#: ../dev_guide/building_documentation.rst:38
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:42
#: ../dev_guide/building_documentation.rst:39
msgid ""
"``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:43
#: ../dev_guide/building_documentation.rst:40
msgid ""
"``Python`` version greater than 2.6 -- preferably 2.7 -- and less than 3.0 "
"(Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:46
#: ../dev_guide/building_documentation.rst:43
msgid "Also, make sure to install the following Python modules:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:48
#: ../doc/dev_guide/building_from_source.rst:81
#: ../dev_guide/building_documentation.rst:45
#: ../dev_guide/building_from_source.rst:78
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:49
#: ../doc/dev_guide/building_from_source.rst:82
#: ../dev_guide/building_documentation.rst:46
#: ../dev_guide/building_from_source.rst:79
msgid "`dev <https://pypi.python.org/pypi/dev>`_, any version"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:50
#: ../doc/dev_guide/building_from_source.rst:83
#: ../dev_guide/building_documentation.rst:47
#: ../dev_guide/building_from_source.rst:80
msgid "`pyYAML <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:51
#: ../dev_guide/building_documentation.rst:48
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:52
#: ../dev_guide/building_documentation.rst:49
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:53
#: ../dev_guide/building_documentation.rst:50
msgid "`pelican <https://pypi.python.org/pypi/pelican>`_, any version"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:54
#: ../dev_guide/building_documentation.rst:51
msgid ""
"`BeautifulSoup <https://pypi.python.org/pypi/BeautifulSoup>`_, any version"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:55
#: ../doc/dev_guide/building_from_source.rst:86
#: ../dev_guide/building_documentation.rst:52
#: ../dev_guide/building_from_source.rst:83
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1b5"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:57
#: ../dev_guide/building_documentation.rst:54
msgid ""
"See installation details in the :ref:`build-from-source "
"<building_from_source>` section of this documentation. The procedure below "
"implies that all the prerequisites are met."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:61
#: ../dev_guide/building_documentation.rst:58
msgid ""
"Use ``git`` to download the latest source code of this documentation from "
"the GitHub repository ``tarantool/doc``, branch 1.7. For example, to a local "
"directory named `~/tarantool-doc`:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:65
#: ../dev_guide/building_documentation.rst:62
msgid "git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:69
#: ../dev_guide/building_documentation.rst:66
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:71
#: ../dev_guide/building_documentation.rst:68
msgid ""
"cd ~/tarantool-doc\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # start initiating"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:78
#: ../dev_guide/building_documentation.rst:75
msgid "Build a local version of the existing documentation package."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:80
#: ../dev_guide/building_documentation.rst:77
msgid ""
"Run the ``make`` command with an appropriate option to specify which "
"documentation version to build."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:83
#: ../dev_guide/building_documentation.rst:80
msgid ""
"cd ~/tarantool-doc\n"
"make all                # all versions\n"
"make sphinx-html        # multi-page English version\n"
"make sphinx-singlehtml  # one-page English version\n"
"make sphinx-html-ru     # multi-page Russian version\n"
"make sphinx-singlehtml  # one-page Russian version"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:92
#: ../dev_guide/building_documentation.rst:89
msgid "Documentation is created and stored at `/www/output`:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:94
#: ../dev_guide/building_documentation.rst:91
msgid "`/www/output/doc` (English versions)"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:95
#: ../dev_guide/building_documentation.rst:92
msgid "`/www/output/doc/ru` (Russian versions)"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:97
#: ../dev_guide/building_documentation.rst:94
msgid ""
"The entry point for each version is `index.html` file in the appropriate "
"directory."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:100
#: ../dev_guide/building_documentation.rst:97
msgid "Set up a web-server."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:102
#: ../dev_guide/building_documentation.rst:99
msgid ""
"Run the following command to set up a web-server (the example below is for "
"Ubuntu, but the procedure is similar for other supported OS's). Make sure to "
"run it from the documentation output folder, as specified below:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:106
#: ../dev_guide/building_documentation.rst:103
msgid ""
"cd ~/tarantool-doc/www/output\n"
"python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:111
#: ../dev_guide/building_documentation.rst:108
msgid ""
"Open your browser and enter ``127.0.0.1:8000/doc`` into the address box. If "
"your local documentation build is valid, the default version (English multi-"
"page) will be displayed in the browser."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:115
#: ../dev_guide/building_documentation.rst:112
msgid ""
"To contribute to documentation, use the ``.rst`` format for drafting and "
"submit your updates as \"Pull Requests\" via GitHub."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:118
#: ../dev_guide/building_documentation.rst:115
msgid ""
"To comply with the writing and formatting style, use the :ref:`guidelines "
"<documentation_guidelines>` provided in the documentation, common sense and "
"existing documents."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:122
#: ../dev_guide/building_documentation.rst:119
msgid "Notes:"
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:124
#: ../dev_guide/building_documentation.rst:121
msgid ""
"If you suggest creating a new documentation section (i.e., a whole new "
"page), it has to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/dev_guide/building_documentation.rst:127
#: ../dev_guide/building_documentation.rst:124
msgid ""
"If you want to contribute to localizing this documentation (e.g. into "
"Russian), add your translation strings to ``.po`` files stored in the "
"corresponding locale directory (e.g. ``/sphinx/locale/ru/LC_MESSAGES/`` for "
"Russian). See more about localizing with Sphinx at http://www.sphinx-doc.org/"
"en/stable/intl.html"
msgstr ""

#: ../dev_guide/building_from_source.rst:30
msgid "Building from source"
msgstr "Сборка из исходных файлов"

#: ../doc/dev_guide/building_from_source.rst:35
#: ../dev_guide/building_from_source.rst:32
msgid ""
"For downloading Tarantool source and building it, the platforms can differ "
"and the preferences can differ. But the steps are always the same. Here in "
"the manual we'll explain what the steps are, and after that you can look at "
"some example scripts on the Internet."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:40
#: ../dev_guide/building_from_source.rst:37
msgid ""
"Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:43
#: ../dev_guide/building_from_source.rst:40
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:45
#: ../dev_guide/building_from_source.rst:42
msgid ""
"A program for downloading source repositories. |br| For all platforms, this "
"is ``git``. It allows to download the latest complete set of source files "
"from the Tarantool repository at GitHub."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:49
#: ../dev_guide/building_from_source.rst:46
msgid ""
"A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version 4.6 "
"or later. On Mac OS X, this is ``Clang`` version 3.2 or later."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:52
#: ../dev_guide/building_from_source.rst:49
msgid ""
"A program for managing the build process. |br| For all platforms, this is "
"``CMake``. The CMake version should be 2.8 or later."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:55
#: ../dev_guide/building_from_source.rst:52
msgid ""
"Command-line interpreter for Python-based code (namely, for Tarantool test "
"suite). |br| For all platforms, this is ``python``. The Python version "
"should be greater than 2.6 -- preferably 2.7 -- and less than 3.0."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:59
#: ../dev_guide/building_from_source.rst:56
msgid ""
"Here are names of tools and libraries which may have to be installed in "
"advance, using ``sudo apt-get`` (for Ubuntu), ``sudo yum install`` (for "
"CentOS), or the equivalent on other platforms. Different platforms may use "
"slightly different names. Ignore the ones marked `optional, only in Mac OS "
"scripts` unless the platform is Mac OS."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:65
#: ../dev_guide/building_from_source.rst:62
msgid "**gcc** and **g++**, or **clang**        # see above"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:66
#: ../dev_guide/building_from_source.rst:63
msgid "**git**                                  # see above"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:67
#: ../dev_guide/building_from_source.rst:64
msgid "**cmake**                                # see above"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:68
#: ../dev_guide/building_from_source.rst:65
msgid "**python**                               # see above; for test suite"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:69
#: ../dev_guide/building_from_source.rst:66
msgid ""
"**libreadline-dev** or **libreadline6-dev** or **readline-devel**  # for "
"interactive mode"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:70
#: ../dev_guide/building_from_source.rst:67
msgid "**libssl-dev**                           # for `digest` module"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:71
#: ../dev_guide/building_from_source.rst:68
msgid ""
"**autoconf**                             # optional, only in Mac OS scripts"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:72
#: ../dev_guide/building_from_source.rst:69
msgid ""
"**zlib1g** or **zlib**                   # optional, only in Mac OS scripts"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:74
#: ../dev_guide/building_from_source.rst:71
msgid "Set up Python modules for running the test suite."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:76
#: ../dev_guide/building_from_source.rst:73
msgid ""
"This step is optional. Python modules are not necessary for building "
"Tarantool itself, unless you intend to use the \"Run the test suite\" option "
"in step 7."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:79
#: ../dev_guide/building_from_source.rst:76
msgid "You need the following Python modules:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:84
#: ../dev_guide/building_from_source.rst:81
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:85
#: ../dev_guide/building_from_source.rst:82
msgid ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version 0.4.6"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:87
#: ../dev_guide/building_from_source.rst:84
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:89
#: ../dev_guide/building_from_source.rst:86
msgid "On Ubuntu, you can get the modules from the repository:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:91
#: ../dev_guide/building_from_source.rst:88
msgid "sudo apt-get install python-pip python-dev python-yaml <...>"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:95
#: ../dev_guide/building_from_source.rst:92
msgid "On CentOS 6, you can likewise get the modules from the repository:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:97
#: ../dev_guide/building_from_source.rst:94
msgid "sudo yum install python26 python26-PyYAML <...>"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:101
#: ../dev_guide/building_from_source.rst:98
msgid ""
"If some modules are not available on a repository, it is best to set up the "
"modules by getting a tarball and doing the setup with ``python setup.py``, "
"thus:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:105
#: ../dev_guide/building_from_source.rst:102
msgid ""
"# On some machines, this initial command may be necessary:\n"
"# wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"# Python module for parsing YAML (pyYAML), for test suite:\n"
"# (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"# what the current version is.)\n"
"cd ~\n"
"wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"tar -xzf PyYAML-3.10.tar.gz\n"
"cd PyYAML-3.10\n"
"sudo python setup.py install"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:119
#: ../dev_guide/building_from_source.rst:116
msgid ""
"Finally, use Python :code:`pip` to bring in Python packages that may not be "
"up-to-date in the distro repositories. (On CentOS 7, it will be necessary to "
"install ``pip`` first, with :code:`sudo yum install epel-release` followed "
"by :code:`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:125
#: ../dev_guide/building_from_source.rst:122
msgid "pip install tarantool\\>0.4 --user"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:129
#: ../dev_guide/building_from_source.rst:126
msgid ""
"Use ``git`` to download the latest Tarantool source code from the GitHub "
"repository ``tarantool/tarantool``, branch 1.7. For example, to a local "
"directory named `~/tarantool`:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:133
#: ../dev_guide/building_from_source.rst:130
msgid "git clone https://github.com/tarantool/tarantool.git ~/tarantool"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:137
#: ../dev_guide/building_from_source.rst:134
msgid ""
"Use ``git`` again so that third-party contributions will be seen as well."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:139
#: ../dev_guide/building_from_source.rst:136
msgid "The build depends on the following external libraries:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:141
#: ../dev_guide/building_from_source.rst:138
msgid ""
"Readline development files (``libreadline-dev/readline-devel`` package)."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:142
#: ../dev_guide/building_from_source.rst:139
msgid "OpenSSL development files (``libssl-dev/openssl-devel`` package)."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:143
#: ../dev_guide/building_from_source.rst:140
msgid "``libyaml`` (``libyaml-dev/libyaml-devel`` package)."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:144
#: ../dev_guide/building_from_source.rst:141
msgid "``liblz4`` (``liblz4-dev/lz4-devel`` package)."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:145
#: ../dev_guide/building_from_source.rst:142
msgid ""
"GNU ``bfd`` which is the part of GNU ``binutils`` (``binutils-dev/binutils-"
"devel`` package)."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:148
#: ../dev_guide/building_from_source.rst:145
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:150
#: ../dev_guide/building_from_source.rst:147
msgid ""
"cd ~/tarantool\n"
"git submodule init\n"
"git submodule update --recursive\n"
"cd ../"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:157
#: ../dev_guide/building_from_source.rst:154
msgid ""
"On rare occasions, the submodules will need to be updated again with the "
"command:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:160
#: ../dev_guide/building_from_source.rst:157
msgid "git submodule update --init --recursive"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:164
#: ../dev_guide/building_from_source.rst:161
msgid ""
"Note: There is an alternative -- to say ``git clone --recursive`` earlier in "
"step 3, -- but we prefer the method above because it works with older "
"versions of ``git``."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:168
#: ../dev_guide/building_from_source.rst:165
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:170
#: ../dev_guide/building_from_source.rst:167
msgid ""
"cd ~/tarantool\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:177
#: ../dev_guide/building_from_source.rst:174
msgid ""
"On some platforms, it may be necessary to specify the C and C++ versions, "
"for example:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:180
#: ../dev_guide/building_from_source.rst:177
msgid "CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:184
#: ../dev_guide/building_from_source.rst:181
msgid ""
"The CMake option for specifying build type is :samp:`-"
"DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:187
#: ../dev_guide/building_from_source.rst:184
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:188
#: ../dev_guide/building_from_source.rst:185
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:189
#: ../dev_guide/building_from_source.rst:186
msgid ""
"``RelWithDebInfo`` -- used for production, also provides debugging "
"capabilities"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:191
#: ../dev_guide/building_from_source.rst:188
msgid ""
"The CMake option for hinting that the result will be distributed is :code:`-"
"DENABLE_DIST=ON`. If this option is on, then later ``make install`` will "
"install tarantoolctl files in addition to tarantool files."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:195
#: ../dev_guide/building_from_source.rst:192
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:197
#: ../dev_guide/building_from_source.rst:194
msgid "make"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:201
#: ../dev_guide/building_from_source.rst:198
msgid "This creates the 'tarantool' executable in the directory `src/`"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:203
#: ../dev_guide/building_from_source.rst:200
msgid ""
"Next, it's highly recommended to say ``make install`` to install Tarantool "
"to the `/usr/local` directory and keep your system clean. However, it is "
"possible to run the Tarantool executable without installation."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:207
#: ../dev_guide/building_from_source.rst:204
msgid "Run the test suite."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:209
#: ../dev_guide/building_from_source.rst:206
msgid ""
"This step is optional. Tarantool's developers always run the test suite "
"before they publish new versions. You should run the test suite too, if you "
"make any changes in the code. Assuming you downloaded to ``~/tarantool``, "
"the principal steps are:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:214
#: ../dev_guide/building_from_source.rst:211
msgid ""
"# make a subdirectory named `bin`\n"
"mkdir ~/tarantool/bin\n"
"# link python to bin (this may require superuser privilege)\n"
"ln /usr/bin/python ~/tarantool/bin/python\n"
"# get on the test subdirectory\n"
"cd ~/tarantool/test\n"
"# run tests using python\n"
"PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:225
#: ../dev_guide/building_from_source.rst:222
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:227
#: ../dev_guide/building_from_source.rst:224
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:240
#: ../dev_guide/building_from_source.rst:237
msgid "To prevent later confusion, clean up what's in the `bin` subdirectory:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:242
#: ../dev_guide/building_from_source.rst:239
msgid ""
"rm ~/tarantool/bin/python\n"
"rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:247
#: ../dev_guide/building_from_source.rst:244
msgid "Make an rpm package."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:249
#: ../dev_guide/building_from_source.rst:246
msgid ""
"This step is optional. It's only for people who want to redistribute "
"Tarantool. Package maintainers who want to build with ``rpmbuild`` should "
"consult the ``rpm-build`` instructions for the appropriate platform."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:253
#: ../dev_guide/building_from_source.rst:250
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:255
#: ../dev_guide/building_from_source.rst:252
msgid "tarantool $ ./src/tarantool"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:259
#: ../dev_guide/building_from_source.rst:256
msgid "This will start Tarantool in the interactive mode."
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:261
#: ../dev_guide/building_from_source.rst:258
msgid ""
"For your added convenience, we provide OS-specific README files with example "
"scripts at GitHub:"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:264
#: ../dev_guide/building_from_source.rst:261
msgid ""
"`README.FreeBSD <https://github.com/tarantool/tarantool/blob/1.7/README."
"FreeBSD>`_ for FreeBSD 10.1"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:266
#: ../dev_guide/building_from_source.rst:263
msgid ""
"`README.MacOSX <https://github.com/tarantool/tarantool/blob/1.7/README."
"MacOSX>`_ for Mac OS X `El Capitan`"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:268
#: ../dev_guide/building_from_source.rst:265
msgid ""
"`README.md <https://github.com/tarantool/tarantool/blob/1.7/README.md>`_ for "
"generic GNU/Linux"
msgstr ""

#: ../doc/dev_guide/building_from_source.rst:270
#: ../dev_guide/building_from_source.rst:267
msgid ""
"These example scripts assume that the intent is to download from the 1.7 "
"branch, build the server and run tests after build."
msgstr ""

#: ../dev_guide/c_style_guide.rst:28
msgid "C Style Guide"
msgstr "Соглашения по разработке на языке C"

#: ../doc/dev_guide/c_style_guide.rst:33 ../dev_guide/c_style_guide.rst:30
msgid ""
"The project's coding style is based on a version of the Linux kernel coding "
"style."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:35 ../dev_guide/c_style_guide.rst:32
msgid ""
"The latest version of the Linux style can be found at: http://www.kernel.org/"
"doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:38 ../dev_guide/c_style_guide.rst:35
msgid ""
"Since it is open for changes, the version of style that we follow, one from "
"2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:41 ../dev_guide/c_style_guide.rst:38
msgid ""
"There are a few additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:44 ../dev_guide/c_style_guide.rst:41
msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-"
"invent the kernel macros\" do not apply, since they are specific to Linux "
"kernel programming environment."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:49 ../dev_guide/c_style_guide.rst:46
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:53 ../dev_guide/c_style_guide.rst:50
msgid "General guidelines"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:55 ../dev_guide/c_style_guide.rst:52
msgid ""
"We use Git for revision control. The latest development is happening in the "
"'master' branch. Our git repository is hosted on github, and can be checked "
"out with git clone git://github.com/tarantool/tarantool.git # anonymous read-"
"only access"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:59 ../dev_guide/c_style_guide.rst:56
msgid ""
"If you have any questions about Tarantool internals, please post them on the "
"developer discussion list, https://groups.google.com/forum/#!forum/"
"tarantool. However, please be warned: Launchpad silently deletes posts from "
"non-subscribed members, thus please be sure to have subscribed to the list "
"prior to posting. Additionally, some engineers are always present on "
"#tarantool channel on irc.freenode.net."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:67 ../dev_guide/c_style_guide.rst:64
msgid "Commenting style"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:69 ../dev_guide/c_style_guide.rst:66
msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than `\\tag`. "
"The main tags in use are @param, @retval, @return, @see, @note and @todo."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:72 ../dev_guide/c_style_guide.rst:69
msgid ""
"Every function, except perhaps a very short and obvious one, should have a "
"comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:75 ../dev_guide/c_style_guide.rst:72
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:90 ../dev_guide/c_style_guide.rst:87
msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:94 ../dev_guide/c_style_guide.rst:91
msgid "Header files"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:96 ../dev_guide/c_style_guide.rst:93
msgid ""
"Use header guards. Put the header guard in the first line in the header, "
"before the copyright or declarations. Use all-uppercase name for the header "
"guard. Derive the header guard name from the file name, and append _INCLUDED "
"to get a macro name. For example, core/log_io.h -> CORE_LOG_IO_H_INCLUDED. "
"In ``.c`` (implementation) file, include the respective declaration header "
"before all other headers, to ensure that the header is self- sufficient. "
"Header \"header.h\" is self-sufficient if the following compiles without "
"errors:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:104 ../dev_guide/c_style_guide.rst:101
msgid "#include \"header.h\""
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:110 ../dev_guide/c_style_guide.rst:107
msgid "Allocating memory"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:112 ../dev_guide/c_style_guide.rst:109
msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to malloc()/"
"free() for any performance-intensive or large  memory allocations. "
"Repetitive use of malloc()/free() can lead to memory fragmentation and "
"should therefore be avoided."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:116 ../dev_guide/c_style_guide.rst:113
msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"free() the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a plug-"
"in can be dynamically loaded and unloaded multiple times, reload should not "
"lead to a memory leak."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:124 ../dev_guide/c_style_guide.rst:121
msgid "Other"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:126 ../dev_guide/c_style_guide.rst:123
msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and "
"statements, use true and false."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:129 ../dev_guide/c_style_guide.rst:126
msgid ""
"The not-so-current list of all GCC C extensions can be found at: http://gcc."
"gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:134 ../dev_guide/c_style_guide.rst:131
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:136 ../dev_guide/c_style_guide.rst:133
msgid ""
"This is a short document describing the preferred coding style for the linux "
"kernel.  Coding style is very personal, and I won't _force_ my views on "
"anybody, but this is what goes for anything that I have to be able to "
"maintain, and I'd prefer it for most other things too.  Please at least "
"consider the points made here."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:142 ../dev_guide/c_style_guide.rst:139
msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, and "
"NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:145 ../dev_guide/c_style_guide.rst:142
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:149 ../dev_guide/c_style_guide.rst:146
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:151 ../dev_guide/c_style_guide.rst:148
msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There "
"are heretic movements that try to make indentations 4 (or even 2!) "
"characters deep, and that is akin to trying to define the value of PI to be "
"3."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:156 ../dev_guide/c_style_guide.rst:153
msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a "
"block of control starts and ends.  Especially when you've been looking at "
"your screen for 20 straight hours, you'll find it a lot easier to see how "
"the indentation works if you have large indentations."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:161 ../dev_guide/c_style_guide.rst:158
msgid ""
"Now, some people will claim that having 8-character indentations makes the "
"code move too far to the right, and makes it hard to read on a 80-character "
"terminal screen.  The answer to that is that if you need more than 3 levels "
"of indentation, you're screwed anyway, and should fix your program."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:167 ../dev_guide/c_style_guide.rst:164
msgid ""
"In short, 8-char indents make things easier to read, and have the added "
"benefit of warning you when you're nesting your functions too deep. Heed "
"that warning."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:171 ../dev_guide/c_style_guide.rst:168
msgid ""
"The preferred way to ease multiple indentation levels in a switch statement "
"is to align the \"switch\" and its subordinate \"case\" labels in the same "
"column instead of \"double-indenting\" the \"case\" labels. e.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:175 ../dev_guide/c_style_guide.rst:172
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:195 ../dev_guide/c_style_guide.rst:192
msgid ""
"Don't put multiple statements on a single line unless you have something to "
"hide:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:198 ../dev_guide/c_style_guide.rst:195
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:203 ../dev_guide/c_style_guide.rst:200
msgid ""
"Don't put multiple assignments on a single line either. Kernel coding style "
"is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:206 ../dev_guide/c_style_guide.rst:203
msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are never "
"used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:209 ../dev_guide/c_style_guide.rst:206
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:214 ../dev_guide/c_style_guide.rst:211
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:216 ../dev_guide/c_style_guide.rst:213
msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:219 ../dev_guide/c_style_guide.rst:216
msgid ""
"The limit on the length of lines is 80 columns and this is a strongly "
"preferred limit."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:222 ../dev_guide/c_style_guide.rst:219
msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are placed "
"substantially to the right. The same applies to function headers with a long "
"argument list. Long strings are as well broken into shorter strings. The "
"only exception to this is where exceeding 80 columns significantly increases "
"readability and does not hide information."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:229 ../dev_guide/c_style_guide.rst:226
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:243 ../dev_guide/c_style_guide.rst:240
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:245 ../dev_guide/c_style_guide.rst:242
msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces.  Unlike the indent size, there are few technical reasons to choose "
"one placement strategy over the other, but the preferred way, as shown to us "
"by the prophets Kernighan and Ritchie, is to put the opening brace last on "
"the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:251 ../dev_guide/c_style_guide.rst:248
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:257 ../dev_guide/c_style_guide.rst:254
msgid ""
"This applies to all non-function statement blocks (if, switch, for, while, "
"do). e.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:260 ../dev_guide/c_style_guide.rst:257
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:273 ../dev_guide/c_style_guide.rst:270
msgid ""
"However, there is one special case, namely functions: they have the opening "
"brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:276 ../dev_guide/c_style_guide.rst:273
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:283 ../dev_guide/c_style_guide.rst:280
msgid ""
"Heretic people all over the world have claimed that this inconsistency "
"is ...  well ...  inconsistent, but all right-thinking people know that (a) "
"K&R are _right_ and (b) K&R are right.  Besides, functions are special "
"anyway (you can't nest them in C)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:288 ../dev_guide/c_style_guide.rst:285
msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in the "
"cases where it is followed by a continuation of the same statement, ie a "
"\"while\" in a do-statement or an \"else\" in an if-statement, like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:293 ../dev_guide/c_style_guide.rst:290
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:299 ../dev_guide/c_style_guide.rst:296
msgid "and"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:301 ../dev_guide/c_style_guide.rst:298
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:311 ../dev_guide/c_style_guide.rst:308
msgid "Rationale: K&R."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:313 ../dev_guide/c_style_guide.rst:310
msgid ""
"Also, note that this brace-placement also minimizes the number of empty (or "
"almost empty) lines, without any loss of readability.  Thus, as the supply "
"of new-lines on your screen is not a renewable resource (think 25-line "
"terminal screens here), you have more empty lines to put comments on."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:319 ../dev_guide/c_style_guide.rst:316
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:321 ../dev_guide/c_style_guide.rst:318
msgid ""
"if (condition)\n"
"    action();"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:326 ../dev_guide/c_style_guide.rst:323
msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:329 ../dev_guide/c_style_guide.rst:326
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:340 ../dev_guide/c_style_guide.rst:337
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:342 ../dev_guide/c_style_guide.rst:339
msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-"
"keyword usage.  Use a space after (most) keywords.  The notable exceptions "
"are sizeof, typeof, alignof, and __attribute__, which look somewhat like "
"functions (and are usually used with parentheses in Linux, although they are "
"not required in the language, as in: \"sizeof info\" after \"struct fileinfo "
"info;\" is declared)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:349 ../dev_guide/c_style_guide.rst:346
msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but "
"not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:352 ../dev_guide/c_style_guide.rst:349
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:356 ../dev_guide/c_style_guide.rst:353
msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example is "
"**bad**:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:359 ../dev_guide/c_style_guide.rst:356
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:363 ../dev_guide/c_style_guide.rst:360
msgid ""
"When declaring pointer data or a function that returns a pointer type, the "
"preferred use of '*' is adjacent to the data name or function name and not "
"adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:367 ../dev_guide/c_style_guide.rst:364
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:373 ../dev_guide/c_style_guide.rst:370
msgid ""
"Use one space around (on each side of) most binary and ternary operators, "
"such as any of these:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:376 ../dev_guide/c_style_guide.rst:373
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:378 ../dev_guide/c_style_guide.rst:375
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:380 ../dev_guide/c_style_guide.rst:377
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:382 ../dev_guide/c_style_guide.rst:379
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:384
#: ../doc/dev_guide/c_style_guide.rst:388 ../dev_guide/c_style_guide.rst:381
#: ../dev_guide/c_style_guide.rst:385
msgid "++  --"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:386 ../dev_guide/c_style_guide.rst:383
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:390 ../dev_guide/c_style_guide.rst:387
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:392 ../dev_guide/c_style_guide.rst:389
msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with "
"\"smart\" indentation will insert whitespace at the beginning of new lines "
"as appropriate, so you can start typing the next line of code right away. "
"However, some such editors do not remove the whitespace if you end up not "
"putting a line of code there, such as if you leave a blank line.  As a "
"result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:399 ../dev_guide/c_style_guide.rst:396
msgid ""
"Git will warn you about patches that introduce trailing whitespace, and can "
"optionally strip the trailing whitespace for you; however, if applying a "
"series of patches, this may make later patches in the series fail by "
"changing their context lines."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:407 ../dev_guide/c_style_guide.rst:404
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:409 ../dev_guide/c_style_guide.rst:406
msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 and "
"Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable "
"\"tmp\", which is much easier to write, and not the least more difficult to "
"understand."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:415 ../dev_guide/c_style_guide.rst:412
msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must.  To call a global function \"foo\" is a "
"shooting offense."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:419 ../dev_guide/c_style_guide.rst:416
msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have "
"descriptive names, as do global functions.  If you have a function that "
"counts the number of active users, you should call that "
"\"count_active_users()\" or similar, you should _not_ call it \"cntusr()\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:424 ../dev_guide/c_style_guide.rst:421
msgid ""
"Encoding the type of a function into the name (so-called Hungarian notation) "
"is brain damaged - the compiler knows the types anyway and can check those, "
"and it only confuses the programmer.  No wonder MicroSoft makes buggy "
"programs."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:429 ../dev_guide/c_style_guide.rst:426
msgid ""
"LOCAL variable names should be short, and to the point.  If you have some "
"random integer loop counter, it should probably be called \"i\". Calling it "
"\"loop_counter\" is non-productive, if there is no chance of it being mis-"
"understood.  Similarly, \"tmp\" can be just about any type of variable that "
"is used to hold a temporary value."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:435 ../dev_guide/c_style_guide.rst:432
msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. See "
"chapter 6 (Functions)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:442 ../dev_guide/c_style_guide.rst:439
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:444 ../dev_guide/c_style_guide.rst:441
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:446 ../dev_guide/c_style_guide.rst:443
msgid ""
"It's a _mistake_ to use typedef for structures and pointers. When you see a"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:448 ../dev_guide/c_style_guide.rst:445
msgid "vps_t a;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:452 ../dev_guide/c_style_guide.rst:449
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:454 ../dev_guide/c_style_guide.rst:451
msgid "In contrast, if it says"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:456 ../dev_guide/c_style_guide.rst:453
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:460 ../dev_guide/c_style_guide.rst:457
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:462 ../dev_guide/c_style_guide.rst:459
msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are "
"useful only for:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:465 ../dev_guide/c_style_guide.rst:462
msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what "
"the object is)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:468 ../dev_guide/c_style_guide.rst:465
msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the "
"proper accessor functions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:471 ../dev_guide/c_style_guide.rst:468
msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. The "
"reason we have them for things like pte_t etc. is that there really is "
"absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:475 ../dev_guide/c_style_guide.rst:472
msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion whether "
"it is \"int\" or \"long\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:478 ../dev_guide/c_style_guide.rst:475
msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category (d) "
"better than here."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:481 ../dev_guide/c_style_guide.rst:478
msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is "
"\"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:484 ../dev_guide/c_style_guide.rst:481
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:488 ../dev_guide/c_style_guide.rst:485
msgid ""
"but if there is a clear reason for why it under certain circumstances might "
"be an \"unsigned int\" and under other configurations might be \"unsigned "
"long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:492 ../dev_guide/c_style_guide.rst:489
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:495 ../dev_guide/c_style_guide.rst:492
msgid ""
"New types which are identical to standard C99 types, in certain exceptional "
"circumstances."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:498 ../dev_guide/c_style_guide.rst:495
msgid ""
"Although it would only take a short amount of time for the eyes and brain to "
"become accustomed to the standard types like 'uint32_t', some people object "
"to their use anyway."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:502 ../dev_guide/c_style_guide.rst:499
msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- although "
"they are not mandatory in new code of your own."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:507 ../dev_guide/c_style_guide.rst:504
msgid ""
"When editing existing code which already uses one or the other set of types, "
"you should conform to the existing choices in that code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:510 ../dev_guide/c_style_guide.rst:507
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:512 ../dev_guide/c_style_guide.rst:509
msgid ""
"In certain structures which are visible to userspace, we cannot require C99 "
"types and cannot use the 'u32' form above. Thus, we use __u32 and similar "
"types in all structures which are shared with userspace."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:517 ../dev_guide/c_style_guide.rst:514
msgid ""
"Maybe there are other cases too, but the rule should basically be to NEVER "
"EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:520 ../dev_guide/c_style_guide.rst:517
msgid ""
"In general, a pointer, or a struct that has elements that can reasonably be "
"directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:526 ../dev_guide/c_style_guide.rst:523
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:528 ../dev_guide/c_style_guide.rst:525
msgid ""
"Functions should be short and sweet, and do just one thing.  They should fit "
"on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, as we "
"all know), and do one thing and do that well."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:532 ../dev_guide/c_style_guide.rst:529
msgid ""
"The maximum length of a function is inversely proportional to the complexity "
"and indentation level of that function.  So, if you have a conceptually "
"simple function that is just one long (but simple) case-statement, where you "
"have to do lots of small things for a lot of different cases, it's OK to "
"have a longer function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:538 ../dev_guide/c_style_guide.rst:535
msgid ""
"However, if you have a complex function, and you suspect that a less-than-"
"gifted first-year high-school student might not even understand what the "
"function is all about, you should adhere to the maximum limits all the more "
"closely.  Use helper functions with descriptive names (you can ask the "
"compiler to in-line them if you think it's performance-critical, and it will "
"probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:546 ../dev_guide/c_style_guide.rst:543
msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the "
"function, and split it into smaller pieces.  A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confu/sed.  You know you're brilliant, but maybe you'd like to understand "
"what you did 2 weeks from now."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:553 ../dev_guide/c_style_guide.rst:550
msgid ""
"In source files, separate functions with one blank line.  If the function is "
"exported, the EXPORT* macro for it should follow immediately after the "
"closing function brace line.  E.g.:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:557 ../dev_guide/c_style_guide.rst:554
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:565 ../dev_guide/c_style_guide.rst:562
msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in Linux "
"because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:571 ../dev_guide/c_style_guide.rst:568
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:573 ../dev_guide/c_style_guide.rst:570
msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is "
"used frequently by compilers in form of the unconditional jump instruction."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:576 ../dev_guide/c_style_guide.rst:573
msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:579 ../dev_guide/c_style_guide.rst:576
msgid "The rationale is:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:581 ../dev_guide/c_style_guide.rst:578
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:582 ../dev_guide/c_style_guide.rst:579
msgid "nesting is reduced"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:583 ../dev_guide/c_style_guide.rst:580
msgid ""
"errors by not updating individual exit points when making modifications are "
"prevented"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:585 ../dev_guide/c_style_guide.rst:582
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:587 ../dev_guide/c_style_guide.rst:584
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:612 ../dev_guide/c_style_guide.rst:609
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:614 ../dev_guide/c_style_guide.rst:611
msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER try "
"to explain HOW your code works in a comment: it's much better to write the "
"code so that the _working_ is obvious, and it's a waste of time to explain "
"badly written code. с Generally, you want your comments to tell WHAT your "
"code does, not HOW. Also, try to avoid putting comments inside a function "
"body: if the function is so complex that you need to separately comment "
"parts of it, you should probably go back to chapter 6 for a while.  You can "
"make small comments to note or warn about something particularly clever (or "
"ugly), but try to avoid excess.  Instead, put the comments at the head of "
"the function, telling people what it does, and possibly WHY it does it."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:628 ../dev_guide/c_style_guide.rst:625
msgid ""
"When commenting the kernel API functions, please use the kernel-doc format. "
"See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts/kernel-doc "
"for details."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:632 ../dev_guide/c_style_guide.rst:629
msgid ""
"Linux style for comments is the C89 ``\"/\\* ... \\*/\"`` style. Don't use "
"C99-style ``\"// ...\"`` comments."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:635 ../dev_guide/c_style_guide.rst:632
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:637 ../dev_guide/c_style_guide.rst:634
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:648 ../dev_guide/c_style_guide.rst:645
msgid ""
"It's also important to comment data, whether they are basic types or derived "
"types.  To this end, use just one data declaration per line (no commas for "
"multiple data declarations).  This leaves you room for a small comment on "
"each item, explaining its use."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:655 ../dev_guide/c_style_guide.rst:652
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:657 ../dev_guide/c_style_guide.rst:654
msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix user "
"helper that \"GNU emacs\" automatically formats the C sources for you, and "
"you've noticed that yes, it does do that, but the defaults it uses are less "
"than desirable (in fact, they are worse than random typing - an infinite "
"number of monkeys typing into GNU emacs would never make a good program)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:664 ../dev_guide/c_style_guide.rst:661
msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner values.  "
"To do the latter, you can stick the following in your .emacs file:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:667 ../dev_guide/c_style_guide.rst:664
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-trees"
"\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:698 ../dev_guide/c_style_guide.rst:695
msgid ""
"This will make emacs go better with the kernel coding style for C files "
"below ~/src/linux-trees."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:701 ../dev_guide/c_style_guide.rst:698
msgid ""
"But even if you fail in getting emacs to do sane formatting, not everything "
"is lost: use \"indent\"."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:704 ../dev_guide/c_style_guide.rst:701
msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs has, "
"which is why you need to give it a few command line options. However, that's "
"not too bad, because even the makers of GNU indent recognize the authority "
"of K&R (the GNU people aren't evil, they are just severely misguided in this "
"matter), so you just give indent the options \"-kr -i8\" (stands for \"K&R, "
"8 character indents\"), or use \"scripts/Lindent\", which indents in the "
"latest style."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:712 ../dev_guide/c_style_guide.rst:709
msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment re-"
"formatting you may want to take a look at the man page.  But remember: "
"\"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:719 ../dev_guide/c_style_guide.rst:716
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:721 ../dev_guide/c_style_guide.rst:718
msgid ""
"For all of the Kconfig* configuration files throughout the source tree, the "
"indentation is somewhat different.  Lines under a \"config\" definition are "
"indented with one tab, while help text is indented an additional two spaces. "
"Example:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:726 ../dev_guide/c_style_guide.rst:723
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:737 ../dev_guide/c_style_guide.rst:734
msgid ""
"Features that might still be considered unstable should be defined as "
"dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:740 ../dev_guide/c_style_guide.rst:737
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:747 ../dev_guide/c_style_guide.rst:744
msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:750 ../dev_guide/c_style_guide.rst:747
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:757 ../dev_guide/c_style_guide.rst:754
msgid ""
"For full documentation on the configuration files, see the file "
"Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:763 ../dev_guide/c_style_guide.rst:760
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:765 ../dev_guide/c_style_guide.rst:762
msgid ""
"Data structures that have visibility outside the single-threaded environment "
"they are created and destroyed in should always have reference counts.  In "
"the kernel, garbage collection doesn't exist (and outside the kernel garbage "
"collection is slow and inefficient), which means that you absolutely _have_ "
"to reference count all your uses."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:771 ../dev_guide/c_style_guide.rst:768
msgid ""
"Reference counting means that you can avoid locking, and allows multiple "
"users to have access to the data structure in parallel - and not having to "
"worry about the structure suddenly going away from under them just because "
"they slept or did something else for a while."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:776 ../dev_guide/c_style_guide.rst:773
msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking is "
"used to keep data structures coherent, while reference counting is a memory "
"management technique.  Usually both are needed, and they are not to be "
"confused with each other."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:781 ../dev_guide/c_style_guide.rst:778
msgid ""
"Many data structures can indeed have two levels of reference counting, when "
"there are users of different \"classes\".  The subclass count counts the "
"number of subclass users, and decrements the global count just once when the "
"subclass count goes to zero."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:786 ../dev_guide/c_style_guide.rst:783
msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found in "
"memory management (\"struct mm_struct\": mm_users and mm_count), and in "
"filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:790 ../dev_guide/c_style_guide.rst:787
msgid ""
"Remember: if another thread can find your data structure, and you don't have "
"a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:795 ../dev_guide/c_style_guide.rst:792
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:797 ../dev_guide/c_style_guide.rst:794
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:799 ../dev_guide/c_style_guide.rst:796
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:803 ../dev_guide/c_style_guide.rst:800
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:805 ../dev_guide/c_style_guide.rst:802
msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions may "
"be named in lower case."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:808 ../dev_guide/c_style_guide.rst:805
msgid ""
"Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:810 ../dev_guide/c_style_guide.rst:807
msgid ""
"Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:812 ../dev_guide/c_style_guide.rst:809
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:820 ../dev_guide/c_style_guide.rst:817
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:822 ../dev_guide/c_style_guide.rst:819
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:824 ../dev_guide/c_style_guide.rst:821
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:832 ../dev_guide/c_style_guide.rst:829
msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the \"calling"
"\" function; don't break the internal parsers of those who will read the "
"code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:835 ../dev_guide/c_style_guide.rst:832
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:837 ../dev_guide/c_style_guide.rst:834
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:841 ../dev_guide/c_style_guide.rst:838
msgid ""
"might look like a good thing, but it's confusing as hell when one reads the "
"code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:844 ../dev_guide/c_style_guide.rst:841
msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite you "
"if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:847 ../dev_guide/c_style_guide.rst:844
msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with "
"macros using parameters."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:851 ../dev_guide/c_style_guide.rst:848
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:856 ../dev_guide/c_style_guide.rst:853
msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual also "
"covers RTL which is used frequently with assembly language in the kernel."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:861 ../dev_guide/c_style_guide.rst:858
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:863 ../dev_guide/c_style_guide.rst:860
msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of "
"kernel messages to make a good impression. Do not use crippled words like "
"\"dont\"; use \"do not\" or \"don't\" instead.  Make the messages concise, "
"clear, and unambiguous."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:868 ../dev_guide/c_style_guide.rst:865
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:870 ../dev_guide/c_style_guide.rst:867
#, python-format
msgid ""
"Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:872 ../dev_guide/c_style_guide.rst:869
msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> "
"which you should use to make sure messages are matched to the right device "
"and driver, and are tagged with the right level:  dev_err(), dev_warn(), "
"dev_info(), and so forth.  For messages that aren't associated with a "
"particular device, <linux/kernel.h> defines pr_debug() and pr_info()."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:878 ../dev_guide/c_style_guide.rst:875
msgid ""
"Coming up with good debugging messages can be quite a challenge; and once "
"you have them, they can be a huge help for remote troubleshooting.  Such "
"messages should be compiled out when the DEBUG symbol is not defined (that "
"is, by default they are not included).  When you use dev_dbg() or "
"pr_debug(), that's automatic.  Many subsystems have Kconfig options to turn "
"on -DDEBUG. A related convention uses VERBOSE_DEBUG to add dev_vdbg() "
"messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:888 ../dev_guide/c_style_guide.rst:885
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:890 ../dev_guide/c_style_guide.rst:887
msgid ""
"The kernel provides the following general purpose memory allocators: "
"kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API "
"documentation for further information about them."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:894 ../dev_guide/c_style_guide.rst:891
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:896 ../dev_guide/c_style_guide.rst:893
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:900 ../dev_guide/c_style_guide.rst:897
msgid ""
"The alternative form where struct name is spelled out hurts readability and "
"introduces an opportunity for a bug when the pointer variable type is "
"changed but the corresponding sizeof that is passed to a memory allocator is "
"not."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:904 ../dev_guide/c_style_guide.rst:901
msgid ""
"Casting the return value which is a void pointer is redundant. The "
"conversion from void pointer to any other pointer type is guaranteed by the "
"C programming language."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:910 ../dev_guide/c_style_guide.rst:907
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:912 ../dev_guide/c_style_guide.rst:909
msgid ""
"There appears to be a common misperception that gcc has a magic \"make me "
"faster\" speedup option called \"inline\". While the use of inlines can be "
"appropriate (for example as a means of replacing macros, see Chapter 12), it "
"very often is not. Abundant use of the inline keyword leads to a much bigger "
"kernel, which in turn slows the system as a whole down, due to a bigger "
"icache footprint for the CPU and simply because there is less memory "
"available for the pagecache. Just think about it; a pagecache miss causes a "
"disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles "
"that can go into these 5 milliseconds."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:922 ../dev_guide/c_style_guide.rst:919
msgid ""
"A reasonable rule of thumb is to not put inline at functions that have more "
"than 3 lines of code in them. An exception to this rule are the cases where "
"a parameter is known to be a compiletime constant, and as a result of this "
"constantness you *know* the compiler will be able to optimize most of your "
"function away at compile time. For a good example of this later case, see "
"the kmalloc() inline function."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:929 ../dev_guide/c_style_guide.rst:926
msgid ""
"Often people argue that adding inline to functions that are static and used "
"only once is always a win since there is no space tradeoff. While this is "
"technically correct, gcc is capable of inlining these automatically without "
"help, and the maintenance issue of removing the inline when a second user "
"appears outweighs the potential value of the hint that tells gcc to do "
"something it would have done anyway."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:938 ../dev_guide/c_style_guide.rst:935
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:940 ../dev_guide/c_style_guide.rst:937
msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed.  Such "
"a value can be represented as an error-code integer (-Exxx = failure, 0 = "
"success) or a \"succeeded\" boolean (0 = failure, non-zero = success)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:946 ../dev_guide/c_style_guide.rst:943
msgid ""
"Mixing up these two sorts of representations is a fertile source of "
"difficult-to-find bugs.  If the C language included a strong distinction "
"between integers and booleans then the compiler would find these mistakes "
"for us... but it doesn't.  To help prevent such bugs, always follow this "
"convention:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:954 ../dev_guide/c_style_guide.rst:951
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:958 ../dev_guide/c_style_guide.rst:955
msgid ""
"For example, \"add work\" is a command, and the add_work() function returns "
"0 for success or -EBUSY for failure.  In the same way, \"PCI device present"
"\" is a predicate, and the pci_dev_present() function returns 1 if it "
"succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:963 ../dev_guide/c_style_guide.rst:960
msgid ""
"All EXPORTed functions must respect this convention, and so should all "
"public functions.  Private (static) functions need not, but it is "
"recommended that they do."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:967 ../dev_guide/c_style_guide.rst:964
msgid ""
"Functions whose return value is the actual result of a computation, rather "
"than an indication of whether the computation succeeded, are not subject to "
"this rule.  Generally they indicate failure by returning some out-of-range "
"result.  Typical examples would be functions that return pointers; they use "
"NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:976 ../dev_guide/c_style_guide.rst:973
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:978 ../dev_guide/c_style_guide.rst:975
msgid ""
"The header file include/linux/kernel.h contains a number of macros that you "
"should use, rather than explicitly coding some variant of them yourself. For "
"example, if you need to calculate the length of an array, take advantage of "
"the macro"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:983 ../dev_guide/c_style_guide.rst:980
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:987 ../dev_guide/c_style_guide.rst:984
msgid ""
"Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:989 ../dev_guide/c_style_guide.rst:986
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:993 ../dev_guide/c_style_guide.rst:990
msgid ""
"There are also min() and max() macros that do strict type checking if you "
"need them.  Feel free to peruse that header file to see what else is already "
"defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:999 ../dev_guide/c_style_guide.rst:996
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1001 ../dev_guide/c_style_guide.rst:998
msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers.  For example, emacs interprets lines "
"marked like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1005 ../dev_guide/c_style_guide.rst:1002
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1009 ../dev_guide/c_style_guide.rst:1006
msgid "Or like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1011 ../dev_guide/c_style_guide.rst:1008
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1019 ../dev_guide/c_style_guide.rst:1016
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1021 ../dev_guide/c_style_guide.rst:1018
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1025 ../dev_guide/c_style_guide.rst:1022
msgid ""
"Do not include any of these in source files.  People have their own personal "
"editor configurations, and your source files should not override them.  This "
"includes markers for indentation and mode configuration.  People may use "
"their own custom mode, or may have some other magic method for making "
"indentation work correctly."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1033 ../dev_guide/c_style_guide.rst:1030
msgid "Appendix I: References"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1035 ../dev_guide/c_style_guide.rst:1032
msgid ""
"`The C Programming Language, Second Edition <https://en.wikipedia.org/wiki/"
"The_C_Programming_Language>`_ by Brian W. Kernighan and Dennis M. Ritchie. |"
"br| Prentice Hall, Inc., 1988. |br| ISBN 0-13-110362-8 (paperback), "
"0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1040 ../dev_guide/c_style_guide.rst:1037
msgid ""
"`The Practice of Programming <https://en.wikipedia.org/wiki/"
"The_Practice_of_Programming>`_ by Brian W. Kernighan and Rob Pike. |br| "
"Addison-Wesley, Inc., 1999. |br| ISBN 0-201-61586-X."
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1045 ../dev_guide/c_style_guide.rst:1042
msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with K&R "
"and this text - for **cpp**, **gcc**, **gcc internals** and **indent**"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1048 ../dev_guide/c_style_guide.rst:1045
msgid ""
"`WG14 International standardization workgroup for the programming language C "
"<http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/dev_guide/c_style_guide.rst:1051 ../dev_guide/c_style_guide.rst:1048
msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 <http://www.kroah.com/"
"linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../dev_guide/developer_guidelines.rst:28
msgid "Developer guidelines"
msgstr "Соглашения по разработке"

#: ../doc/dev_guide/developer_guidelines.rst:35
#: ../dev_guide/developer_guidelines.rst:32
msgid "How to work on a bug"
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:37
#: ../dev_guide/developer_guidelines.rst:34
msgid ""
"Any defect, even minor, if it changes the user-visible server behavior, "
"needs a bug report. Report a bug at http://github.com/tarantool/tarantool/"
"issues."
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:40
#: ../dev_guide/developer_guidelines.rst:37
msgid ""
"When reporting a bug, try to come up with a test case right away. Set the "
"current maintenance milestone for the bug fix, and specify the series. "
"Assign the bug to yourself. Put the status to 'In progress' Once the patch "
"is ready, put the bug the bug to 'In review' and solicit a review for the "
"fix."
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:45
#: ../dev_guide/developer_guidelines.rst:42
msgid ""
"Once there is a positive code review, push the patch and set the status to "
"'Closed'"
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:47
#: ../dev_guide/developer_guidelines.rst:44
msgid ""
"Patches for bugs should contain a reference to the respective Launchpad bug "
"page or at least bug id. Each patch should have a test, unless coming up "
"with one is difficult in the current framework, in which case QA should be "
"alerted."
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:51
#: ../dev_guide/developer_guidelines.rst:48
msgid ""
"There are two things you need to do when your patch makes it into the master:"
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:53
#: ../dev_guide/developer_guidelines.rst:50
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/dev_guide/developer_guidelines.rst:54
#: ../dev_guide/developer_guidelines.rst:51
msgid "delete the remote branch."
msgstr ""

#: ../dev_guide/documentation_guidelines.rst:30
msgid "Documentation guidelines"
msgstr "Соглашения по документации"

#: ../doc/dev_guide/documentation_guidelines.rst:35
#: ../dev_guide/documentation_guidelines.rst:32
msgid ""
"These guidelines are updated on the on-demand basis, covering only those "
"issues that cause pains to the existing writers. At this point, we do not "
"aim to come up with an exhaustive Documentation Style Guide for the "
"Tarantool project."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:41
#: ../dev_guide/documentation_guidelines.rst:38
msgid "Markup issues"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:45
#: ../dev_guide/documentation_guidelines.rst:42
msgid "Wrapping text"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:47
#: ../dev_guide/documentation_guidelines.rst:44
msgid ""
"The limit is 80 characters per line for plain text, and no limit for any "
"other constructions when wrapping affects ReST readability and/or HTML "
"output. Also, it makes no sense to wrap text into lines shorter than 80 "
"characters unless you have a good reason to do so."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:52
#: ../dev_guide/documentation_guidelines.rst:49
msgid ""
"The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, and "
"it's unlikely that readers/writers will use 80-character consoles. Yet it's "
"still a standard for many coding guidelines (including Tarantool). As for "
"writers, the benefit is that an 80-character page guide allows keeping the "
"text window rather narrow most of the time, leaving more space for other "
"applications in a wide-screen environment."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:61
#: ../dev_guide/documentation_guidelines.rst:58
msgid "Formatting code snippets"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:63
#: ../dev_guide/documentation_guidelines.rst:60
msgid ""
"For code snippets, we mainly use the ``code-block`` directive with an "
"appropriate highlighting language. The most commonly used highlighting "
"languages are:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:67
#: ../dev_guide/documentation_guidelines.rst:64
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:68
#: ../dev_guide/documentation_guidelines.rst:65
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:69
#: ../dev_guide/documentation_guidelines.rst:66
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:71
#: ../dev_guide/documentation_guidelines.rst:68
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:80
#: ../dev_guide/documentation_guidelines.rst:77
msgid ""
"In rare cases, when we need custom highlight for specific parts of a code "
"snippet and the ``code-block`` directive is not enough, we use the per-line "
"``codenormal`` directive together and explicit output formatting (defined "
"in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:85
#: ../dev_guide/documentation_guidelines.rst:82
msgid "Examples:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:87
#: ../dev_guide/documentation_guidelines.rst:84
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:89
#: ../dev_guide/documentation_guidelines.rst:86
msgid ""
":codenormal:`box.space.`:codeitalic:`space-name`:codenormal:`:"
"create_index('index-name')`"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:91
#: ../dev_guide/documentation_guidelines.rst:88
msgid ""
"A tdb session (user input is in bold, command prompt is in blue, computer "
"output is in green):"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:103
#: ../dev_guide/documentation_guidelines.rst:100
msgid ""
"Warning: Every entry of explicit output formatting (``codenormal``, "
"``codebold``, etc) tends to cause troubles when this documentation is "
"translated to other languages. Please avoid using explicit output formatting "
"unless it is REALLY needed."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:110
#: ../dev_guide/documentation_guidelines.rst:107
msgid "Using separated links"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:112
#: ../dev_guide/documentation_guidelines.rst:109
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:114
#: ../dev_guide/documentation_guidelines.rst:111
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:120
#: ../dev_guide/documentation_guidelines.rst:117
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:122
#: ../dev_guide/documentation_guidelines.rst:119
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:126
#: ../dev_guide/documentation_guidelines.rst:123
msgid ""
"Warning: Every separated link tends to cause troubles when this "
"documentation is translated to other languages. Please avoid using separated "
"links unless it is REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:132
#: ../dev_guide/documentation_guidelines.rst:129
msgid "Creating labels for local links"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:134
#: ../dev_guide/documentation_guidelines.rst:131
msgid ""
"We avoid using links that sphinx generates automatically for most objects. "
"Instead, we add our own labels for linking to any place in this "
"documentation."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:137
#: ../dev_guide/documentation_guidelines.rst:134
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:139
#: ../dev_guide/documentation_guidelines.rst:136
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:141
#: ../dev_guide/documentation_guidelines.rst:138
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:143
#: ../dev_guide/documentation_guidelines.rst:140
msgid ""
"Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is "
"the directory name, |br| ``box_index`` is the file name (without \".rst\"), "
"and |br| ``iterator_type`` is the tag."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:149
#: ../dev_guide/documentation_guidelines.rst:146
msgid ""
"The file name is useful for knowing, when you see \"ref\", where it is "
"pointing to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:152
#: ../dev_guide/documentation_guidelines.rst:149
msgid ""
"The file name alone, without a path, is enough when the file name is unique "
"within ``doc/sphinx``. So, for ``fiber.rst`` it should be just \"fiber\", "
"not \"reference-fiber\". While for \"index.rst\" (we have a handful of "
"\"index.rst\" in different directories) please specify the path before the "
"file name, e.g. \"reference-index\"."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:159
#: ../dev_guide/documentation_guidelines.rst:156
msgid ""
"Use a dash \"-\" to delimit the path and the file name. In the documentation "
"source, we use only underscores \"_\" in paths and file names, reserving "
"dash \"-\" as the delimiter for local links."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:163
#: ../dev_guide/documentation_guidelines.rst:160
msgid ""
"The tag can be anything meaningful. The only guideline is for Tarantool "
"syntax items (such as members), where the preferred tag syntax is "
"``module_or_object_name dash member_name``. For example, ``box_space-drop``."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:169
#: ../dev_guide/documentation_guidelines.rst:166
msgid "Making comments"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:171
#: ../dev_guide/documentation_guidelines.rst:168
msgid ""
"Sometimes we may need to leave comments in a ReST file. To make sphinx "
"ignore some text during processing, use the following per-line notation with "
"\".. //\" as the comment marker:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:175
#: ../dev_guide/documentation_guidelines.rst:172
msgid ".. // your comment here"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:179
#: ../dev_guide/documentation_guidelines.rst:176
msgid ""
"The starting symbols \".. //\" do not interfere with the other ReST markup, "
"and they are easy to find both visually and using grep. There are no symbols "
"to escape in grep search, just go ahead with something like this:"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:183
#: ../dev_guide/documentation_guidelines.rst:180
msgid "grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:187
#: ../dev_guide/documentation_guidelines.rst:184
msgid ""
"These comments don't work properly in nested documentation, though (e.g. if "
"you leave a comment in module -> object -> method, sphinx ignores the "
"comment and all nested content that follows in the method description)."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:193
#: ../dev_guide/documentation_guidelines.rst:190
msgid "Language and style issues"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:197
#: ../dev_guide/documentation_guidelines.rst:194
msgid "US vs British spelling"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:199
#: ../dev_guide/documentation_guidelines.rst:196
msgid "We use English US spelling."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:203
#: ../dev_guide/documentation_guidelines.rst:200
msgid "Examples and templates"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:207
#: ../dev_guide/documentation_guidelines.rst:204
msgid "Module and function"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:209
#: ../dev_guide/documentation_guidelines.rst:206
msgid ""
"Here is an example of documenting a module (``my_fiber``) and a function "
"(``my_fiber.create``)."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:216
#: ../dev_guide/documentation_guidelines.rst:213
msgid ""
"Create and start a ``my_fiber`` object. The object is created and begins to "
"run immediately."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:219
#: ../dev_guide/documentation_guidelines.rst:216
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:220
#: ../doc/reference/reference_lua/fiber.rst:86
#: ../dev_guide/documentation_guidelines.rst:217
#: ../reference/reference_lua/fiber.rst:83 ../reference_lua/fiber.rst:83
msgid "what will be passed to function"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:222
#: ../dev_guide/documentation_guidelines.rst:219
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:227
#: ../dev_guide/documentation_guidelines.rst:224
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:243
#: ../dev_guide/documentation_guidelines.rst:240
msgid "Module, class and method"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:245
#: ../dev_guide/documentation_guidelines.rst:242
msgid ""
"Here is an example of documenting a module (``my_box.index``), a class "
"(``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:256
#: ../dev_guide/documentation_guidelines.rst:253
msgid "an object reference"
msgstr ""

#: ../doc/dev_guide/documentation_guidelines.rst:257
#: ../dev_guide/documentation_guidelines.rst:254
msgid "a new name for the index (type = string)"
msgstr ""

#: ../dev_guide/guidelines_index.rst:28
msgid "Guidelines"
msgstr "Соглашения по разработке"

#: ../dev_guide/internals_index.rst:28
msgid "Internals"
msgstr "Детали реализации"

#: ../dev_guide/box_protocol.rst:5
msgid "Tarantool's binary protocol"
msgstr "Бинарный протокол в Tarantool'е"

#: ../dev_guide/box_protocol.rst:7
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""
"Бинарный протокол в Tarantool'е -- это бинарный протокол для обмена "
"запросами и ответами."

#: ../doc/dev_guide/box_protocol.rst:11
msgid "Notation in diagrams"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../dev_guide/box_protocol.rst:32
msgid "MsgPack data types:"
msgstr "Типы данных из библиотеки MsgPack:"

#: ../dev_guide/box_protocol.rst:34
msgid "**MP_INT** - Integer"
msgstr "**MP_INT** - целое число (integer)"

#: ../dev_guide/box_protocol.rst:35
msgid "**MP_MAP** - Map"
msgstr "**MP_MAP** - соответствие (map)"

#: ../dev_guide/box_protocol.rst:36
msgid "**MP_ARR** - Array"
msgstr "**MP_ARR** - массив (array)"

#: ../dev_guide/box_protocol.rst:37
msgid "**MP_STRING** - String"
msgstr "**MP_STRING** - строка (string)"

#: ../dev_guide/box_protocol.rst:38
msgid "**MP_FIXSTR** - Fixed size string"
msgstr "**MP_FIXSTR** - строка фиксированной длины (fixed size string)"

#: ../dev_guide/box_protocol.rst:39
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr "**MP_OBJECT** - объект типа MsgPack (MsgPack object)"

#: ../dev_guide/box_protocol.rst:43
msgid "Greeting packet"
msgstr "Пакет-приветствие"

#: ../doc/dev_guide/box_protocol.rst:45 ../dev_guide/box_protocol.rst:45
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:61
msgid ""
"The server begins the dialogue by sending a fixed-size (128-byte) text "
"greeting to the client. The greeting always contains two 64-byte lines of "
"ASCII text, each line ending with a newline character ('\\\\n'). The first "
"line contains the server version and protocol type. The second line contains "
"up to 44 bytes of base64-encoded random string, to use in the authentication "
"packet, and ends with up to 23 spaces."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:69 ../dev_guide/box_protocol.rst:69
msgid "Unified packet structure"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:71 ../dev_guide/box_protocol.rst:71
msgid ""
"Once a greeting is read, the protocol becomes pure request/response and "
"features a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:74 ../dev_guide/box_protocol.rst:74
msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple requests "
"via the same connection"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:76 ../dev_guide/box_protocol.rst:76
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:78 ../dev_guide/box_protocol.rst:78
msgid ""
"For data structuring and encoding, the protocol uses msgpack data format, "
"see http://msgpack.org"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:81
msgid ""
"The Tarantool protocol mandates use of a few integer constants serving as "
"keys in maps used in the protocol. These constants are defined in `src/box/"
"iproto_constants.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/"
"iproto_constants.h>`_"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:85
msgid "We list them here too:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:87 ../dev_guide/box_protocol.rst:87
msgid ""
"-- user keys\n"
"<code>          ::= 0x00\n"
"<sync>          ::= 0x01\n"
"<schema_id>     ::= 0x05\n"
"<space_id>      ::= 0x10\n"
"<index_id>      ::= 0x11\n"
"<limit>         ::= 0x12\n"
"<offset>        ::= 0x13\n"
"<iterator>      ::= 0x14\n"
"<key>           ::= 0x20\n"
"<tuple>         ::= 0x21\n"
"<function_name> ::= 0x22\n"
"<username>      ::= 0x23\n"
"<expression>    ::= 0x27\n"
"<ops>           ::= 0x28\n"
"<data>          ::= 0x30\n"
"<error>         ::= 0x31"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:107
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>  ::= 0x01\n"
"<insert>  ::= 0x02\n"
"<replace> ::= 0x03\n"
"<update>  ::= 0x04\n"
"<delete>  ::= 0x05\n"
"<call_16> ::= 0x06\n"
"<auth>    ::= 0x07\n"
"<eval>    ::= 0x08\n"
"<upsert>  ::= 0x09\n"
"<call>    ::= 0x0a\n"
"-- Admin command codes\n"
"<ping>    ::= 0x40\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:129 ../dev_guide/box_protocol.rst:128
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:131 ../dev_guide/box_protocol.rst:130
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:143 ../dev_guide/box_protocol.rst:142
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:155
msgid ""
"They only differ in the allowed set of keys and values. The key defines the "
"type of value that follows. If a body has no keys, the entire msgpack map "
"for the body may be missing. Such is the case, for example, for a <ping> "
"request. ``schema_id`` may be absent in the request's header, meaning that "
"there will be no version checking, but it must be present in the response. "
"If ``schema_id`` is sent in the header, then it will be checked."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:166 ../dev_guide/box_protocol.rst:165
msgid "Authentication"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:168 ../dev_guide/box_protocol.rst:167
msgid ""
"When a client connects to the server, the server responds with a 128-byte "
"text greeting message. Part of the greeting is base-64 encoded session salt "
"- a random string which can be used for authentication. The length of "
"decoded salt (44 bytes) exceeds the amount necessary to sign the "
"authentication message (first 20 bytes). An excess is reserved for future "
"authentication schemas."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:175 ../dev_guide/box_protocol.rst:174
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  | MP_STRING | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:203 ../dev_guide/box_protocol.rst:202
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and password, encrypted according to the specified "
"mechanism. Authentication in Tarantool is optional, if no authentication is "
"performed, session user is 'guest'. The server responds to authentication "
"packet with a standard response with 0 tuples."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:213 ../dev_guide/box_protocol.rst:212
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:216 ../dev_guide/box_protocol.rst:215
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:233 ../dev_guide/box_protocol.rst:232
msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same "
"unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:235 ../dev_guide/box_protocol.rst:234
msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing "
"one."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:238 ../dev_guide/box_protocol.rst:237
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:251 ../dev_guide/box_protocol.rst:250
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:254 ../dev_guide/box_protocol.rst:253
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:273 ../dev_guide/box_protocol.rst:272
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:296 ../dev_guide/box_protocol.rst:295
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:318 ../dev_guide/box_protocol.rst:317
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:330
msgid ""
"It is an error to specify an argument of a type that differs from the "
"expected type."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:332 ../dev_guide/box_protocol.rst:331
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:335 ../dev_guide/box_protocol.rst:334
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:348
msgid ""
"CALL_16: CODE - 0x06 Call a stored function, returning an array of tuples. "
"This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:351
msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:364 ../dev_guide/box_protocol.rst:363
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:367 ../dev_guide/box_protocol.rst:366
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:380 ../dev_guide/box_protocol.rst:379
msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to "
"insert tuple. Always use primary index for key."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:383 ../dev_guide/box_protocol.rst:382
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not "
"exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create "
"no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field "
"between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is "
"skipped.\n"
"      It's not possible to change with update operations a part of the "
"primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:424
msgid ""
"CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a list "
"of values, unconverted"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:427 ../dev_guide/box_protocol.rst:350
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:442 ../dev_guide/box_protocol.rst:425
msgid "Response packet structure"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:444
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:446 ../dev_guide/box_protocol.rst:429
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:460 ../dev_guide/box_protocol.rst:443
msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of "
"tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary "
"MsgPack values."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:463 ../dev_guide/box_protocol.rst:446
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:478
msgid ""
"An error message is present in the response only if there is an error; :code:"
"`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:481 ../dev_guide/box_protocol.rst:464
msgid ""
"Convenience macros which define hexadecimal constants for return codes can "
"be found in `src/box/errcode.h <https://github.com/tarantool/tarantool/"
"blob/1.7/src/box/errcode.h>`_"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:487 ../dev_guide/box_protocol.rst:470
msgid "Replication packet structure"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:489 ../dev_guide/box_protocol.rst:472
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:499 ../dev_guide/box_protocol.rst:482
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:506 ../dev_guide/box_protocol.rst:489
msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send JOIN\n"
"                         HEADER                          BODY\n"
"+================+================+===================++-------+\n"
"|                |                |    SERVER_UUID    ||       |\n"
"|   0x00: 0x41   |   0x01: SYNC   |   0x24: UUID      || EMPTY |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT | MP_INT: MP_STRING ||       |\n"
"|                |                |                   ||       |\n"
"+================+================+===================++-------+\n"
"               MP_MAP                                   MP_MAP\n"
"\n"
"Then server, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x41    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:566 ../dev_guide/box_protocol.rst:549
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:568
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:570
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:578
msgid ""
"After the file header come the data tuples. Tuples begin with a row marker "
"``0xd5ba0bab`` and the last tuple may be followed by an EOF marker "
"``0xd510aded``. Thus, between the file header and the EOF marker, there may "
"be data tuples that have this form:"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:585 ../dev_guide/box_protocol.rst:577
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/dev_guide/box_protocol.rst:602
msgid "See the example in the following section."
msgstr ""

#: ../dev_guide/internals.rst:5
msgid "Data persistence and the WAL file format"
msgstr "Персистентность данных и формат WAL-файла"

#: ../doc/dev_guide/internals.rst:9
msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(insert, update, delete, replace, upsert) into a write-ahead log (WAL) file "
"in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is "
"created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
"rows_per_wal>` records. Each data change request gets assigned a "
"continuously growing 64-bit log sequence number. The name of the WAL file is "
"based on the log sequence number of the first record in the file, plus an "
"extension ``.xlog``."
msgstr ""

#: ../doc/dev_guide/internals.rst:17
msgid ""
"Apart from a log sequence number and the data change request (formatted as "
"in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`), each "
"WAL record contains a header, some metadata, and then the data formatted "
"according to `msgpack <https://en.wikipedia.org/wiki/MessagePack>`_ rules. "
"For example this is what the WAL file looks like after the first INSERT "
"request (\"s:insert({1})\") for the introductory sandbox exercise \":ref:"
"`Starting Tarantool and making your first database "
"<user_guide_getting_started-first_database>`“. On the left are the "
"hexadecimal bytes that one would see with: |br| ``$ hexdump "
"00000000000000000000.xlog`` |br| and on the right are comments."
msgstr ""

#: ../doc/dev_guide/internals.rst:28
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte "
"first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed "
"array={1}"
msgstr ""

#: ../doc/dev_guide/internals.rst:57 ../dev_guide/internals.rst:50
msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this "
"happens, using the REPLACE request as an example:"
msgstr ""

#: ../doc/dev_guide/internals.rst:61 ../dev_guide/internals.rst:54
msgid ""
"The server attempts to locate the original tuple by primary key. If found, a "
"reference to the tuple is retained for later use."
msgstr ""

#: ../doc/dev_guide/internals.rst:64 ../dev_guide/internals.rst:57
msgid ""
"The new tuple is validated. If for example it does not contain an indexed "
"field, or it has an indexed field whose type does not match the type "
"according to the index definition, the change is aborted."
msgstr ""

#: ../doc/dev_guide/internals.rst:68 ../dev_guide/internals.rst:61
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/dev_guide/internals.rst:70 ../dev_guide/internals.rst:63
msgid ""
"A message is sent to WAL writer running in a separate thread, requesting "
"that the change be recorded in the WAL. The server switches to work on the "
"next request until the write is acknowledged."
msgstr ""

#: ../doc/dev_guide/internals.rst:74 ../dev_guide/internals.rst:67
msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction processor "
"rolls back all changes to the database which occurred after the first failed "
"change, from latest to oldest, up to the first failed change. All rolled "
"back requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No "
"new change is applied while rollback is in progress. When the rollback "
"procedure is finished, the server restarts the processing pipeline."
msgstr ""

#: ../doc/dev_guide/internals.rst:82 ../dev_guide/internals.rst:75
msgid ""
"One advantage of the described algorithm is that complete request pipelining "
"is achieved, even for requests on the same value of the primary key. As a "
"result, database performance doesn't degrade even if all requests refer to "
"the same key in the same space."
msgstr ""

#: ../doc/dev_guide/internals.rst:87 ../dev_guide/internals.rst:80
msgid ""
"The transaction processor thread communicates with the WAL writer thread "
"using asynchronous (yet reliable) messaging; the transaction processor "
"thread, not being blocked on WAL tasks, continues to handle requests quickly "
"even at high volumes of disk I/O. A response to a request is sent as soon as "
"it is ready, even if there were earlier incomplete requests on the same "
"connection. In particular, SELECT performance, even for SELECTs running on a "
"connection packed with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../doc/dev_guide/internals.rst:95 ../dev_guide/internals.rst:88
msgid ""
"The WAL writer employs a number of durability modes, as defined in "
"configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible to "
"turn the write-ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the write-"
"ahead log it's still possible to take a persistent copy of the entire data "
"set with the :ref:`box.snapshot() <admin-snapshot>` request."
msgstr ""

#: ../doc/dev_guide/internals.rst:102 ../dev_guide/internals.rst:95
msgid ""
"An .xlog file always contains changes based on the primary key. Even if the "
"client requested an update or delete using a secondary key, the record in "
"the .xlog file will contain the primary key."
msgstr ""

#: ../dev_guide/internals.rst:101
msgid "The snapshot file format"
msgstr "Формат файла-снимка"

#: ../doc/dev_guide/internals.rst:110 ../dev_guide/internals.rst:103
msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a "
"WAL .xlog file. However, the snapshot header differs: it contains the "
"server's global unique identifier and the snapshot file's position in "
"history, relative to earlier snapshot files. Also, the content differs: an ."
"xlog file may contain records for any data-change requests (inserts, "
"updates, upserts, and deletes), a .snap file may only contain records of "
"inserts to memtx spaces."
msgstr ""

#: ../doc/dev_guide/internals.rst:117 ../dev_guide/internals.rst:110
msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore the "
"records of system spaces, such as _schema and _space and _index and _func "
"and _priv and _cluster, will be at the start of the .snap file, before the "
"records of any spaces that were created by users."
msgstr ""

#: ../doc/dev_guide/internals.rst:122 ../dev_guide/internals.rst:115
msgid ""
"Secondarily, the .snap file's records are ordered by primary key within "
"space id."
msgstr ""

#: ../dev_guide/internals.rst:119
msgid "The recovery process"
msgstr "Процесс восстановления после сбоя"

#: ../doc/dev_guide/internals.rst:128 ../dev_guide/internals.rst:121
msgid ""
"The recovery process begins when box.cfg{} happens for the first time after "
"the Tarantool server starts."
msgstr ""

#: ../doc/dev_guide/internals.rst:131 ../dev_guide/internals.rst:124
msgid ""
"The recovery process must recover the databases as of the moment when the "
"server was last shut down. For this it may use the latest snapshot file and "
"any WAL files that were written after the snapshot. One complicating factor "
"is that Tarantool has two engines -- the memtx data must be reconstructed "
"entirely from the snapshot and the WAL files, while the vinyl data will be "
"on disk but might require updating around the time of a checkpoint. (When a "
"snapshot happens, Tarantool tells the vinyl engine to make a checkpoint, and "
"the snapshot operation is rolled back if anything goes wrong, so vinyl's "
"checkpoint is at least as fresh as the snapshot file.)"
msgstr ""

#: ../doc/dev_guide/internals.rst:149 ../dev_guide/internals.rst:142
msgid "Step 1"
msgstr ""

#: ../doc/dev_guide/internals.rst:144 ../dev_guide/internals.rst:137
msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. Parameters "
"which affect recovery may include :ref:`work_dir <cfg_basic-work_dir>`, :ref:"
"`wal_dir <cfg_basic-wal_dir>`, :ref:`snap_dir <cfg_basic-snap_dir>`, :ref:"
"`vinyl_dir <cfg_basic-vinyl_dir>`, :ref:`panic_on_snap_error "
"<cfg_binary_logging_snapshots-panic_on_snap_error>`, and :ref:"
"`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error>`."
msgstr ""

#: ../doc/dev_guide/internals.rst:153 ../doc/dev_guide/internals.rst:176
#: ../dev_guide/internals.rst:146 ../dev_guide/internals.rst:169
msgid "Step 2"
msgstr ""

#: ../doc/dev_guide/internals.rst:152 ../dev_guide/internals.rst:145
msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../doc/dev_guide/internals.rst:155 ../dev_guide/internals.rst:148
msgid ""
"There are actually two variations of the reconstruction procedure for the "
"memtx databases, depending whether the recovery process is \"default\"."
msgstr ""

#: ../doc/dev_guide/internals.rst:158 ../dev_guide/internals.rst:151
msgid ""
"If it is default (``panic_on_snap_error`` is ``true`` and "
"``panic_on_wal_error`` is ``true``), memtx can read data in the snapshot "
"with all indexes disabled. First, all tuples are read into memory. Then, "
"primary keys are built in bulk, taking advantage of the fact that the data "
"is already sorted by primary key within each space."
msgstr ""

#: ../doc/dev_guide/internals.rst:164 ../dev_guide/internals.rst:157
msgid ""
"If it is not default (``panic_on_snap_error`` is ``false`` or "
"``panic_on_wal_error`` is ``false``), Tarantool performs additional "
"checking. Indexes are enabled at the start, and tuples are added one by one. "
"This means that any unique-key constraint violations will be caught, and any "
"duplicates will be skipped. Normally there will be no constraint violations "
"or duplicates, so these checks are only made if an error has occurred."
msgstr ""

#: ../doc/dev_guide/internals.rst:172 ../dev_guide/internals.rst:165
msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot file. "
"Read its log entries until the log-entry LSN is greater than the LSN of the "
"snapshot, or greater than the LSN of the vinyl checkpoint. This is the "
"recovery process's \"start position\"; it matches the current state of the "
"engines."
msgstr ""

#: ../doc/dev_guide/internals.rst:180 ../dev_guide/internals.rst:173
msgid "Step 3"
msgstr ""

#: ../doc/dev_guide/internals.rst:179 ../dev_guide/internals.rst:172
msgid ""
"Redo the log entries, from the start position to the end of the WAL. The "
"engine skips a redo instruction if it is older than the engine's checkpoint."
msgstr ""

#: ../doc/dev_guide/internals.rst:183 ../dev_guide/internals.rst:176
msgid "Step 4"
msgstr ""

#: ../doc/dev_guide/internals.rst:183 ../dev_guide/internals.rst:176
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../dev_guide/internals.rst:182
msgid "Server startup with replication"
msgstr "Запуск сервера в режиме репликации"

#: ../doc/dev_guide/internals.rst:191 ../dev_guide/internals.rst:184
msgid ""
"In addition to the recovery process described above, the server must take "
"additional steps and precautions if :ref:`replication <index-"
"box_replication>` is enabled."
msgstr ""

#: ../doc/dev_guide/internals.rst:195 ../dev_guide/internals.rst:188
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` request. "
"One of the box.cfg parameters may be :ref:`replication_source "
"<cfg_replication-replication_source>`. We will refer to this server, which "
"is starting up due to box.cfg, as the \"local\" server to distinguish it "
"from the other servers in a cluster, which we will refer to as \"distant\" "
"servers."
msgstr ""

#: ../doc/dev_guide/internals.rst:202 ../dev_guide/internals.rst:195
msgid ""
"*If there is no snapshot .snap file and replication_source is empty*: |br| "
"then the local server assumes it is an unreplicated \"standalone\" server, "
"or is the first server of a new replication cluster. It will generate new "
"UUIDs for itself and for the cluster. The server UUID is stored in the "
"_cluster space; the cluster UUID is stored in the _schema space. Since a "
"snapshot contains all the data in all the spaces, that means the local "
"server's snapshot will contain the server UUID and the cluster UUID. "
"Therefore, when the local server restarts on later occasions, it will be "
"able to recover these UUIDs when it reads the .snap file."
msgstr ""

#: ../doc/dev_guide/internals.rst:212 ../dev_guide/internals.rst:205
msgid ""
"*If there is no snapshot .snap file and replication_source is not empty and "
"the _cluster space contains no other server UUIDs*: |br| then the local "
"server assumes it is not a standalone server, but is not yet part of a "
"cluster. It must now join the cluster. It will send its server UUID to the "
"first distant server which is listed in replication_source, which will act "
"as a master. This is called the \"join request\". When a distant server "
"receives a join request, it will send back:"
msgstr ""

#: ../doc/dev_guide/internals.rst:220 ../dev_guide/internals.rst:213
msgid "the distant server's cluster UUID,"
msgstr ""

#: ../doc/dev_guide/internals.rst:221 ../dev_guide/internals.rst:214
msgid ""
"the contents of the distant server's .snap file. |br| When the local server "
"receives this information, it puts the cluster UUID in its _schema space, "
"puts the distant server's UUID and connection information in its _cluster "
"space, and makes a snapshot containing all the data sent by the distant "
"server. Then, if the local server has data in its WAL .xlog files, it sends "
"that data to the distant server. The distant server will receive this and "
"update its own copy of the data, and add the local server's UUID to its "
"_cluster space."
msgstr ""

#: ../doc/dev_guide/internals.rst:230 ../dev_guide/internals.rst:223
msgid ""
"*If there is no snapshot .snap file and replication_source is not empty and "
"the _cluster space contains other server UUIDs*: |br| then the local server "
"assumes it is not a standalone server, and is already part of a cluster. It "
"will send its server UUID and cluster UUID to all the distant servers which "
"are listed in replication_source. This is called the \"on-connect handshake"
"\". When a distant server receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/dev_guide/internals.rst:237 ../dev_guide/internals.rst:230
msgid ""
"the distant server compares its own copy of the cluster UUID to the one in "
"the on-connect handshake. If there is no match, then the handshake fails and "
"the local server will display an error."
msgstr ""

#: ../doc/dev_guide/internals.rst:240 ../dev_guide/internals.rst:233
msgid ""
"the distant server looks for a record of the connecting instance in its "
"_cluster space. If there is none, then the handshake fails. |br| Otherwise "
"the handshake is successful. The distant server will read any new "
"information from its own .snap and .xlog files, and send the new requests to "
"the local server."
msgstr ""

#: ../doc/dev_guide/internals.rst:246 ../dev_guide/internals.rst:239
msgid ""
"In the end ... the local server knows what cluster it belongs to, the "
"distant server knows that the local server is a member of the cluster, and "
"both servers have the same database contents."
msgstr ""

#: ../doc/dev_guide/internals.rst:252 ../dev_guide/internals.rst:243
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local server goes through the recovery process described in the "
"previous section, using its own .snap and .xlog files. Then it sends a "
"\"subscribe\" request to all the other servers of the cluster. The subscribe "
"request contains the server vector clock. The vector clock has a collection "
"of pairs 'server id, lsn' for every server in the _cluster system space. "
"Each distant server, upon receiving a subscribe request, will read its .xlog "
"files' requests and send them to the local server if (lsn of .xlog file "
"request) is greater than (lsn of the vector clock in the subscribe request). "
"After all the other servers of the cluster have responded to the local "
"server's subscribe request, the server startup is complete."
msgstr ""

#: ../doc/dev_guide/internals.rst:264 ../dev_guide/internals.rst:255
msgid "The following temporary limitations apply for version 1.7:"
msgstr ""

#: ../doc/dev_guide/internals.rst:266 ../dev_guide/internals.rst:257
msgid ""
"The URIs in replication_source should all be in the same order on all "
"servers. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/dev_guide/internals.rst:268 ../dev_guide/internals.rst:259
msgid ""
"The servers of a cluster should be started up at slightly different times. "
"This is not mandatory but prevents a situation where each server is waiting "
"for the other server to be ready."
msgstr ""

#: ../doc/dev_guide/internals.rst:271 ../dev_guide/internals.rst:262
msgid ""
"The maximum number of entries in the _cluster space is 32. Tuples for out-of-"
"date replicas are not automatically re-used, so if this 32-replica limit is "
"reached, users may have to reorganize the _cluster space manually."
msgstr ""

#: ../dev_guide/python_style_guide.rst:28
msgid "Python Style Guide"
msgstr "Соглашения по разработке на языке Python"

#: ../doc/dev_guide/python_style_guide.rst:35
#: ../dev_guide/python_style_guide.rst:32
msgid "Introduction"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:37
#: ../dev_guide/python_style_guide.rst:34
msgid ""
"This document gives coding conventions for the Python code comprising the "
"standard library in the main Python distribution.  Please see the companion "
"informational PEP describing style guidelines for the C code in the C "
"implementation of Python [1]_."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:42
#: ../dev_guide/python_style_guide.rst:39
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from Guido's "
"original Python Style Guide essay, with some additions from Barry's style "
"guide [2]_."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:49
#: ../dev_guide/python_style_guide.rst:46
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:51
#: ../dev_guide/python_style_guide.rst:48
msgid ""
"One of Guido's key insights is that code is read much more often than it is "
"written.  The guidelines provided here are intended to improve the "
"readability of code and make it consistent across the wide spectrum of "
"Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:56
#: ../dev_guide/python_style_guide.rst:53
msgid ""
"A style guide is about consistency.  Consistency with this style guide is "
"important.  Consistency within a project is more important. Consistency "
"within one module or function is the most important."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:60
#: ../dev_guide/python_style_guide.rst:57
msgid ""
"But most importantly: know when to be inconsistent -- sometimes the style "
"guide just doesn't apply.  When in doubt, use your best judgment.  Look at "
"other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:65
#: ../dev_guide/python_style_guide.rst:62
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:67
#: ../dev_guide/python_style_guide.rst:64
msgid ""
"When applying the rule would make the code less readable, even for someone "
"who is used to reading code that follows the rules."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:70
#: ../dev_guide/python_style_guide.rst:67
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for "
"historic reasons) -- although this is also an opportunity to clean up "
"someone else's mess (in true XP style)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:77
#: ../dev_guide/python_style_guide.rst:74
msgid "Code lay-out"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:81
#: ../dev_guide/python_style_guide.rst:78
msgid "Indentation"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:83
#: ../dev_guide/python_style_guide.rst:80
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:85
#: ../dev_guide/python_style_guide.rst:82
msgid ""
"For really old code that you don't want to mess up, you can continue to use "
"8-space tabs."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:88
#: ../dev_guide/python_style_guide.rst:85
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, or "
"using a hanging indent.  When using a hanging indent the following "
"considerations should be applied; there should be no arguments on the first "
"line and further indentation should be used to clearly distinguish itself as "
"a continuation line."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:95
#: ../doc/dev_guide/python_style_guide.rst:352
#: ../doc/dev_guide/python_style_guide.rst:381
#: ../doc/dev_guide/python_style_guide.rst:400
#: ../doc/dev_guide/python_style_guide.rst:413
#: ../dev_guide/python_style_guide.rst:92
#: ../dev_guide/python_style_guide.rst:349
#: ../dev_guide/python_style_guide.rst:378
#: ../dev_guide/python_style_guide.rst:397
#: ../dev_guide/python_style_guide.rst:410
msgid "Yes::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:97
#: ../dev_guide/python_style_guide.rst:94
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:107
#: ../doc/dev_guide/python_style_guide.rst:358
#: ../doc/dev_guide/python_style_guide.rst:389
#: ../doc/dev_guide/python_style_guide.rst:405
#: ../dev_guide/python_style_guide.rst:104
#: ../dev_guide/python_style_guide.rst:355
#: ../dev_guide/python_style_guide.rst:386
#: ../dev_guide/python_style_guide.rst:402
msgid "No::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:109
#: ../dev_guide/python_style_guide.rst:106
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:119
#: ../dev_guide/python_style_guide.rst:116
msgid "Optional::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:121
#: ../dev_guide/python_style_guide.rst:118
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:126
#: ../dev_guide/python_style_guide.rst:123
msgid ""
"The closing brace/bracket/parenthesis on multi-line constructs may either "
"line up under the first non-whitespace character of the last line of list, "
"as in::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:130
#: ../dev_guide/python_style_guide.rst:127
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:139
#: ../dev_guide/python_style_guide.rst:136
msgid ""
"or it may be lined up under the first character of the line that starts the "
"multi-line construct, as in::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:142
#: ../dev_guide/python_style_guide.rst:139
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:154
#: ../dev_guide/python_style_guide.rst:151
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:156
#: ../dev_guide/python_style_guide.rst:153
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:158
#: ../dev_guide/python_style_guide.rst:155
msgid ""
"The most popular way of indenting Python is with spaces only.  The second-"
"most popular way is with tabs only.  Code indented with a mixture of tabs "
"and spaces should be converted to using spaces exclusively.  When invoking "
"the Python command line interpreter with the ``-t`` option, it issues "
"warnings about code that illegally mixes tabs and spaces.  When using ``-"
"tt`` these warnings become errors. These options are highly recommended!"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:166
#: ../dev_guide/python_style_guide.rst:163
msgid ""
"For new projects, spaces-only are strongly recommended over tabs. Most "
"editors have features that make this easy to do."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:171
#: ../dev_guide/python_style_guide.rst:168
msgid "Maximum Line Length"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:173
#: ../dev_guide/python_style_guide.rst:170
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:175
#: ../dev_guide/python_style_guide.rst:172
msgid ""
"There are still many devices around that are limited to 80 character lines; "
"plus, limiting windows to 80 characters makes it possible to have several "
"windows side-by-side.  The default wrapping on such devices disrupts the "
"visual structure of the code, making it more difficult to understand.  "
"Therefore, please limit all lines to a maximum of 79 characters.  For "
"flowing long blocks of text (docstrings or comments), limiting the length to "
"72 characters is recommended."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:183
#: ../dev_guide/python_style_guide.rst:180
msgid ""
"The preferred way of wrapping long lines is by using Python's implied line "
"continuation inside parentheses, brackets and braces.  Long lines can be "
"broken over multiple lines by wrapping expressions in parentheses. These "
"should be used in preference to using a backslash for line continuation."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:189
#: ../dev_guide/python_style_guide.rst:186
msgid ""
"Backslashes may still be appropriate at times.  For example, long, multiple "
"``with``-statements cannot use implicit continuation, so backslashes are "
"acceptable::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:193
#: ../dev_guide/python_style_guide.rst:190
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:197
#: ../dev_guide/python_style_guide.rst:194
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:199
#: ../dev_guide/python_style_guide.rst:196
msgid ""
"Make sure to indent the continued line appropriately.  The preferred place "
"to break around a binary operator is *after* the operator, not before it.  "
"Some examples::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:203
#: ../dev_guide/python_style_guide.rst:200
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:220
#: ../dev_guide/python_style_guide.rst:217
msgid "Blank Lines"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:222
#: ../dev_guide/python_style_guide.rst:219
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:225
#: ../dev_guide/python_style_guide.rst:222
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:228
#: ../dev_guide/python_style_guide.rst:225
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-liners "
"(e.g. a set of dummy implementations)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:232
#: ../dev_guide/python_style_guide.rst:229
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:234
#: ../dev_guide/python_style_guide.rst:231
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace; "
"Many tools treat these characters as page separators, so you may use them to "
"separate pages of related sections of your file. Note, some editors and web-"
"based code viewers may not recognize control-L as a form feed and will show "
"another glyph in its place."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:242
#: ../dev_guide/python_style_guide.rst:239
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:244
#: ../dev_guide/python_style_guide.rst:241
msgid ""
"Code in the core Python distribution should always use the ASCII or Latin-1 "
"encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 is preferred "
"over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:248
#: ../dev_guide/python_style_guide.rst:245
msgid ""
"Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) "
"should only be used when a comment or docstring needs to mention an author "
"name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or ``\\U`` "
"escapes is the preferred way to include non-ASCII data in string literals."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:254
#: ../dev_guide/python_style_guide.rst:251
msgid ""
"For Python 3.0 and beyond, the following policy is prescribed for the "
"standard library (see PEP 3131): All identifiers in the Python standard "
"library MUST use ASCII-only identifiers, and SHOULD use English words "
"wherever feasible (in many cases, abbreviations and technical terms are used "
"which aren't English). In addition, string literals and comments must also "
"be in ASCII. The only exceptions are (a) test cases testing the non-ASCII "
"features, and (b) names of authors. Authors whose names are not based on the "
"latin alphabet MUST provide a latin transliteration of their names."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:265
#: ../dev_guide/python_style_guide.rst:262
msgid ""
"Open source projects with a global audience are encouraged to adopt a "
"similar policy."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:271
#: ../dev_guide/python_style_guide.rst:268
msgid "Imports"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:273
#: ../dev_guide/python_style_guide.rst:270
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:280
#: ../dev_guide/python_style_guide.rst:277
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:284
#: ../dev_guide/python_style_guide.rst:281
msgid ""
"Imports are always put at the top of the file, just after any module "
"comments and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:287
#: ../dev_guide/python_style_guide.rst:284
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:289
#: ../dev_guide/python_style_guide.rst:286
msgid "standard library imports"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:290
#: ../dev_guide/python_style_guide.rst:287
msgid "related third party imports"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:291
#: ../dev_guide/python_style_guide.rst:288
msgid "local application/library specific imports"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:293
#: ../dev_guide/python_style_guide.rst:290
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:295
#: ../dev_guide/python_style_guide.rst:292
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:297
#: ../dev_guide/python_style_guide.rst:294
msgid ""
"Relative imports for intra-package imports are highly discouraged. Always "
"use the absolute package path for all imports.  Even now that PEP 328 is "
"fully implemented in Python 2.5, its style of explicit relative imports is "
"actively discouraged; absolute imports are more portable and usually more "
"readable."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:303
#: ../dev_guide/python_style_guide.rst:300
msgid ""
"When importing a class from a class-containing module, it's usually okay to "
"spell this::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:309
#: ../dev_guide/python_style_guide.rst:306
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:314
#: ../dev_guide/python_style_guide.rst:311
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:319
#: ../dev_guide/python_style_guide.rst:316
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:323
#: ../dev_guide/python_style_guide.rst:320
msgid "Pet Peeves"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:325
#: ../dev_guide/python_style_guide.rst:322
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:327
#: ../dev_guide/python_style_guide.rst:324
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:332
#: ../dev_guide/python_style_guide.rst:329
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:337
#: ../dev_guide/python_style_guide.rst:334
msgid ""
"Immediately before the open parenthesis that starts the argument list of a "
"function call::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:343
#: ../dev_guide/python_style_guide.rst:340
msgid ""
"Immediately before the open parenthesis that starts an indexing or slicing::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:349
#: ../dev_guide/python_style_guide.rst:346
msgid ""
"More than one space around an assignment (or other) operator to align it "
"with another."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:367
#: ../dev_guide/python_style_guide.rst:364
msgid "Other Recommendations"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:369
#: ../dev_guide/python_style_guide.rst:366
msgid ""
"Always surround these binary operators with a single space on either side: "
"assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), comparisons "
"(``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, ``in``, ``not in``, "
"``is``, ``is not``), Booleans (``and``, ``or``, ``not``)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:375
#: ../dev_guide/python_style_guide.rst:372
msgid ""
"If operators with different priorities are used, consider adding whitespace "
"around the operators with the lowest priority(ies). Use your own judgement; "
"however, never use more than one space, and always have the same amount of "
"whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:397
#: ../dev_guide/python_style_guide.rst:394
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword "
"argument or a default parameter value."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:410
#: ../dev_guide/python_style_guide.rst:407
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:421
#: ../doc/dev_guide/python_style_guide.rst:430
#: ../dev_guide/python_style_guide.rst:418
#: ../dev_guide/python_style_guide.rst:427
msgid "Rather not::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:426
#: ../dev_guide/python_style_guide.rst:423
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the "
"same line, never do this for multi-clause statements.  Also avoid folding "
"such long lines!"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:436
#: ../dev_guide/python_style_guide.rst:433
msgid "Definitely not::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:451
#: ../dev_guide/python_style_guide.rst:448
msgid "Comments"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:453
#: ../dev_guide/python_style_guide.rst:450
msgid ""
"Comments that contradict the code are worse than no comments.  Always make a "
"priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:457
#: ../dev_guide/python_style_guide.rst:454
msgid ""
"Comments should be complete sentences.  If a comment is a phrase or "
"sentence, its first word should be capitalized, unless it is an identifier "
"that begins with a lower case letter (never alter the case of identifiers!)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:462
#: ../dev_guide/python_style_guide.rst:459
msgid ""
"If a comment is short, the period at the end can be omitted.  Block comments "
"generally consist of one or more paragraphs built out of complete sentences, "
"and each sentence should end in a period."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:466
#: ../dev_guide/python_style_guide.rst:463
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:468
#: ../dev_guide/python_style_guide.rst:465
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:470
#: ../dev_guide/python_style_guide.rst:467
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your "
"comments in English, unless you are 120% sure that the code will never be "
"read by people who don't speak your language."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:476
#: ../dev_guide/python_style_guide.rst:473
msgid "Block Comments"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:478
#: ../dev_guide/python_style_guide.rst:475
msgid ""
"Block comments generally apply to some (or all) code that follows them, and "
"are indented to the same level as that code.  Each line of a block comment "
"starts with a ``#`` and a single space (unless it is indented text inside "
"the comment)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:483
#: ../dev_guide/python_style_guide.rst:480
msgid ""
"Paragraphs inside a block comment are separated by a line containing a "
"single ``#``."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:488
#: ../dev_guide/python_style_guide.rst:485
msgid "Inline Comments"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:490
#: ../dev_guide/python_style_guide.rst:487
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:492
#: ../dev_guide/python_style_guide.rst:489
msgid ""
"An inline comment is a comment on the same line as a statement. Inline "
"comments should be separated by at least two spaces from the statement.  "
"They should start with a # and a single space."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:496
#: ../dev_guide/python_style_guide.rst:493
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the "
"obvious.  Don't do this::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:499
#: ../dev_guide/python_style_guide.rst:496
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:501
#: ../dev_guide/python_style_guide.rst:498
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:503
#: ../dev_guide/python_style_guide.rst:500
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:507
#: ../dev_guide/python_style_guide.rst:504
msgid "Documentation Strings"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:509
#: ../dev_guide/python_style_guide.rst:506
msgid ""
"Conventions for writing good documentation strings (a.k.a. \"docstrings\") "
"are immortalized in PEP 257."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:512
#: ../dev_guide/python_style_guide.rst:509
msgid ""
"Write docstrings for all public modules, functions, classes, and methods.  "
"Docstrings are not necessary for non-public methods, but you should have a "
"comment that describes what the method does.  This comment should appear "
"after the ``def`` line."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:517
#: ../dev_guide/python_style_guide.rst:514
msgid ""
"PEP 257 describes good docstring conventions.  Note that most importantly, "
"the ``\"\"\"`` that ends a multiline docstring should be on a line by "
"itself, and preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:527
#: ../dev_guide/python_style_guide.rst:524
msgid ""
"For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the "
"same line."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:533
#: ../dev_guide/python_style_guide.rst:530
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:535
#: ../dev_guide/python_style_guide.rst:532
msgid ""
"If you have to have Subversion, CVS, or RCS crud in your source file, do it "
"as follows. ::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:538
#: ../dev_guide/python_style_guide.rst:535
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:541
#: ../dev_guide/python_style_guide.rst:538
msgid ""
"These lines should be included after the module's docstring, before any "
"other code, separated by a blank line above and below."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:547
#: ../dev_guide/python_style_guide.rst:544
msgid "Naming Conventions"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:549
#: ../dev_guide/python_style_guide.rst:546
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll "
"never get this completely consistent -- nevertheless, here are the currently "
"recommended naming standards.  New modules and packages (including third "
"party frameworks) should be written to these standards, but where an "
"existing library has a different style, internal consistency is preferred."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:558
#: ../dev_guide/python_style_guide.rst:555
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:560
#: ../dev_guide/python_style_guide.rst:557
msgid ""
"There are a lot of different naming styles.  It helps to be able to "
"recognize what naming style is being used, independently from what they are "
"used for."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:564
#: ../dev_guide/python_style_guide.rst:561
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:566
#: ../dev_guide/python_style_guide.rst:563
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:567
#: ../dev_guide/python_style_guide.rst:564
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:568
#: ../dev_guide/python_style_guide.rst:565
msgid "``lowercase``"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:569
#: ../dev_guide/python_style_guide.rst:566
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:570
#: ../dev_guide/python_style_guide.rst:567
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:571
#: ../dev_guide/python_style_guide.rst:568
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:572
#: ../dev_guide/python_style_guide.rst:569
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of the "
"bumpy look of its letters [3]_).  This is also sometimes known as StudlyCaps."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:576
#: ../dev_guide/python_style_guide.rst:573
msgid ""
"Note: When using abbreviations in CapWords, capitalize all the letters of "
"the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:579
#: ../dev_guide/python_style_guide.rst:576
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase character!)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:581
#: ../dev_guide/python_style_guide.rst:578
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:583
#: ../dev_guide/python_style_guide.rst:580
msgid ""
"There's also the style of using a short unique prefix to group related names "
"together.  This is not used much in Python, but it is mentioned for "
"completeness.  For example, the ``os.stat()`` function returns a tuple whose "
"items traditionally have names like ``st_mode``, ``st_size``, ``st_mtime`` "
"and so on.  (This is done to emphasize the correspondence with the fields of "
"the POSIX system call struct, which helps programmers familiar with that.)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:591
#: ../dev_guide/python_style_guide.rst:588
msgid ""
"The X11 library uses a leading X for all its public functions.  In Python, "
"this style is generally deemed unnecessary because attribute and method "
"names are prefixed with an object, and function names are prefixed with a "
"module name."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:596
#: ../dev_guide/python_style_guide.rst:593
msgid ""
"In addition, the following special forms using leading or trailing "
"underscores are recognized (these can generally be combined with any case "
"convention):"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:600
#: ../dev_guide/python_style_guide.rst:597
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. ``from "
"M import *`` does not import objects whose name starts with an underscore."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:604
#: ../dev_guide/python_style_guide.rst:601
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts with "
"Python keyword, e.g. ::"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:609
#: ../dev_guide/python_style_guide.rst:606
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes name "
"mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; see "
"below)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:613
#: ../dev_guide/python_style_guide.rst:610
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or "
"attributes that live in user-controlled namespaces. E.g. ``__init__``, "
"``__import__`` or ``__file__``.  Never invent such names; only use them as "
"documented."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:620
#: ../dev_guide/python_style_guide.rst:617
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:624
#: ../dev_guide/python_style_guide.rst:621
msgid "Names to Avoid"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:626
#: ../dev_guide/python_style_guide.rst:623
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter "
"oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:630
#: ../dev_guide/python_style_guide.rst:627
msgid ""
"In some fonts, these characters are indistinguishable from the numerals one "
"and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:635
#: ../dev_guide/python_style_guide.rst:632
msgid "Package and Module Names"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:637
#: ../dev_guide/python_style_guide.rst:634
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used in "
"the module name if it improves readability.  Python packages should also "
"have short, all-lowercase names, although the use of underscores is "
"discouraged."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:642
#: ../dev_guide/python_style_guide.rst:639
msgid ""
"Since module names are mapped to file names, and some file systems are case "
"insensitive and truncate long names, it is important that module names be "
"chosen to be fairly short -- this won't be a problem on Unix, but it may be "
"a problem when the code is transported to older Mac or Windows versions, or "
"DOS."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:648
#: ../dev_guide/python_style_guide.rst:645
msgid ""
"When an extension module written in C or C++ has an accompanying Python "
"module that provides a higher level (e.g. more object oriented) interface, "
"the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:655
#: ../dev_guide/python_style_guide.rst:652
msgid "Class Names"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:657
#: ../dev_guide/python_style_guide.rst:654
msgid ""
"Almost without exception, class names use the CapWords convention. Classes "
"for internal use have a leading underscore in addition."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:662
#: ../dev_guide/python_style_guide.rst:659
msgid "Exception Names"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:664
#: ../dev_guide/python_style_guide.rst:661
msgid ""
"Because exceptions should be classes, the class naming convention applies "
"here.  However, you should use the suffix \"Error\" on your exception names "
"(if the exception actually is an error)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:670
#: ../dev_guide/python_style_guide.rst:667
msgid "Global Variable Names"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:672
#: ../dev_guide/python_style_guide.rst:669
msgid ""
"(Let's hope that these variables are meant for use inside one module only.)  "
"The conventions are about the same as those for functions."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:675
#: ../dev_guide/python_style_guide.rst:672
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older "
"convention of prefixing such globals with an underscore (which you might "
"want to do to indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:683
#: ../dev_guide/python_style_guide.rst:680
msgid "Function Names"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:685
#: ../dev_guide/python_style_guide.rst:682
msgid ""
"Function names should be lowercase, with words separated by underscores as "
"necessary to improve readability."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:688
#: ../dev_guide/python_style_guide.rst:685
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing "
"style (e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:694
#: ../dev_guide/python_style_guide.rst:691
msgid "Function and method arguments"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:696
#: ../dev_guide/python_style_guide.rst:693
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:698
#: ../dev_guide/python_style_guide.rst:695
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:700
#: ../dev_guide/python_style_guide.rst:697
msgid ""
"If a function argument's name clashes with a reserved keyword, it is "
"generally better to append a single trailing underscore rather than use an "
"abbreviation or spelling corruption.  Thus ``class_`` is better than "
"``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:708
#: ../dev_guide/python_style_guide.rst:705
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:710
#: ../dev_guide/python_style_guide.rst:707
msgid ""
"Use the function naming rules: lowercase with words separated by underscores "
"as necessary to improve readability."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:713
#: ../dev_guide/python_style_guide.rst:710
msgid ""
"Use one leading underscore only for non-public methods and instance "
"variables."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:716
#: ../dev_guide/python_style_guide.rst:713
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to invoke "
"Python's name mangling rules."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:719
#: ../dev_guide/python_style_guide.rst:716
msgid ""
"Python mangles these names with the class name: if class Foo has an "
"attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An "
"insistent user could still gain access by calling ``Foo._Foo__a``.) "
"Generally, double leading underscores should be used only to avoid name "
"conflicts with attributes in classes designed to be subclassed."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:725
#: ../dev_guide/python_style_guide.rst:722
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:729
#: ../dev_guide/python_style_guide.rst:726
msgid "Constants"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:731
#: ../dev_guide/python_style_guide.rst:728
msgid ""
"Constants are usually defined on a module level and written in all capital "
"letters with underscores separating words.  Examples include "
"``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:737
#: ../dev_guide/python_style_guide.rst:734
msgid "Designing for inheritance"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:739
#: ../dev_guide/python_style_guide.rst:736
msgid ""
"Always decide whether a class's methods and instance variables "
"(collectively: \"attributes\") should be public or non-public.  If in doubt, "
"choose non-public; it's easier to make it public later than to make a public "
"attribute non-public."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:744
#: ../dev_guide/python_style_guide.rst:741
msgid ""
"Public attributes are those that you expect unrelated clients of your class "
"to use, with your commitment to avoid backward incompatible changes.  Non-"
"public attributes are those that are not intended to be used by third "
"parties; you make no guarantees that non-public attributes won't change or "
"even be removed."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:750
#: ../dev_guide/python_style_guide.rst:747
msgid ""
"We don't use the term \"private\" here, since no attribute is really private "
"in Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:753
#: ../dev_guide/python_style_guide.rst:750
msgid ""
"Another category of attributes are those that are part of the \"subclass API"
"\" (often called \"protected\" in other languages).  Some classes are "
"designed to be inherited from, either to extend or modify aspects of the "
"class's behavior.  When designing such a class, take care to make explicit "
"decisions about which attributes are public, which are part of the subclass "
"API, and which are truly only to be used by your base class."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:761
#: ../dev_guide/python_style_guide.rst:758
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:763
#: ../dev_guide/python_style_guide.rst:760
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:765
#: ../dev_guide/python_style_guide.rst:762
msgid ""
"If your public attribute name collides with a reserved keyword, append a "
"single trailing underscore to your attribute name.  This is preferable to an "
"abbreviation or corrupted spelling.  (However, not withstanding this rule, "
"'cls' is the preferred spelling for any variable or argument which is known "
"to be a class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:773
#: ../doc/dev_guide/python_style_guide.rst:784
#: ../doc/dev_guide/python_style_guide.rst:806
#: ../dev_guide/python_style_guide.rst:770
#: ../dev_guide/python_style_guide.rst:781
#: ../dev_guide/python_style_guide.rst:803
msgid "Note 1:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:773
#: ../dev_guide/python_style_guide.rst:770
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:775
#: ../dev_guide/python_style_guide.rst:772
msgid ""
"For simple public data attributes, it is best to expose just the attribute "
"name, without complicated accessor/mutator methods.  Keep in mind that "
"Python provides an easy path to future enhancement, should you find that a "
"simple data attribute needs to grow functional behavior.  In that case, use "
"properties to hide functional implementation behind simple data attribute "
"access syntax."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:784
#: ../dev_guide/python_style_guide.rst:781
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:788
#: ../doc/dev_guide/python_style_guide.rst:811
#: ../dev_guide/python_style_guide.rst:785
#: ../dev_guide/python_style_guide.rst:808
msgid "Note 2:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:787
#: ../dev_guide/python_style_guide.rst:784
msgid ""
"Try to keep the functional behavior side-effect free, although side-effects "
"such as caching are generally fine."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:793
#: ../doc/dev_guide/python_style_guide.rst:816
#: ../dev_guide/python_style_guide.rst:790
#: ../dev_guide/python_style_guide.rst:813
msgid "Note 3:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:791
#: ../dev_guide/python_style_guide.rst:788
msgid ""
"Avoid using properties for computationally expensive operations; the "
"attribute notation makes the caller believe that access is (relatively) "
"cheap."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:795
#: ../dev_guide/python_style_guide.rst:792
msgid ""
"If your class is intended to be subclassed, and you have attributes that you "
"do not want subclasses to use, consider naming them with double leading "
"underscores and no trailing underscores.  This invokes Python's name "
"mangling algorithm, where the name of the class is mangled into the "
"attribute name.  This helps avoid attribute name collisions should "
"subclasses inadvertently contain attributes with the same name."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:804
#: ../dev_guide/python_style_guide.rst:801
msgid ""
"Note that only the simple class name is used in the mangled name, so if a "
"subclass chooses both the same class name and attribute name, you can still "
"get name collisions."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:809
#: ../dev_guide/python_style_guide.rst:806
msgid ""
"Name mangling can make certain uses, such as debugging and "
"``__getattr__()``, less convenient.  However the name mangling algorithm is "
"well documented and easy to perform manually."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:814
#: ../dev_guide/python_style_guide.rst:811
msgid ""
"Not everyone likes name mangling.  Try to balance the need to avoid "
"accidental name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:820
#: ../dev_guide/python_style_guide.rst:817
msgid "References"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:822
#: ../dev_guide/python_style_guide.rst:819
msgid ""
"`PEP 7, Style Guide for C Code, van Rossum <https://www.python.org/dev/peps/"
"pep-0007/>`_"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:823
#: ../dev_guide/python_style_guide.rst:820
msgid ""
"`Barry's GNU Mailman style guide <http://barry.warsaw.us/software/STYLEGUIDE."
"txt>`_"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:824
#: ../dev_guide/python_style_guide.rst:821
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:828
#: ../dev_guide/python_style_guide.rst:825
msgid "Copyright"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:830
#: ../dev_guide/python_style_guide.rst:827
msgid "Author:"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:832
#: ../dev_guide/python_style_guide.rst:829
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/dev_guide/python_style_guide.rst:833
#: ../dev_guide/python_style_guide.rst:830
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../reference_capi/box.rst:28
msgid "Module `box`"
msgstr "Модуль `box`"

#: ../doc/dev_guide/reference_capi/box.rst:35
#: ../dev_guide/reference_capi/box.rst:32 ../reference_capi/box.rst:32
msgid "Opaque structure passed to the stored C procedure"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:39
#: ../dev_guide/reference_capi/box.rst:36 ../reference_capi/box.rst:36
msgid "Return a tuple from stored C procedure."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:41
#: ../dev_guide/reference_capi/box.rst:38 ../reference_capi/box.rst:38
msgid "Returned tuple is automatically reference counted by Tarantool."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:43
#: ../dev_guide/reference_capi/box.rst:40 ../reference_capi/box.rst:40
msgid "an opaque structure passed to the stored C procedure by Tarantool"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:45
#: ../dev_guide/reference_capi/box.rst:42 ../reference_capi/box.rst:42
msgid "a tuple to return"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:47
#: ../dev_guide/reference_capi/box.rst:44 ../reference_capi/box.rst:44
msgid ""
"-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-"
"error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:49
#: ../doc/dev_guide/reference_capi/box.rst:97
#: ../doc/dev_guide/reference_capi/box.rst:112
#: ../doc/dev_guide/reference_capi/box.rst:128
#: ../doc/dev_guide/reference_capi/box.rst:150
#: ../doc/dev_guide/reference_capi/box.rst:172
#: ../doc/dev_guide/reference_capi/tuple.rst:85
#: ../doc/dev_guide/reference_capi/tuple.rst:98
#: ../dev_guide/reference_capi/box.rst:46
#: ../dev_guide/reference_capi/box.rst:94
#: ../dev_guide/reference_capi/box.rst:109
#: ../dev_guide/reference_capi/box.rst:125
#: ../dev_guide/reference_capi/box.rst:147
#: ../dev_guide/reference_capi/box.rst:169
#: ../dev_guide/reference_capi/tuple.rst:82
#: ../dev_guide/reference_capi/tuple.rst:95 ../reference_capi/box.rst:46
#: ../reference_capi/box.rst:94 ../reference_capi/box.rst:109
#: ../reference_capi/box.rst:125 ../reference_capi/box.rst:147
#: ../reference_capi/box.rst:169 ../reference_capi/tuple.rst:82
#: ../reference_capi/tuple.rst:95
msgid "0 otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:55
#: ../dev_guide/reference_capi/box.rst:52 ../reference_capi/box.rst:52
msgid "Find space id by name."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:57
#: ../dev_guide/reference_capi/box.rst:54 ../reference_capi/box.rst:54
msgid "This function performs SELECT request to _vspace system space."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:59
#: ../dev_guide/reference_capi/box.rst:56 ../reference_capi/box.rst:56
msgid "space name"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:60
#: ../doc/dev_guide/reference_capi/box.rst:74
#: ../dev_guide/reference_capi/box.rst:57
#: ../dev_guide/reference_capi/box.rst:71 ../reference_capi/box.rst:57
#: ../reference_capi/box.rst:71
msgid "length of ``name``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:62
#: ../doc/dev_guide/reference_capi/box.rst:76
#: ../dev_guide/reference_capi/box.rst:59
#: ../dev_guide/reference_capi/box.rst:73 ../reference_capi/box.rst:59
#: ../reference_capi/box.rst:73
msgid ""
":c:macro:`BOX_ID_NIL` on error or if not found (check :ref:"
"`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:64
#: ../doc/dev_guide/reference_capi/box.rst:78
#: ../dev_guide/reference_capi/box.rst:61
#: ../dev_guide/reference_capi/box.rst:75 ../reference_capi/box.rst:61
#: ../reference_capi/box.rst:75
msgid "space_id otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:66
#: ../dev_guide/reference_capi/box.rst:63 ../reference_capi/box.rst:63
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:70
#: ../dev_guide/reference_capi/box.rst:67 ../reference_capi/box.rst:67
msgid "Find index id by name."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:72
#: ../doc/dev_guide/reference_capi/box.rst:90
#: ../doc/dev_guide/reference_capi/box.rst:105
#: ../doc/dev_guide/reference_capi/box.rst:120
#: ../doc/dev_guide/reference_capi/box.rst:136
#: ../doc/dev_guide/reference_capi/box.rst:158
#: ../doc/dev_guide/reference_capi/box_index.rst:113
#: ../doc/dev_guide/reference_capi/box_index.rst:152
#: ../doc/dev_guide/reference_capi/box_index.rst:162
#: ../doc/dev_guide/reference_capi/box_index.rst:172
#: ../doc/dev_guide/reference_capi/box_index.rst:189
#: ../doc/dev_guide/reference_capi/box_index.rst:205
#: ../doc/dev_guide/reference_capi/box_index.rst:221
#: ../doc/dev_guide/reference_capi/box_index.rst:237
#: ../dev_guide/reference_capi/box.rst:69
#: ../dev_guide/reference_capi/box.rst:87
#: ../dev_guide/reference_capi/box.rst:102
#: ../dev_guide/reference_capi/box.rst:117
#: ../dev_guide/reference_capi/box.rst:133
#: ../dev_guide/reference_capi/box.rst:155
#: ../dev_guide/reference_capi/box_index.rst:110
#: ../dev_guide/reference_capi/box_index.rst:149
#: ../dev_guide/reference_capi/box_index.rst:159
#: ../dev_guide/reference_capi/box_index.rst:169
#: ../dev_guide/reference_capi/box_index.rst:186
#: ../dev_guide/reference_capi/box_index.rst:202
#: ../dev_guide/reference_capi/box_index.rst:218
#: ../dev_guide/reference_capi/box_index.rst:234 ../reference_capi/box.rst:69
#: ../reference_capi/box.rst:87 ../reference_capi/box.rst:102
#: ../reference_capi/box.rst:117 ../reference_capi/box.rst:133
#: ../reference_capi/box.rst:155 ../reference_capi/box_index.rst:110
#: ../reference_capi/box_index.rst:149 ../reference_capi/box_index.rst:159
#: ../reference_capi/box_index.rst:169 ../reference_capi/box_index.rst:186
#: ../reference_capi/box_index.rst:202 ../reference_capi/box_index.rst:218
#: ../reference_capi/box_index.rst:234
msgid "space identifier"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:73
#: ../dev_guide/reference_capi/box.rst:70 ../reference_capi/box.rst:70
msgid "index name"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:80
#: ../dev_guide/reference_capi/box.rst:77 ../reference_capi/box.rst:77
msgid "This function performs SELECT request to _vindex system space."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:82
#: ../dev_guide/reference_capi/box.rst:79 ../reference_capi/box.rst:79
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:88
#: ../dev_guide/reference_capi/box.rst:85 ../reference_capi/box.rst:85
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:91
#: ../doc/dev_guide/reference_capi/box.rst:106
#: ../doc/dev_guide/reference_capi/box.rst:160
#: ../dev_guide/reference_capi/box.rst:88
#: ../dev_guide/reference_capi/box.rst:103
#: ../dev_guide/reference_capi/box.rst:157 ../reference_capi/box.rst:88
#: ../reference_capi/box.rst:103 ../reference_capi/box.rst:157
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:92
#: ../doc/dev_guide/reference_capi/box.rst:107
#: ../doc/dev_guide/reference_capi/box.rst:161
#: ../dev_guide/reference_capi/box.rst:89
#: ../dev_guide/reference_capi/box.rst:104
#: ../dev_guide/reference_capi/box.rst:158 ../reference_capi/box.rst:89
#: ../reference_capi/box.rst:104 ../reference_capi/box.rst:158
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:93
#: ../doc/dev_guide/reference_capi/box.rst:108
#: ../dev_guide/reference_capi/box.rst:90
#: ../dev_guide/reference_capi/box.rst:105 ../reference_capi/box.rst:90
#: ../reference_capi/box.rst:105
msgid "output argument. Resulted tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:96
#: ../doc/dev_guide/reference_capi/box.rst:111
#: ../doc/dev_guide/reference_capi/box.rst:127
#: ../doc/dev_guide/reference_capi/box.rst:149
#: ../dev_guide/reference_capi/box.rst:93
#: ../dev_guide/reference_capi/box.rst:108
#: ../dev_guide/reference_capi/box.rst:124
#: ../dev_guide/reference_capi/box.rst:146 ../reference_capi/box.rst:93
#: ../reference_capi/box.rst:108 ../reference_capi/box.rst:124
#: ../reference_capi/box.rst:146
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:99
#: ../dev_guide/reference_capi/box.rst:96 ../reference_capi/box.rst:96
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:103
#: ../dev_guide/reference_capi/box.rst:100 ../reference_capi/box.rst:100
msgid "Execute an REPLACE request."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:114
#: ../dev_guide/reference_capi/box.rst:111 ../reference_capi/box.rst:111
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:118
#: ../dev_guide/reference_capi/box.rst:115 ../reference_capi/box.rst:115
msgid "Execute an DELETE request."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:121
#: ../doc/dev_guide/reference_capi/box.rst:137
#: ../doc/dev_guide/reference_capi/box.rst:159
#: ../doc/dev_guide/reference_capi/box_index.rst:114
#: ../doc/dev_guide/reference_capi/box_index.rst:153
#: ../doc/dev_guide/reference_capi/box_index.rst:163
#: ../doc/dev_guide/reference_capi/box_index.rst:173
#: ../doc/dev_guide/reference_capi/box_index.rst:190
#: ../doc/dev_guide/reference_capi/box_index.rst:206
#: ../doc/dev_guide/reference_capi/box_index.rst:222
#: ../doc/dev_guide/reference_capi/box_index.rst:238
#: ../dev_guide/reference_capi/box.rst:118
#: ../dev_guide/reference_capi/box.rst:134
#: ../dev_guide/reference_capi/box.rst:156
#: ../dev_guide/reference_capi/box_index.rst:111
#: ../dev_guide/reference_capi/box_index.rst:150
#: ../dev_guide/reference_capi/box_index.rst:160
#: ../dev_guide/reference_capi/box_index.rst:170
#: ../dev_guide/reference_capi/box_index.rst:187
#: ../dev_guide/reference_capi/box_index.rst:203
#: ../dev_guide/reference_capi/box_index.rst:219
#: ../dev_guide/reference_capi/box_index.rst:235 ../reference_capi/box.rst:118
#: ../reference_capi/box.rst:134 ../reference_capi/box.rst:156
#: ../reference_capi/box_index.rst:111 ../reference_capi/box_index.rst:150
#: ../reference_capi/box_index.rst:160 ../reference_capi/box_index.rst:170
#: ../reference_capi/box_index.rst:187 ../reference_capi/box_index.rst:203
#: ../reference_capi/box_index.rst:219 ../reference_capi/box_index.rst:235
msgid "index identifier"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:122
#: ../doc/dev_guide/reference_capi/box.rst:138
#: ../dev_guide/reference_capi/box.rst:119
#: ../dev_guide/reference_capi/box.rst:135 ../reference_capi/box.rst:119
#: ../reference_capi/box.rst:135
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:123
#: ../doc/dev_guide/reference_capi/box.rst:139
#: ../dev_guide/reference_capi/box.rst:120
#: ../dev_guide/reference_capi/box.rst:136 ../reference_capi/box.rst:120
#: ../reference_capi/box.rst:136
msgid "end of a ``key``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:124
#: ../doc/dev_guide/reference_capi/box.rst:146
#: ../doc/dev_guide/reference_capi/box.rst:168
#: ../dev_guide/reference_capi/box.rst:121
#: ../dev_guide/reference_capi/box.rst:143
#: ../dev_guide/reference_capi/box.rst:165 ../reference_capi/box.rst:121
#: ../reference_capi/box.rst:143 ../reference_capi/box.rst:165
msgid ""
"output argument. Result an old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:130
#: ../dev_guide/reference_capi/box.rst:127 ../reference_capi/box.rst:127
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:134
#: ../dev_guide/reference_capi/box.rst:131 ../reference_capi/box.rst:131
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:140
#: ../doc/dev_guide/reference_capi/box.rst:162
#: ../dev_guide/reference_capi/box.rst:137
#: ../dev_guide/reference_capi/box.rst:159 ../reference_capi/box.rst:137
#: ../reference_capi/box.rst:159
msgid ""
"encoded operations in MsgPack Arrat format, e.g. ``[[ '=', field_id,  "
"value ], ['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:142
#: ../doc/dev_guide/reference_capi/box.rst:164
#: ../dev_guide/reference_capi/box.rst:139
#: ../dev_guide/reference_capi/box.rst:161 ../reference_capi/box.rst:139
#: ../reference_capi/box.rst:161
msgid "end of a ``ops``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:143
#: ../doc/dev_guide/reference_capi/box.rst:165
#: ../dev_guide/reference_capi/box.rst:140
#: ../dev_guide/reference_capi/box.rst:162 ../reference_capi/box.rst:140
#: ../reference_capi/box.rst:162
msgid ""
"0 if field_ids in update operation are zero-based indexed (like C) or 1 if "
"for one-based indexed field ids (like Lua)."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:152
#: ../dev_guide/reference_capi/box.rst:149 ../reference_capi/box.rst:149
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:156
#: ../dev_guide/reference_capi/box.rst:153 ../reference_capi/box.rst:153
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:171
#: ../dev_guide/reference_capi/box.rst:168 ../reference_capi/box.rst:168
msgid ""
"-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box.rst:174
#: ../dev_guide/reference_capi/box.rst:171 ../reference_capi/box.rst:171
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../reference_capi/box_index.rst:28
msgid "Module `index`"
msgstr "Модуль `index`"

#: ../doc/dev_guide/reference_capi/box_index.rst:35
#: ../dev_guide/reference_capi/box_index.rst:32
#: ../reference_capi/box_index.rst:32
msgid "A space iterator"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:41
#: ../dev_guide/reference_capi/box_index.rst:38
#: ../reference_capi/box_index.rst:38
msgid ""
"Controls how to iterate over tuples in an index. Different index types "
"support different iterator types. For example, one can start iteration from "
"a particular value (request key) and then retrieve all tuples where keys are "
"greater or equal (= GE) to this key."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:46
#: ../dev_guide/reference_capi/box_index.rst:43
#: ../reference_capi/box_index.rst:43
msgid ""
"If iterator type is not supported by the selected index type, iterator "
"constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, "
"an index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:50
#: ../dev_guide/reference_capi/box_index.rst:47
#: ../reference_capi/box_index.rst:47
msgid ""
"NULL value of request key corresponds to the first or last key in the index, "
"depending on iteration direction. (first key for GE and GT types, and last "
"key for LE and LT). Therefore, to iterate over all tuples in an index, one "
"can use ITER_GE or ITER_LE iteration types with start key equal to NULL. For "
"ITER_EQ, the key must not be NULL."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:58
#: ../dev_guide/reference_capi/box_index.rst:55
#: ../reference_capi/box_index.rst:55
msgid "key == x ASC order"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:62
#: ../dev_guide/reference_capi/box_index.rst:59
#: ../reference_capi/box_index.rst:59
msgid "key == x DESC order"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:66
#: ../dev_guide/reference_capi/box_index.rst:63
#: ../reference_capi/box_index.rst:63
msgid "all tuples"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:70
#: ../dev_guide/reference_capi/box_index.rst:67
#: ../reference_capi/box_index.rst:67
msgid "key < x"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:74
#: ../dev_guide/reference_capi/box_index.rst:71
#: ../reference_capi/box_index.rst:71
msgid "key <= x"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:78
#: ../dev_guide/reference_capi/box_index.rst:75
#: ../reference_capi/box_index.rst:75
msgid "key >= x"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:82
#: ../dev_guide/reference_capi/box_index.rst:79
#: ../reference_capi/box_index.rst:79
msgid "key > x"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:86
#: ../dev_guide/reference_capi/box_index.rst:83
#: ../reference_capi/box_index.rst:83
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:90
#: ../dev_guide/reference_capi/box_index.rst:87
#: ../reference_capi/box_index.rst:87
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:94
#: ../dev_guide/reference_capi/box_index.rst:91
#: ../reference_capi/box_index.rst:91
msgid "all bits are not set"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:98
#: ../dev_guide/reference_capi/box_index.rst:95
#: ../reference_capi/box_index.rst:95
msgid "key overlaps x"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:102
#: ../dev_guide/reference_capi/box_index.rst:99
#: ../reference_capi/box_index.rst:99
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:108
#: ../dev_guide/reference_capi/box_index.rst:105
#: ../reference_capi/box_index.rst:105
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:110
#: ../dev_guide/reference_capi/box_index.rst:107
#: ../reference_capi/box_index.rst:107
msgid ""
"The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-"
"box_index-box_iterator_free>`."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:115
#: ../doc/dev_guide/reference_capi/box_index.rst:239
#: ../dev_guide/reference_capi/box_index.rst:112
#: ../dev_guide/reference_capi/box_index.rst:236
#: ../reference_capi/box_index.rst:112 ../reference_capi/box_index.rst:236
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:116
#: ../doc/dev_guide/reference_capi/box_index.rst:191
#: ../doc/dev_guide/reference_capi/box_index.rst:207
#: ../doc/dev_guide/reference_capi/box_index.rst:223
#: ../doc/dev_guide/reference_capi/box_index.rst:240
#: ../dev_guide/reference_capi/box_index.rst:113
#: ../dev_guide/reference_capi/box_index.rst:188
#: ../dev_guide/reference_capi/box_index.rst:204
#: ../dev_guide/reference_capi/box_index.rst:220
#: ../dev_guide/reference_capi/box_index.rst:237
#: ../reference_capi/box_index.rst:113 ../reference_capi/box_index.rst:188
#: ../reference_capi/box_index.rst:204 ../reference_capi/box_index.rst:220
#: ../reference_capi/box_index.rst:237
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:117
#: ../doc/dev_guide/reference_capi/box_index.rst:192
#: ../doc/dev_guide/reference_capi/box_index.rst:208
#: ../doc/dev_guide/reference_capi/box_index.rst:224
#: ../doc/dev_guide/reference_capi/box_index.rst:241
#: ../dev_guide/reference_capi/box_index.rst:114
#: ../dev_guide/reference_capi/box_index.rst:189
#: ../dev_guide/reference_capi/box_index.rst:205
#: ../dev_guide/reference_capi/box_index.rst:221
#: ../dev_guide/reference_capi/box_index.rst:238
#: ../reference_capi/box_index.rst:114 ../reference_capi/box_index.rst:189
#: ../reference_capi/box_index.rst:205 ../reference_capi/box_index.rst:221
#: ../reference_capi/box_index.rst:238
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:119
#: ../dev_guide/reference_capi/box_index.rst:116
#: ../reference_capi/box_index.rst:116
msgid "NULL on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:120
#: ../dev_guide/reference_capi/box_index.rst:117
#: ../reference_capi/box_index.rst:117
msgid "iterator otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:122
#: ../dev_guide/reference_capi/box_index.rst:119
#: ../reference_capi/box_index.rst:119
msgid ""
"See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, :ref:"
"`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:129
#: ../dev_guide/reference_capi/box_index.rst:126
#: ../reference_capi/box_index.rst:126
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:131
#: ../doc/dev_guide/reference_capi/box_index.rst:145
#: ../dev_guide/reference_capi/box_index.rst:128
#: ../dev_guide/reference_capi/box_index.rst:142
#: ../reference_capi/box_index.rst:128 ../reference_capi/box_index.rst:142
msgid ""
"an iterator returned by :ref:box_index_iterator`c_api-box_index-"
"box_index_iterator>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:133
#: ../dev_guide/reference_capi/box_index.rst:130
#: ../reference_capi/box_index.rst:130
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:136
#: ../doc/dev_guide/reference_capi/box_index.rst:155
#: ../doc/dev_guide/reference_capi/box_index.rst:165
#: ../doc/dev_guide/reference_capi/box_index.rst:196
#: ../dev_guide/reference_capi/box_index.rst:133
#: ../dev_guide/reference_capi/box_index.rst:152
#: ../dev_guide/reference_capi/box_index.rst:162
#: ../dev_guide/reference_capi/box_index.rst:193
#: ../reference_capi/box_index.rst:133 ../reference_capi/box_index.rst:152
#: ../reference_capi/box_index.rst:162 ../reference_capi/box_index.rst:193
msgid "-1 on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:137
#: ../dev_guide/reference_capi/box_index.rst:134
#: ../reference_capi/box_index.rst:134
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:143
#: ../dev_guide/reference_capi/box_index.rst:140
#: ../reference_capi/box_index.rst:140
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:150
#: ../dev_guide/reference_capi/box_index.rst:147
#: ../reference_capi/box_index.rst:147
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:156
#: ../doc/dev_guide/reference_capi/box_index.rst:166
#: ../dev_guide/reference_capi/box_index.rst:153
#: ../dev_guide/reference_capi/box_index.rst:163
#: ../reference_capi/box_index.rst:153 ../reference_capi/box_index.rst:163
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:160
#: ../dev_guide/reference_capi/box_index.rst:157
#: ../reference_capi/box_index.rst:157
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:170
#: ../dev_guide/reference_capi/box_index.rst:167
#: ../reference_capi/box_index.rst:167
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:174
#: ../dev_guide/reference_capi/box_index.rst:171
#: ../reference_capi/box_index.rst:171
msgid "random seed"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:175
#: ../doc/dev_guide/reference_capi/box_index.rst:193
#: ../doc/dev_guide/reference_capi/box_index.rst:209
#: ../doc/dev_guide/reference_capi/box_index.rst:225
#: ../dev_guide/reference_capi/box_index.rst:172
#: ../dev_guide/reference_capi/box_index.rst:190
#: ../dev_guide/reference_capi/box_index.rst:206
#: ../dev_guide/reference_capi/box_index.rst:222
#: ../reference_capi/box_index.rst:172 ../reference_capi/box_index.rst:190
#: ../reference_capi/box_index.rst:206 ../reference_capi/box_index.rst:222
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:178
#: ../dev_guide/reference_capi/box_index.rst:175
#: ../reference_capi/box_index.rst:175
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:182
#: ../dev_guide/reference_capi/box_index.rst:179
#: ../reference_capi/box_index.rst:179
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:184
#: ../dev_guide/reference_capi/box_index.rst:181
#: ../reference_capi/box_index.rst:181
msgid ""
"Please note that this function works much more faster than :ref:"
"`index_object.select<box_index-select>` or :ref:`box_index_iterator<c_api-"
"box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-box_index-"
"box_iterator_next>`."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:197
#: ../doc/dev_guide/reference_capi/box_index.rst:213
#: ../doc/dev_guide/reference_capi/box_index.rst:229
#: ../doc/dev_guide/reference_capi/box_index.rst:244
#: ../doc/dev_guide/reference_capi/txn.rst:44
#: ../doc/dev_guide/reference_capi/txn.rst:51
#: ../doc/dev_guide/reference_capi/utils.rst:93
#: ../dev_guide/reference_capi/box_index.rst:194
#: ../dev_guide/reference_capi/box_index.rst:210
#: ../dev_guide/reference_capi/box_index.rst:226
#: ../dev_guide/reference_capi/box_index.rst:241
#: ../dev_guide/reference_capi/txn.rst:41
#: ../dev_guide/reference_capi/txn.rst:48
#: ../dev_guide/reference_capi/utils.rst:90 ../reference_capi/box_index.rst:194
#: ../reference_capi/box_index.rst:210 ../reference_capi/box_index.rst:226
#: ../reference_capi/box_index.rst:241 ../reference_capi/txn.rst:41
#: ../reference_capi/txn.rst:48 ../reference_capi/utils.rst:90
msgid "0 on success"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:199
#: ../dev_guide/reference_capi/box_index.rst:196
#: ../reference_capi/box_index.rst:196
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:203
#: ../dev_guide/reference_capi/box_index.rst:200
#: ../reference_capi/box_index.rst:200
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:212
#: ../doc/dev_guide/reference_capi/box_index.rst:228
#: ../doc/dev_guide/reference_capi/box_index.rst:243
#: ../dev_guide/reference_capi/box_index.rst:209
#: ../dev_guide/reference_capi/box_index.rst:225
#: ../dev_guide/reference_capi/box_index.rst:240
#: ../reference_capi/box_index.rst:209 ../reference_capi/box_index.rst:225
#: ../reference_capi/box_index.rst:240
msgid "-1 on error (check :ref:box_error_last()`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:215
#: ../dev_guide/reference_capi/box_index.rst:212
#: ../reference_capi/box_index.rst:212
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:219
#: ../dev_guide/reference_capi/box_index.rst:216
#: ../reference_capi/box_index.rst:216
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:231
#: ../dev_guide/reference_capi/box_index.rst:228
#: ../reference_capi/box_index.rst:228
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:235
#: ../dev_guide/reference_capi/box_index.rst:232
#: ../reference_capi/box_index.rst:232
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/dev_guide/reference_capi/box_index.rst:246
#: ../dev_guide/reference_capi/box_index.rst:243
#: ../reference_capi/box_index.rst:243
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../reference_capi/clock.rst:28 ../reference_lua/clock.rst:30
msgid "Module `clock`"
msgstr "Модуль `clock`"

#: ../reference_capi/coio.rst:28
msgid "Module `coio`"
msgstr "Модуль `coio`"

#: ../doc/dev_guide/reference_capi/coio.rst:37
#: ../dev_guide/reference_capi/coio.rst:34 ../reference_capi/coio.rst:34
msgid "READ event"
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:41
#: ../dev_guide/reference_capi/coio.rst:38 ../reference_capi/coio.rst:38
msgid "WRITE event"
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:45
#: ../dev_guide/reference_capi/coio.rst:42 ../reference_capi/coio.rst:42
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:47
#: ../dev_guide/reference_capi/coio.rst:44 ../reference_capi/coio.rst:44
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:48
#: ../dev_guide/reference_capi/coio.rst:45 ../reference_capi/coio.rst:45
msgid ""
"requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:50
#: ../dev_guide/reference_capi/coio.rst:47 ../reference_capi/coio.rst:47
msgid "timeout in seconds."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:52
#: ../dev_guide/reference_capi/coio.rst:49 ../reference_capi/coio.rst:49
msgid "0 - timeout"
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:53
#: ../dev_guide/reference_capi/coio.rst:50 ../reference_capi/coio.rst:50
msgid ""
">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:57
#: ../dev_guide/reference_capi/coio.rst:54 ../reference_capi/coio.rst:54
msgid ""
"Create new eio task with specified function and arguments. Yield and wait "
"until the task is complete or a timeout occurs."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:60
#: ../dev_guide/reference_capi/coio.rst:57 ../reference_capi/coio.rst:57
msgid ""
"This function doesn't throw exceptions to avoid double error checking: in "
"most cases it's also necessary to check the return value of the called "
"function and perform necessary actions. If func sets errno, the errno is "
"preserved across the call."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:65
#: ../dev_guide/reference_capi/coio.rst:62 ../reference_capi/coio.rst:62
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:66
#: ../dev_guide/reference_capi/coio.rst:63 ../reference_capi/coio.rst:63
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:70
#: ../dev_guide/reference_capi/coio.rst:67 ../reference_capi/coio.rst:67
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/dev_guide/reference_capi/coio.rst:86
#: ../dev_guide/reference_capi/coio.rst:83 ../reference_capi/coio.rst:83
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../reference_capi/error.rst:28
msgid "Module `error`"
msgstr "Модуль `error`"

#: ../doc/dev_guide/reference_capi/error.rst:157
#: ../dev_guide/reference_capi/error.rst:154 ../reference_capi/error.rst:154
msgid "Error - contains information about error."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:161
#: ../dev_guide/reference_capi/error.rst:158 ../reference_capi/error.rst:158
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:163
#: ../doc/dev_guide/reference_capi/error.rst:170
#: ../doc/dev_guide/reference_capi/error.rst:177
#: ../dev_guide/reference_capi/error.rst:160
#: ../dev_guide/reference_capi/error.rst:167
#: ../dev_guide/reference_capi/error.rst:174 ../reference_capi/error.rst:160
#: ../reference_capi/error.rst:167 ../reference_capi/error.rst:174
msgid "error"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:164
#: ../doc/dev_guide/reference_capi/error.rst:178
#: ../dev_guide/reference_capi/error.rst:161
#: ../dev_guide/reference_capi/error.rst:175 ../reference_capi/error.rst:161
#: ../reference_capi/error.rst:175
msgid "not-null string"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:168
#: ../dev_guide/reference_capi/error.rst:165 ../reference_capi/error.rst:165
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:171
#: ../dev_guide/reference_capi/error.rst:168 ../reference_capi/error.rst:168
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:175
#: ../dev_guide/reference_capi/error.rst:172 ../reference_capi/error.rst:172
msgid "Return the error message"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:184
#: ../dev_guide/reference_capi/error.rst:181 ../reference_capi/error.rst:181
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:186
#: ../dev_guide/reference_capi/error.rst:183 ../reference_capi/error.rst:183
msgid ""
"The Tarantool error handling works most like libc's errno. All API calls "
"return -1 or NULL in the event of error. An internal pointer to box_error_t "
"type is set by API functions to indicate what went wrong. This value is only "
"significant if API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:191
#: ../dev_guide/reference_capi/error.rst:188 ../reference_capi/error.rst:188
msgid ""
"Successful function can also touch the last error in some cases. You don't "
"have to clear the last error before calling API functions. The returned "
"object is valid only until next call to **any** API function."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:195
#: ../dev_guide/reference_capi/error.rst:192 ../reference_capi/error.rst:192
msgid ""
"You must set the last error using box_error_set() in your stored C "
"procedures if you want to return a custom error message. You can re-throw "
"the last API error to IPROTO client by keeping the current value and "
"returning -1 to Tarantool from your stored procedure."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:200
#: ../dev_guide/reference_capi/error.rst:197 ../reference_capi/error.rst:197
msgid "last error"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:204
#: ../dev_guide/reference_capi/error.rst:201 ../reference_capi/error.rst:201
msgid "Clear the last error."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:208
#: ../dev_guide/reference_capi/error.rst:205 ../reference_capi/error.rst:205
msgid "Set the last error."
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:212
#: ../dev_guide/reference_capi/error.rst:209 ../reference_capi/error.rst:209
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:214
#: ../doc/dev_guide/reference_capi/say.rst:59
#: ../doc/dev_guide/reference_capi/say.rst:73
#: ../dev_guide/reference_capi/error.rst:211
#: ../dev_guide/reference_capi/say.rst:56
#: ../dev_guide/reference_capi/say.rst:70 ../reference_capi/error.rst:211
#: ../reference_capi/say.rst:56 ../reference_capi/say.rst:70
msgid "format arguments"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:216
#: ../dev_guide/reference_capi/error.rst:213 ../reference_capi/error.rst:213
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/error.rst:220
#: ../dev_guide/reference_capi/error.rst:217 ../reference_capi/error.rst:217
msgid "A backward-compatible API define."
msgstr ""

#: ../reference_capi/fiber.rst:28 ../reference_lua/fiber.rst:28
msgid "Module `fiber`"
msgstr "Модуль `fiber`"

#: ../doc/dev_guide/reference_capi/fiber.rst:35
#: ../dev_guide/reference_capi/fiber.rst:32 ../reference_capi/fiber.rst:32
msgid "Fiber - contains information about fiber"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:41
#: ../dev_guide/reference_capi/fiber.rst:38 ../reference_capi/fiber.rst:38
msgid "Create a new fiber."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:43
#: ../dev_guide/reference_capi/fiber.rst:40 ../reference_capi/fiber.rst:40
msgid ""
"Takes a fiber from fiber cache, if it's not empty. Can fail only if there is "
"not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:46
#: ../dev_guide/reference_capi/fiber.rst:43 ../reference_capi/fiber.rst:43
msgid ""
"The created fiber automatically returns itself to the fiber cache when its "
"\"main\" function completes."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:49
#: ../dev_guide/reference_capi/fiber.rst:46 ../reference_capi/fiber.rst:46
msgid "string with fiber name"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:50
#: ../dev_guide/reference_capi/fiber.rst:47 ../reference_capi/fiber.rst:47
msgid "func for run inside fiber"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:52
#: ../dev_guide/reference_capi/fiber.rst:49 ../reference_capi/fiber.rst:49
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:56
#: ../dev_guide/reference_capi/fiber.rst:53 ../reference_capi/fiber.rst:53
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:58
#: ../dev_guide/reference_capi/fiber.rst:55 ../reference_capi/fiber.rst:55
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:64
#: ../dev_guide/reference_capi/fiber.rst:61 ../reference_capi/fiber.rst:61
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:66
#: ../dev_guide/reference_capi/fiber.rst:63 ../reference_capi/fiber.rst:63
msgid "fiber to start"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:67
#: ../dev_guide/reference_capi/fiber.rst:64 ../reference_capi/fiber.rst:64
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:73
#: ../dev_guide/reference_capi/fiber.rst:70 ../reference_capi/fiber.rst:70
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:75
#: ../doc/dev_guide/reference_capi/fiber.rst:111
#: ../dev_guide/reference_capi/fiber.rst:72
#: ../dev_guide/reference_capi/fiber.rst:108 ../reference_capi/fiber.rst:72
#: ../reference_capi/fiber.rst:108
msgid "fiber to be woken up"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:79
#: ../dev_guide/reference_capi/fiber.rst:76 ../reference_capi/fiber.rst:76
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:81
#: ../dev_guide/reference_capi/fiber.rst:78 ../reference_capi/fiber.rst:78
msgid ""
"If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be woken "
"up (maybe prematurely). Then current fiber yields until the target fiber is "
"dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`)."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:85
#: ../dev_guide/reference_capi/fiber.rst:82 ../reference_capi/fiber.rst:82
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:89
#: ../dev_guide/reference_capi/fiber.rst:86 ../reference_capi/fiber.rst:86
msgid ""
"Make it possible or not possible to wakeup the current fiber immediately "
"when it's cancelled."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:92
#: ../doc/dev_guide/reference_capi/fiber.rst:103
#: ../dev_guide/reference_capi/fiber.rst:89
#: ../dev_guide/reference_capi/fiber.rst:100 ../reference_capi/fiber.rst:89
#: ../reference_capi/fiber.rst:100
msgid "fiber"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:93
#: ../doc/dev_guide/reference_capi/fiber.rst:104
#: ../dev_guide/reference_capi/fiber.rst:90
#: ../dev_guide/reference_capi/fiber.rst:101 ../reference_capi/fiber.rst:90
#: ../reference_capi/fiber.rst:101
msgid "status to set"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:95
#: ../dev_guide/reference_capi/fiber.rst:92 ../reference_capi/fiber.rst:92
msgid "previous state"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:101
#: ../dev_guide/reference_capi/fiber.rst:98 ../reference_capi/fiber.rst:98
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:108
#: ../dev_guide/reference_capi/fiber.rst:105 ../reference_capi/fiber.rst:105
msgid ""
"Wait until the fiber is dead and then move its execution status to the "
"caller. The fiber must not be detached."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:113
#: ../dev_guide/reference_capi/fiber.rst:110 ../reference_capi/fiber.rst:110
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:115
#: ../dev_guide/reference_capi/fiber.rst:112 ../reference_capi/fiber.rst:112
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:119
#: ../dev_guide/reference_capi/fiber.rst:116 ../reference_capi/fiber.rst:116
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:121
#: ../dev_guide/reference_capi/fiber.rst:118 ../reference_capi/fiber.rst:118
msgid "time to sleep"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:123
#: ../dev_guide/reference_capi/fiber.rst:120 ../reference_capi/fiber.rst:120
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:125
#: ../dev_guide/reference_capi/fiber.rst:122 ../reference_capi/fiber.rst:122
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:131
#: ../dev_guide/reference_capi/fiber.rst:128 ../reference_capi/fiber.rst:128
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:135
#: ../dev_guide/reference_capi/fiber.rst:132 ../reference_capi/fiber.rst:132
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:139
#: ../dev_guide/reference_capi/fiber.rst:136 ../reference_capi/fiber.rst:136
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:143
#: ../dev_guide/reference_capi/fiber.rst:140 ../reference_capi/fiber.rst:140
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/dev_guide/reference_capi/fiber.rst:149
#: ../dev_guide/reference_capi/fiber.rst:146 ../reference_capi/fiber.rst:146
msgid "Return slab_cache suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../dev_guide/reference_capi/index.rst:30 ../reference_capi/index.rst:30
msgid "C API reference"
msgstr "Справочник по C API"

#: ../reference_capi/latch.rst:28
msgid "Module `latch`"
msgstr "Модуль `latch`"

#: ../doc/dev_guide/reference_capi/latch.rst:35
#: ../dev_guide/reference_capi/latch.rst:32 ../reference_capi/latch.rst:32
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:39
#: ../dev_guide/reference_capi/latch.rst:36 ../reference_capi/latch.rst:36
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:41
#: ../dev_guide/reference_capi/latch.rst:38 ../reference_capi/latch.rst:38
msgid "allocated latch object"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:42
#: ../dev_guide/reference_capi/latch.rst:39 ../reference_capi/latch.rst:39
msgid "box_latch_t *"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:46
#: ../dev_guide/reference_capi/latch.rst:43 ../reference_capi/latch.rst:43
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:48
#: ../dev_guide/reference_capi/latch.rst:45 ../reference_capi/latch.rst:45
msgid "latch to destroy"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:52
#: ../dev_guide/reference_capi/latch.rst:49 ../reference_capi/latch.rst:49
msgid ""
"Lock a latch. Waits indefinitely until the current fiber can gain access to "
"the latch."
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:55
#: ../doc/dev_guide/reference_capi/latch.rst:61
#: ../dev_guide/reference_capi/latch.rst:52
#: ../dev_guide/reference_capi/latch.rst:58 ../reference_capi/latch.rst:52
#: ../reference_capi/latch.rst:58
msgid "latch to lock"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:59
#: ../dev_guide/reference_capi/latch.rst:56 ../reference_capi/latch.rst:56
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:62
#: ../dev_guide/reference_capi/latch.rst:59 ../reference_capi/latch.rst:59
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:63
#: ../dev_guide/reference_capi/latch.rst:60 ../reference_capi/latch.rst:60
msgid "int"
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:67
#: ../dev_guide/reference_capi/latch.rst:64 ../reference_capi/latch.rst:64
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/dev_guide/reference_capi/latch.rst:69
#: ../dev_guide/reference_capi/latch.rst:66 ../reference_capi/latch.rst:66
msgid "latch to unlock"
msgstr ""

#: ../reference_capi/say.rst:28
msgid "Module `say` (logging)"
msgstr "Модуль `say` (логирование)"

#: ../doc/dev_guide/reference_capi/say.rst:39
#: ../dev_guide/reference_capi/say.rst:36 ../reference_capi/say.rst:36
msgid "do not use this value directly"
msgstr ""

#: ../doc/dev_guide/reference_capi/say.rst:55
#: ../doc/dev_guide/reference_capi/say.rst:70
#: ../dev_guide/reference_capi/say.rst:52
#: ../dev_guide/reference_capi/say.rst:67 ../reference_capi/say.rst:52
#: ../reference_capi/say.rst:67
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/dev_guide/reference_capi/say.rst:57
#: ../dev_guide/reference_capi/say.rst:54 ../reference_capi/say.rst:54
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/say.rst:58
#: ../doc/dev_guide/reference_capi/say.rst:72
#: ../dev_guide/reference_capi/say.rst:55
#: ../dev_guide/reference_capi/say.rst:69 ../reference_capi/say.rst:55
#: ../reference_capi/say.rst:69
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/dev_guide/reference_capi/say.rst:61
#: ../doc/dev_guide/reference_capi/say.rst:75
#: ../dev_guide/reference_capi/say.rst:58
#: ../dev_guide/reference_capi/say.rst:72 ../reference_capi/say.rst:58
#: ../reference_capi/say.rst:72
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/say.rst:79
#: ../dev_guide/reference_capi/say.rst:76 ../reference_capi/say.rst:76
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../reference_capi/schema.rst:28
msgid "Module `schema`"
msgstr "Модуль `schema`"

#: ../doc/dev_guide/reference_capi/schema.rst:39
#: ../dev_guide/reference_capi/schema.rst:36 ../reference_capi/schema.rst:36
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:43
#: ../dev_guide/reference_capi/schema.rst:40 ../reference_capi/schema.rst:40
msgid "Space id of _schema."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:47
#: ../dev_guide/reference_capi/schema.rst:44 ../reference_capi/schema.rst:44
msgid "Space id of _space."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:51
#: ../dev_guide/reference_capi/schema.rst:48 ../reference_capi/schema.rst:48
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:55
#: ../dev_guide/reference_capi/schema.rst:52 ../reference_capi/schema.rst:52
msgid "Space id of _index."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:59
#: ../dev_guide/reference_capi/schema.rst:56 ../reference_capi/schema.rst:56
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:63
#: ../dev_guide/reference_capi/schema.rst:60 ../reference_capi/schema.rst:60
msgid "Space id of _func."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:67
#: ../dev_guide/reference_capi/schema.rst:64 ../reference_capi/schema.rst:64
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:71
#: ../dev_guide/reference_capi/schema.rst:68 ../reference_capi/schema.rst:68
msgid "Space id of _user."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:75
#: ../dev_guide/reference_capi/schema.rst:72 ../reference_capi/schema.rst:72
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:79
#: ../dev_guide/reference_capi/schema.rst:76 ../reference_capi/schema.rst:76
msgid "Space id of _priv."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:83
#: ../dev_guide/reference_capi/schema.rst:80 ../reference_capi/schema.rst:80
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:87
#: ../dev_guide/reference_capi/schema.rst:84 ../reference_capi/schema.rst:84
msgid "Space id of _cluster."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:91
#: ../dev_guide/reference_capi/schema.rst:88 ../reference_capi/schema.rst:88
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/dev_guide/reference_capi/schema.rst:95
#: ../dev_guide/reference_capi/schema.rst:92 ../reference_capi/schema.rst:92
msgid "NULL value, returned on error."
msgstr ""

#: ../reference_capi/trivia.rst:28
msgid "Module `trivia/config`"
msgstr "Модуль `trivia/config`"

#: ../doc/dev_guide/reference_capi/trivia.rst:35
#: ../dev_guide/reference_capi/trivia.rst:32 ../reference_capi/trivia.rst:32
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:39
#: ../dev_guide/reference_capi/trivia.rst:36 ../reference_capi/trivia.rst:36
msgid "Package major version - 1 for 1.7.0."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:43
#: ../dev_guide/reference_capi/trivia.rst:40 ../reference_capi/trivia.rst:40
msgid "Package minor version - 7 for 1.7.0."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:47
#: ../dev_guide/reference_capi/trivia.rst:44 ../reference_capi/trivia.rst:44
msgid "Package patch version - 0 for 1.7.0."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:51
#: ../dev_guide/reference_capi/trivia.rst:48 ../reference_capi/trivia.rst:48
msgid ""
"A string with major-minor-patch-commit-id identifier of the release, e.g. "
"1.7.0-1216-g73f7154."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:56
#: ../dev_guide/reference_capi/trivia.rst:53 ../reference_capi/trivia.rst:53
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:60
#: ../dev_guide/reference_capi/trivia.rst:57 ../reference_capi/trivia.rst:57
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:64
#: ../dev_guide/reference_capi/trivia.rst:61 ../reference_capi/trivia.rst:61
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:68
#: ../dev_guide/reference_capi/trivia.rst:65 ../reference_capi/trivia.rst:65
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:72
#: ../dev_guide/reference_capi/trivia.rst:69 ../reference_capi/trivia.rst:69
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:76
#: ../dev_guide/reference_capi/trivia.rst:73 ../reference_capi/trivia.rst:73
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:80
#: ../dev_guide/reference_capi/trivia.rst:77 ../reference_capi/trivia.rst:77
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:84
#: ../dev_guide/reference_capi/trivia.rst:81 ../reference_capi/trivia.rst:81
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:88
#: ../dev_guide/reference_capi/trivia.rst:85 ../reference_capi/trivia.rst:85
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:92
#: ../dev_guide/reference_capi/trivia.rst:89 ../reference_capi/trivia.rst:89
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:96
#: ../dev_guide/reference_capi/trivia.rst:93 ../reference_capi/trivia.rst:93
msgid ""
"A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:100
#: ../dev_guide/reference_capi/trivia.rst:97 ../reference_capi/trivia.rst:97
msgid ""
"A constant added to ``package.path`` in Lua to find ``*.lua`` module files."
msgstr ""

#: ../doc/dev_guide/reference_capi/trivia.rst:104
#: ../dev_guide/reference_capi/trivia.rst:101 ../reference_capi/trivia.rst:101
msgid ""
"A constant added to ``package.cpath`` in Lua to find ``*.so`` module files."
msgstr ""

#: ../reference_capi/tuple.rst:28
msgid "Module `tuple`"
msgstr "Модуль `tuple`"

#: ../doc/dev_guide/reference_capi/tuple.rst:39
#: ../dev_guide/reference_capi/tuple.rst:36 ../reference_capi/tuple.rst:36
msgid "Tuple format."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:41
#: ../dev_guide/reference_capi/tuple.rst:38 ../reference_capi/tuple.rst:38
msgid ""
"Each Tuple has associated format (class). Default format is used to create "
"tuples which are not attach to any particular space."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:46
#: ../dev_guide/reference_capi/tuple.rst:43 ../reference_capi/tuple.rst:43
msgid "Tuple"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:52
#: ../dev_guide/reference_capi/tuple.rst:49 ../reference_capi/tuple.rst:49
msgid "Allocate and initialize a new tuple from a raw MsgPack Array data."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:54
#: ../dev_guide/reference_capi/tuple.rst:51 ../reference_capi/tuple.rst:51
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:57
#: ../dev_guide/reference_capi/tuple.rst:54 ../reference_capi/tuple.rst:54
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:58
#: ../dev_guide/reference_capi/tuple.rst:55 ../reference_capi/tuple.rst:55
msgid "the end of ``data``"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:60
#: ../doc/dev_guide/reference_capi/txn.rst:65
#: ../dev_guide/reference_capi/tuple.rst:57
#: ../dev_guide/reference_capi/txn.rst:62 ../reference_capi/tuple.rst:57
#: ../reference_capi/txn.rst:62
msgid "NULL on out of memory"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:61
#: ../dev_guide/reference_capi/tuple.rst:58 ../reference_capi/tuple.rst:58
msgid "tuple otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:63
#: ../dev_guide/reference_capi/tuple.rst:60 ../reference_capi/tuple.rst:60
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:69
#: ../dev_guide/reference_capi/tuple.rst:66 ../reference_capi/tuple.rst:66
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:71
#: ../dev_guide/reference_capi/tuple.rst:68 ../reference_capi/tuple.rst:68
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee "
"that the last returned tuple is refcounted internally until the next call to "
"API function that yields or returns another tuple."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:75
#: ../dev_guide/reference_capi/tuple.rst:72 ../reference_capi/tuple.rst:72
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. Such tuples will not be garbage collected even if "
"another fiber remove they from space. After processing please decrement the "
"reference counter using :ref:`box_tuple_unref()<c_api-tuple-"
"box_tuple_unref>`, otherwise the tuple will leak."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:82
#: ../doc/dev_guide/reference_capi/tuple.rst:95
#: ../doc/dev_guide/reference_capi/tuple.rst:108
#: ../doc/dev_guide/reference_capi/tuple.rst:114
#: ../doc/dev_guide/reference_capi/tuple.rst:133
#: ../doc/dev_guide/reference_capi/tuple.rst:143
#: ../dev_guide/reference_capi/tuple.rst:79
#: ../dev_guide/reference_capi/tuple.rst:92
#: ../dev_guide/reference_capi/tuple.rst:105
#: ../dev_guide/reference_capi/tuple.rst:111
#: ../dev_guide/reference_capi/tuple.rst:130
#: ../dev_guide/reference_capi/tuple.rst:140 ../reference_capi/tuple.rst:79
#: ../reference_capi/tuple.rst:92 ../reference_capi/tuple.rst:105
#: ../reference_capi/tuple.rst:111 ../reference_capi/tuple.rst:130
#: ../reference_capi/tuple.rst:140
msgid "a tuple"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:84
#: ../doc/dev_guide/reference_capi/tuple.rst:97
#: ../doc/dev_guide/reference_capi/tuple.rst:126
#: ../dev_guide/reference_capi/tuple.rst:81
#: ../dev_guide/reference_capi/tuple.rst:94
#: ../dev_guide/reference_capi/tuple.rst:123 ../reference_capi/tuple.rst:81
#: ../reference_capi/tuple.rst:94 ../reference_capi/tuple.rst:123
msgid "-1 on error"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:87
#: ../dev_guide/reference_capi/tuple.rst:84 ../reference_capi/tuple.rst:84
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:93
#: ../dev_guide/reference_capi/tuple.rst:90 ../reference_capi/tuple.rst:90
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:100
#: ../dev_guide/reference_capi/tuple.rst:97 ../reference_capi/tuple.rst:97
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:106
#: ../dev_guide/reference_capi/tuple.rst:103 ../reference_capi/tuple.rst:103
msgid "Return the number of fields in tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:112
#: ../dev_guide/reference_capi/tuple.rst:109 ../reference_capi/tuple.rst:109
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack Array)."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:118
#: ../dev_guide/reference_capi/tuple.rst:115 ../reference_capi/tuple.rst:115
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:120
#: ../dev_guide/reference_capi/tuple.rst:117 ../reference_capi/tuple.rst:117
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:122
#: ../dev_guide/reference_capi/tuple.rst:119 ../reference_capi/tuple.rst:119
msgid ""
"Upon successful return, the function returns the number of bytes written. If "
"buffer size is not enough then the return value is the number of bytes which "
"would have been written if enough space had been available."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:127
#: ../dev_guide/reference_capi/tuple.rst:124 ../reference_capi/tuple.rst:124
msgid "number of bytes written on success."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:131
#: ../dev_guide/reference_capi/tuple.rst:128 ../reference_capi/tuple.rst:128
msgid "Return the associated format."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:135
#: ../dev_guide/reference_capi/tuple.rst:132 ../reference_capi/tuple.rst:132
msgid "tuple format"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:139
#: ../dev_guide/reference_capi/tuple.rst:136 ../reference_capi/tuple.rst:136
msgid "Return the raw tuple field in MsgPack format."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:141
#: ../dev_guide/reference_capi/tuple.rst:138 ../reference_capi/tuple.rst:138
msgid "The buffer is valid until next call to box_tuple_* functions."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:144
#: ../dev_guide/reference_capi/tuple.rst:141 ../reference_capi/tuple.rst:141
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:146
#: ../dev_guide/reference_capi/tuple.rst:143 ../reference_capi/tuple.rst:143
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:147
#: ../dev_guide/reference_capi/tuple.rst:144 ../reference_capi/tuple.rst:144
msgid "msgpack otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:151
#: ../dev_guide/reference_capi/tuple.rst:148 ../reference_capi/tuple.rst:148
msgid "Tuple iterator"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:155
#: ../dev_guide/reference_capi/tuple.rst:152 ../reference_capi/tuple.rst:152
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allow to "
"iterate over fields at root level of MsgPack array."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:160
#: ../dev_guide/reference_capi/tuple.rst:157 ../reference_capi/tuple.rst:157
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind iterator to first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:183
#: ../dev_guide/reference_capi/tuple.rst:180 ../reference_capi/tuple.rst:180
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:189
#: ../dev_guide/reference_capi/tuple.rst:186 ../reference_capi/tuple.rst:186
msgid ""
"Return zero-based next position in iterator. That is, this function return "
"the field id of field that will be returned by the next call to :ref:"
"`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is zero after "
"initialization or rewind and :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:196
#: ../doc/dev_guide/reference_capi/tuple.rst:203
#: ../doc/dev_guide/reference_capi/tuple.rst:214
#: ../dev_guide/reference_capi/tuple.rst:193
#: ../dev_guide/reference_capi/tuple.rst:200
#: ../dev_guide/reference_capi/tuple.rst:211 ../reference_capi/tuple.rst:193
#: ../reference_capi/tuple.rst:200 ../reference_capi/tuple.rst:211
msgid "a tuple iterator"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:197
#: ../dev_guide/reference_capi/tuple.rst:194 ../reference_capi/tuple.rst:194
msgid "position"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:201
#: ../dev_guide/reference_capi/tuple.rst:198 ../reference_capi/tuple.rst:198
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:205
#: ../dev_guide/reference_capi/tuple.rst:202 ../reference_capi/tuple.rst:202
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:209
#: ../dev_guide/reference_capi/tuple.rst:206 ../reference_capi/tuple.rst:206
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:211
#: ../dev_guide/reference_capi/tuple.rst:208 ../reference_capi/tuple.rst:208
msgid ""
"The returned buffer is valid until next call to box_tuple_* API. Requested "
"field_no returned by next call to box_tuple_next(it)."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:215
#: ../dev_guide/reference_capi/tuple.rst:212 ../reference_capi/tuple.rst:212
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:218
#: ../dev_guide/reference_capi/tuple.rst:215 ../reference_capi/tuple.rst:215
msgid "After:"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:220
#: ../dev_guide/reference_capi/tuple.rst:217 ../reference_capi/tuple.rst:217
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:221
#: ../dev_guide/reference_capi/tuple.rst:218 ../reference_capi/tuple.rst:218
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned value "
"is NULL."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:228
#: ../dev_guide/reference_capi/tuple.rst:225 ../reference_capi/tuple.rst:225
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:230
#: ../dev_guide/reference_capi/tuple.rst:227 ../reference_capi/tuple.rst:227
msgid "The returned buffer is valid until next call to box_tuple_* API."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:233
#: ../dev_guide/reference_capi/tuple.rst:230 ../reference_capi/tuple.rst:230
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:234
#: ../dev_guide/reference_capi/tuple.rst:231 ../reference_capi/tuple.rst:231
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:236
#: ../dev_guide/reference_capi/tuple.rst:233 ../reference_capi/tuple.rst:233
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is zero-"
"based ID of returned field."
msgstr ""

#: ../doc/dev_guide/reference_capi/tuple.rst:239
#: ../dev_guide/reference_capi/tuple.rst:236 ../reference_capi/tuple.rst:236
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if "
"returned value is NULL."
msgstr ""

#: ../reference_capi/txn.rst:28
msgid "Module `txn`"
msgstr "Модуль `txn`"

#: ../doc/dev_guide/reference_capi/txn.rst:35
#: ../dev_guide/reference_capi/txn.rst:32 ../reference_capi/txn.rst:32
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:39
#: ../dev_guide/reference_capi/txn.rst:36 ../reference_capi/txn.rst:36
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:41
#: ../dev_guide/reference_capi/txn.rst:38 ../reference_capi/txn.rst:38
msgid ""
"A transaction is attached to caller fiber, therefore one fiber can have only "
"one active transaction."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:45
#: ../dev_guide/reference_capi/txn.rst:42 ../reference_capi/txn.rst:42
msgid "-1 on error. Perhaps a transaction has already been started"
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:49
#: ../dev_guide/reference_capi/txn.rst:46 ../reference_capi/txn.rst:46
msgid "Commit the current transaction."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:52
#: ../dev_guide/reference_capi/txn.rst:49 ../reference_capi/txn.rst:49
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:56
#: ../dev_guide/reference_capi/txn.rst:53 ../reference_capi/txn.rst:53
msgid "Rollback the current transaction."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:60
#: ../dev_guide/reference_capi/txn.rst:57 ../reference_capi/txn.rst:57
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/dev_guide/reference_capi/txn.rst:62
#: ../dev_guide/reference_capi/txn.rst:59 ../reference_capi/txn.rst:59
msgid ""
"The memory is automatically deallocated when the transaction is committed or "
"rolled back."
msgstr ""

#: ../reference_capi/utils.rst:28
msgid "Module `lua/utils`"
msgstr "Модуль `lua/utils`"

#: ../doc/dev_guide/reference_capi/utils.rst:37
#: ../dev_guide/reference_capi/utils.rst:34 ../reference_capi/utils.rst:34
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:39
#: ../dev_guide/reference_capi/utils.rst:36 ../reference_capi/utils.rst:36
msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:42
#: ../doc/dev_guide/reference_capi/utils.rst:55
#: ../doc/dev_guide/reference_capi/utils.rst:70
#: ../doc/dev_guide/reference_capi/utils.rst:77
#: ../doc/dev_guide/reference_capi/utils.rst:90
#: ../doc/dev_guide/reference_capi/utils.rst:102
#: ../doc/dev_guide/reference_capi/utils.rst:109
#: ../dev_guide/reference_capi/utils.rst:39
#: ../dev_guide/reference_capi/utils.rst:52
#: ../dev_guide/reference_capi/utils.rst:67
#: ../dev_guide/reference_capi/utils.rst:74
#: ../dev_guide/reference_capi/utils.rst:87
#: ../dev_guide/reference_capi/utils.rst:99
#: ../dev_guide/reference_capi/utils.rst:106 ../reference_capi/utils.rst:39
#: ../reference_capi/utils.rst:52 ../reference_capi/utils.rst:67
#: ../reference_capi/utils.rst:74 ../reference_capi/utils.rst:87
#: ../reference_capi/utils.rst:99 ../reference_capi/utils.rst:106
msgid "Lua State"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:43
#: ../dev_guide/reference_capi/utils.rst:40 ../reference_capi/utils.rst:40
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:45
#: ../doc/dev_guide/reference_capi/utils.rst:59
#: ../dev_guide/reference_capi/utils.rst:42
#: ../dev_guide/reference_capi/utils.rst:56 ../reference_capi/utils.rst:42
#: ../reference_capi/utils.rst:56
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:47
#: ../dev_guide/reference_capi/utils.rst:44 ../reference_capi/utils.rst:44
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:53
#: ../dev_guide/reference_capi/utils.rst:50 ../reference_capi/utils.rst:50
msgid "Checks whether the function argument ``idx`` is a cdata"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:56
#: ../doc/dev_guide/reference_capi/utils.rst:71
#: ../dev_guide/reference_capi/utils.rst:53
#: ../dev_guide/reference_capi/utils.rst:68 ../reference_capi/utils.rst:53
#: ../reference_capi/utils.rst:68
msgid "stack index"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:57
#: ../dev_guide/reference_capi/utils.rst:54 ../reference_capi/utils.rst:54
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:61
#: ../dev_guide/reference_capi/utils.rst:58 ../reference_capi/utils.rst:58
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:65
#: ../dev_guide/reference_capi/utils.rst:62 ../reference_capi/utils.rst:62
msgid "Sets finalizer function on a cdata object."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:67
#: ../dev_guide/reference_capi/utils.rst:64 ../reference_capi/utils.rst:64
msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on "
"the top of the stack."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:75
#: ../dev_guide/reference_capi/utils.rst:72 ../reference_capi/utils.rst:72
msgid "Return CTypeID (FFI) of given СDATA type"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:78
#: ../dev_guide/reference_capi/utils.rst:75 ../reference_capi/utils.rst:75
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:81
#: ../dev_guide/reference_capi/utils.rst:78 ../reference_capi/utils.rst:78
msgid "CTypeID"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:83
#: ../dev_guide/reference_capi/utils.rst:80 ../reference_capi/utils.rst:80
msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, :ref:"
"`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:88
#: ../dev_guide/reference_capi/utils.rst:85 ../reference_capi/utils.rst:85
msgid "Declare symbols for FFI"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:91
#: ../dev_guide/reference_capi/utils.rst:88 ../reference_capi/utils.rst:88
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:94
#: ../dev_guide/reference_capi/utils.rst:91 ../reference_capi/utils.rst:91
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:96
#: ../dev_guide/reference_capi/utils.rst:93 ../reference_capi/utils.rst:93
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:100
#: ../dev_guide/reference_capi/utils.rst:97 ../reference_capi/utils.rst:97
msgid "Push uint64_t onto the stack"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:103
#: ../doc/dev_guide/reference_capi/utils.rst:110
#: ../dev_guide/reference_capi/utils.rst:100
#: ../dev_guide/reference_capi/utils.rst:107 ../reference_capi/utils.rst:100
#: ../reference_capi/utils.rst:107
msgid "value to push"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:107
#: ../dev_guide/reference_capi/utils.rst:104 ../reference_capi/utils.rst:104
msgid "Push int64_t onto the stack"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:114
#: ../doc/dev_guide/reference_capi/utils.rst:128
#: ../dev_guide/reference_capi/utils.rst:111
#: ../dev_guide/reference_capi/utils.rst:125 ../reference_capi/utils.rst:111
#: ../reference_capi/utils.rst:125
msgid ""
"Checks whether the argument idx is a uint64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:117
#: ../doc/dev_guide/reference_capi/utils.rst:124
#: ../dev_guide/reference_capi/utils.rst:114
#: ../dev_guide/reference_capi/utils.rst:121 ../reference_capi/utils.rst:114
#: ../reference_capi/utils.rst:121
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:121
#: ../doc/dev_guide/reference_capi/utils.rst:135
#: ../dev_guide/reference_capi/utils.rst:118
#: ../dev_guide/reference_capi/utils.rst:132 ../reference_capi/utils.rst:118
#: ../reference_capi/utils.rst:132
msgid ""
"Checks whether the argument idx is a int64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/dev_guide/reference_capi/utils.rst:131
#: ../doc/dev_guide/reference_capi/utils.rst:138
#: ../dev_guide/reference_capi/utils.rst:128
#: ../dev_guide/reference_capi/utils.rst:135 ../reference_capi/utils.rst:128
#: ../reference_capi/utils.rst:135
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../dev_guide/release_management.rst:28
msgid "Release management"
msgstr "Работа с релизами"

#: ../doc/dev_guide/release_management.rst:34
#: ../dev_guide/release_management.rst:31
msgid "How to make a minor release"
msgstr ""

#: ../doc/dev_guide/release_management.rst:36
#: ../dev_guide/release_management.rst:33
msgid ""
"$ git tag -a 1.4.4 -m \"Next minor in 1.4 series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/dev_guide/release_management.rst:42
#: ../dev_guide/release_management.rst:39
msgid "Update the Web site in doc/www"
msgstr ""

#: ../doc/dev_guide/release_management.rst:44
#: ../dev_guide/release_management.rst:41
msgid ""
"Update all issues, upload the ChangeLog based on ``git log`` output. The "
"ChangeLog must only include items which are mentioned as issues on github. "
"If anything significant is there, which is not mentioned, something went "
"wrong in release planning and the release should be held up until this is "
"cleared."
msgstr ""

#: ../doc/dev_guide/release_management.rst:50
#: ../dev_guide/release_management.rst:47
msgid ""
"Click 'Release milestone'. Create a milestone for the next minor release. "
"Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/singlehtml.rst:5 ../doc/singlehtml.rst:33
msgid "Documentation"
msgstr ""

#: ../doc/index.rst:31
msgid ":ref:`genindex`"
msgstr ""

#: ../doc/index.rst:35
msgid ""
"For one page HTML documentation, please, use `this link </doc/singlehtml."
"html>`_."
msgstr ""

#: ../intro.rst:32
msgid "An application server together with a database manager"
msgstr "Сервер приложений + СУБД"

#: ../intro.rst:34
msgid ""
"Tarantool is a Lua application server integrated with a database management "
"system. It has a \"fiber\" model which means that many Tarantool "
"applications can run simultaneously on a single thread, while the Tarantool "
"server itself can run multiple threads for input-output and background "
"maintenance. It incorporates the LuaJIT -- \"Just In Time\" -- Lua compiler, "
"Lua libraries for most common applications, and the Tarantool Database "
"Server which is an established NoSQL DBMS. Thus Tarantool serves all the "
"purposes that have made node.js and Twisted popular, plus it supports data "
"persistence."
msgstr ""
"Tarantool представляет собой сервер приложений на языке Lua, интегрированный "
"с СУБД. В основе Tarantool лежат файберы (fibers), что позволяет нескольким "
"Lua-приложениям работать в одном потоке (thread), при этом Tarantool-сервер "
"может одновременно запускать другие потоки для обработки ввода-вывода данных "
"и фоновых сервисных задач. Tarantool включает в себя LuaJIT (Just In Time) "
"Lua-компилятор, Lua-библиотеки для решения наиболее частых задач, а также "
"сервер баз данных Tarantool, представляющий собой NoSQL СУБД. Таким образом, "
"Tarantool может всё то же, что node.js и Twisted, а кроме того обеспечивает "
"сохранность данных."

#: ../intro.rst:42
msgid ""
"The code is free. The open-source license is `BSD license`_. The supported "
"platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""
"Tarantool — это open-source проект. Исходный код открыт для всех и "
"распространяется бесплатно согласно лицензии `BSD license`_. Поддерживаемые "
"платформы: GNU / Linux, Mac OS и FreeBSD."

#: ../intro.rst:45
msgid ""
"Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet "
"company in Russia, with 30 million users, 25 million emails per day, and a "
"web site whose Alexa global rank is in the `top 40`_ worldwide. Tarantool "
"services Mail.Ru's hottest data, such as the session data of online users, "
"the properties of online applications, the caches of the underlying data, "
"the distribution and sharding algorithms, and much more. Outside Mail.Ru the "
"software is used by a growing number of projects in online gaming, digital "
"marketing, and social media industries. Although Mail.Ru is the sponsor for "
"product development, the roadmap and the bugs database and the development "
"process are fully open. The software incorporates patches from dozens of "
"community contributors. The Tarantool community writes and maintains most of "
"the drivers for programming languages.  The greater Lua community has "
"hundreds of useful packages most of which can become Tarantool extensions."
msgstr ""
"Создателем Tarantool'а — а также его основным пользователем — является "
"компания `Mail.Ru`_, крупнейшая Интернет-компания России (30 млн "
"пользователей, 25 млн электронных писем в день, веб-сайт в списке `top 40`_ "
"международного Alexa-рейтинга). Tarantool используется для обработки самых "
"\"горячих\" данных Mail.Ru, таких как данные пользовательских онлайн-сессий, "
"настройки онлайн-приложений, кеширование сервисных данных, алгоритмы "
"распределения данных и шардинга, и т.д. Tarantool также используется во всё "
"большем количестве проектов вне стен Mail.Ru. Это, к примеру, онлайн-игры, "
"цифровой маркетинг, социальные сети. Несмотря на то что Mail.Ru спонсирует "
"разработку Tarantool'а, весь процесс разработки, в т.ч. дальнейшие планы и "
"база обнаруженных ошибок, является полностью открытым. В Tarantool включены "
"патчи от большого числа сторонних разработчиков. Усилиями сообщества "
"разработчиков Tarantool'а были написаны (и далее поддерживаются) библиотеки "
"для подключения модулей на внешних языках программирования. А сообщество Lua-"
"разработчиков предоставило сотни полезных пакетов, большинство из которых "
"можно использовать в качестве расширений для Tarantool'а."

#: ../intro.rst:59
msgid ""
"Users can create, modify and drop **Lua functions** at runtime. Or they can "
"define **Lua programs** that are loaded during startup for triggers, "
"background tasks, and interacting with networked peers. Unlike popular "
"application development frameworks based on a \"reactor\" pattern, "
"networking in server-side Lua is sequential, yet very efficient, as it is "
"built on top of the **cooperative multitasking** environment that Tarantool "
"itself uses."
msgstr ""
"Пользователи Tarantool'а могут создавать, изменять и удалять **Lua-функции** "
"прямо во время исполнения кода. Также они могут указывать **Lua-программы**, "
"которые будут загружаться во время запуска Tarantool'а. Такие программы "
"могут служить триггерами, выполнять фоновые задачи и взаимодействовать с "
"другими программами по сети. В отличие от многих популярных сред разработки "
"приложений, которые используют \"реактивный\" принцип, сетевое "
"взаимодействие в Lua устроено последовательно, но очень эффективно, т.к. оно "
"использует среду **взаимной многозадачности** самого Tarantool'а."

#: ../intro.rst:67
msgid ""
"One of the built-in Lua packages provides an API for the Database Management "
"System. Thus some developers see Tarantool as a DBMS with a popular stored "
"procedure language, while others see it as a Lua interpreter, while still "
"others see it as a replacement for many components of multi-tier Web "
"applications. Performance can be a few hundred thousand transactions per "
"second on a laptop, scalable upwards or outwards to server farms."
msgstr ""
"Один из встраиваемых Lua-пакетов — это API для функционала СУБД. Таким "
"образом, некоторые разработчики рассматривают Tarantool как СУБД с "
"популярным языком для написания хранимых процедур, другие рассматривают его "
"как Lua-интерпретатор, а третьи -- как вариант замены сразу нескольких "
"компонентов в многозвенных веб-приложениях. Производительность Tarantool'а "
"может достигать сотен тысяч транзакций в секунду на ноутбуке, и ее можно "
"наращивать \"вверх\" или \"вширь\" за счет новых серверных ферм."

#: ../intro.rst:77
msgid "Database features"
msgstr "Возможности СУБД"

#: ../intro.rst:79
msgid ""
"Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a "
"strong distinguishing feature."
msgstr ""
"Компонент \"box\" — серверная часть с функционалом СУБД — это важная часть "
"Tarantool'а, хотя он может работать и без данного компонента."

#: ../intro.rst:82
msgid ""
"The database API allows for permanently storing Lua objects, managing object "
"collections, creating or dropping secondary keys, making changes atomically, "
"configuring and monitoring replication, performing controlled fail-over, and "
"executing Lua code triggered by database events. Remote database instances "
"are accessible transparently via a remote-procedure-invocation API."
msgstr ""
"API для функционала СУБД позволяет хранить Lua-объекты, управлять "
"коллекциями объектов, создавать и удалять вторичные ключи, делать атомарные "
"изменения, конфигурировать и мониторить репликацию, производить "
"контролируемое переключение при отказе (failover), а также исполнять код на "
"Lua, который вызывается событиями в базе. А для прозрачного доступа к "
"удаленным (remote) экземплярам баз данных разработан API для вызова "
"удаленных процедур."

#: ../intro.rst:90
msgid ""
"Tarantool's DBMS server uses the **storage engine** concept, where different "
"sets of algorithms and data structures can be used for different situations. "
"Two storage engines are built-in: an in-memory engine which has all the data "
"and indexes in RAM, and a two-level B-tree engine for data sets whose size "
"is 10 to 1000 times the amount of available RAM. All storage engines in "
"Tarantool support transactions and replication by using a common **write "
"ahead log** (WAL). This ensures consistency and crash safety of the "
"persistent state. Changes are not considered complete until the WAL is "
"written. The logging subsystem supports group commit."
msgstr ""
"В архитектуре серверной части СУБД Tarantool'а реализована концепция "
"\"движков\" базы данных (storage engines), где в разных ситуациях "
"используются разные наборы алгоритмов и структуры данных. В Tarantool'е есть "
"два встроенных движка: in-memory движок, который держит все данные и индексы "
"в оперативной памяти, и двухуровневый движок для B-деревьев, который "
"обрабатывает данные размером в 10-1000 раз больше того, что может "
"поместиться в оперативной памяти. Все движки в Tarantool'е поддерживают "
"транзакции и репликацию, поскольку они используют единый механизм "
"**упреждающей записи** (WAL = write ahead log). Это механизм обеспечивает "
"согласованность и сохранность данных при сбоях. Таким образом, изменения не "
"считаются завершенными, пока не проходит запись в лог WAL. Подсистема "
"логирования также поддерживает групповые коммиты. "

#: ../intro.rst:101
msgid ""
"**Tarantool's in-memory storage engine** (memtx) keeps all the data in "
"random-access memory, and therefore has very low read latency. It also keeps "
"persistent copies of the data in non-volatile storage, such as disk, when "
"users request \"snapshots\". If a server stops and the random-access memory "
"is lost, then restarts, it reads the latest snapshot and then replays the "
"transactions that are in the log -- therefore no data is lost."
msgstr ""
"**In-memory движок** (memtx) хранит все данные в оперативной памяти, поэтому "
"время ожидания при чтении у него очень мало. Также, когда пользователи "
"запрашивают статические снимки (snapshots), этот движок создает "
"персистентные копии данных в постоянной памяти, например на жестком диске. "
"Если Tarantool-сервер прекращает работать и данные в оперативной памяти "
"теряются, то при следующем запуске Tarantool-сервер загружает в память самую "
"свежую копию данных с диска и применяет к ней все транзакции из лога, "
"которые были сделаны с момента создания копии. Таким образом, данные при "
"сбое не теряются."

#: ../intro.rst:110
msgid ""
"**Tarantool's in-memory engine is lock-free** in typical situations. Instead "
"of the operating system's concurrency primitives, such as mutexes, Tarantool "
"uses cooperative multitasking to handle thousands of connections "
"simultaneously. There is a fixed number of independent execution threads. "
"The threads do not share state. Instead they exchange data using low-"
"overhead message queues. While this approach limits the number of cores that "
"the server will use, it removes competition for the memory bus and ensures "
"peak scalability of memory access and network throughput. CPU utilization of "
"a typical highly-loaded Tarantool server is under 10%. Searches are possible "
"via **secondary index keys** as well as primary keys."
msgstr ""
"В штатных ситуациях **in-memory движок работает без блокировок**. Вместо "
"низкоуровневых механизмов параллельной обработки данных, которые предлагает "
"операционная система (например, mutex'ов), Tarantool использует среду "
"взаимной многозадачности, и таким образом может работать с тысячами "
"соединений одновременно. В Tarantool'е есть фиксированное количество "
"независимых нитей (thread), и у них нет общего состояния. Для обмена данными "
"между нитями используются очереди сообщений, что позволяет уменьшить "
"накладные расходы. Такой подход накладывает ограничение на количество "
"процессорных ядер, которые Tarantool-сервер может использовать, но в то же "
"время он позволяет избежать конкуренции за шину памяти, а также дает запас "
"масштабируемости по скорости доступа к памяти и производительности сети. В "
"результате даже сильно нагруженный Tarantool-сервер в среднем использует "
"процессор не более чем на 10%. Кроме того, Tarantool поддерживает поиск как "
"по первичным, так и по **вторичным ключам в индексах**."

#: ../intro.rst:120
msgid ""
"**Tarantool's disk-based storage engine** is a fusion of ideas from modern "
"filesystems, log-structured merge trees and classical B-trees. All data is "
"organized into **ranges**. Each range is represented by a file on disk. "
"Range size is a configuration option and normally is around 64MB. Each range "
"is a collection of pages, serving different purposes. Pages in a fully "
"merged range contain non-overlapping ranges of keys. A range can be "
"partially merged if there were a lot of changes in its key range recently. "
"In that case some pages represent new keys and values in the range. The disk-"
"based storage engine is append only: new data never overwrites old data. The "
"disk-based storage engine is named :ref:`vinyl <index-vinyl>`."
msgstr ""
"**Дисковый движок** (:ref:`vinyl <index-vinyl>`) совмещает в себе подходы, "
"заимствованные из современных файловых систем, журналируемых merge-деревьев "
"(log-structured merge trees) и классических B-деревьев. Все данные в этом "
"движке разбиты по забегам (runs), где каждый забег представляет собой файл "
"на диске. Максимальный размер забега обычно равен 64МБ, и его можно "
"настраивать. Каждый забег -- это набор страниц, которые нужны для каких-то "
"целей. Если забег полностью смержен, то диапазоны ключей на его страницах не "
"пересекаются. Если же диапазоны ключей в забеге в какой-то момент сильно "
"изменялись, то мы имеем дело с частично смерженным забегом. В этом случае на "
"некоторых страницах появились новые ключи и значения, которых ранее не было "
"в данном забеге. Дисковый движок обновляет данные по принципу дописывания в "
"конец: новые данные никогда не затирают старые."

#: ../intro.rst:131
msgid ""
"Tarantool supports **multi-part index keys**. The possible index types are "
"HASH, TREE, BITSET, and RTREE."
msgstr ""
"Tarantool поддерживает работу с **составными ключами в индексах**. Возможные "
"типы ключей: HASH, TREE, BITSET и RTREE."

#: ../intro.rst:134
msgid ""
"Tarantool supports **asynchronous replication**, locally or to remote hosts. "
"The replication architecture can be **master-master**, that is, many nodes "
"may both handle the loads and receive what others have handled, for the same "
"data sets."
msgstr ""
"Tarantool также поддерживает **асинхронную репликацию** — как локальную, так "
"и на удаленных серверах. При этом репликацию можно настроить по принципу "
"**мастер-мастер**, когда несколько узлов могут не только обрабатывать "
"входящую нагрузку, но и получать данные от других узлов."

#: ../reference/configuration/index.rst:30
msgid "Configuration reference"
msgstr "Справочник по настройке"

#: ../doc/reference/configuration/index.rst:35
#: ../reference/configuration/index.rst:32
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an initialization file."
msgstr ""

#: ../doc/reference/configuration/index.rst:38
#: ../reference/configuration/index.rst:35
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../doc/reference/configuration/index.rst:43
#: ../reference/configuration/index.rst:40
msgid ""
"$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../reference/configuration/index.rst:48
msgid "Command options"
msgstr "Опции комнандной строки"

#: ../doc/reference/configuration/index.rst:55
#: ../reference/configuration/index.rst:52
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/reference/configuration/index.rst:61
#: ../reference/configuration/index.rst:58
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:63
#: ../reference/configuration/index.rst:60
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/reference/configuration/index.rst:70
#: ../reference/configuration/index.rst:67
msgid "In this example:"
msgstr ""

#: ../doc/reference/configuration/index.rst:72
#: ../reference/configuration/index.rst:69
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking programming "
"framework."
msgstr ""

#: ../doc/reference/configuration/index.rst:75
#: ../reference/configuration/index.rst:72
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is "
"incremented for each new milestone and indicates possible incompatible "
"changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there may "
"be a commit number and commit SHA1 to indicate how much this particular "
"build has diverged from the last release."
msgstr ""

#: ../doc/reference/configuration/index.rst:83
#: ../reference/configuration/index.rst:80
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""

#: ../doc/reference/configuration/index.rst:88
#: ../reference/configuration/index.rst:85
msgid ""
"Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/"
"docs/git-describe.html>`_ to produce its version id, and this id can be used "
"at any time to check out the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../reference/configuration/index.rst:95
msgid "URI"
msgstr "Универсальный код ресурса (URI)"

#: ../doc/reference/configuration/index.rst:100
#: ../reference/configuration/index.rst:97
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to the "
"`generic syntax for a URI schema <http://en.wikipedia.org/wiki/"
"URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for "
"login, a password, a host name or host IP address, and a port number. Only "
"the port number is always mandatory. The password is mandatory if the user "
"name is specified, unless the user name is 'guest'. So, formally, the URI "
"syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is "
"omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 "
"address or any IPv6 address, on the local machine. If username:password is "
"omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/reference/configuration/index.rst:119
#: ../reference/configuration/index.rst:116
msgid "URI fragment"
msgstr ""

#: ../doc/reference/configuration/index.rst:121
#: ../reference/configuration/index.rst:118
msgid "port"
msgstr ""

#: ../doc/reference/configuration/index.rst:121
#: ../reference/configuration/index.rst:118
msgid "3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:123
#: ../reference/configuration/index.rst:120
msgid "host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:123
#: ../reference/configuration/index.rst:120
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:125
#: ../reference/configuration/index.rst:122
msgid "username:password@host:port"
msgstr ""

#: ../doc/reference/configuration/index.rst:125
#: ../reference/configuration/index.rst:122
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/reference/configuration/index.rst:128
#: ../reference/configuration/index.rst:125
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/"
"tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/reference/configuration/index.rst:132
#: ../reference/configuration/index.rst:129
msgid ""
"A method for parsing URIs is illustrated in :ref:`Cookbook recipes <cookbook-"
"uri>`."
msgstr ""

#: ../reference/configuration/index.rst:135
msgid "Initialization file"
msgstr "Файл инициализации"

#: ../doc/reference/configuration/index.rst:140
#: ../reference/configuration/index.rst:137
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-initialization-"
"file`, then Tarantool begins by invoking the Lua program in the file, which "
"by convention may have the name \"``script.lua``\". The Lua program may get "
"further arguments from the command line or may use operating-system "
"functions, such as ``getenv()``. The Lua program almost always begins by "
"invoking ``box.cfg()``, if the database server will be used or if ports need "
"to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../doc/reference/configuration/index.rst:148
#: ../reference/configuration/index.rst:145
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/reference/configuration/index.rst:159
#: ../reference/configuration/index.rst:156
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and suppose "
"the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the "
"screen might look like this:"
msgstr ""

#: ../doc/reference/configuration/index.rst:163
#: ../reference/configuration/index.rst:160
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/reference/configuration/index.rst:177
#: ../reference/configuration/index.rst:174
msgid ""
"If one wishes to start an interactive session on the same terminal after "
"initialization is complete, one can use :ref:`console.start() <console-"
"start>`."
msgstr ""

#: ../reference/configuration/index.rst:190
msgid "Configuration parameters"
msgstr "Параметры конфигурации"

#: ../doc/reference/configuration/index.rst:195
#: ../reference/configuration/index.rst:192
msgid ""
"Configuration parameters have the form: |br| :extsamp:`{**{box.cfg}**}"
"{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/reference/configuration/index.rst:198
#: ../reference/configuration/index.rst:195
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since some "
"of the parameters (such as directory addresses) are semi-permanent, it's "
"best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the "
"initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/reference/configuration/index.rst:203
#: ../reference/configuration/index.rst:200
msgid ""
"Most configuration parameters are for allocating resources, opening ports, "
"and specifying database behavior. All parameters are optional. A few "
"parameters are dynamic, that is, they can be changed at runtime by calling "
"``box.cfg{}`` a second time."
msgstr ""

#: ../doc/reference/configuration/index.rst:208
#: ../reference/configuration/index.rst:205
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see "
"a particular parameter, for example the listen address, say ``box.cfg."
"listen``."
msgstr ""

#: ../doc/reference/configuration/index.rst:211
#: ../reference/configuration/index.rst:208
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for networking, "
"and for logging."
msgstr ""

#: ../doc/reference/configuration/index.rst:216
#: ../reference/configuration/index.rst:213
msgid "Basic parameters"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:4
#: ../reference/configuration/cfg_basic.rst:4
#: ../reference/configuration/cfg_basic.rst:29
msgid ""
"Run the server as a background task. The :ref:`logger <cfg_logging-logger>` "
"and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:7
#: ../doc/reference/configuration/cfg_basic.rst:15
#: ../reference/configuration/cfg_basic.rst:7
#: ../reference/configuration/cfg_basic.rst:15
#: ../reference/configuration/cfg_basic.rst:32
#: ../reference/configuration/cfg_basic.rst:40
msgid "Type: boolean |br| Default: false |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:13
#: ../reference/configuration/cfg_basic.rst:13
#: ../reference/configuration/cfg_basic.rst:38
msgid "Deprecated. Do not use."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:23
#: ../reference/configuration/cfg_basic.rst:23
#: ../reference/configuration/cfg_basic.rst:48
msgid ""
"Add the given string to the server's :ref:`Process title <administration-"
"proctitle>` (what’s shown in the COMMAND column for :samp:`ps -ef` and :samp:"
"`top -c` commands)."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:26
#: ../reference/configuration/cfg_basic.rst:26
#: ../reference/configuration/cfg_basic.rst:51
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process "
"thus:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:28
#: ../reference/configuration/cfg_basic.rst:28
#: ../reference/configuration/cfg_basic.rst:53
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:33
#: ../reference/configuration/cfg_basic.rst:33
#: ../reference/configuration/cfg_basic.rst:58
msgid ""
"But if the configuration parameters include ``custom_proc_title='sessions'`` "
"then the output looks like:"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:36
#: ../reference/configuration/cfg_basic.rst:36
#: ../reference/configuration/cfg_basic.rst:61
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:41
#: ../reference/configuration/cfg_basic.rst:41
#: ../reference/configuration/cfg_basic.rst:66
msgid "Type: string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:49
#: ../reference/configuration/cfg_basic.rst:49
#: ../reference/configuration/cfg_basic.rst:74
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be specified** "
"if connections will occur from remote clients that do not use the :ref:"
"`“admin port” <administration-admin_ports>`. Connections made with :samp:"
"`listen={URI}` are sometimes called \"binary protocol\" or \"primary port\" "
"connections."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:54
#: ../reference/configuration/cfg_basic.rst:54
#: ../reference/configuration/cfg_basic.rst:79
msgid ""
"A typical value is 3301. The listen parameter may also be set for local hot "
"standby."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:59
#: ../reference/configuration/cfg_basic.rst:59
#: ../reference/configuration/cfg_basic.rst:84
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:62
#: ../reference/configuration/cfg_basic.rst:62
#: ../reference/configuration/cfg_basic.rst:87
msgid "Type: integer or string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:70
#: ../reference/configuration/cfg_basic.rst:70
#: ../reference/configuration/cfg_basic.rst:95
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:73
#: ../doc/reference/configuration/cfg_basic.rst:115
#: ../doc/reference/configuration/cfg_basic.rst:146
#: ../doc/reference/configuration/cfg_logging.rst:88
#: ../reference/configuration/cfg_basic.rst:73
#: ../reference/configuration/cfg_basic.rst:98
#: ../reference/configuration/cfg_basic.rst:115
#: ../reference/configuration/cfg_basic.rst:140
#: ../reference/configuration/cfg_basic.rst:146
#: ../reference/configuration/cfg_basic.rst:171
#: ../reference/configuration/cfg_logging.rst:88
#: ../reference/configuration/cfg_logging.rst:113
msgid "Type: string |br| Default: null |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:81
#: ../reference/configuration/cfg_basic.rst:81
#: ../reference/configuration/cfg_basic.rst:106
msgid ""
"Put the server in read-only mode. After this, any requests that try to "
"change data will fail with error ER_READONLY."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:84
#: ../reference/configuration/cfg_basic.rst:84
#: ../reference/configuration/cfg_basic.rst:109
msgid "Type: boolean |br| Default: false |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:92
#: ../reference/configuration/cfg_basic.rst:92
#: ../reference/configuration/cfg_basic.rst:117
msgid ""
"A directory where snapshot (.snap) files will be stored. Can be relative to :"
"ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to work_dir. "
"See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:96
#: ../doc/reference/configuration/cfg_basic.rst:107
#: ../doc/reference/configuration/cfg_basic.rst:129
#: ../reference/configuration/cfg_basic.rst:96
#: ../reference/configuration/cfg_basic.rst:107
#: ../reference/configuration/cfg_basic.rst:121
#: ../reference/configuration/cfg_basic.rst:129
#: ../reference/configuration/cfg_basic.rst:132
#: ../reference/configuration/cfg_basic.rst:154
msgid "Type: string |br| Default: \".\" |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:104
#: ../reference/configuration/cfg_basic.rst:104
#: ../reference/configuration/cfg_basic.rst:129
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults "
"to work_dir."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:113
#: ../reference/configuration/cfg_basic.rst:113
#: ../reference/configuration/cfg_basic.rst:138
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:123
#: ../reference/configuration/cfg_basic.rst:123
#: ../reference/configuration/cfg_basic.rst:148
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be relative "
"to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes wal_dir and :ref:"
"`snap_dir <cfg_basic-snap_dir>` are specified with different values, so that "
"write-ahead log files and snapshot files can be stored on different disks. "
"If not specified, defaults to work_dir."
msgstr ""

#: ../doc/reference/configuration/cfg_basic.rst:137
#: ../reference/configuration/cfg_basic.rst:137
#: ../reference/configuration/cfg_basic.rst:162
msgid ""
"A directory where database working files will be stored. The server switches "
"to work_dir with :manpage:`chdir(2)` after start. Can be relative to the "
"current directory. If not specified, defaults to the current directory. "
"Other directory parameters may be relative to work_dir, for example |br| :"
"codenormal:`box.cfg{work_dir='/home/user/A',wal_dir='B',snap_dir='C'}` |br| "
"will put xlog files in /home/user/A/B, snapshot files in /home/user/A/C, and "
"all other files or subdirectories in /home/user/A."
msgstr ""

#: ../doc/reference/configuration/index.rst:222
#: ../reference/configuration/index.rst:219
msgid "Configuring the storage"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:5
#: ../reference/configuration/cfg_storage.rst:5
#: ../reference/configuration/cfg_storage.rst:30
msgid ""
"How much memory Tarantool allocates to actually store tuples, in gigabytes. "
"When the limit is reached, INSERT or UPDATE requests begin failing with "
"error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the "
"defined limit to allocate tuples, there is additional memory used to store "
"indexes and connection information. Depending on actual configuration and "
"workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:12
#: ../reference/configuration/cfg_storage.rst:12
#: ../reference/configuration/cfg_storage.rst:37
msgid "Type: float |br| Default: 1.0 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:20
#: ../reference/configuration/cfg_storage.rst:20
#: ../reference/configuration/cfg_storage.rst:45
msgid ""
"Use slab_alloc_factor as the multiplier for computing the sizes of memory "
"chunks that tuples are stored in. A lower value may result in less wasted "
"memory depending on the total amount of memory available and the "
"distribution of item sizes."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:25
#: ../reference/configuration/cfg_storage.rst:25
#: ../reference/configuration/cfg_storage.rst:50
msgid "Type: float |br| Default: 1.1 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:33
#: ../reference/configuration/cfg_storage.rst:33
#: ../reference/configuration/cfg_storage.rst:58
msgid ""
"Size of the largest allocation unit. It can be increased if it is necessary "
"to store large tuples."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:36
#: ../reference/configuration/cfg_storage.rst:36
#: ../reference/configuration/cfg_storage.rst:61
msgid "Type: integer |br| Default: 1048576 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:44
#: ../reference/configuration/cfg_storage.rst:44
#: ../reference/configuration/cfg_storage.rst:69
msgid ""
"Size of the smallest allocation unit. It can be decreased if most of the "
"tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:47
#: ../reference/configuration/cfg_storage.rst:47
#: ../reference/configuration/cfg_storage.rst:72
msgid "Type: integer |br| Default: 16 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:55
#: ../reference/configuration/cfg_storage.rst:55
#: ../reference/configuration/cfg_storage.rst:80
msgid "The default vinyl configuration can be changed with"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:436
#: ../reference/configuration/cfg_storage.rst:85
#: ../reference/configuration/cfg_storage.rst:433
msgid ""
"vinyl = {\n"
"  run_age_wm = *number*,\n"
"  run_age_period = *number of seconds*,\n"
"  memory_limit = *number of gigabytes*,\n"
"  compact_wm = *number*,\n"
"  threads = *number*,\n"
"  run_age = *number*,\n"
"  run_prio = *number*,\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:70
#: ../reference/configuration/cfg_storage.rst:70
#: ../reference/configuration/cfg_storage.rst:95
msgid "This method may change in the future."
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:72
#: ../reference/configuration/cfg_storage.rst:72
#: ../reference/configuration/cfg_storage.rst:97
msgid "Default values are:"
msgstr ""

#: ../doc/reference/configuration/cfg_storage.rst:453
#: ../reference/configuration/cfg_storage.rst:102
#: ../reference/configuration/cfg_storage.rst:450
msgid ""
"vinyl = {\n"
"  run_age_wm = 0,\n"
"  run_age_period = 0,\n"
"  memory_limit = 1,\n"
"  compact_wm = 2,\n"
"  threads = 5,\n"
"  run_age = 0,\n"
"  run_prio = 2,\n"
"}"
msgstr ""

#: ../doc/reference/configuration/index.rst:230
#: ../reference/configuration/index.rst:227
msgid "Snapshot daemon"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:2
#: ../reference/configuration/cfg_snapshot_daemon.rst:2
#: ../reference/configuration/cfg_snapshot_daemon.rst:27
msgid ""
"The snapshot daemon is a fiber which is constantly running. At intervals, it "
"may make new snapshot (.snap) files and then may remove old snapshot files. "
"If the snapshot daemon removes an old snapshot file, it will also remove any "
"write-ahead log (.xlog) files that are older than the snapshot file and "
"contain information that is present in the snapshot file."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:10
#: ../reference/configuration/cfg_snapshot_daemon.rst:10
#: ../reference/configuration/cfg_snapshot_daemon.rst:35
msgid ""
"The :ref:`snapshot_period <cfg_snapshot_daemon-snapshot_period>` and :ref:"
"`snapshot_count <cfg_snapshot_daemon-snapshot_count>` configuration settings "
"determine how long the intervals are, and how many snapshots should exist "
"before removals occur."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:19
#: ../reference/configuration/cfg_snapshot_daemon.rst:19
#: ../reference/configuration/cfg_snapshot_daemon.rst:44
msgid ""
"The interval between actions by the snapshot daemon, in seconds. If "
"``snapshot_period`` is set to a value greater than zero, and there is "
"activity which causes change to a database, then the snapshot daemon will "
"call :ref:`box.snapshot <admin-snapshot>` every ``snapshot_period`` seconds, "
"creating a new snapshot file each time."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:25
#: ../reference/configuration/cfg_snapshot_daemon.rst:25
#: ../reference/configuration/cfg_snapshot_daemon.rst:50
msgid ""
"For example: ``box.cfg{snapshot_period=3600}`` will cause the snapshot "
"daemon to create a new database snapshot once per hour."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:29
#: ../reference/configuration/cfg_snapshot_daemon.rst:29
#: ../reference/configuration/cfg_snapshot_daemon.rst:54
msgid "Type: integer |br| Default: 0 |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:37
#: ../reference/configuration/cfg_snapshot_daemon.rst:37
#: ../reference/configuration/cfg_snapshot_daemon.rst:62
msgid ""
"The maximum number of snapshots that may exist on the snap_dir directory "
"before the snapshot daemon will remove old snapshots. If snapshot_count "
"equals zero, then the snapshot daemon does not remove old snapshots. For "
"example:"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:43
#: ../reference/configuration/cfg_snapshot_daemon.rst:43
#: ../reference/configuration/cfg_snapshot_daemon.rst:68
msgid ""
"box.cfg{\n"
"    snapshot_period = 3600,\n"
"    snapshot_count  = 10\n"
"}"
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:50
#: ../reference/configuration/cfg_snapshot_daemon.rst:50
#: ../reference/configuration/cfg_snapshot_daemon.rst:75
msgid ""
"will cause the snapshot daemon to create a new snapshot each hour until it "
"has created ten snapshots. After that, it will remove the oldest snapshot "
"(and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../doc/reference/configuration/cfg_snapshot_daemon.rst:55
#: ../reference/configuration/cfg_snapshot_daemon.rst:55
#: ../reference/configuration/cfg_snapshot_daemon.rst:80
msgid "Type: integer |br| Default: 6 |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/index.rst:236
#: ../reference/configuration/index.rst:233
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:1
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error>`, |br| :ref:`panic_on_wal_error "
"<cfg_binary_logging_snapshots-panic_on_wal_error>`, |br| :ref:`rows_per_wal "
"<cfg_binary_logging_snapshots-rows_per_wal>`, |br| :ref:`snap_io_rate_limit "
"<cfg_binary_logging_snapshots-snap_io_rate_limit>`, |br| :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`, |br| :ref:`wal_dir_rescan_delay "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:12
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:12
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:37
msgid ""
"If there is an error while reading the snapshot file (at server start), "
"abort."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:15
#: ../doc/reference/configuration/cfg_logging.rst:102
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:15
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:40
#: ../reference/configuration/cfg_logging.rst:102
#: ../reference/configuration/cfg_logging.rst:127
msgid "Type: boolean |br| Default: true |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:48
msgid ""
"If there is an error while reading a write-ahead log file (at server start "
"or to relay to a replica), abort."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:26
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:26
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid "Type: boolean |br| Default: true |br| Dynamic: yes |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:34
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:34
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:59
msgid ""
"How many log records to store in a single write-ahead log file. When this "
"limit is reached, Tarantool creates another WAL file named :samp:`{<first-"
"lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:39
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:39
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid "Type: integer |br| Default: 500000 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:47
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:47
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:72
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <admin-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes "
"per second it can write to disk. The same can be achieved by splitting :ref:"
"`wal_dir <cfg_basic-wal_dir>` and :ref:`snap_dir <cfg_basic-snap_dir>` "
"locations and moving snapshots to a separate disk."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:53
#: ../doc/reference/configuration/cfg_networking.rst:13
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:53
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:78
#: ../reference/configuration/cfg_networking.rst:13
#: ../reference/configuration/cfg_networking.rst:38
msgid "Type: float |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:61
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:61
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:86
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:63
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:63
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:88
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:64
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:64
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:89
msgid ""
"``write``: fibers wait for their data to be written to the write-ahead log "
"(no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:66
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:66
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:91
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :"
"manpage:`write(2)`;"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:69
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:94
msgid "Type: string |br| Default: \"write\" |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:77
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:77
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:102
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the sake "
"of replication or local hot standby."
msgstr ""

#: ../doc/reference/configuration/cfg_binary_logging_snapshots.rst:81
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:81
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:106
msgid "Type: float |br| Default: 2 |br| Dynamic: no |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:5
#: ../reference/configuration/cfg_replication.rst:5
#: ../reference/configuration/cfg_replication.rst:30
msgid ""
"If replication_source is not an empty string, the server is considered to be "
"a Tarantool :ref:`replica <index-box_replication>`. The replica server will "
"try to connect to the master which replication_source specifies with a :ref:"
"`URI <index-uri>` (Universal Resource Identifier), for example :samp:"
"`{konstantin}:{secret_password}@{tarantool.org}:{3301}`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:10
#: ../reference/configuration/cfg_replication.rst:10
#: ../reference/configuration/cfg_replication.rst:35
msgid ""
"If there is more than one replication source in a cluster, specify an array "
"of URIs, for example |br| :codenormal:`box.cfg{replication_source = {`:"
"codeitalic:`uri#1,uri#2`:codenormal:`}}` |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:14
#: ../reference/configuration/cfg_replication.rst:14
#: ../reference/configuration/cfg_replication.rst:39
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"same server that :codenormal:`box.cfg{}` is being executed on -- then it is "
"ignored. Thus it is possible to use the same replication_source "
"specification on multiple servers."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:19
#: ../reference/configuration/cfg_replication.rst:19
#: ../reference/configuration/cfg_replication.rst:44
msgid ""
"The default user name is ‘guest’. A replica server does not accept data-"
"change requests on the :ref:`listen <cfg_basic-listen>` port. The "
"replication_source parameter is dynamic, that is, to enter master mode, "
"simply set replication_source to an empty string and issue :code:`box."
"cfg{replication_source=`:samp:`{new-value}`:code:`}`."
msgstr ""

#: ../doc/reference/configuration/cfg_replication.rst:25
#: ../reference/configuration/cfg_replication.rst:25
#: ../reference/configuration/cfg_replication.rst:50
msgid "Type: string |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/index.rst:248
#: ../reference/configuration/index.rst:245
msgid "Networking"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:1
#: ../reference/configuration/cfg_networking.rst:1
msgid ""
":ref:`io_collect_interval <cfg_networking-io_collect_interval>`, |br| :ref:"
"`readahead <cfg_networking-readahead>`  |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:8
#: ../reference/configuration/cfg_networking.rst:8
#: ../reference/configuration/cfg_networking.rst:33
msgid ""
"The server will sleep for io_collect_interval seconds between iterations of "
"the event loop. Can be used to reduce CPU load in deployments in which the "
"number of client connections is large, but requests are not so frequent (for "
"example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:21
#: ../reference/configuration/cfg_networking.rst:21
#: ../reference/configuration/cfg_networking.rst:46
msgid ""
"The size of the read-ahead buffer associated with a client connection. The "
"larger the buffer, the more memory an active connection consumes and the "
"more requests can be read from the operating system buffer in a single "
"system call. The rule of thumb is to make sure the buffer can contain at "
"least a few dozen requests. Therefore, if a typical tuple in a request is "
"large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size "
"should be increased. If batched request processing is not used, it’s prudent "
"to leave this setting at its default."
msgstr ""

#: ../doc/reference/configuration/cfg_networking.rst:30
#: ../reference/configuration/cfg_networking.rst:30
#: ../reference/configuration/cfg_networking.rst:55
msgid "Type: integer |br| Default: 16320 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/index.rst:254
#: ../reference/configuration/index.rst:251
msgid "Logging"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:5
#: ../reference/configuration/cfg_logging.rst:5
#: ../reference/configuration/cfg_logging.rst:30
msgid "How verbose the logging is. There are six log verbosity classes:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:7
#: ../reference/configuration/cfg_logging.rst:7
#: ../reference/configuration/cfg_logging.rst:32
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:8
#: ../reference/configuration/cfg_logging.rst:8
#: ../reference/configuration/cfg_logging.rst:33
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:9
#: ../reference/configuration/cfg_logging.rst:9
#: ../reference/configuration/cfg_logging.rst:34
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:10
#: ../reference/configuration/cfg_logging.rst:10
#: ../reference/configuration/cfg_logging.rst:35
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:11
#: ../reference/configuration/cfg_logging.rst:11
#: ../reference/configuration/cfg_logging.rst:36
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:12
#: ../reference/configuration/cfg_logging.rst:12
#: ../reference/configuration/cfg_logging.rst:37
msgid "6 – ``DEBUG``"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:14
#: ../reference/configuration/cfg_logging.rst:14
#: ../reference/configuration/cfg_logging.rst:39
msgid ""
"By setting log_level, one can enable logging of all classes below or equal "
"to the given level. Tarantool prints its logs to the standard error stream "
"by default, but this can be changed with the :ref:`logger <cfg_logging-"
"logger>` configuration parameter."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:19
#: ../reference/configuration/cfg_logging.rst:19
#: ../reference/configuration/cfg_logging.rst:44
msgid "Type: integer |br| Default: 5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:27
#: ../reference/configuration/cfg_logging.rst:27
#: ../reference/configuration/cfg_logging.rst:52
msgid ""
"By default, the log is sent to the standard error stream (``stderr``). If "
"``logger`` is specified, the log is sent to a file, or to a pipe, or to the "
"system logger."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:31
#: ../doc/reference/configuration/cfg_logging.rst:43
#: ../doc/reference/configuration/cfg_logging.rst:57
#: ../reference/configuration/cfg_logging.rst:31
#: ../reference/configuration/cfg_logging.rst:43
#: ../reference/configuration/cfg_logging.rst:56
#: ../reference/configuration/cfg_logging.rst:57
#: ../reference/configuration/cfg_logging.rst:68
#: ../reference/configuration/cfg_logging.rst:82
msgid "Example setting:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:33
#: ../reference/configuration/cfg_logging.rst:33
#: ../reference/configuration/cfg_logging.rst:58
msgid ""
"box.cfg{logger = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'file: tarantool.log'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:39
#: ../reference/configuration/cfg_logging.rst:39
#: ../reference/configuration/cfg_logging.rst:64
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s default "
"directory. If the ``logger`` string has no prefix or has the prefix \"file:"
"\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:45
#: ../reference/configuration/cfg_logging.rst:45
#: ../reference/configuration/cfg_logging.rst:70
msgid ""
"box.cfg{logger = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:51
#: ../reference/configuration/cfg_logging.rst:51
#: ../reference/configuration/cfg_logging.rst:76
msgid ""
"This will start the program ``cronolog`` when the server starts, and will "
"send all log messages to the standard input (``stdin``) of cronolog. If the "
"``logger`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/"
"Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:59
#: ../reference/configuration/cfg_logging.rst:59
#: ../reference/configuration/cfg_logging.rst:84
msgid ""
"box.cfg{logger = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:67
#: ../reference/configuration/cfg_logging.rst:67
#: ../reference/configuration/cfg_logging.rst:92
msgid ""
"If the ``logger`` string has the prefix \"syslog:\", then the string is "
"interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/"
"rfc-5424.txt>`_ program which normally is running in the background of any "
"Unix-like platform. One can optionally specify an ``identity``, a "
"``facility``, or both. The ``identity`` is an arbitrary string, default "
"value = ``tarantool``, which will be placed at the beginning of all "
"messages. The facility is an abbreviation for the name of one of the `syslog "
"<https://en.wikipedia.org/wiki/Syslog>`_ facilities, default value = "
"``user``, which tell syslogd where the message should go."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:78
#: ../reference/configuration/cfg_logging.rst:78
#: ../reference/configuration/cfg_logging.rst:103
msgid ""
"Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, "
"kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, "
"local3, local4, local5, local6, local7."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:82
#: ../reference/configuration/cfg_logging.rst:82
#: ../reference/configuration/cfg_logging.rst:107
msgid ""
"The ``facility`` setting is currently ignored but will be used in the future."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:84
#: ../reference/configuration/cfg_logging.rst:84
#: ../reference/configuration/cfg_logging.rst:109
msgid ""
"When logging to a file, tarantool reopens the log on SIGHUP. When log is a "
"program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` "
"variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:96
#: ../reference/configuration/cfg_logging.rst:96
#: ../reference/configuration/cfg_logging.rst:121
msgid ""
"If ``logger_nonblock`` equals true, Tarantool does not block on the log file "
"descriptor when it’s not ready for write, and drops the message instead. If :"
"ref:`log_level <cfg_logging-log_level>` is high, and a lot of messages go to "
"the log file, setting ``logger_nonblock`` to true may improve logging "
"performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:110
#: ../reference/configuration/cfg_logging.rst:110
#: ../reference/configuration/cfg_logging.rst:135
msgid ""
"If processing a request takes longer than the given value (in seconds), warn "
"about it in the log. Has effect only if :ref:`log_level <cfg_logging-"
"log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:114
#: ../reference/configuration/cfg_logging.rst:114
#: ../reference/configuration/cfg_logging.rst:139
msgid "Type: float |br| Default: 0.5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:120
#: ../reference/configuration/cfg_logging.rst:120
#: ../reference/configuration/cfg_logging.rst:145
msgid "**Logging example:**"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:122
#: ../reference/configuration/cfg_logging.rst:122
#: ../reference/configuration/cfg_logging.rst:147
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when the "
"server is writing to a log and signals are used when archiving it."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:125
#: ../reference/configuration/cfg_logging.rst:125
#: ../reference/configuration/cfg_logging.rst:150
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:127
#: ../reference/configuration/cfg_logging.rst:127
#: ../reference/configuration/cfg_logging.rst:152
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the logging "
"will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:130
#: ../reference/configuration/cfg_logging.rst:130
#: ../reference/configuration/cfg_logging.rst:155
msgid ""
"box.cfg{logger='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:136
#: ../reference/configuration/cfg_logging.rst:136
#: ../reference/configuration/cfg_logging.rst:161
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The "
"result of this is: the next log message will go to `Log_file.bak`. |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:846
#: ../reference/configuration/cfg_logging.rst:167
#: ../reference/configuration/cfg_logging.rst:846
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:144
#: ../reference/configuration/cfg_logging.rst:144
#: ../reference/configuration/cfg_logging.rst:169
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file. |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:146
#: ../reference/configuration/cfg_logging.rst:146
#: ../reference/configuration/cfg_logging.rst:171
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:150
#: ../reference/configuration/cfg_logging.rst:150
#: ../reference/configuration/cfg_logging.rst:175
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool server. |"
"br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:859
#: ../reference/configuration/cfg_logging.rst:180
#: ../reference/configuration/cfg_logging.rst:859
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:157
#: ../reference/configuration/cfg_logging.rst:157
#: ../reference/configuration/cfg_logging.rst:182
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool "
"server. The result of this is: Tarantool will open `Log_file` again, and the "
"next log message will go to `Log_file`. (The same effect could be "
"accomplished by executing log.rotate() on the server.) |br|"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:869
#: ../reference/configuration/cfg_logging.rst:190
#: ../reference/configuration/cfg_logging.rst:869
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:167
#: ../reference/configuration/cfg_logging.rst:167
#: ../reference/configuration/cfg_logging.rst:192
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:169
#: ../reference/configuration/cfg_logging.rst:169
#: ../reference/configuration/cfg_logging.rst:194
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:173
#: ../reference/configuration/cfg_logging.rst:173
#: ../reference/configuration/cfg_logging.rst:198
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the example "
"is done:"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:883
#: ../reference/configuration/cfg_logging.rst:204
#: ../reference/configuration/cfg_logging.rst:883
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/reference/configuration/cfg_logging.rst:182
#: ../reference/configuration/cfg_logging.rst:182
#: ../reference/configuration/cfg_logging.rst:207
msgid "and `Log_file` will have"
msgstr ""

#: ../internal after doc/reference/configuration/cfg_logging.rst:891 padding
#: ../reference/configuration/cfg_logging.rst:212
#: reference/configuration/cfg_logging.rst:891
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/reference/reference_lua/box.rst:35
#: ../reference/reference_lua/box.rst:32
msgid ""
"As well as executing Lua chunks or defining their own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its "
"submodules."
msgstr ""

#: ../doc/reference/reference_lua/box.rst:38
msgid ""
"The contents of the ``box`` library can be inspected at runtime with "
"``box``, with no arguments. The submodules inside the box library are:"
msgstr ""

#: ../doc/reference/reference_lua/box.rst:57
msgid ""
"Every submodule contains one or more Lua functions. A few submodules contain "
"members as well as functions. The functions allow data definition (create "
"alter drop), data manipulation (insert delete update upsert select replace), "
"and introspection (inspecting contents of spaces, accessing server "
"configuration)."
msgstr ""

#: ../reference_lua/box_error.rst:28
msgid "Submodule `box.error`"
msgstr "Вложенный модуль `box.error`"

#: ../doc/reference/reference_lua/box_error.rst:35
#: ../reference/reference_lua/box_error.rst:32
#: ../reference_lua/box_error.rst:32
msgid ""
"The ``box.error`` function is for raising an error. The difference between "
"this function and Lua's built-in ``error()`` function is that when the error "
"reaches the client, its error code is preserved. In contrast, a Lua error "
"would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:42
#: ../reference/reference_lua/box_error.rst:39
#: ../reference_lua/box_error.rst:39
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:50
#: ../reference/reference_lua/box_error.rst:47
#: ../reference_lua/box_error.rst:47
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the last "
"error was."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:57
#: ../reference/reference_lua/box_error.rst:52
#: ../reference_lua/box_error.rst:52
msgid ""
"Emulate a request error, with text based on one of the pre-defined Tarantool "
"errors defined in the file `errcode.h <https://github.com/tarantool/"
"tarantool/blob/1.7/src/box/errcode.h>`_ in the source tree. Lua constants "
"which correspond to those Tarantool errors are defined as members of ``box."
"error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:63
#: ../reference/reference_lua/box_error.rst:58
#: ../reference_lua/box_error.rst:58
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:64
#: ../reference/reference_lua/box_error.rst:59
#: ../reference_lua/box_error.rst:59
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:68
#: ../reference/reference_lua/box_error.rst:63
#: ../reference_lua/box_error.rst:63
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. Thus "
"a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, "
"'joe')`` will result in an error with the accompanying message \"``User "
"'joe' is not found``\"."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:74
#: ../reference/reference_lua/box_error.rst:69
#: ../reference_lua/box_error.rst:69
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:78
#: ../reference/reference_lua/box_error.rst:73
#: ../reference_lua/box_error.rst:73
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:97
#: ../reference/reference_lua/box_error.rst:90
#: ../reference_lua/box_error.rst:90
msgid ""
"Returns a description of the last error, as a Lua table with five members: "
"\"line\" (number) Tarantool source file line number, \"code\" (number) "
"error's number, \"type\", (string) error's C++ class, \"message\" (string) "
"error's message, \"file\" (string) Tarantool source file. Additionally, if "
"the error is a system error (for example due to a failure in socket or file "
"io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:107
#: ../reference/reference_lua/box_error.rst:100
#: ../reference_lua/box_error.rst:100
msgid "rtype: table"
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:111
#: ../reference/reference_lua/box_error.rst:104
#: ../reference_lua/box_error.rst:104
msgid ""
"Clears the record of errors, so functions like `box.error()` or `box.error."
"last()` will have no effect."
msgstr ""

#: ../doc/reference/reference_lua/box_error.rst:116
#: ../reference/reference_lua/box_error.rst:109
#: ../reference_lua/box_error.rst:109
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference_lua/box_once.rst:30
msgid "Function `box.once`"
msgstr "Функция `box.once`"

#: ../doc/reference/reference_lua/box_once.rst:37
#: ../reference/reference_lua/box_once.rst:34 ../reference_lua/box_once.rst:34
msgid ""
"Execute a function, provided it has not been executed before. A passed value "
"is checked to see whether the function has already been executed. If it has "
"been executed before, nothing happens. If it has not been executed before, "
"the function is invoked. For an explanation why ``box.once`` is useful, see "
"the section :ref:`Preventing Duplicate Actions <index-"
"preventing_duplicate_actions>`."
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:43
#: ../reference/reference_lua/box_once.rst:40 ../reference_lua/box_once.rst:40
msgid "a value that will be checked"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:44
#: ../reference/reference_lua/box_once.rst:41 ../reference_lua/box_once.rst:41
msgid "a function"
msgstr ""

#: ../doc/reference/reference_lua/box_once.rst:45
#: ../reference/reference_lua/box_once.rst:42 ../reference_lua/box_once.rst:42
msgid "arguments, that must be passed to function"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:35
#: ../reference/reference_lua/clock.rst:32 ../reference_lua/clock.rst:32
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module return a "
"number of seconds; functions whose names end in \"64\" return a 64-bit "
"number of nanoseconds."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:47
#: ../reference/reference_lua/clock.rst:44 ../reference_lua/clock.rst:44
msgid ""
"The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). "
"This is the best function for knowing what the official time is, as "
"determined by the system administrator."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:51
#: ../reference/reference_lua/clock.rst:48 ../reference_lua/clock.rst:48
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:52
#: ../doc/reference/reference_lua/clock.rst:74
#: ../doc/reference/reference_lua/clock.rst:92
#: ../doc/reference/reference_lua/clock.rst:110
#: ../reference/reference_lua/clock.rst:49
#: ../reference/reference_lua/clock.rst:70
#: ../reference/reference_lua/clock.rst:88
#: ../reference/reference_lua/clock.rst:106 ../reference_lua/clock.rst:49
#: ../reference_lua/clock.rst:70 ../reference_lua/clock.rst:88
#: ../reference_lua/clock.rst:106
msgid "number or number64"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:56
#: ../reference/reference_lua/clock.rst:53 ../reference_lua/clock.rst:53
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:62
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function "
"`os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:68
#: ../reference/reference_lua/clock.rst:64 ../reference_lua/clock.rst:64
msgid ""
"The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). "
"Monotonic time is similar to wall clock time but is not affected by changes "
"to or from daylight saving time, or by changes done by a user. This is the "
"best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:73
#: ../reference/reference_lua/clock.rst:69 ../reference_lua/clock.rst:69
msgid ""
"seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:78
#: ../reference/reference_lua/clock.rst:74 ../reference_lua/clock.rst:74
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:87
#: ../reference/reference_lua/clock.rst:83 ../reference_lua/clock.rst:83
msgid ""
"The processor time. Derived from C function "
"clock_gettime(CLOCK_PROCESS_CPUTIME_ID). This is the best function to use "
"with benchmarks that need to calculate how much time has been spent within a "
"CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:91
#: ../reference/reference_lua/clock.rst:87 ../reference_lua/clock.rst:87
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:96
#: ../reference/reference_lua/clock.rst:92 ../reference_lua/clock.rst:92
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:105
#: ../reference/reference_lua/clock.rst:101 ../reference_lua/clock.rst:101
msgid ""
"The thread time. Derived from C function "
"clock_gettime(CLOCK_THREAD_CPUTIME_ID). This is the best function to use "
"with benchmarks that need to calculate how much time has been spent within a "
"thread within a CPU."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:109
#: ../reference/reference_lua/clock.rst:105 ../reference_lua/clock.rst:105
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:114
#: ../reference/reference_lua/clock.rst:110 ../reference_lua/clock.rst:110
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:122
#: ../reference/reference_lua/clock.rst:118 ../reference_lua/clock.rst:118
msgid ""
"The time that a function takes within a processor. This function uses clock."
"proc(), therefore it calculates elapsed CPU time. Therefore it is not useful "
"for showing actual elapsed time."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:128
#: ../reference/reference_lua/clock.rst:124 ../reference_lua/clock.rst:124
msgid ":samp:`{function}` = function or function reference;"
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:129
#: ../reference/reference_lua/clock.rst:125 ../reference_lua/clock.rst:125
msgid ""
":samp:`{function parameters}` = whatever values are required by the function."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:131
#: ../reference/reference_lua/clock.rst:127 ../reference_lua/clock.rst:127
msgid ""
"table. first element = seconds of CPU time; second element = whatever the "
"function returns."
msgstr ""

#: ../doc/reference/reference_lua/clock.rst:136
#: ../reference/reference_lua/clock.rst:132 ../reference_lua/clock.rst:132
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f,10)"
msgstr ""

#: ../reference_lua/console.rst:30
msgid "Module `console`"
msgstr "Модуль `console`"

#: ../doc/reference/reference_lua/console.rst:35
#: ../reference/reference_lua/console.rst:32 ../reference_lua/console.rst:32
msgid ""
"The console module allows one Tarantool server to access another Tarantool "
"server, and allows one Tarantool server to start listening on an :ref:`admin "
"port <administration-admin_ports>`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:44
#: ../reference/reference_lua/console.rst:41 ../reference_lua/console.rst:41
msgid ""
"Connect to the server at :ref:`URI <index-uri>`, change the prompt from ':"
"samp:`tarantool>`' to ':samp:`{uri}>`', and act henceforth as a client until "
"the user ends the session or types :code:`control-D`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:48
#: ../reference/reference_lua/console.rst:45 ../reference_lua/console.rst:45
msgid ""
"The console.connect function allows one Tarantool server, in interactive "
"mode, to access another Tarantool server. Subsequent requests will appear to "
"be handled locally, but in reality the requests are being sent to the remote "
"server and the local server is acting as a client. Once connection is "
"successful, the prompt will change and subsequent requests are sent to, and "
"executed on, the remote server. Results are displayed on the local server. "
"To return to local mode, enter :code:`control-D`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:57
#: ../reference/reference_lua/console.rst:54 ../reference_lua/console.rst:54
msgid ""
"If the Tarantool server at :samp:`uri` requires authentication, the "
"connection might look something like: :code:`console.connect('admin:"
"secretpassword@distanthost.com:3301')`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:61
#: ../reference/reference_lua/console.rst:58 ../reference_lua/console.rst:58
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the login "
"to the remote server is done with user name = 'guest'. The remote server "
"could allow for this by granting at least one privilege: :code:`box.schema."
"user.grant('guest','execute','universe')`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:67
#: ../reference/reference_lua/console.rst:64 ../reference_lua/console.rst:64
msgid "the URI of the remote server"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:71
#: ../reference/reference_lua/console.rst:68 ../reference_lua/console.rst:68
msgid ""
"Possible errors: the connection will fail if the target Tarantool server was "
"not initiated with :code:`box.cfg{listen=...}`."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:76
#: ../reference/reference_lua/console.rst:73 ../reference_lua/console.rst:73
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that server is remote"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:90
#: ../reference/reference_lua/console.rst:87 ../reference_lua/console.rst:87
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming "
"requests is via the connection-information string, or URI, specified in :"
"code:`box.cfg{listen=...}`. The alternative way of listening is via the URI "
"specified in :code:`console.listen(...)`. This alternative way is called "
"\"administrative\" or simply :ref:`\"admin port\" <administration-"
"admin_ports>`. The listening is usually over a local host with a Unix domain "
"socket."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:97
#: ../reference/reference_lua/console.rst:94 ../reference_lua/console.rst:94
msgid "the URI of the local server"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:99
#: ../reference/reference_lua/console.rst:96 ../reference_lua/console.rst:96
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, so "
"it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, for "
"example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:109
#: ../reference/reference_lua/console.rst:106 ../reference_lua/console.rst:106
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:130
#: ../reference/reference_lua/console.rst:127 ../reference_lua/console.rst:127
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/reference/reference_lua/console.rst:134
#: ../reference/reference_lua/console.rst:131 ../reference_lua/console.rst:131
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the tarantool server with :samp:"
"`tarantool {initialization file}` there is no console. This can be remedied "
"by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:141
#: ../reference/reference_lua/console.rst:138 ../reference_lua/console.rst:138
msgid ""
"console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/reference/reference_lua/console.rst:150
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user is "
"using tarantool as a client or the user is using tarantool via console."
"connect(), then hitting the TAB key may cause tarantool to complete a word "
"automatically. The default auto-completion value is `true`."
msgstr ""

#: ../reference_lua/crypto.rst:30
msgid "Module `crypto`"
msgstr "Модуль `crypto`"

#: ../doc/reference/reference_lua/crypto.rst:37
#: ../reference/reference_lua/crypto.rst:34 ../reference_lua/crypto.rst:34
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic hash "
"function`_), applied against a string. Tarantool's crypto module supports "
"ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, "
"MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto functionality is "
"also present in the :ref:`digest` module. The functions in crypto are:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:49
#: ../reference/reference_lua/crypto.rst:46 ../reference_lua/crypto.rst:46
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:52
#: ../reference/reference_lua/crypto.rst:49 ../reference_lua/crypto.rst:49
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:53
#: ../reference/reference_lua/crypto.rst:50 ../reference_lua/crypto.rst:50
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:54
#: ../reference/reference_lua/crypto.rst:51 ../reference_lua/crypto.rst:51
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:55
#: ../reference/reference_lua/crypto.rst:52 ../reference_lua/crypto.rst:52
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:58
#: ../reference/reference_lua/crypto.rst:55 ../reference_lua/crypto.rst:55
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:60
#: ../reference/reference_lua/crypto.rst:57 ../reference_lua/crypto.rst:57
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:61
#: ../reference/reference_lua/crypto.rst:58 ../reference_lua/crypto.rst:58
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:62
#: ../reference/reference_lua/crypto.rst:59 ../reference_lua/crypto.rst:59
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:63
#: ../reference/reference_lua/crypto.rst:60 ../reference_lua/crypto.rst:60
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:65
#: ../reference/reference_lua/crypto.rst:62 ../reference_lua/crypto.rst:62
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:69
#: ../reference/reference_lua/crypto.rst:66 ../reference_lua/crypto.rst:66
msgid ""
"crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:80
#: ../reference/reference_lua/crypto.rst:77 ../reference_lua/crypto.rst:77
msgid ""
"Pass or return a digest derived from the string. The twelve choices of "
"algorithms:"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:83
#: ../reference/reference_lua/crypto.rst:80 ../reference_lua/crypto.rst:80
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:84
#: ../reference/reference_lua/crypto.rst:81 ../reference_lua/crypto.rst:81
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:85
#: ../reference/reference_lua/crypto.rst:82 ../reference_lua/crypto.rst:82
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:86
#: ../reference/reference_lua/crypto.rst:83 ../reference_lua/crypto.rst:83
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:87
#: ../reference/reference_lua/crypto.rst:84 ../reference_lua/crypto.rst:84
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:88
#: ../reference/reference_lua/crypto.rst:85 ../reference_lua/crypto.rst:85
msgid "ripemd160 -"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:89
#: ../reference/reference_lua/crypto.rst:86 ../reference_lua/crypto.rst:86
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:90
#: ../reference/reference_lua/crypto.rst:87 ../reference_lua/crypto.rst:87
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:91
#: ../reference/reference_lua/crypto.rst:88 ../reference_lua/crypto.rst:88
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:92
#: ../reference/reference_lua/crypto.rst:89 ../reference_lua/crypto.rst:89
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:93
#: ../reference/reference_lua/crypto.rst:90 ../reference_lua/crypto.rst:90
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:94
#: ../reference/reference_lua/crypto.rst:91 ../reference_lua/crypto.rst:91
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:98
#: ../reference/reference_lua/crypto.rst:95 ../reference_lua/crypto.rst:95
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:105
#: ../reference/reference_lua/crypto.rst:102 ../reference_lua/crypto.rst:102
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:107
#: ../reference/reference_lua/crypto.rst:104 ../reference_lua/crypto.rst:104
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest could "
"be recomputed for the whole string 'AB', but it is faster to take what was "
"computed before for 'A' and apply changes based on the new part 'B'. This is "
"called multi-step or \"incremental\" digesting, which Tarantool supports for "
"all crypto functions.."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:113
#: ../reference/reference_lua/crypto.rst:110 ../reference_lua/crypto.rst:110
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:137
#: ../reference/reference_lua/crypto.rst:134 ../reference_lua/crypto.rst:134
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:139
#: ../reference/reference_lua/crypto.rst:136 ../reference_lua/crypto.rst:136
msgid ""
"The following functions are equivalent. For example, the ``digest`` function "
"and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/reference/reference_lua/crypto.rst:142
#: ../reference/reference_lua/crypto.rst:139 ../reference_lua/crypto.rst:139
msgid ""
"crypto.cipher.aes256.cbc.encrypt('string', 'key') == digest.aes256cbc."
"encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:31
#: ../reference/reference_lua/csv.rst:28 ../reference_lua/csv.rst:28
msgid "Module `csv`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:35
#: ../reference/reference_lua/csv.rst:32 ../reference_lua/csv.rst:32
msgid ""
"The csv module handles records formatted according to Comma-Separated-Values "
"(CSV) rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:38
#: ../reference/reference_lua/csv.rst:35 ../reference_lua/csv.rst:35
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:40
#: ../reference/reference_lua/csv.rst:37 ../reference_lua/csv.rst:37
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but "
"not within files,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:42
#: ../reference/reference_lua/csv.rst:39 ../reference_lua/csv.rst:39
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:43
#: ../reference/reference_lua/csv.rst:40 ../reference_lua/csv.rst:40
msgid ""
"Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:44
#: ../reference/reference_lua/csv.rst:41 ../reference_lua/csv.rst:41
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:45
#: ../reference/reference_lua/csv.rst:42 ../reference_lua/csv.rst:42
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:46
#: ../reference/reference_lua/csv.rst:43 ../reference_lua/csv.rst:43
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are treated "
"as ordinary characters, and a pair of quote marks \"\" is treated as a "
"single quote mark."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:52
#: ../reference/reference_lua/csv.rst:49 ../reference_lua/csv.rst:49
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:54
#: ../reference/reference_lua/csv.rst:51 ../reference_lua/csv.rst:51
msgid ""
":samp:`delimiter = {string}` -- single-byte character to designate end-of-"
"field, default = comma"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:55
#: ../reference/reference_lua/csv.rst:52 ../reference_lua/csv.rst:52
msgid ""
":samp:`quote_char = {string}` -- single-byte character to designate encloser "
"of string, default = quote mark"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:56
msgid ""
":samp:`chunk_size = {number}` -- number of characters to read at once "
"(usually for file-IO efficiency), default = 4096"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:57
#: ../reference/reference_lua/csv.rst:54 ../reference_lua/csv.rst:54
msgid ""
":samp:`skip_head_lines = {number}` -- number of lines to skip at the start "
"(usually for a header), default 0"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:63
#: ../reference/reference_lua/csv.rst:60 ../reference_lua/csv.rst:60
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:67
#: ../reference/reference_lua/csv.rst:64 ../reference_lua/csv.rst:64
msgid ""
"a string, or any object which has a read() method, formatted according to "
"the CSV rules"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:69
#: ../doc/reference/reference_lua/csv.rst:191
#: ../reference/reference_lua/csv.rst:66 ../reference/reference_lua/csv.rst:188
#: ../reference_lua/csv.rst:66 ../reference_lua/csv.rst:187
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:70
#: ../reference/reference_lua/csv.rst:67 ../reference_lua/csv.rst:67
msgid "loaded_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:75
#: ../reference/reference_lua/csv.rst:72 ../reference_lua/csv.rst:72
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:77
#: ../reference/reference_lua/csv.rst:74 ../reference_lua/csv.rst:74
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:89
#: ../reference/reference_lua/csv.rst:86 ../reference_lua/csv.rst:86
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: (This "
"displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:92
#: ../reference/reference_lua/csv.rst:89 ../reference_lua/csv.rst:89
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:99
#: ../reference/reference_lua/csv.rst:96 ../reference_lua/csv.rst:96
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:101
#: ../reference/reference_lua/csv.rst:98 ../reference_lua/csv.rst:98
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:109
#: ../reference/reference_lua/csv.rst:106 ../reference_lua/csv.rst:106
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of "
"fio is in section :ref:`fio <fio-section>`. Source CSV file and example "
"respectively:"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:113
#: ../reference/reference_lua/csv.rst:110 ../reference_lua/csv.rst:110
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close(nn)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:140
#: ../reference/reference_lua/csv.rst:137 ../reference_lua/csv.rst:137
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. :ref:`csv.dump() "
"<csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:146
#: ../doc/reference/reference_lua/csv.rst:190
#: ../reference/reference_lua/csv.rst:143
#: ../reference/reference_lua/csv.rst:187 ../reference_lua/csv.rst:143
#: ../reference_lua/csv.rst:186
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:147
#: ../reference/reference_lua/csv.rst:144 ../reference_lua/csv.rst:144
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:148
#: ../reference/reference_lua/csv.rst:145 ../reference_lua/csv.rst:145
msgid "any object which has a write() method"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:149
#: ../reference/reference_lua/csv.rst:146 ../reference_lua/csv.rst:146
msgid "dumped_value"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:150
#: ../reference/reference_lua/csv.rst:147 ../reference_lua/csv.rst:147
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:154
#: ../reference/reference_lua/csv.rst:151 ../reference_lua/csv.rst:151
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:156
#: ../reference/reference_lua/csv.rst:153 ../reference_lua/csv.rst:153
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:168
#: ../reference/reference_lua/csv.rst:165 ../reference_lua/csv.rst:165
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:170
#: ../reference/reference_lua/csv.rst:167 ../reference_lua/csv.rst:167
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:186
#: ../reference/reference_lua/csv.rst:183
msgid ""
"Form a Lua iterator function for going through CSV records one field at a "
"time. Use of an iterator is strongly recommended if the amount of data is "
"large (ten or more megabytes)."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:192
#: ../reference/reference_lua/csv.rst:189 ../reference_lua/csv.rst:188
msgid "Lua iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:193
#: ../reference/reference_lua/csv.rst:190 ../reference_lua/csv.rst:189
msgid "iterator function"
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:197
#: ../reference/reference_lua/csv.rst:194 ../reference_lua/csv.rst:193
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-"
"load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a "
"function which is the same as the :ref:`csv.load() <csv-load>` function, as "
"seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/reference/reference_lua/csv.rst:201
#: ../reference/reference_lua/csv.rst:198 ../reference_lua/csv.rst:197
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../reference_lua/digest.rst:30
msgid "Module `digest`"
msgstr "Модуль `digest`"

#: ../doc/reference/reference_lua/digest.rst:37
#: ../reference/reference_lua/digest.rst:34 ../reference_lua/digest.rst:34
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"digest module supports several types of cryptographic hash functions (AES_, "
"MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function (CRC32_), "
"two functions for base64_, and two non-cryptographic hash functions (guava_, "
"murmur_). Some of the digest functionality is also present in the :ref:"
"`crypto <crypto>` module."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:45
#: ../reference/reference_lua/digest.rst:42 ../reference_lua/digest.rst:42
msgid "The functions in digest are:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:50
#: ../reference/reference_lua/digest.rst:47 ../reference_lua/digest.rst:47
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:54
#: ../reference/reference_lua/digest.rst:51 ../reference_lua/digest.rst:51
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:58
#: ../reference/reference_lua/digest.rst:55 ../reference_lua/digest.rst:55
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:62
#: ../reference/reference_lua/digest.rst:59 ../reference_lua/digest.rst:59
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:66
#: ../reference/reference_lua/digest.rst:63 ../reference_lua/digest.rst:63
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:70
#: ../reference/reference_lua/digest.rst:67 ../reference_lua/digest.rst:67
msgid ""
"Returns 160-bit binary string = digest made with SHA-0.|br| Not recommended."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:75
#: ../reference/reference_lua/digest.rst:72 ../reference_lua/digest.rst:72
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:79
#: ../reference/reference_lua/digest.rst:76 ../reference_lua/digest.rst:76
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:83
#: ../reference/reference_lua/digest.rst:80 ../reference_lua/digest.rst:80
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:87
#: ../reference/reference_lua/digest.rst:84 ../reference_lua/digest.rst:84
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:91
#: ../reference/reference_lua/digest.rst:88 ../reference_lua/digest.rst:88
msgid ""
"Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:95
#: ../reference/reference_lua/digest.rst:92 ../reference_lua/digest.rst:92
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:99
#: ../reference/reference_lua/digest.rst:96 ../reference_lua/digest.rst:96
msgid ""
"Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:103
#: ../reference/reference_lua/digest.rst:100 ../reference_lua/digest.rst:100
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:107
#: ../reference/reference_lua/digest.rst:104 ../reference_lua/digest.rst:104
msgid ""
"Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:111
#: ../reference/reference_lua/digest.rst:108 ../reference_lua/digest.rst:108
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:115
#: ../reference/reference_lua/digest.rst:112 ../reference_lua/digest.rst:112
msgid ""
"Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:119
#: ../reference/reference_lua/digest.rst:116 ../reference_lua/digest.rst:116
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:123
#: ../reference/reference_lua/digest.rst:120 ../reference_lua/digest.rst:120
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:127
#: ../reference/reference_lua/digest.rst:124 ../reference_lua/digest.rst:124
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:131
#: ../reference/reference_lua/digest.rst:128 ../reference_lua/digest.rst:128
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:133
#: ../reference/reference_lua/digest.rst:130 ../reference_lua/digest.rst:130
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ "
"polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to be "
"compatible with other checksum functions in other programming languages, "
"ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:138
#: ../reference/reference_lua/digest.rst:135 ../reference_lua/digest.rst:135
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:145
#: ../reference/reference_lua/digest.rst:142 ../reference_lua/digest.rst:142
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:147
#: ../reference/reference_lua/digest.rst:144 ../reference_lua/digest.rst:144
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, "
"refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:154
#: ../reference/reference_lua/digest.rst:151 ../reference_lua/digest.rst:151
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:160
#: ../reference/reference_lua/digest.rst:157 ../reference_lua/digest.rst:157
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:167
#: ../reference/reference_lua/digest.rst:164 ../reference_lua/digest.rst:164
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:169
#: ../reference/reference_lua/digest.rst:166 ../reference_lua/digest.rst:166
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google "
"guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:174
#: ../reference/reference_lua/digest.rst:171 ../reference_lua/digest.rst:171
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:184
#: ../reference/reference_lua/digest.rst:181 ../reference_lua/digest.rst:181
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:189
#: ../reference/reference_lua/digest.rst:186 ../reference_lua/digest.rst:186
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:196
#: ../reference/reference_lua/digest.rst:193 ../reference_lua/digest.rst:193
msgid "Incremental methods in the digest module"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:198
#: ../reference/reference_lua/digest.rst:195 ../reference_lua/digest.rst:195
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest could "
"be recomputed for the whole string 'AB', but it is faster to take what was "
"computed before for 'A' and apply changes based on the new part 'B'. This is "
"called multi-step or \"incremental\" digesting, which Tarantool supports "
"with crc32 and with murmur..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:204
#: ../reference/reference_lua/digest.rst:201 ../reference_lua/digest.rst:201
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:226
#: ../reference/reference_lua/digest.rst:223 ../reference_lua/digest.rst:223
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which "
"requires input of a password."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:230
#: ../reference/reference_lua/digest.rst:227 ../reference_lua/digest.rst:227
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:256
#: ../reference/reference_lua/digest.rst:253 ../reference_lua/digest.rst:253
msgid ""
"If a later user calls the ``password_check()`` function and enters the wrong "
"password, the result is an error."
msgstr ""

#: ../doc/reference/reference_lua/digest.rst:259
#: ../reference/reference_lua/digest.rst:256 ../reference_lua/digest.rst:256
msgid ""
"tarantool> password_insert('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:30
msgid "Database error codes"
msgstr "Коды ошибок от базы данных"

#: ../doc/reference/reference_lua/errcodes.rst:35
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason or "
"operating system error code. All such messages, however, are logged in the "
"error log. Below are general descriptions of some popular codes. A complete "
"list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:46
#: ../reference/reference_lua/errcodes.rst:43
msgid "**List of error codes**"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
#: ../reference/reference_lua/errcodes.rst:49
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:52
#: ../reference/reference_lua/errcodes.rst:49
msgid "Can't modify data on a replication slave."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:54
#: ../reference/reference_lua/errcodes.rst:51
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:54
#: ../reference/reference_lua/errcodes.rst:51
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
#: ../reference/reference_lua/errcodes.rst:54
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:57
#: ../reference/reference_lua/errcodes.rst:54
msgid ""
"Out of memory: :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` limit "
"has been reached."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:61
#: ../reference/reference_lua/errcodes.rst:58
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:61
#: ../reference/reference_lua/errcodes.rst:58
msgid ""
"Failed to write to disk. May mean: failed to record a change in the write-"
"ahead log. Some sort of disk error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:65
#: ../reference/reference_lua/errcodes.rst:62
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:65
#: ../reference/reference_lua/errcodes.rst:62
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:68
#: ../reference/reference_lua/errcodes.rst:65
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:68
#: ../reference/reference_lua/errcodes.rst:65
msgid "The specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:71
#: ../reference/reference_lua/errcodes.rst:68
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:71
#: ../reference/reference_lua/errcodes.rst:68
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:74
#: ../reference/reference_lua/errcodes.rst:71
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:74
#: ../reference/reference_lua/errcodes.rst:71
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:77
#: ../reference/reference_lua/errcodes.rst:74
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:77
#: ../reference/reference_lua/errcodes.rst:74
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:82
#: ../reference/reference_lua/errcodes.rst:79
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:82
#: ../reference/reference_lua/errcodes.rst:79
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:85
#: ../reference/reference_lua/errcodes.rst:82
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:85
#: ../reference/reference_lua/errcodes.rst:82
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:91
msgid "Handling errors"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:93
msgid ""
"Here are some procedures that can make Lua functions more robust when there "
"are errors, particularly database errors."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:96
msgid "Invoke with pcall."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:98
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\" "
"<http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with |br| :samp:`box.space.{space-name}:{function-"
"name}()` |br| say |br| :samp:`if pcall(box.space.{space-name}:{function-name}"
"() ...`"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:105
msgid ""
"For some Tarantool box functions, pcall also returns error details including "
"a file-name and line-number within Tarantool's source code. This can be seen "
"by unpacking. For example: |br| ``x, y = pcall(function() box.schema.space."
"create('') end)`` |br| ``y:unpack()``"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:111
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:114
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:116
msgid ""
"To make a new error and pass it on, the box.error module provides :ref:`box."
"error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:119
msgid ""
"To find the last error, the box.error module provides :ref:`box.error.last() "
"<box_error-last>`. (There is also a way to find the text of the last "
"operating-system error for certain functions -- :ref:`errno.strerror([code]) "
"<errno-strerror>`.)"
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:124
msgid "Log."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:126
msgid "Put messages in a log using the :ref:`log module <log>`."
msgstr ""

#: ../doc/reference/reference_lua/errcodes.rst:128
msgid ""
"And filter messages that are automatically generated, with the :ref:`logger "
"<cfg_logging-logger>` configuration parameter."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:33
msgid "Module `errno`"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:37
msgid ""
"The ``errno`` module has a function ``strerror()`` which will return the "
"text of an operating-system error, given its error number. Typically this "
"module is used within a function or within a Lua program, in association "
"with a module whose functions can return operating-system errors, such as :"
"ref:`fio <fio-module>`."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:49
msgid ""
"Return a string, given an error number. The string will contain the "
"conventional error message for the current operating system. If ``code`` is "
"not supplied, the error message will be for the last operating-system-"
"related function, or 0."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:55
msgid "number of an operating-system error"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:57
msgid "Return type: string"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:59
#: ../doc/reference/reference_lua/socket.rst:214
#: ../doc/reference/reference_lua/xlog.rst:52
msgid "Example:"
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:61
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-open>` "
"which causes error 2 (errno.ENOENT)."
msgstr ""

#: ../doc/reference/reference_lua/errno.rst:64
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print(errno.strerror())\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"No such file or directory\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:33
#: ../reference/reference_lua/fiber.rst:30 ../reference_lua/fiber.rst:30
msgid ""
"The ``fiber`` module allows for creating, running and managing *fibers*."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:35
#: ../reference/reference_lua/fiber.rst:32 ../reference_lua/fiber.rst:32
msgid ""
"A fiber is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a user-"
"supplied function called the *fiber function*. A fiber has three possible "
"states: **running**, **suspended** or **dead**. When a fiber is created "
"with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber "
"yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. "
"When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:43
#: ../reference/reference_lua/fiber.rst:40 ../reference_lua/fiber.rst:40
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:47
#: ../reference/reference_lua/fiber.rst:44 ../reference_lua/fiber.rst:44
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-"
"cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is "
"advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() "
"<fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:"
"`box.space...delete() <box_space-delete>` or :ref:`box.space...update() "
"<box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` "
"but :ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations and "
"does not check whether it has been cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:58
#: ../reference/reference_lua/fiber.rst:55 ../reference_lua/fiber.rst:55
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant events "
"occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-"
"kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an "
"asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-"
"testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:65
#: ../reference/reference_lua/fiber.rst:62 ../reference_lua/fiber.rst:62
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage "
"collector frees pool allocator memory owned by the fiber, resets all fiber "
"data, and returns the fiber (now called a fiber carcass) to the fiber pool. "
"The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:70
#: ../reference/reference_lua/fiber.rst:67 ../reference_lua/fiber.rst:67
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use of "
"fibers is recommended."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:83
#: ../reference/reference_lua/fiber.rst:80 ../reference_lua/fiber.rst:80
msgid ""
"Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:85
#: ../reference/reference_lua/fiber.rst:82 ../reference_lua/fiber.rst:82
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:88
#: ../reference/reference_lua/fiber.rst:85 ../reference_lua/fiber.rst:85
msgid "created fiber object"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:93
#: ../reference/reference_lua/fiber.rst:90 ../reference_lua/fiber.rst:90
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:112
#: ../reference/reference_lua/fiber.rst:109 ../reference_lua/fiber.rst:109
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:117
#: ../reference/reference_lua/fiber.rst:114 ../reference_lua/fiber.rst:114
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:130
#: ../reference/reference_lua/fiber.rst:127 ../reference_lua/fiber.rst:127
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:132
#: ../reference/reference_lua/fiber.rst:129 ../reference_lua/fiber.rst:129
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:137
#: ../reference/reference_lua/fiber.rst:134 ../reference_lua/fiber.rst:134
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:150
#: ../reference/reference_lua/fiber.rst:147 ../reference_lua/fiber.rst:147
msgid ""
"Yield control to the transaction processor thread and sleep for the "
"specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:153
#: ../reference/reference_lua/fiber.rst:150 ../reference_lua/fiber.rst:150
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:157
#: ../reference/reference_lua/fiber.rst:154 ../reference_lua/fiber.rst:154
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:167
#: ../reference/reference_lua/fiber.rst:164 ../reference_lua/fiber.rst:164
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-"
"sleep>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:171
#: ../reference/reference_lua/fiber.rst:168 ../reference_lua/fiber.rst:168
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:181
#: ../reference/reference_lua/fiber.rst:178 ../reference_lua/fiber.rst:178
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:183
#: ../reference/reference_lua/fiber.rst:180 ../reference_lua/fiber.rst:180
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:188
#: ../reference/reference_lua/fiber.rst:185 ../reference_lua/fiber.rst:185
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:199
#: ../reference/reference_lua/fiber.rst:196 ../reference_lua/fiber.rst:196
msgid "Return information about all fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:201
#: ../reference/reference_lua/fiber.rst:198 ../reference_lua/fiber.rst:198
msgid ""
"number of context switches, backtrace, id, total memory, used memory, name "
"for each fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:207
#: ../reference/reference_lua/fiber.rst:204 ../reference_lua/fiber.rst:204
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:225
#: ../reference/reference_lua/fiber.rst:222 ../reference_lua/fiber.rst:222
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber."
"kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:"
"`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:229
#: ../reference/reference_lua/fiber.rst:226 ../reference_lua/fiber.rst:226
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:230
#: ../reference/reference_lua/fiber.rst:227 ../reference_lua/fiber.rst:227
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:234
#: ../reference/reference_lua/fiber.rst:231 ../reference_lua/fiber.rst:231
msgid ""
"tarantool> fiber.kill(fiber.id())\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:245
#: ../reference/reference_lua/fiber.rst:242 ../reference_lua/fiber.rst:242
msgid ""
"Check if the current fiber has been cancelled and throw an exception if this "
"is the case."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:250
#: ../reference/reference_lua/fiber.rst:247 ../reference_lua/fiber.rst:247
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:263
#: ../doc/reference/reference_lua/fiber.rst:284
#: ../doc/reference/reference_lua/fiber.rst:308
#: ../doc/reference/reference_lua/fiber.rst:328
#: ../doc/reference/reference_lua/fiber.rst:352
#: ../reference/reference_lua/fiber.rst:260
#: ../reference/reference_lua/fiber.rst:281
#: ../reference/reference_lua/fiber.rst:305
#: ../reference/reference_lua/fiber.rst:325
#: ../reference/reference_lua/fiber.rst:349 ../reference_lua/fiber.rst:260
#: ../reference_lua/fiber.rst:281 ../reference_lua/fiber.rst:305
#: ../reference_lua/fiber.rst:325 ../reference_lua/fiber.rst:349
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create "
"<fiber-create>`"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:265
#: ../reference/reference_lua/fiber.rst:262 ../reference_lua/fiber.rst:262
msgid "id of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:270
#: ../reference/reference_lua/fiber.rst:267 ../reference_lua/fiber.rst:267
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:286
#: ../reference/reference_lua/fiber.rst:283 ../reference_lua/fiber.rst:283
msgid "name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:291
#: ../reference/reference_lua/fiber.rst:288 ../reference_lua/fiber.rst:288
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:302
#: ../reference/reference_lua/fiber.rst:299 ../reference_lua/fiber.rst:299
msgid ""
"Change the fiber name. By default the Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to :ref:`fiber."
"create <fiber-create>` are named 'lua'. Giving fibers distinct names makes "
"it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:310
#: ../reference/reference_lua/fiber.rst:307 ../reference_lua/fiber.rst:307
msgid "the new name of the fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:316
#: ../reference/reference_lua/fiber.rst:313 ../reference_lua/fiber.rst:313
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:326
#: ../reference/reference_lua/fiber.rst:323 ../reference_lua/fiber.rst:323
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:331
#: ../reference/reference_lua/fiber.rst:328 ../reference_lua/fiber.rst:328
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:336
#: ../reference/reference_lua/fiber.rst:333 ../reference_lua/fiber.rst:333
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:347
#: ../reference/reference_lua/fiber.rst:344 ../reference_lua/fiber.rst:344
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber "
"has been cancelled, attempts to operate on it will cause errors, for "
"example :ref:`fiber_object:id() <fiber_object-id>` will cause ``error: the "
"fiber is dead``."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:357
#: ../reference/reference_lua/fiber.rst:354 ../reference_lua/fiber.rst:354
msgid ""
"Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:361
#: ../reference/reference_lua/fiber.rst:358 ../reference_lua/fiber.rst:358
msgid ""
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:372
#: ../reference/reference_lua/fiber.rst:369
msgid ""
"Local storage within the fiber. The storage can contain any number of named "
"values, subject to memory limitations. Naming may be done with :samp:"
"`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` "
"or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be "
"either numbers or strings. The storage is garbage-collected when :samp:"
"`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:381
#: ../reference/reference_lua/fiber.rst:378 ../reference_lua/fiber.rst:378
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: fiber."
"create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber "
"is dead'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:412
#: ../reference/reference_lua/fiber.rst:409 ../reference_lua/fiber.rst:409
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:418
#: ../reference/reference_lua/fiber.rst:415 ../reference_lua/fiber.rst:415
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The time "
"is taken from the event loop clock, which makes this call very cheap, but "
"still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:422
#: ../doc/reference/reference_lua/fiber.rst:441
#: ../reference/reference_lua/fiber.rst:419
#: ../reference/reference_lua/fiber.rst:438 ../reference_lua/fiber.rst:419
#: ../reference_lua/fiber.rst:438
msgid "num"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:426
#: ../reference/reference_lua/fiber.rst:423 ../reference_lua/fiber.rst:423
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:438
#: ../reference/reference_lua/fiber.rst:435 ../reference_lua/fiber.rst:435
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit integer. "
"The time is taken from the event loop clock."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:445
#: ../reference/reference_lua/fiber.rst:442 ../reference_lua/fiber.rst:442
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:455
#: ../reference/reference_lua/fiber.rst:452 ../reference_lua/fiber.rst:452
msgid "Example Of Fiber Use"
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:457
#: ../reference/reference_lua/fiber.rst:454 ../reference_lua/fiber.rst:454
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each iteration "
"of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 "
"seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:462
#: ../reference/reference_lua/fiber.rst:459 ../reference_lua/fiber.rst:459
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:475
#: ../reference/reference_lua/fiber.rst:472 ../reference_lua/fiber.rst:472
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. It "
"will immediately \"detach\" so it will be running independently of the "
"caller."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:478
#: ../reference/reference_lua/fiber.rst:475 ../reference_lua/fiber.rst:475
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:486
#: ../reference/reference_lua/fiber.rst:483 ../reference_lua/fiber.rst:483
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:488
#: ../reference/reference_lua/fiber.rst:485 ../reference_lua/fiber.rst:485
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:494
#: ../reference/reference_lua/fiber.rst:491 ../reference_lua/fiber.rst:491
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the "
"fiber id, the fiber status, and gvar (gvar will have gone up a bit depending "
"how long the pause lasted). The status is suspended because the fiber spends "
"almost all its time sleeping or yielding."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:499
#: ../reference/reference_lua/fiber.rst:496 ../reference_lua/fiber.rst:496
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:506
#: ../reference/reference_lua/fiber.rst:503 ../reference_lua/fiber.rst:503
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and gvar "
"(gvar will have gone up a bit more depending how long the pause lasted). "
"This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/reference/reference_lua/fiber.rst:511
#: ../reference/reference_lua/fiber.rst:508 ../reference_lua/fiber.rst:508
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:31
msgid "Submodule `fiber-cond`"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:33
msgid ""
"The ``fiber-cond`` submodule has a synchronization mechanism for fibers, "
"similar to \"Condition Variables\" and similar to operating-system functions "
"such as pthread_cond_wait() plus pthread_cond_signal()."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:37
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be "
"called cond for examples in this section. Call ``cond:wait()`` to make a "
"fiber wait for a signal via a condition variable. Call ``cond:signal()`` to "
"send a signal to wake up a single fiber that has executed ``cond:wait()``. "
"Call ``cond:broadcast()`` to send a signal to all fibers that have executed "
"``cond:wait()``."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:47
msgid "Create a new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:49
msgid "new condition variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:50
msgid "Lua object"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:56
msgid ""
"Make the current fiber go to sleep, waiting until until another fiber "
"invokes the ``signal()`` or ``broadcast()`` method on the cond object. The "
"sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:61
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:62
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of the "
"timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:69
msgid ""
"Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:75
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:84
msgid ""
"Assume that a tarantool server is running and listening for connections on "
"localhost port 3301. Assume that guest users have privileges to connect. We "
"will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:89
msgid "On terminal #1, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:91
msgid ""
"tarantoolctl connect '3301'\n"
"fiber = require('fiber')\n"
"cond = fiber.cond()\n"
"cond:wait()"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:98
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:102
msgid "On terminal #2, say"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:104
msgid ""
"tarantoolctl connect '3301'\n"
"cond:signal()"
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:109
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and "
"the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/reference/reference_lua/fiber_cond.rst:113
msgid ""
"This example depended on the use of a global conditional variable with the "
"arbitrary name ``cond``. In real life, programmers would make sure to use "
"different conditional variable names for different applications."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:28
msgid "Submodule `fiber-ipc`"
msgstr "Модуль `fiber-ipc`"

#: ../doc/reference/reference_lua/fiber_ipc.rst:33
#: ../reference/reference_lua/fiber_ipc.rst:30
#: ../reference_lua/fiber_ipc.rst:30
msgid ""
"The ``fiber-ipc`` submodule allows sending and receiving messages between "
"different processes. The words \"different processes\" in this context mean "
"different connections, different sessions, or different fibers."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:37
#: ../reference/reference_lua/fiber_ipc.rst:34
#: ../reference_lua/fiber_ipc.rst:34
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, which "
"will be called channel for examples in this section. Call the other ``fiber-"
"ipc`` routines, via channel, to send messages, receive messages, or check "
"ipc status. Message exchange is synchronous. The channel is garbage "
"collected when no one is using it, as with any other Lua object. Use object-"
"oriented syntax, for example ``channel:put(message)`` rather than ``fiber."
"channel.put(message)``."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:51
#: ../reference/reference_lua/fiber_ipc.rst:48
#: ../reference_lua/fiber_ipc.rst:48
msgid "Create a new communication channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:53
#: ../reference/reference_lua/fiber_ipc.rst:50
#: ../reference_lua/fiber_ipc.rst:50
msgid ""
"positive integer as great as the maximum number of slots (spaces for ``get`` "
"or ``put`` messages) that might be pending at any given time."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:57
#: ../reference/reference_lua/fiber_ipc.rst:54
#: ../reference_lua/fiber_ipc.rst:54
msgid "new channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:58
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:64
#: ../reference/reference_lua/fiber_ipc.rst:61
#: ../reference_lua/fiber_ipc.rst:61
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()`` "
"blocks until there is a free slot in the channel."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:69
msgid ""
"If timeout is provided, and there is no free slot in the channel for the "
"duration of the timeout, ``channel:put()`` returns false. Otherwise it "
"returns true."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:76
#: ../reference/reference_lua/fiber_ipc.rst:73
#: ../reference_lua/fiber_ipc.rst:73
msgid ""
"Close the channel. All waiters in the channel will be woken up. All "
"following ``channel:put()`` or ``channel:get()`` operations will return an "
"error (``nil``)."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:82
#: ../reference/reference_lua/fiber_ipc.rst:79
#: ../reference_lua/fiber_ipc.rst:79
msgid ""
"Fetch a message from a channel. If the channel is empty, ``channel:get()`` "
"blocks until there is a message."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:86
msgid ""
"the message placed on the channel by ``channel:put()``. If timeout is "
"provided, and there is no message in the channel for the duration of the "
"timeout, ``channel:get()`` returns nil."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:93
#: ../reference/reference_lua/fiber_ipc.rst:89
#: ../reference_lua/fiber_ipc.rst:89
msgid "Check whether the specified channel is empty (has no messages)."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:95
#: ../reference/reference_lua/fiber_ipc.rst:91
#: ../reference_lua/fiber_ipc.rst:91
msgid "true if the specified channel is empty"
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:100
#: ../reference/reference_lua/fiber_ipc.rst:96
#: ../reference_lua/fiber_ipc.rst:96
msgid ""
"Find out how many messages are on the channel. The answer is 0 if the "
"channel is empty."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:102
#: ../reference/reference_lua/fiber_ipc.rst:98
#: ../reference_lua/fiber_ipc.rst:98
msgid "the number of messages."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:107
#: ../reference/reference_lua/fiber_ipc.rst:103
#: ../reference_lua/fiber_ipc.rst:103
msgid "Check whether the specified channel is full."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:109
#: ../reference/reference_lua/fiber_ipc.rst:105
#: ../reference_lua/fiber_ipc.rst:105
msgid "true if the specified channel is full (has no room for a new message)."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:114
#: ../reference/reference_lua/fiber_ipc.rst:110
#: ../reference_lua/fiber_ipc.rst:110
msgid ""
"Check whether the specified channel is empty and has readers waiting for a "
"message (because they have issued ``channel:get()`` and then blocked)."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:117
#: ../doc/reference/reference_lua/fiber_ipc.rst:125
#: ../reference/reference_lua/fiber_ipc.rst:113
#: ../reference/reference_lua/fiber_ipc.rst:121
#: ../reference_lua/fiber_ipc.rst:113 ../reference_lua/fiber_ipc.rst:121
msgid "true if blocked users are waiting. Otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:122
#: ../reference/reference_lua/fiber_ipc.rst:118
#: ../reference_lua/fiber_ipc.rst:118
msgid ""
"Check whether the specified channel is full and has writers waiting (because "
"they have issued ``channel:put()`` and then blocked due to lack of room)."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:130
#: ../reference/reference_lua/fiber_ipc.rst:126
#: ../reference_lua/fiber_ipc.rst:126
msgid "true if the specified channel is already closed. Otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:137
#: ../reference/reference_lua/fiber_ipc.rst:133
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in :"
"ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/reference/reference_lua/fiber_ipc.rst:142
#: ../reference/reference_lua/fiber_ipc.rst:138
#: ../reference_lua/fiber_ipc.rst:133
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:33
#: ../reference/reference_lua/fio.rst:30 ../reference_lua/fio.rst:30
msgid "Module `fio`"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:37
#: ../reference/reference_lua/fio.rst:34 ../reference_lua/fio.rst:34
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX "
"syscalls. All operations are performed asynchronously. Multiple fibers can "
"access the same file simultaneously."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:45
#: ../reference/reference_lua/fio.rst:42 ../reference_lua/fio.rst:42
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:49
#: ../reference/reference_lua/fio.rst:46 ../reference_lua/fio.rst:46
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:51
#: ../reference/reference_lua/fio.rst:48 ../reference_lua/fio.rst:48
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:52
#: ../doc/reference/reference_lua/fio.rst:69
#: ../doc/reference/reference_lua/fio.rst:88
#: ../reference/reference_lua/fio.rst:49 ../reference/reference_lua/fio.rst:66
#: ../reference/reference_lua/fio.rst:85 ../reference_lua/fio.rst:49
#: ../reference_lua/fio.rst:66 ../reference_lua/fio.rst:85
msgid "path name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:57
#: ../reference/reference_lua/fio.rst:54 ../reference_lua/fio.rst:54
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:66
#: ../reference/reference_lua/fio.rst:63 ../reference_lua/fio.rst:63
msgid ""
"Given a full path name, remove all but the final part (the file name). Also "
"remove the suffix, if it is passed."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:70
#: ../reference/reference_lua/fio.rst:67 ../reference_lua/fio.rst:67
msgid "suffix"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:72
#: ../reference/reference_lua/fio.rst:69 ../reference_lua/fio.rst:69
msgid "file name"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:77
#: ../reference/reference_lua/fio.rst:74 ../reference_lua/fio.rst:74
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:86
#: ../reference/reference_lua/fio.rst:83 ../reference_lua/fio.rst:83
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:90
#: ../reference/reference_lua/fio.rst:87 ../reference_lua/fio.rst:87
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:95
#: ../reference/reference_lua/fio.rst:92 ../reference_lua/fio.rst:92
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:104
#: ../reference/reference_lua/fio.rst:101 ../reference_lua/fio.rst:101
msgid "Common file manipulations"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:108
#: ../reference/reference_lua/fio.rst:105 ../reference_lua/fio.rst:105
msgid ""
"Set the mask bits used when creating files or directories. For a detailed "
"description type \"man 2 umask\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:111
#: ../reference/reference_lua/fio.rst:108 ../reference_lua/fio.rst:108
msgid "mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:112
#: ../reference/reference_lua/fio.rst:109 ../reference_lua/fio.rst:109
msgid "previous mask bits."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:117
#: ../reference/reference_lua/fio.rst:114 ../reference_lua/fio.rst:114
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:127
#: ../reference/reference_lua/fio.rst:124 ../reference_lua/fio.rst:124
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\" or "
"\"man 2 stat\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:130
#: ../reference/reference_lua/fio.rst:127 ../reference_lua/fio.rst:127
msgid "path name of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:131
#: ../reference/reference_lua/fio.rst:128 ../reference_lua/fio.rst:128
msgid ""
"fields which describe the file's block size, creation time, size, and other "
"attributes."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:137
#: ../reference/reference_lua/fio.rst:134 ../reference_lua/fio.rst:134
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:163
#: ../reference/reference_lua/fio.rst:160 ../reference_lua/fio.rst:160
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2 "
"rmdir\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:166
#: ../reference/reference_lua/fio.rst:163 ../reference_lua/fio.rst:163
msgid "path of directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:167
#: ../reference/reference_lua/fio.rst:164 ../reference_lua/fio.rst:164
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:170
#: ../doc/reference/reference_lua/fio.rst:266
#: ../doc/reference/reference_lua/fio.rst:308
#: ../doc/reference/reference_lua/fio.rst:324
#: ../doc/reference/reference_lua/fio.rst:452
#: ../doc/reference/reference_lua/fio.rst:526
#: ../reference/reference_lua/fio.rst:167
#: ../reference/reference_lua/fio.rst:263
#: ../reference/reference_lua/fio.rst:305
#: ../reference/reference_lua/fio.rst:321
#: ../reference/reference_lua/fio.rst:447
#: ../reference/reference_lua/fio.rst:521 ../reference_lua/fio.rst:167
#: ../reference_lua/fio.rst:263 ../reference_lua/fio.rst:305
#: ../reference_lua/fio.rst:321 ../reference_lua/fio.rst:447
#: ../reference_lua/fio.rst:521
msgid "true if success, false if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:175
#: ../reference/reference_lua/fio.rst:172 ../reference_lua/fio.rst:172
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:184
#: ../reference/reference_lua/fio.rst:181 ../reference_lua/fio.rst:181
msgid ""
"Return a list of files that match an input string. The list is constructed "
"with a single flag that controls the behavior of the function: "
"GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:188
#: ../reference/reference_lua/fio.rst:185 ../reference_lua/fio.rst:185
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:189
#: ../reference/reference_lua/fio.rst:186 ../reference_lua/fio.rst:186
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:192
#: ../doc/reference/reference_lua/fio.rst:360
#: ../doc/reference/reference_lua/fio.rst:476
#: ../doc/reference/reference_lua/socket.rst:373
#: ../reference/reference_lua/fio.rst:189
#: ../reference/reference_lua/fio.rst:355
#: ../reference/reference_lua/fio.rst:471
#: ../reference/reference_lua/socket.rst:350 ../reference_lua/fio.rst:189
#: ../reference_lua/fio.rst:355 ../reference_lua/fio.rst:471
#: ../reference_lua/socket.rst:349
msgid "Possible errors: nil."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:196
#: ../reference/reference_lua/fio.rst:193 ../reference_lua/fio.rst:193
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:207
#: ../reference/reference_lua/fio.rst:204 ../reference_lua/fio.rst:204
msgid ""
"Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:211
#: ../reference/reference_lua/fio.rst:208 ../reference_lua/fio.rst:208
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:220
#: ../reference/reference_lua/fio.rst:217 ../reference_lua/fio.rst:217
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:224
#: ../reference/reference_lua/fio.rst:221 ../reference_lua/fio.rst:221
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:236
#: ../reference/reference_lua/fio.rst:233 ../reference_lua/fio.rst:233
msgid ""
"Functions to create and delete links. For details type \"man readlink\", "
"\"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:239
#: ../reference/reference_lua/fio.rst:236 ../reference_lua/fio.rst:236
msgid "existing file name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:240
#: ../reference/reference_lua/fio.rst:237 ../reference_lua/fio.rst:237
msgid "linked name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:242
#: ../reference/reference_lua/fio.rst:239 ../reference_lua/fio.rst:239
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if success, "
"false if failure. ``fio.readlink`` returns the link value if success, nil if "
"failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:248
#: ../reference/reference_lua/fio.rst:245 ../reference_lua/fio.rst:245
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:261
#: ../reference/reference_lua/fio.rst:258 ../reference_lua/fio.rst:258
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:263
#: ../reference/reference_lua/fio.rst:260 ../reference_lua/fio.rst:260
msgid "original name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:264
#: ../reference/reference_lua/fio.rst:261 ../reference_lua/fio.rst:261
msgid "new name."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:271
#: ../reference/reference_lua/fio.rst:268 ../reference_lua/fio.rst:268
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:281
#: ../reference/reference_lua/fio.rst:278 ../reference_lua/fio.rst:278
msgid ""
"Manage the rights to file objects, or ownership of file objects. For details "
"type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:284
#: ../reference/reference_lua/fio.rst:281 ../reference_lua/fio.rst:281
msgid "new user uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:285
#: ../reference/reference_lua/fio.rst:282 ../reference_lua/fio.rst:282
msgid "new group uid."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:286
#: ../reference/reference_lua/fio.rst:283 ../reference_lua/fio.rst:283
msgid "new permissions"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:290
#: ../reference/reference_lua/fio.rst:287 ../reference_lua/fio.rst:287
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:303
#: ../reference/reference_lua/fio.rst:300 ../reference_lua/fio.rst:300
msgid ""
"Reduce file size to a specified value. For details type \"man 2 truncate\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:313
#: ../reference/reference_lua/fio.rst:310 ../reference_lua/fio.rst:310
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:322
#: ../reference/reference_lua/fio.rst:319 ../reference_lua/fio.rst:319
msgid ""
"Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:329
#: ../reference/reference_lua/fio.rst:326 ../reference_lua/fio.rst:326
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:345
#: ../reference/reference_lua/fio.rst:340 ../reference_lua/fio.rst:340
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:348
#: ../reference/reference_lua/fio.rst:343 ../reference_lua/fio.rst:343
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:352
#: ../reference/reference_lua/fio.rst:347 ../reference_lua/fio.rst:347
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREATE` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:357
#: ../reference/reference_lua/fio.rst:352 ../reference_lua/fio.rst:352
msgid "file handle (later - fh)"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:364
#: ../reference/reference_lua/fio.rst:359 ../reference_lua/fio.rst:359
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:378
#: ../reference/reference_lua/fio.rst:373 ../reference_lua/fio.rst:373
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 "
"close\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:380
#: ../doc/reference/reference_lua/fio.rst:400
#: ../doc/reference/reference_lua/fio.rst:431
#: ../doc/reference/reference_lua/fio.rst:451
#: ../doc/reference/reference_lua/fio.rst:469
#: ../doc/reference/reference_lua/fio.rst:492
#: ../doc/reference/reference_lua/fio.rst:525
#: ../reference/reference_lua/fio.rst:375
#: ../reference/reference_lua/fio.rst:395
#: ../reference/reference_lua/fio.rst:426
#: ../reference/reference_lua/fio.rst:446
#: ../reference/reference_lua/fio.rst:464
#: ../reference/reference_lua/fio.rst:487
#: ../reference/reference_lua/fio.rst:520 ../reference_lua/fio.rst:375
#: ../reference_lua/fio.rst:395 ../reference_lua/fio.rst:426
#: ../reference_lua/fio.rst:446 ../reference_lua/fio.rst:464
#: ../reference_lua/fio.rst:487 ../reference_lua/fio.rst:520
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:381
#: ../reference/reference_lua/fio.rst:376 ../reference_lua/fio.rst:376
msgid "true if success, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:386
#: ../reference/reference_lua/fio.rst:381 ../reference_lua/fio.rst:381
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:396
#: ../reference/reference_lua/fio.rst:391 ../reference_lua/fio.rst:391
msgid ""
"Perform read/write random-access operation on a file, without affecting the "
"current seek position of the file. For details type \"man 2 pread\" or \"man "
"2 pwrite\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:401
#: ../doc/reference/reference_lua/fio.rst:432
#: ../reference/reference_lua/fio.rst:396
#: ../reference/reference_lua/fio.rst:427 ../reference_lua/fio.rst:396
#: ../reference_lua/fio.rst:427
msgid "number of bytes to read"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:402
#: ../doc/reference/reference_lua/fio.rst:433
#: ../reference/reference_lua/fio.rst:397
#: ../reference/reference_lua/fio.rst:428 ../reference_lua/fio.rst:397
#: ../reference_lua/fio.rst:428
msgid "value to write"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:403
#: ../reference/reference_lua/fio.rst:398 ../reference_lua/fio.rst:398
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:404
#: ../reference/reference_lua/fio.rst:399 ../reference_lua/fio.rst:399
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:409
#: ../reference/reference_lua/fio.rst:404 ../reference_lua/fio.rst:404
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:421
#: ../reference/reference_lua/fio.rst:416 ../reference_lua/fio.rst:416
msgid ""
"Perform non-random-access read or write on a file. For details type \"man 2 "
"read\" or \"man 2 write\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:426
#: ../reference/reference_lua/fio.rst:421 ../reference_lua/fio.rst:421
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, and "
"this must be taken into account when working on the same file from multiple "
"fibers. It is possible to limit or prevent file access from other fibers "
"with ``fiber.ipc``."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:434
#: ../reference/reference_lua/fio.rst:429 ../reference_lua/fio.rst:429
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` returns "
"the data that was read, or nil if failure."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:439
#: ../reference/reference_lua/fio.rst:434 ../reference_lua/fio.rst:434
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:448
#: ../reference/reference_lua/fio.rst:443 ../reference_lua/fio.rst:443
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:457
#: ../reference/reference_lua/fio.rst:452 ../reference_lua/fio.rst:452
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:466
#: ../reference/reference_lua/fio.rst:461 ../reference_lua/fio.rst:461
msgid ""
"Shift position in the file to the specified position. For details type \"man "
"2 seek\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:470
#: ../reference/reference_lua/fio.rst:465 ../reference_lua/fio.rst:465
msgid "position to seek to"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:471
#: ../reference/reference_lua/fio.rst:466 ../reference_lua/fio.rst:466
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:473
#: ../reference/reference_lua/fio.rst:468 ../reference_lua/fio.rst:468
msgid "the new position if success"
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:480
#: ../reference/reference_lua/fio.rst:475 ../reference_lua/fio.rst:475
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:489
#: ../reference/reference_lua/fio.rst:484 ../reference_lua/fio.rst:484
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` which "
"return statistics about a closed file. For details type \"man 2 stat\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:493
#: ../reference/reference_lua/fio.rst:488 ../reference_lua/fio.rst:488
msgid "details about the file."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:498
#: ../reference/reference_lua/fio.rst:493 ../reference_lua/fio.rst:493
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:521
#: ../reference/reference_lua/fio.rst:516 ../reference_lua/fio.rst:516
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type \"man 2 fsync\" or "
"\"man 2 fdatasync\"."
msgstr ""

#: ../doc/reference/reference_lua/fio.rst:530
#: ../reference/reference_lua/fio.rst:525 ../reference_lua/fio.rst:525
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:33
#: ../reference/reference_lua/fun.rst:30 ../reference_lua/fun.rst:30
msgid "Module `fun`"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:35
#: ../reference/reference_lua/fun.rst:32 ../reference_lua/fun.rst:32
msgid ""
"Lua fun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the module "
"are \"sequence processors\" such as map, filter, reduce, zip -- they take a "
"user-written function as an argument and run it against every element in a "
"sequence, which can be faster or more convenient than a user-written loop. "
"Inside the module are \"generators\" such as range, tabulate, and rands -- "
"they return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the important "
"features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:47
#: ../reference/reference_lua/fun.rst:44 ../reference_lua/fun.rst:44
msgid ""
"The full documentation is `On the luafun section of github`_. However, the "
"first chapter can be skipped because installation is already done, it's "
"inside Tarantool. All that is needed is the usual :code:`require` request. "
"After that, all the operations described in the Lua fun manual will work, "
"provided they are preceded by the name returned by the :code:`require` "
"request. For example:"
msgstr ""

#: ../doc/reference/reference_lua/fun.rst:55
#: ../reference/reference_lua/fun.rst:52 ../reference_lua/fun.rst:52
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/index.rst:28
msgid "Built-in library reference"
msgstr "Справочник по встроенной библиотеке"

#: ../doc/reference/reference_lua/index.rst:33
#: ../reference/reference_lua/index.rst:30
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/reference/reference_lua/index.rst:37
#: ../reference/reference_lua/index.rst:34
msgid ""
"Some functions in these modules are analogs to functions from `standard Lua "
"libraries <http://www.lua.org/manual/>`_. For better results, we recommend "
"using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:33
#: ../reference/reference_lua/json.rst:30 ../reference_lua/json.rst:30
msgid "Module `json`"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:35
#: ../reference/reference_lua/json.rst:32 ../reference_lua/json.rst:32
msgid ""
"The json module provides JSON manipulation routines. It is based on the `Lua-"
"CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON please "
"read `the official documentation`_."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:45
#: ../reference/reference_lua/json.rst:42 ../reference_lua/json.rst:42
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:47
#: ../doc/reference/reference_lua/msgpack.rst:44
#: ../doc/reference/reference_lua/yaml.rst:44
#: ../reference/reference_lua/json.rst:44
#: ../reference/reference_lua/msgpack.rst:41
#: ../reference/reference_lua/yaml.rst:41 ../reference_lua/json.rst:44
#: ../reference_lua/msgpack.rst:41 ../reference_lua/yaml.rst:41
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:48
#: ../reference/reference_lua/json.rst:45 ../reference_lua/json.rst:45
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:53
#: ../reference/reference_lua/json.rst:50 ../reference_lua/json.rst:50
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:83
#: ../reference/reference_lua/json.rst:80 ../reference_lua/json.rst:80
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:85
#: ../reference/reference_lua/json.rst:82 ../reference_lua/json.rst:82
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:86
#: ../doc/reference/reference_lua/yaml.rst:53
#: ../reference/reference_lua/json.rst:83
#: ../reference/reference_lua/yaml.rst:50 ../reference_lua/json.rst:83
#: ../reference_lua/yaml.rst:50
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:91
#: ../reference/reference_lua/json.rst:88 ../reference_lua/json.rst:88
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:113
#: ../doc/reference/reference_lua/msgpack.rst:64
#: ../doc/reference/reference_lua/yaml.rst:60
#: ../reference/reference_lua/json.rst:110
#: ../reference/reference_lua/msgpack.rst:61
#: ../reference/reference_lua/yaml.rst:57 ../reference_lua/json.rst:110
#: ../reference_lua/msgpack.rst:61 ../reference_lua/yaml.rst:57
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in a "
"tuple."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:117
#: ../reference/reference_lua/json.rst:114 ../reference_lua/json.rst:114
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'}\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:139
#: ../reference/reference_lua/json.rst:136 ../reference_lua/json.rst:136
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:141
#: ../reference/reference_lua/json.rst:138 ../reference_lua/json.rst:138
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:142
#: ../reference/reference_lua/json.rst:139 ../reference_lua/json.rst:139
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:144
#: ../doc/reference/reference_lua/yaml.rst:97
#: ../reference/reference_lua/json.rst:141
#: ../reference/reference_lua/yaml.rst:94 ../reference_lua/json.rst:141
#: ../reference_lua/yaml.rst:94
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:146
#: ../reference/reference_lua/json.rst:143 ../reference_lua/json.rst:143
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize="
"\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize="
"\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:170
#: ../reference/reference_lua/json.rst:167 ../reference_lua/json.rst:167
msgid "Configuration settings"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:172
#: ../reference/reference_lua/json.rst:169 ../reference_lua/json.rst:169
msgid ""
"There are configuration settings which affect the way that Tarantool encodes "
"invalid numbers or types. They are all boolean ``true``/``false`` values"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:175
#: ../reference/reference_lua/json.rst:172 ../reference_lua/json.rst:172
msgid "``cfg.encode_invalid_numbers`` - allow nan and inf (default is true)"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:176
#: ../reference/reference_lua/json.rst:173 ../reference_lua/json.rst:173
msgid ""
"``cfg.encode_use_tostring`` - use tostring for unrecognizable types (default "
"is false)"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:177
#: ../reference/reference_lua/json.rst:174 ../reference_lua/json.rst:174
msgid ""
"``cfg.encode_invalid_as_nil`` - use null for all unrecognizable types "
"(default is false)"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:178
#: ../reference/reference_lua/json.rst:175 ../reference_lua/json.rst:175
msgid "``cfg.encode_load_metatables`` - load metatables (default is false)"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:180
#: ../reference/reference_lua/json.rst:177 ../reference_lua/json.rst:177
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a number"
"\") and 1/0 (which is \"infinity\") as special values rather than nulls or "
"errors:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:183
#: ../reference/reference_lua/json.rst:180 ../reference_lua/json.rst:180
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:191
#: ../reference/reference_lua/json.rst:188 ../reference_lua/json.rst:188
msgid "The result of the json.encode request will look like this:"
msgstr ""

#: ../doc/reference/reference_lua/json.rst:193
#: ../reference/reference_lua/json.rst:190 ../reference_lua/json.rst:190
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/json.rst:200
#: ../reference/reference_lua/json.rst:197 ../reference_lua/json.rst:197
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack <msgpack-"
"module>`, and for :ref:`YAML <yaml-module>`. >>>>>>> Fix every NOTE to be "
"highlighted on site + JSON cfg rewritten"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:33
#: ../reference/reference_lua/log.rst:30 ../reference_lua/log.rst:30
msgid "Module `log`"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:37
#: ../reference/reference_lua/log.rst:34 ../reference_lua/log.rst:34
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified by "
"the :ref:`logger <cfg_logging-logger>` configuration parameter. Diagnostic "
"messages may be either system-generated by the server's internal code, or "
"user-generated with the ``log.log_level_function_name`` function."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:47
#: ../reference/reference_lua/log.rst:44 ../reference_lua/log.rst:44
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-logger>`, "
"given log_level_function_name = ``error`` or ``warn`` or ``info`` or "
"``debug``."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:50
#: ../reference/reference_lua/log.rst:47 ../reference_lua/log.rst:47
#, python-format
msgid ""
"The actual output will be a line containing the current timestamp, a module "
"name, 'E' or 'W' or 'I' or 'D' or 'R' depending on "
"``log_level_function_name``, and ``message``. Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`. Messages may contain C-style format specifiers %d "
"or %s, so :samp:`log.error('...%d...%s',{x},{y})` will work if x is a number "
"and y is a string."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:71
#: ../reference/reference_lua/log.rst:68 ../reference_lua/log.rst:68
#, python-format
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()\n"
"$ less tarantool.txt"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:84
#: ../reference/reference_lua/log.rst:81 ../reference_lua/log.rst:81
msgid ""
"2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...1 [5261] main/101/spawner C> initialized\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/reference/reference_lua/log.rst:89
#: ../reference/reference_lua/log.rst:86 ../reference_lua/log.rst:86
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../doc/reference/reference_lua/log.rst:91
#: ../reference/reference_lua/log.rst:88 ../reference_lua/log.rst:88
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../reference_lua/msgpack.rst:30
msgid "Module `msgpack`"
msgstr "Модуль `msgpack`"

#: ../doc/reference/reference_lua/msgpack.rst:35
#: ../reference/reference_lua/msgpack.rst:32 ../reference_lua/msgpack.rst:32
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or "
"takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:42
#: ../reference/reference_lua/msgpack.rst:39 ../reference_lua/msgpack.rst:39
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:45
#: ../reference/reference_lua/msgpack.rst:42 ../reference_lua/msgpack.rst:42
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:50
#: ../reference/reference_lua/msgpack.rst:47 ../reference_lua/msgpack.rst:47
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:52
#: ../reference/reference_lua/msgpack.rst:49 ../reference_lua/msgpack.rst:49
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:55
#: ../reference/reference_lua/msgpack.rst:52 ../reference_lua/msgpack.rst:52
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:56
#: ../reference/reference_lua/msgpack.rst:53 ../reference_lua/msgpack.rst:53
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:70
#: ../reference/reference_lua/msgpack.rst:67 ../reference_lua/msgpack.rst:67
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:95
#: ../reference/reference_lua/msgpack.rst:90 ../reference_lua/msgpack.rst:90
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:97
#: ../reference/reference_lua/msgpack.rst:92 ../reference_lua/msgpack.rst:92
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:98
#: ../reference/reference_lua/msgpack.rst:93 ../reference_lua/msgpack.rst:93
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:100
#: ../reference/reference_lua/msgpack.rst:95 ../reference_lua/msgpack.rst:95
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes `{'A','B'}` "
"both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:104
#: ../reference/reference_lua/msgpack.rst:99 ../reference_lua/msgpack.rst:99
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' "
"'\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:124
#: ../reference/reference_lua/msgpack.rst:119 ../reference_lua/msgpack.rst:119
msgid "**Result:**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:129
#: ../reference/reference_lua/msgpack.rst:124 ../reference_lua/msgpack.rst:124
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:132
#: ../reference/reference_lua/msgpack.rst:127 ../reference_lua/msgpack.rst:127
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:137
#: ../reference/reference_lua/msgpack.rst:132 ../reference_lua/msgpack.rst:132
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:139
#: ../reference/reference_lua/msgpack.rst:134 ../reference_lua/msgpack.rst:134
msgid "and the second encoding means:"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:144
#: ../reference/reference_lua/msgpack.rst:139 ../reference_lua/msgpack.rst:139
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:146
#: ../reference/reference_lua/msgpack.rst:141 ../reference_lua/msgpack.rst:141
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on the "
"right."
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:154
#: ../reference/reference_lua/msgpack.rst:149 ../reference_lua/msgpack.rst:149
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:160
#: ../reference/reference_lua/msgpack.rst:155 ../reference_lua/msgpack.rst:155
msgid "{}"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:160
#: ../reference/reference_lua/msgpack.rst:155 ../reference_lua/msgpack.rst:155
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:163
#: ../reference/reference_lua/msgpack.rst:158 ../reference_lua/msgpack.rst:158
msgid "'a'"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:163
#: ../reference/reference_lua/msgpack.rst:158 ../reference_lua/msgpack.rst:158
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:165
#: ../reference/reference_lua/msgpack.rst:160 ../reference_lua/msgpack.rst:160
msgid "'false' = c2"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:167
#: ../reference/reference_lua/msgpack.rst:162 ../reference_lua/msgpack.rst:162
msgid "'true' = c3"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:169
#: ../reference/reference_lua/msgpack.rst:164 ../reference_lua/msgpack.rst:164
msgid "127"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:169
#: ../reference/reference_lua/msgpack.rst:164 ../reference_lua/msgpack.rst:164
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:171
#: ../reference/reference_lua/msgpack.rst:166 ../reference_lua/msgpack.rst:166
msgid "65535"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:171
#: ../reference/reference_lua/msgpack.rst:166 ../reference_lua/msgpack.rst:166
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:173
#: ../reference/reference_lua/msgpack.rst:168 ../reference_lua/msgpack.rst:168
msgid "4294967295"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:173
#: ../reference/reference_lua/msgpack.rst:168 ../reference_lua/msgpack.rst:168
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:175
#: ../reference/reference_lua/msgpack.rst:170 ../reference_lua/msgpack.rst:170
msgid "'nil' = c0"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:177
#: ../reference/reference_lua/msgpack.rst:172 ../reference_lua/msgpack.rst:172
msgid "msgpack.NULL"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:177
#: ../reference/reference_lua/msgpack.rst:172 ../reference_lua/msgpack.rst:172
msgid "same as nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:179
#: ../reference/reference_lua/msgpack.rst:174 ../reference_lua/msgpack.rst:174
msgid "[0] = 5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:179
#: ../reference/reference_lua/msgpack.rst:174 ../reference_lua/msgpack.rst:174
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the "
"value) = 81 00 05"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:182
#: ../reference/reference_lua/msgpack.rst:177 ../reference_lua/msgpack.rst:177
msgid "[0] = nil"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:182
#: ../reference/reference_lua/msgpack.rst:177 ../reference_lua/msgpack.rst:177
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:185
#: ../reference/reference_lua/msgpack.rst:180 ../reference_lua/msgpack.rst:180
msgid "1.5"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:185
#: ../reference/reference_lua/msgpack.rst:180 ../reference_lua/msgpack.rst:180
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/reference/reference_lua/msgpack.rst:188
#: ../reference/reference_lua/msgpack.rst:183 ../reference_lua/msgpack.rst:183
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../reference_lua/net_box.rst:30
msgid "Module `net.box`"
msgstr "Модуль `net.box`"

#: ../doc/reference/reference_lua/net_box.rst:35
msgid ""
"The ``net.box`` module contains connectors to remote database systems. One "
"variant, to be discussed later, is connecting to MySQL or MariaDB or "
"PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The other "
"variant, which is discussed in this section, is connecting to Tarantool "
"servers via a network using the built-in ``net.box`` module."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:41
msgid "You can call the following methods:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:43
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for "
"examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:45
msgid ""
"``net_box.new()`` to connect and get a connection object (named ``conn`` for "
"examples in this section),"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:47
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on a "
"remote box,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:49
msgid ":ref:`conn:close <socket-close>` to disconnect."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:51
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and use "
"the same connection object across multiple concurrent fibers. In fact, it's "
"perhaps the best programming practice with Tarantool. When multiple fibers "
"use the same connection, all requests are pipelined through the same network "
"socket, but each fiber gets back a correct response. Reducing the number of "
"active sockets lowers the overhead of system calls and increases the overall "
"server performance. There are, however, cases when a single connection is "
"not enough — for example, when it's necessary to prioritize requests or to "
"use different authentication IDs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:60
msgid ""
"Since Tarantool 1.7.2, support for the Lua console protocol in ``net.box`` "
"was dropped. Now only the binary protocol is supported."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:63
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:73
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a "
"disconnect (see ``reconnect_after`` option below). The returned ``conn`` "
"object supports methods for making remote requests, such as select, update "
"or delete."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:79
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = {net_box}."
"self`. However, there is an important difference between the embedded "
"connection and a remote one. With the embedded connection, requests which do "
"not modify data do not yield. When using a remote connection, due to :ref:"
"`the implicit rules <atomic-the_implicit_yield_rules>` any request can "
"yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:88
msgid "Possible options:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:90
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before returning "
"(e.g. ``wait_connected=1.5`` makes it wait at most 1.5 secs). |br| Note: In "
"the presence of ``reconnect_after``, ``wait_connected`` ignores transient "
"failures. The wait completes once the connection is established or is closed "
"explicitly."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:96
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any time "
"the connection is broken or if a connection attempt fails. This makes "
"transient network failures become transparent to the application. Reconnect "
"happens automatically in the background, so queries/requests that suffered "
"due to connectivity loss are transparently retried. The number of retries is "
"unlimited, connection attempts are done over the specified timeout (e.g. "
"``reconnect_after=5`` for 5 secs). Once a connection is explicitly closed "
"(or garbage-collected), reconnects stop."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:105
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with a "
"new binary protocol command for CALL, which is not backward compatible with "
"previous versions. The new CALL no longer restricts a function to returning "
"an array of tuples and allows returning an arbitrary MsgPack/JSON result, "
"including scalars, nil and void (nothing). The old CALL is left intact for "
"backward compatibility. It will be removed in the next major release. All "
"programming language drivers will be gradually changed to use the new CALL. "
"To connect to a Tarantool instance that uses the old CALL, specify "
"``call_16=true``."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:114
#: ../reference/reference_lua/net_box.rst:72 ../reference_lua/net_box.rst:72
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:115
msgid "possible options are `wait_connected`, `reconnect_after` and `call_16`"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:116
#: ../reference/reference_lua/net_box.rst:74 ../reference_lua/net_box.rst:74
msgid "conn object"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:121
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.new('127.0.0.1:3303', {reconnect_after = 5, call_16 = true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:131
#: ../reference/reference_lua/net_box.rst:88 ../reference_lua/net_box.rst:88
msgid "Execute a PING command."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:133
#: ../reference/reference_lua/net_box.rst:90 ../reference_lua/net_box.rst:90
msgid "true on success, false on error"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:138
#: ../reference/reference_lua/net_box.rst:95 ../reference_lua/net_box.rst:95
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:144
#: ../reference/reference_lua/net_box.rst:101 ../reference_lua/net_box.rst:101
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:146
#: ../doc/reference/reference_lua/net_box.rst:174
msgid "in seconds"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:147
#: ../reference/reference_lua/net_box.rst:104 ../reference_lua/net_box.rst:104
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:152
#: ../reference/reference_lua/net_box.rst:109 ../reference_lua/net_box.rst:109
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:158
#: ../reference/reference_lua/net_box.rst:115 ../reference_lua/net_box.rst:115
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:160
#: ../reference/reference_lua/net_box.rst:117 ../reference_lua/net_box.rst:117
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:165
#: ../reference/reference_lua/net_box.rst:122 ../reference_lua/net_box.rst:122
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:171
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:173
msgid "target states"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:175
msgid ""
"true when a target state is reached, false on timeout or connection closure"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:180
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:193
#: ../reference/reference_lua/net_box.rst:129 ../reference_lua/net_box.rst:129
msgid "Close a connection."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:195
#: ../reference/reference_lua/net_box.rst:131 ../reference_lua/net_box.rst:131
msgid ""
"Connection objects are garbage collected just like any other objects in Lua, "
"so an explicit destruction is not mandatory. However, since close() is a "
"system call, it is good programming practice to close a connection "
"explicitly when it is no longer needed, to avoid lengthy stalls of the "
"garbage collector."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:202
#: ../reference/reference_lua/net_box.rst:138 ../reference_lua/net_box.rst:138
msgid "conn:close()"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:208
#: ../reference/reference_lua/net_box.rst:144 ../reference_lua/net_box.rst:144
msgid ""
":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:select`:code:"
"`{...}`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:213
msgid ""
"Due to :ref:`the implicit yield rules <atomic-the_implicit_yield_rules>` a "
"local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but "
"a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a remote :"
"samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:222
#: ../reference/reference_lua/net_box.rst:158 ../reference_lua/net_box.rst:158
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:227
#: ../reference/reference_lua/net_box.rst:163 ../reference_lua/net_box.rst:163
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:232
#: ../reference/reference_lua/net_box.rst:168 ../reference_lua/net_box.rst:168
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent "
"of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:237
#: ../reference/reference_lua/net_box.rst:173 ../reference_lua/net_box.rst:173
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:242
#: ../reference/reference_lua/net_box.rst:178 ../reference_lua/net_box.rst:178
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:247
#: ../reference/reference_lua/net_box.rst:183 ../reference_lua/net_box.rst:183
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of "
"the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:254
#: ../reference/reference_lua/net_box.rst:190 ../reference_lua/net_box.rst:190
msgid ""
"``conn:call('func', '1', '2', '3')`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure "
"call."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:260
#: ../reference/reference_lua/net_box.rst:196 ../reference_lua/net_box.rst:196
msgid "conn:call('function5')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:268
#: ../reference/reference_lua/net_box.rst:204 ../reference_lua/net_box.rst:204
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-"
"string, which may be any statement or series of statements. An :ref:`execute "
"privilege <authentication-privileges>` is required; if the user does not "
"have it, an administrator may grant it with :samp:`box.schema.user."
"grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:276
#: ../reference/reference_lua/net_box.rst:212 ../reference_lua/net_box.rst:212
msgid "conn:eval('return 5+5')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:282
#: ../reference/reference_lua/net_box.rst:218 ../reference_lua/net_box.rst:218
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:287
#: ../reference/reference_lua/net_box.rst:223 ../reference_lua/net_box.rst:223
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:291
#: ../reference/reference_lua/net_box.rst:227 ../reference_lua/net_box.rst:227
msgid ""
"All remote calls support execution timeouts. Using a wrapper object makes "
"the remote connection API compatible with the local one, removing the need "
"for a separate ``timeout`` argument, which the local version would ignore. "
"Once a request is sent, it cannot be revoked from the remote server even if "
"a timeout expires: the timeout expiration only aborts the wait for the "
"remote server response, not the request itself."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:302
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:304
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:306
msgid "the Tarantool server is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:307
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:309
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:311
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:316
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:322
msgid "And here starts the example:"
msgstr ""

#: ../doc/reference/reference_lua/net_box.rst:324
#: ../reference/reference_lua/net_box.rst:243 ../reference_lua/net_box.rst:243
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-"
"established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} "
"was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../reference_lua/other.rst:28
msgid "Miscellaneous"
msgstr "Разное"

#: ../doc/reference/reference_lua/other.rst:37
#: ../reference/reference_lua/other.rst:34 ../reference_lua/other.rst:34
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The result can be used "
"in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather "
"than floating-point arithmetic. (Operations on an unconverted Lua number use "
"floating-point arithmetic.) The ``tonumber64()`` function is added by "
"Tarantool; the name is global."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:45
#: ../reference/reference_lua/other.rst:42 ../reference_lua/other.rst:42
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:68
#: ../reference/reference_lua/other.rst:65 ../reference_lua/other.rst:65
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly "
"useful to define and run Lua code without having to introduce changes to the "
"global Lua environment."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:72
#: ../reference/reference_lua/other.rst:69 ../reference_lua/other.rst:69
msgid "Lua code"
msgstr ""

#: ../doc/reference/reference_lua/other.rst:73
#: ../reference/reference_lua/other.rst:70 ../reference_lua/other.rst:70
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:76
#: ../reference/reference_lua/other.rst:73 ../reference_lua/other.rst:73
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:78
#: ../reference/reference_lua/other.rst:75 ../reference_lua/other.rst:75
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr ""

#: ../doc/reference/reference_lua/other.rst:82
#: ../reference/reference_lua/other.rst:79 ../reference_lua/other.rst:79
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference_lua/pickle.rst:28
msgid "Module `pickle`"
msgstr "Модуль `pickle`"

#: ../doc/reference/reference_lua/pickle.rst:37
#: ../reference/reference_lua/pickle.rst:34 ../reference_lua/pickle.rst:34
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:43
#: ../reference/reference_lua/pickle.rst:40 ../reference_lua/pickle.rst:40
msgid "**Format specifiers**"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:48
#: ../reference/reference_lua/pickle.rst:45 ../reference_lua/pickle.rst:45
msgid "b, B"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:48
#: ../reference/reference_lua/pickle.rst:45 ../reference_lua/pickle.rst:45
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:51
#: ../reference/reference_lua/pickle.rst:48 ../reference_lua/pickle.rst:48
msgid "s, S"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:51
#: ../reference/reference_lua/pickle.rst:48 ../reference_lua/pickle.rst:48
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:55
#: ../reference/reference_lua/pickle.rst:52 ../reference_lua/pickle.rst:52
msgid "i, I"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:55
#: ../reference/reference_lua/pickle.rst:52 ../reference_lua/pickle.rst:52
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:59
#: ../reference/reference_lua/pickle.rst:56 ../reference_lua/pickle.rst:56
msgid "l, L"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:59
#: ../reference/reference_lua/pickle.rst:56 ../reference_lua/pickle.rst:56
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:63
#: ../reference/reference_lua/pickle.rst:60 ../reference_lua/pickle.rst:60
msgid "n"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:63
#: ../reference/reference_lua/pickle.rst:60 ../reference_lua/pickle.rst:60
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:67
#: ../reference/reference_lua/pickle.rst:64 ../reference_lua/pickle.rst:64
msgid "N"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:67
#: ../reference/reference_lua/pickle.rst:64 ../reference_lua/pickle.rst:64
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:70
#: ../reference/reference_lua/pickle.rst:67 ../reference_lua/pickle.rst:67
msgid "q, Q"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:70
#: ../reference/reference_lua/pickle.rst:67 ../reference_lua/pickle.rst:67
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:74
#: ../reference/reference_lua/pickle.rst:71 ../reference_lua/pickle.rst:71
msgid "f"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:74
#: ../reference/reference_lua/pickle.rst:71 ../reference_lua/pickle.rst:71
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:77
#: ../reference/reference_lua/pickle.rst:74 ../reference_lua/pickle.rst:74
msgid "d"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:77
#: ../reference/reference_lua/pickle.rst:74 ../reference_lua/pickle.rst:74
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the "
"resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:80
#: ../reference/reference_lua/pickle.rst:77 ../reference_lua/pickle.rst:77
msgid "a, A"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:80
#: ../reference/reference_lua/pickle.rst:77 ../reference_lua/pickle.rst:77
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in the "
"resulting string"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:84
#: ../reference/reference_lua/pickle.rst:81 ../reference_lua/pickle.rst:81
msgid "string containing format specifiers"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:85
#: ../reference/reference_lua/pickle.rst:82 ../reference_lua/pickle.rst:82
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:86
#: ../reference/reference_lua/pickle.rst:83 ../reference_lua/pickle.rst:83
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:90
#: ../reference/reference_lua/pickle.rst:87 ../reference_lua/pickle.rst:87
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:94
#: ../reference/reference_lua/pickle.rst:91 ../reference_lua/pickle.rst:91
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:128
#: ../reference/reference_lua/pickle.rst:125 ../reference_lua/pickle.rst:125
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, "
"it must be the last item."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:134
#: ../reference/reference_lua/pickle.rst:131 ../reference_lua/pickle.rst:131
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/reference/reference_lua/pickle.rst:139
#: ../reference/reference_lua/pickle.rst:136 ../reference_lua/pickle.rst:136
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/socket.rst:30
msgid "Module `socket`"
msgstr "Модуль `socket`"

#: ../doc/reference/reference_lua/socket.rst:35
#: ../reference/reference_lua/socket.rst:32 ../reference_lua/socket.rst:32
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local or "
"remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. "
"Semantics of the calls in the ``socket`` API closely follow semantics of the "
"corresponding POSIX calls. Function names and signatures are mostly "
"compatible with `luasocket`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:41
#: ../reference/reference_lua/socket.rst:38 ../reference_lua/socket.rst:38
msgid ""
"The functions for setting up and connecting are ``socket``, ``sysconnect``, "
"``tcp_connect``. The functions for sending data are ``send``, ``sendto``, "
"``write``, ``syswrite``. The functions for receiving data are ``recv``, "
"``recvfrom``, ``read``. The functions for waiting before sending/receiving "
"data are ``wait``, ``readable``, ``writable``. The functions for setting "
"flags are ``nonblock``, ``setsockopt``. The functions for stopping and "
"disconnecting are ``shutdown``, ``close``. The functions for error checking "
"are ``errno``, ``error``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:52
#: ../reference/reference_lua/socket.rst:49 ../reference_lua/socket.rst:49
msgid "**Socket functions**"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
#: ../reference/reference_lua/socket.rst:54 ../reference_lua/socket.rst:54
msgid "Purposes"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:57
#: ../reference/reference_lua/socket.rst:54 ../reference_lua/socket.rst:54
msgid "Names"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:59
#: ../reference/reference_lua/socket.rst:56 ../reference_lua/socket.rst:56
msgid "setup"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:59
#: ../reference/reference_lua/socket.rst:56 ../reference_lua/socket.rst:56
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:61
#: ../doc/reference/reference_lua/socket.rst:63
#: ../doc/reference/reference_lua/socket.rst:65
#: ../doc/reference/reference_lua/socket.rst:67
#: ../doc/reference/reference_lua/socket.rst:71
#: ../doc/reference/reference_lua/socket.rst:73
#: ../doc/reference/reference_lua/socket.rst:77
#: ../doc/reference/reference_lua/socket.rst:79
#: ../doc/reference/reference_lua/socket.rst:83
#: ../doc/reference/reference_lua/socket.rst:85
#: ../doc/reference/reference_lua/socket.rst:89
#: ../doc/reference/reference_lua/socket.rst:93
#: ../doc/reference/reference_lua/socket.rst:97
#: ../doc/reference/reference_lua/socket.rst:101
#: ../doc/reference/reference_lua/socket.rst:103
#: ../doc/reference/reference_lua/socket.rst:105
#: ../doc/reference/reference_lua/socket.rst:109
#: ../doc/reference/reference_lua/socket.rst:111
#: ../doc/reference/reference_lua/socket.rst:113
#: ../reference/reference_lua/socket.rst:58
#: ../reference/reference_lua/socket.rst:60
#: ../reference/reference_lua/socket.rst:62
#: ../reference/reference_lua/socket.rst:64
#: ../reference/reference_lua/socket.rst:68
#: ../reference/reference_lua/socket.rst:70
#: ../reference/reference_lua/socket.rst:74
#: ../reference/reference_lua/socket.rst:76
#: ../reference/reference_lua/socket.rst:80
#: ../reference/reference_lua/socket.rst:82
#: ../reference/reference_lua/socket.rst:86
#: ../reference/reference_lua/socket.rst:90
#: ../reference/reference_lua/socket.rst:94
#: ../reference/reference_lua/socket.rst:98
#: ../reference/reference_lua/socket.rst:100
#: ../reference/reference_lua/socket.rst:102
#: ../reference/reference_lua/socket.rst:106
#: ../reference/reference_lua/socket.rst:108 ../reference_lua/socket.rst:58
#: ../reference_lua/socket.rst:60 ../reference_lua/socket.rst:62
#: ../reference_lua/socket.rst:64 ../reference_lua/socket.rst:68
#: ../reference_lua/socket.rst:70 ../reference_lua/socket.rst:74
#: ../reference_lua/socket.rst:76 ../reference_lua/socket.rst:80
#: ../reference_lua/socket.rst:82 ../reference_lua/socket.rst:86
#: ../reference_lua/socket.rst:90 ../reference_lua/socket.rst:94
#: ../reference_lua/socket.rst:98 ../reference_lua/socket.rst:100
#: ../reference_lua/socket.rst:102 ../reference_lua/socket.rst:106
#: ../reference_lua/socket.rst:108
msgid "\"\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:61
#: ../reference/reference_lua/socket.rst:58 ../reference_lua/socket.rst:58
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:63
#: ../reference/reference_lua/socket.rst:60 ../reference_lua/socket.rst:60
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:65
#: ../reference/reference_lua/socket.rst:62 ../reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:67
#: ../reference/reference_lua/socket.rst:64 ../reference_lua/socket.rst:64
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:69
#: ../reference/reference_lua/socket.rst:66 ../reference_lua/socket.rst:66
msgid "sending"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:69
#: ../reference/reference_lua/socket.rst:66 ../reference_lua/socket.rst:66
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:71
#: ../reference/reference_lua/socket.rst:68 ../reference_lua/socket.rst:68
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:73
#: ../reference/reference_lua/socket.rst:70 ../reference_lua/socket.rst:70
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:75
#: ../reference/reference_lua/socket.rst:72 ../reference_lua/socket.rst:72
msgid "receiving"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:75
#: ../reference/reference_lua/socket.rst:72 ../reference_lua/socket.rst:72
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:77
#: ../reference/reference_lua/socket.rst:74 ../reference_lua/socket.rst:74
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:79
#: ../reference/reference_lua/socket.rst:76 ../reference_lua/socket.rst:76
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:81
#: ../reference/reference_lua/socket.rst:78 ../reference_lua/socket.rst:78
msgid "flag setting"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:81
#: ../reference/reference_lua/socket.rst:78 ../reference_lua/socket.rst:78
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:83
#: ../reference/reference_lua/socket.rst:80 ../reference_lua/socket.rst:80
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:85
#: ../reference/reference_lua/socket.rst:82 ../reference_lua/socket.rst:82
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:87
#: ../reference/reference_lua/socket.rst:84 ../reference_lua/socket.rst:84
msgid "client/server"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:87
#: ../reference/reference_lua/socket.rst:84 ../reference_lua/socket.rst:84
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:89
#: ../reference/reference_lua/socket.rst:86 ../reference_lua/socket.rst:86
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:91
#: ../reference/reference_lua/socket.rst:88 ../reference_lua/socket.rst:88
msgid "teardown"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:91
#: ../reference/reference_lua/socket.rst:88 ../reference_lua/socket.rst:88
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:93
#: ../reference/reference_lua/socket.rst:90 ../reference_lua/socket.rst:90
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:95
#: ../reference/reference_lua/socket.rst:92 ../reference_lua/socket.rst:92
msgid "error checking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:95
#: ../reference/reference_lua/socket.rst:92 ../reference_lua/socket.rst:92
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:97
#: ../reference/reference_lua/socket.rst:94 ../reference_lua/socket.rst:94
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
#: ../reference/reference_lua/socket.rst:96 ../reference_lua/socket.rst:96
msgid "information"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:99
#: ../reference/reference_lua/socket.rst:96 ../reference_lua/socket.rst:96
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:101
#: ../reference/reference_lua/socket.rst:98 ../reference_lua/socket.rst:98
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:103
#: ../reference/reference_lua/socket.rst:100 ../reference_lua/socket.rst:100
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:105
#: ../reference/reference_lua/socket.rst:102 ../reference_lua/socket.rst:102
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:107
#: ../reference/reference_lua/socket.rst:104 ../reference_lua/socket.rst:104
msgid "state checking"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:107
#: ../reference/reference_lua/socket.rst:104 ../reference_lua/socket.rst:104
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:109
#: ../reference/reference_lua/socket.rst:106 ../reference_lua/socket.rst:106
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:111
#: ../reference/reference_lua/socket.rst:108 ../reference_lua/socket.rst:108
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:113
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:117
#: ../reference/reference_lua/socket.rst:111 ../reference_lua/socket.rst:111
msgid ""
"Typically a socket session will begin with the setup functions, will set one "
"or more flags, will have a loop with sending and receiving functions, will "
"end with the teardown functions -- as an example at the end of this section "
"will show. Throughout, there may be error-checking and waiting functions for "
"synchronization. To prevent a fiber containing socket functions from "
"\"blocking\" other fibers, the :ref:`implicit yield rules <atomic-"
"the_implicit_yield_rules>` will cause a yield so that other processes may "
"take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:126
#: ../reference/reference_lua/socket.rst:120 ../reference_lua/socket.rst:120
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:135
#: ../reference/reference_lua/socket.rst:129 ../reference_lua/socket.rst:129
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in the "
"`Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2."
"html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:138
#: ../reference/reference_lua/socket.rst:132 ../reference_lua/socket.rst:132
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:143
#: ../reference/reference_lua/socket.rst:137 ../reference_lua/socket.rst:137
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:151
#: ../reference/reference_lua/socket.rst:145 ../reference_lua/socket.rst:145
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:153
#: ../reference/reference_lua/socket.rst:147 ../reference_lua/socket.rst:147
msgid "URL or IP address"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:154
#: ../reference/reference_lua/socket.rst:148 ../reference_lua/socket.rst:148
msgid "port number"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:155
#: ../reference/reference_lua/socket.rst:149
msgid "timeout"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:156
#: ../reference/reference_lua/socket.rst:150 ../reference_lua/socket.rst:149
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:161
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:169
#: ../reference/reference_lua/socket.rst:163 ../reference_lua/socket.rst:162
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for ``sock:sysconnect()`` "
"can be passed."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:173
#: ../doc/reference/reference_lua/socket.rst:545
#: ../doc/reference/reference_lua/socket.rst:557
#: ../reference/reference_lua/socket.rst:167
#: ../reference/reference_lua/socket.rst:522
#: ../reference/reference_lua/socket.rst:534 ../reference_lua/socket.rst:166
#: ../reference_lua/socket.rst:521 ../reference_lua/socket.rst:533
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", \"protocol"
"\", \"port\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:178
#: ../reference/reference_lua/socket.rst:172 ../reference_lua/socket.rst:171
msgid ""
"``socket.getaddrinfo('tarantool.org', 'http')`` will return variable "
"information such as"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:181
#: ../reference/reference_lua/socket.rst:175 ../reference_lua/socket.rst:174
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:200
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that "
"can accept connections. Usually the same objective is accomplished with :ref:"
"`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:204
msgid ""
"Parameters: ``host`` = (string) host name or IP; ``port`` = (integer) host "
"port, may be 0; ``handler-function`` = (function or table containing "
"function) what to execute when a connection occurs; ``timeout`` = (integer) "
"number of seconds to wait before timing out."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:210
msgid ""
"The handler-function parameter may be a function name (for example "
"``function_55``) a function declaration (for example ``function () "
"print('!') end``), or a table including handler = function (for example "
"``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:216
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:224
#: ../reference/reference_lua/socket.rst:210 ../reference_lua/socket.rst:209
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:231
#: ../reference/reference_lua/socket.rst:217 ../reference_lua/socket.rst:216
msgid "Either:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:230
#: ../reference/reference_lua/socket.rst:216 ../reference_lua/socket.rst:215
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:232
#: ../reference/reference_lua/socket.rst:218 ../reference_lua/socket.rst:217
msgid "port - a number."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:234
#: ../doc/reference/reference_lua/socket.rst:241
#: ../reference/reference_lua/socket.rst:220
#: ../reference/reference_lua/socket.rst:227 ../reference_lua/socket.rst:219
#: ../reference_lua/socket.rst:226
msgid "Or:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:234
#: ../reference/reference_lua/socket.rst:220 ../reference_lua/socket.rst:219
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:235
#: ../reference/reference_lua/socket.rst:221 ../reference_lua/socket.rst:220
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:237
#: ../reference/reference_lua/socket.rst:223 ../reference_lua/socket.rst:222
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:239
#: ../reference/reference_lua/socket.rst:225 ../reference_lua/socket.rst:224
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound to a "
"random local port."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:243
#: ../reference/reference_lua/socket.rst:229 ../reference_lua/socket.rst:228
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:248
#: ../reference/reference_lua/socket.rst:234 ../reference_lua/socket.rst:233
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:259
#: ../reference/reference_lua/socket.rst:245 ../reference_lua/socket.rst:244
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:262
#: ../doc/reference/reference_lua/socket.rst:385
#: ../reference/reference_lua/socket.rst:248
#: ../reference/reference_lua/socket.rst:362 ../reference_lua/socket.rst:247
#: ../reference_lua/socket.rst:361
msgid "the number of bytes sent."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:265
#: ../reference/reference_lua/socket.rst:251 ../reference_lua/socket.rst:250
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:271
#: ../reference/reference_lua/socket.rst:257 ../reference_lua/socket.rst:256
msgid ""
"Write as much as possible data to the socket buffer if non-blocking. Rarely "
"used. For details see `this description`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:278
#: ../reference/reference_lua/socket.rst:264 ../reference_lua/socket.rst:263
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead buffer "
"is used to reduce the cost of this call."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:282
#: ../reference/reference_lua/socket.rst:268 ../reference_lua/socket.rst:267
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:285
#: ../reference/reference_lua/socket.rst:271 ../reference_lua/socket.rst:270
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by \"eof"
"\" status."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:298
#: ../reference/reference_lua/socket.rst:284 ../reference_lua/socket.rst:283
msgid ""
"Read from a connected socket until some condition is true, and return the "
"bytes that were read. Reading goes on until ``limit`` bytes have been read, "
"or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:303
#: ../doc/reference/reference_lua/socket.rst:325
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:305
#: ../reference/reference_lua/socket.rst:291 ../reference_lua/socket.rst:290
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:307
#: ../reference/reference_lua/socket.rst:293 ../reference_lua/socket.rst:292
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:310
#: ../reference/reference_lua/socket.rst:296 ../reference_lua/socket.rst:295
msgid ""
"an empty string if there is nothing more to read, or a nil value if error, "
"or a string up to ``limit`` bytes long, which may include the bytes that "
"matched the ``delimiter`` expression."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:320
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is "
"blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description <https://github.com/tarantool/tarantool/"
"wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:328
msgid ""
"an empty string if there is nothing more to read, or a nil value if error, "
"or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:336
#: ../reference/reference_lua/socket.rst:313 ../reference_lua/socket.rst:312
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be used "
"to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP "
"socket can be used to accept new connections, after it has been put in "
"listen mode."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:344
#: ../reference/reference_lua/socket.rst:321 ../reference_lua/socket.rst:320
msgid "a socket object on success"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:347
#: ../reference/reference_lua/socket.rst:324 ../reference_lua/socket.rst:323
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:353
#: ../reference/reference_lua/socket.rst:330 ../reference_lua/socket.rst:329
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:355
#: ../reference/reference_lua/socket.rst:332 ../reference_lua/socket.rst:331
msgid ""
"On Linux the listen ``backlog`` backlog may be from /proc/sys/net/core/"
"somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:359
#: ../reference/reference_lua/socket.rst:336 ../reference_lua/socket.rst:335
msgid "true for success, false for error."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:360
#: ../reference/reference_lua/socket.rst:337 ../reference_lua/socket.rst:336
msgid "boolean."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:366
#: ../reference/reference_lua/socket.rst:343 ../reference_lua/socket.rst:342
msgid ""
"Accept a new client connection and create a new connected socket. It is good "
"practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:370
#: ../reference/reference_lua/socket.rst:347 ../reference_lua/socket.rst:346
msgid "new socket if success."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:379
#: ../reference/reference_lua/socket.rst:356 ../reference_lua/socket.rst:355
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:388
#: ../doc/reference/reference_lua/socket.rst:400
#: ../reference/reference_lua/socket.rst:365
#: ../reference/reference_lua/socket.rst:377 ../reference_lua/socket.rst:364
#: ../reference_lua/socket.rst:376
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:394
#: ../reference/reference_lua/socket.rst:371 ../reference_lua/socket.rst:370
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:397
#: ../reference/reference_lua/socket.rst:374 ../reference_lua/socket.rst:373
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:398
#: ../reference/reference_lua/socket.rst:375 ../reference_lua/socket.rst:374
msgid "string, table"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:404
#: ../reference/reference_lua/socket.rst:381 ../reference_lua/socket.rst:380
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:408
#: ../reference/reference_lua/socket.rst:385 ../reference_lua/socket.rst:384
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:418
#: ../reference/reference_lua/socket.rst:395 ../reference_lua/socket.rst:394
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:420
#: ../reference/reference_lua/socket.rst:397 ../reference_lua/socket.rst:396
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:422
#: ../doc/reference/reference_lua/tap.rst:93
#: ../doc/reference/reference_lua/tap.rst:125
#: ../doc/reference/reference_lua/tap.rst:156
#: ../doc/reference/reference_lua/tap.rst:167
#: ../doc/reference/reference_lua/tap.rst:184
#: ../doc/reference/reference_lua/tap.rst:192
#: ../reference/reference_lua/socket.rst:399
#: ../reference/reference_lua/tap.rst:90 ../reference/reference_lua/tap.rst:122
#: ../reference/reference_lua/tap.rst:153
#: ../reference/reference_lua/tap.rst:164
#: ../reference/reference_lua/tap.rst:181
#: ../reference/reference_lua/tap.rst:189 ../reference_lua/socket.rst:398
#: ../reference_lua/tap.rst:90 ../reference_lua/tap.rst:122
#: ../reference_lua/tap.rst:153 ../reference_lua/tap.rst:164
#: ../reference_lua/tap.rst:181 ../reference_lua/tap.rst:189
msgid "true or false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:429
#: ../reference/reference_lua/socket.rst:406 ../reference_lua/socket.rst:405
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when its userdata is garbage collected by Lua."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:432
#: ../reference/reference_lua/socket.rst:409 ../reference_lua/socket.rst:408
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:441
#: ../reference/reference_lua/socket.rst:418 ../reference_lua/socket.rst:417
msgid ""
"Retrieve information about the last error that occurred on a socket, if any. "
"Errors do not cause throwing of exceptions so these functions are usually "
"necessary."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:444
#: ../reference/reference_lua/socket.rst:421 ../reference_lua/socket.rst:420
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:446
#: ../reference/reference_lua/socket.rst:423 ../reference_lua/socket.rst:422
msgid "number, string"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:452
#: ../reference/reference_lua/socket.rst:429 ../reference_lua/socket.rst:428
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2."
"html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:456
#: ../reference/reference_lua/socket.rst:433 ../reference_lua/socket.rst:432
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:457
#: ../reference/reference_lua/socket.rst:434 ../reference_lua/socket.rst:433
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:458
#: ../reference/reference_lua/socket.rst:435 ../reference_lua/socket.rst:434
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:459
#: ../reference/reference_lua/socket.rst:436 ../reference_lua/socket.rst:435
msgid "SO_DEBUG"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:460
#: ../reference/reference_lua/socket.rst:437 ../reference_lua/socket.rst:436
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:461
#: ../reference/reference_lua/socket.rst:438 ../reference_lua/socket.rst:437
msgid "SO_ERROR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:462
#: ../reference/reference_lua/socket.rst:439 ../reference_lua/socket.rst:438
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:463
#: ../reference/reference_lua/socket.rst:440 ../reference_lua/socket.rst:439
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:464
#: ../reference/reference_lua/socket.rst:441 ../reference_lua/socket.rst:440
msgid "SO_MARK"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:465
#: ../reference/reference_lua/socket.rst:442 ../reference_lua/socket.rst:441
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:466
#: ../reference/reference_lua/socket.rst:443 ../reference_lua/socket.rst:442
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:467
#: ../reference/reference_lua/socket.rst:444 ../reference_lua/socket.rst:443
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:468
#: ../reference/reference_lua/socket.rst:445 ../reference_lua/socket.rst:444
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:469
#: ../reference/reference_lua/socket.rst:446 ../reference_lua/socket.rst:445
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:470
#: ../reference/reference_lua/socket.rst:447 ../reference_lua/socket.rst:446
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:471
#: ../reference/reference_lua/socket.rst:448 ../reference_lua/socket.rst:447
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:472
#: ../reference/reference_lua/socket.rst:449 ../reference_lua/socket.rst:448
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:473
#: ../reference/reference_lua/socket.rst:450 ../reference_lua/socket.rst:449
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:474
#: ../reference/reference_lua/socket.rst:451 ../reference_lua/socket.rst:450
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:475
#: ../reference/reference_lua/socket.rst:452 ../reference_lua/socket.rst:451
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:476
#: ../reference/reference_lua/socket.rst:453 ../reference_lua/socket.rst:452
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:477
#: ../reference/reference_lua/socket.rst:454 ../reference_lua/socket.rst:453
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:478
#: ../reference/reference_lua/socket.rst:455 ../reference_lua/socket.rst:454
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:479
#: ../reference/reference_lua/socket.rst:456 ../reference_lua/socket.rst:455
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:480
#: ../reference/reference_lua/socket.rst:457 ../reference_lua/socket.rst:456
msgid "SO_TYPE"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:482
#: ../reference/reference_lua/socket.rst:459 ../reference_lua/socket.rst:458
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:488
#: ../reference/reference_lua/socket.rst:465 ../reference_lua/socket.rst:464
msgid ""
"Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:494
#: ../reference/reference_lua/socket.rst:471 ../reference_lua/socket.rst:470
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:499
#: ../reference/reference_lua/socket.rst:476 ../reference_lua/socket.rst:475
msgid "new active and timeout values."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:505
#: ../reference/reference_lua/socket.rst:482 ../reference_lua/socket.rst:481
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:506
#: ../reference/reference_lua/socket.rst:483 ../reference_lua/socket.rst:482
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:507
#: ../reference/reference_lua/socket.rst:484 ../reference_lua/socket.rst:483
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:509
#: ../reference/reference_lua/socket.rst:486 ../reference_lua/socket.rst:485
msgid ""
"This function may be useful before invoking a function which might otherwise "
"block indefinitely."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:516
#: ../reference/reference_lua/socket.rst:493 ../reference_lua/socket.rst:492
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:518
#: ../reference/reference_lua/socket.rst:495 ../reference_lua/socket.rst:494
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:524
#: ../reference/reference_lua/socket.rst:501 ../reference_lua/socket.rst:500
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:526
#: ../reference/reference_lua/socket.rst:503 ../reference_lua/socket.rst:502
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:532
#: ../reference/reference_lua/socket.rst:509 ../reference_lua/socket.rst:508
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:534
#: ../reference/reference_lua/socket.rst:511 ../reference_lua/socket.rst:510
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' "
"if the socket is now both readable and writable, '' (empty string) if "
"timeout expired;"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:540
#: ../reference/reference_lua/socket.rst:517 ../reference_lua/socket.rst:516
msgid ""
"The ``sock:name()`` function is used to get information about the near side "
"of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:"
"name`` will return information about ``[host:xyz.com, port:45]``. The "
"equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:552
#: ../reference/reference_lua/socket.rst:529 ../reference_lua/socket.rst:528
msgid ""
"The ``sock:peer()`` function is used to get information about the far side "
"of a connection. If a TCP connection has been made to a distant host "
"``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:"
"tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:564
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:567
msgid "file descriptor"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:568
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:569
msgid "number of seconds to wait"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:571
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout. If "
"the timeout parameter is nil or unspecified, then timeout is infinite."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:574
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading or "
"writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:578
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:586
#: ../reference/reference_lua/socket.rst:545 ../reference_lua/socket.rst:544
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:588
msgid ""
"In this example a connection is made over the internet between the Tarantool "
"server and tarantool.org, then an HTTP \"head\" message is sent, and a "
"response is received: \"``HTTP/1.1 200 OK``\" or something else if the site "
"has moved. This is not a useful way to communicate with this particular "
"site, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:594
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: tarantool.org\\r\\n\\r\\n"
"\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:625
#: ../reference/reference_lua/socket.rst:583 ../reference_lua/socket.rst:582
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:627
#: ../reference/reference_lua/socket.rst:585 ../reference_lua/socket.rst:584
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to "
"``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:633
#: ../reference/reference_lua/socket.rst:591 ../reference_lua/socket.rst:590
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:670
#: ../reference/reference_lua/socket.rst:628 ../reference_lua/socket.rst:627
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:672
#: ../reference/reference_lua/socket.rst:630 ../reference_lua/socket.rst:629
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility will "
"be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:677
#: ../reference/reference_lua/socket.rst:635 ../reference_lua/socket.rst:634
msgid ""
"Start two shells. The first shell will be the server. The second shell will "
"be the client."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:680
#: ../reference/reference_lua/socket.rst:638 ../reference_lua/socket.rst:637
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:682
#: ../reference/reference_lua/socket.rst:640 ../reference_lua/socket.rst:639
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:697
#: ../reference/reference_lua/socket.rst:655 ../reference_lua/socket.rst:654
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from any "
"host on port 3302. When it happens, enter a loop that reads on the socket "
"and prints what it reads. The \"delimiter\" for the read function is \"\\\\n"
"\" so each `read()` will read a string as far as the next line feed, "
"including the line feed."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:704
#: ../reference/reference_lua/socket.rst:662 ../reference_lua/socket.rst:661
msgid ""
"On the second shell, create a file that contains a few lines. The contents "
"don't matter. Suppose the first line contains A, the second line contains B, "
"the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:709
#: ../reference/reference_lua/socket.rst:667 ../reference_lua/socket.rst:666
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to the "
"server's host and port:"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:712
#: ../reference/reference_lua/socket.rst:670 ../reference_lua/socket.rst:669
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/reference/reference_lua/socket.rst:716
#: ../reference/reference_lua/socket.rst:674 ../reference_lua/socket.rst:673
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" "
"are printed."
msgstr ""

#: ../reference_lua/strict.rst:28
msgid "Module `strict`"
msgstr "Модуль `strict`"

#: ../doc/reference/reference_lua/strict.rst:35
#: ../reference/reference_lua/strict.rst:32 ../reference_lua/strict.rst:32
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or "
"off. When strict mode is on, an attempt to use an undeclared global variable "
"will cause an error. A global variable is considered \"undeclared\" if it "
"has never had a value assigned to it. Often this is an indication of a "
"programming error."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:40
#: ../reference/reference_lua/strict.rst:37 ../reference_lua/strict.rst:37
msgid ""
"By default strict mode is off, unless tarantool was built with the ``-"
"DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in "
"section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/reference/reference_lua/strict.rst:46
#: ../reference/reference_lua/strict.rst:43 ../reference_lua/strict.rst:43
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:31
#: ../reference/reference_lua/tap.rst:28 ../reference_lua/tap.rst:28
msgid "Module `tap`"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:33
#: ../reference/reference_lua/tap.rst:30 ../reference_lua/tap.rst:30
msgid ""
"The tap module streamlines the testing of other modules. It allows writing "
"of tests in the `TAP protocol`_. The results from the tests can be parsed by "
"standard TAP-analyzers so they can be passed to utilities such as `prove`_. "
"Thus one can run tests and then use the results for statistics, decision-"
"making, and so on."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:42
#: ../reference/reference_lua/tap.rst:39 ../reference_lua/tap.rst:39
msgid "Initialize."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:44
#: ../reference/reference_lua/tap.rst:41 ../reference_lua/tap.rst:41
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in the "
"rest of this discussion, which is necessary for ``taptest:plan()`` and all "
"the other methods."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:48
#: ../reference/reference_lua/tap.rst:45 ../reference_lua/tap.rst:45
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:49
#: ../reference/reference_lua/tap.rst:46 ../reference_lua/tap.rst:46
msgid "taptest"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:52
#: ../reference/reference_lua/tap.rst:49 ../reference_lua/tap.rst:49
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:61
#: ../reference/reference_lua/tap.rst:58 ../reference_lua/tap.rst:58
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:68
#: ../reference/reference_lua/tap.rst:65 ../reference_lua/tap.rst:65
msgid ""
"Checks the number of tests performed. This check should only be done after "
"all planned tests are complete, so ordinarily ``taptest:check()`` will only "
"appear at the end of a script."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:72
#: ../reference/reference_lua/tap.rst:69 ../reference_lua/tap.rst:69
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not "
"equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:79
#: ../reference/reference_lua/tap.rst:76 ../reference_lua/tap.rst:76
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:81
#: ../reference/reference_lua/tap.rst:78 ../reference_lua/tap.rst:78
msgid "the message to be displayed."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:86
#: ../reference/reference_lua/tap.rst:83 ../reference_lua/tap.rst:83
msgid ""
"This is a basic function which is used by other functions. Depending on the "
"value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:90
#: ../reference/reference_lua/tap.rst:87 ../reference_lua/tap.rst:87
msgid "an expression which is true or false"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:91
#: ../doc/reference/reference_lua/tap.rst:123
#: ../doc/reference/reference_lua/tap.rst:134
#: ../doc/reference/reference_lua/tap.rst:155
#: ../doc/reference/reference_lua/tap.rst:165
#: ../doc/reference/reference_lua/tap.rst:182
#: ../doc/reference/reference_lua/tap.rst:197
#: ../reference/reference_lua/tap.rst:88 ../reference/reference_lua/tap.rst:120
#: ../reference/reference_lua/tap.rst:131
#: ../reference/reference_lua/tap.rst:152
#: ../reference/reference_lua/tap.rst:162
#: ../reference/reference_lua/tap.rst:179
#: ../reference/reference_lua/tap.rst:194 ../reference_lua/tap.rst:88
#: ../reference_lua/tap.rst:120 ../reference_lua/tap.rst:131
#: ../reference_lua/tap.rst:152 ../reference_lua/tap.rst:162
#: ../reference_lua/tap.rst:179 ../reference_lua/tap.rst:194
msgid "name of test"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:98
#: ../reference/reference_lua/tap.rst:95 ../reference_lua/tap.rst:95
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:120
#: ../reference/reference_lua/tap.rst:117 ../reference_lua/tap.rst:117
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays "
"the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:130
#: ../reference/reference_lua/tap.rst:127 ../reference_lua/tap.rst:127
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:140
#: ../reference/reference_lua/tap.rst:137 ../reference_lua/tap.rst:137
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:150
#: ../reference/reference_lua/tap.rst:147 ../reference_lua/tap.rst:147
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:153
#: ../doc/reference/reference_lua/tap.rst:163
#: ../doc/reference/reference_lua/tap.rst:195
#: ../reference/reference_lua/tap.rst:150
#: ../reference/reference_lua/tap.rst:160
#: ../reference/reference_lua/tap.rst:192 ../reference_lua/tap.rst:150
#: ../reference_lua/tap.rst:160 ../reference_lua/tap.rst:192
msgid "actual result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:154
#: ../doc/reference/reference_lua/tap.rst:164
#: ../doc/reference/reference_lua/tap.rst:196
#: ../reference/reference_lua/tap.rst:151
#: ../reference/reference_lua/tap.rst:161
#: ../reference/reference_lua/tap.rst:193 ../reference_lua/tap.rst:151
#: ../reference_lua/tap.rst:161 ../reference_lua/tap.rst:193
msgid "expected result"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:161
#: ../reference/reference_lua/tap.rst:158 ../reference_lua/tap.rst:158
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:178
#: ../reference/reference_lua/tap.rst:175 ../reference_lua/tap.rst:175
msgid ""
"Test whether a value has a particular type. Displays a long message if the "
"value is not of the specified type."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:189
#: ../reference/reference_lua/tap.rst:186 ../reference_lua/tap.rst:186
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare "
"tables as well as scalar values."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:207
#: ../reference/reference_lua/tap.rst:204 ../reference_lua/tap.rst:204
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make tap."
"lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:211
#: ../reference/reference_lua/tap.rst:208 ../reference_lua/tap.rst:208
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:225
#: ../reference/reference_lua/tap.rst:222 ../reference_lua/tap.rst:222
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/reference/reference_lua/tap.rst:227
#: ../reference/reference_lua/tap.rst:224 ../reference_lua/tap.rst:224
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../reference_lua/tarantool.rst:28
msgid "Module `tarantool`"
msgstr "Модуль `tarantool`"

#: ../doc/reference/reference_lua/tarantool.rst:35
#: ../reference/reference_lua/tarantool.rst:32
#: ../reference_lua/tarantool.rst:32
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about how "
"the tarantool server was built, such as \"what flags were used\", or \"what "
"was the version of the compiler\"."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:41
msgid ""
"Additionally one can see the uptime and the server version and the process "
"id. Those information items can also be accessed with :ref:`box.info() "
"<box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../doc/reference/reference_lua/tarantool.rst:47
#: ../reference/reference_lua/tarantool.rst:44
#: ../reference_lua/tarantool.rst:44
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -"
"fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:31
#: ../reference/reference_lua/uuid.rst:28 ../reference_lua/uuid.rst:28
msgid "Module `uuid`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:33
#: ../reference/reference_lua/uuid.rst:30 ../reference_lua/uuid.rst:30
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application requires "
"that a value be unique only within a single computer or on a single "
"database, then a simple counter is better than a UUID, because getting a "
"UUID is time-consuming (it requires a syscall_). For clusters of computers, "
"or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:39
#: ../reference/reference_lua/uuid.rst:36 ../reference_lua/uuid.rst:36
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:41
#: ../reference/reference_lua/uuid.rst:38 ../reference_lua/uuid.rst:38
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:42
#: ../reference/reference_lua/uuid.rst:39 ../reference_lua/uuid.rst:39
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:43
#: ../reference/reference_lua/uuid.rst:40 ../reference_lua/uuid.rst:40
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:45
#: ../reference/reference_lua/uuid.rst:42 ../reference_lua/uuid.rst:42
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:47
#: ../reference/reference_lua/uuid.rst:44 ../reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:48
#: ../reference/reference_lua/uuid.rst:45 ../reference_lua/uuid.rst:45
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:49
#: ../reference/reference_lua/uuid.rst:46 ../reference_lua/uuid.rst:46
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:50
#: ../reference/reference_lua/uuid.rst:47 ../reference_lua/uuid.rst:47
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:52
#: ../reference/reference_lua/uuid.rst:49 ../reference_lua/uuid.rst:49
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:54
#: ../reference/reference_lua/uuid.rst:51 ../reference_lua/uuid.rst:51
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:60
#: ../reference/reference_lua/uuid.rst:57 ../reference_lua/uuid.rst:57
msgid "A nil object"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:66
#: ../doc/reference/reference_lua/uuid.rst:73
#: ../doc/reference/reference_lua/uuid.rst:80
#: ../reference/reference_lua/uuid.rst:63
#: ../reference/reference_lua/uuid.rst:70
#: ../reference/reference_lua/uuid.rst:77 ../reference_lua/uuid.rst:63
#: ../reference_lua/uuid.rst:70 ../reference_lua/uuid.rst:77
msgid "a UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:67
#: ../doc/reference/reference_lua/uuid.rst:89
#: ../doc/reference/reference_lua/uuid.rst:97
#: ../reference/reference_lua/uuid.rst:64
#: ../reference/reference_lua/uuid.rst:86
#: ../reference/reference_lua/uuid.rst:94 ../reference_lua/uuid.rst:64
#: ../reference_lua/uuid.rst:86 ../reference_lua/uuid.rst:94
msgid "cdata"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:74
#: ../reference/reference_lua/uuid.rst:71 ../reference_lua/uuid.rst:71
msgid "16-byte string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:81
#: ../reference/reference_lua/uuid.rst:78 ../reference_lua/uuid.rst:78
msgid "36-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:87
#: ../reference/reference_lua/uuid.rst:84 ../reference_lua/uuid.rst:84
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:88
#: ../doc/reference/reference_lua/uuid.rst:96
#: ../reference/reference_lua/uuid.rst:85
#: ../reference/reference_lua/uuid.rst:93 ../reference_lua/uuid.rst:85
#: ../reference_lua/uuid.rst:93
msgid "converted UUID"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:95
#: ../reference/reference_lua/uuid.rst:92 ../reference_lua/uuid.rst:92
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:105
#: ../reference/reference_lua/uuid.rst:102 ../reference_lua/uuid.rst:102
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:107
#: ../reference/reference_lua/uuid.rst:104 ../reference_lua/uuid.rst:104
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:108
#: ../reference/reference_lua/uuid.rst:105 ../reference_lua/uuid.rst:105
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:109
#: ../reference/reference_lua/uuid.rst:106 ../reference_lua/uuid.rst:106
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:110
#: ../reference/reference_lua/uuid.rst:107 ../reference_lua/uuid.rst:107
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:112
#: ../reference/reference_lua/uuid.rst:109 ../reference_lua/uuid.rst:109
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:114
#: ../doc/reference/reference_lua/uuid.rst:121
#: ../reference/reference_lua/uuid.rst:111
#: ../reference/reference_lua/uuid.rst:118 ../reference_lua/uuid.rst:111
#: ../reference_lua/uuid.rst:118
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:115
#: ../reference/reference_lua/uuid.rst:112 ../reference_lua/uuid.rst:112
msgid "16-byte binary string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:122
#: ../reference/reference_lua/uuid.rst:119 ../reference_lua/uuid.rst:119
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:128
#: ../reference/reference_lua/uuid.rst:125 ../reference_lua/uuid.rst:125
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid."
"fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an "
"all-zero value can also be expressed as ``uuid_with_type_cdata == uuid."
"NULL``."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:133
#: ../reference/reference_lua/uuid.rst:130 ../reference_lua/uuid.rst:130
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/reference/reference_lua/uuid.rst:140
#: ../reference/reference_lua/uuid.rst:137 ../reference_lua/uuid.rst:137
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uui:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:33
msgid "Module `xlog`"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:35
msgid ""
"The xlog module contains one function: pairs(). It can be used to read "
"Tarantool's snapshot files or write-ahead-log (WAL) files. A description of "
"the file format is in section :ref:`Data persistence and the WAL file format "
"<internals-data_persistence>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:45
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:48
msgid ""
"Return: `iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in "
"a for/end loop."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:50
msgid ""
"Possible errors: File does not contain properly formatted snapshot or write-"
"ahead-log information."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:54
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in the :"
"ref:`wal_dir <cfg_basic-wal_dir>` directory by the introductory sandbox "
"exercise \":ref:`Starting Tarantool and making your first database "
"<user_guide_getting_started-first_database>`“."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:59
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure can "
"be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:62
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"  end\n"
"return t"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:71
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/reference/reference_lua/xlog.rst:73
msgid ""
"...\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:33
#: ../reference/reference_lua/yaml.rst:30 ../reference_lua/yaml.rst:30
msgid "Module `yaml`"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:35
#: ../reference/reference_lua/yaml.rst:32 ../reference_lua/yaml.rst:32
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or takes "
"a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:42
#: ../reference/reference_lua/yaml.rst:39 ../reference_lua/yaml.rst:39
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:45
#: ../reference/reference_lua/yaml.rst:42 ../reference_lua/yaml.rst:42
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:50
#: ../reference/reference_lua/yaml.rst:47 ../reference_lua/yaml.rst:47
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:52
#: ../reference/reference_lua/yaml.rst:49 ../reference_lua/yaml.rst:49
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:66
#: ../reference/reference_lua/yaml.rst:63 ../reference_lua/yaml.rst:63
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:89
#: ../reference/reference_lua/yaml.rst:86 ../reference_lua/yaml.rst:86
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:92
#: ../reference/reference_lua/yaml.rst:89 ../reference_lua/yaml.rst:89
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:93
#: ../reference/reference_lua/yaml.rst:90 ../reference_lua/yaml.rst:90
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:94
#: ../reference/reference_lua/yaml.rst:91 ../reference_lua/yaml.rst:91
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:95
#: ../reference/reference_lua/yaml.rst:92 ../reference_lua/yaml.rst:92
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:100
#: ../reference/reference_lua/yaml.rst:97 ../reference_lua/yaml.rst:97
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence"
"\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize="
"\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize="
"\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/reference/reference_lua/yaml.rst:136
#: ../reference/reference_lua/yaml.rst:133 ../reference_lua/yaml.rst:133
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in the "
"same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../reference/reference_rock/dbms.rst:30 ../reference_rock/dbms.rst:30
#, fuzzy
msgid "SQL DBMS Modules"
msgstr ""
"#-#-#-#-#  reference.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL DBMS\n"
"#-#-#-#-#  reference_rock.po (Tarantool 1.7)  #-#-#-#-#\n"
"Модули SQL СУБД"

#: ../doc/reference/reference_rock/dbms.rst:35
#: ../reference/reference_rock/dbms.rst:32 ../reference_rock/dbms.rst:32
msgid ""
"The discussion here in the reference is about incorporating and using two "
"modules that have already been created: the \"SQL DBMS rocks\" for MySQL and "
"PostgreSQL."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:39
#: ../reference/reference_rock/dbms.rst:36 ../reference_rock/dbms.rst:36
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: another "
"DBMS, and Tarantool. The module which connects Tarantool to another DBMS may "
"be called a \"connector\". Within the module there is a shared library which "
"may be called a \"driver\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:44
#: ../reference/reference_rock/dbms.rst:41 ../reference_rock/dbms.rst:41
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for Lua, "
"LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:47
#: ../reference/reference_rock/dbms.rst:44 ../reference_rock/dbms.rst:44
msgid ""
"The Tarantool rocks allow for connecting to an SQL server and executing SQL "
"statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL "
"Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even "
"if that was all Tarantool could do. But of course Tarantool is also a DBMS, "
"so the module also is useful for any operations, such as database copying "
"and accelerating, which work best when the application can work on both SQL "
"and Tarantool inside the same Lua routine. The methods for connect/select/"
"insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` "
"module."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:58
#: ../reference/reference_rock/dbms.rst:55 ../reference_rock/dbms.rst:55
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very similar, "
"so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- "
"contain some redundancy."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:66
#: ../reference/reference_rock/dbms.rst:63 ../reference_rock/dbms.rst:63
msgid "MySQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:68
#: ../reference/reference_rock/dbms.rst:65 ../reference_rock/dbms.rst:65
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C connector "
"is used. The package that matters most is the MySQL client developer "
"package, typically named something like libmysqlclient-dev. The file that "
"matters most from this package is libmysqlclient.so or a similar name. One "
"can use ``find`` or ``whereis`` to see what directories these files are "
"installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:75
#: ../reference/reference_rock/dbms.rst:72 ../reference_rock/dbms.rst:72
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server. After that, one can pass "
"any MySQL statement to the server and receive results, including multiple "
"result sets."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:81
#: ../doc/reference/reference_rock/dbms.rst:435
#: ../reference/reference_rock/dbms.rst:78
#: ../reference/reference_rock/dbms.rst:432 ../reference_rock/dbms.rst:78
#: ../reference_rock/dbms.rst:432
msgid "Installation"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:83
#: ../reference/reference_rock/dbms.rst:80 ../reference_rock/dbms.rst:80
msgid ""
"Check the instructions for :ref:`Downloading and installing a binary package "
"<user_guide_getting_started-downloading_and_installing_a_binary_package>` "
"that apply for the environment where tarantool was installed. In addition to "
"installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, "
"add the line"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:88
#: ../doc/reference/reference_rock/dbms.rst:443
#: ../reference/reference_rock/dbms.rst:85
#: ../reference/reference_rock/dbms.rst:440 ../reference_rock/dbms.rst:85
#: ../reference_rock/dbms.rst:440
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:92
#: ../reference/reference_rock/dbms.rst:89 ../reference_rock/dbms.rst:89
msgid ""
"Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:96
#: ../doc/reference/reference_rock/dbms.rst:451
#: ../reference/reference_rock/dbms.rst:93
#: ../reference/reference_rock/dbms.rst:448 ../reference_rock/dbms.rst:93
#: ../reference_rock/dbms.rst:448
msgid "With LuaRocks"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:98
#: ../doc/reference/reference_rock/dbms.rst:453
#: ../reference/reference_rock/dbms.rst:95
#: ../reference/reference_rock/dbms.rst:450 ../reference_rock/dbms.rst:95
#: ../reference_rock/dbms.rst:450
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:105
#: ../reference/reference_rock/dbms.rst:102 ../reference_rock/dbms.rst:102
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:111
#: ../reference/reference_rock/dbms.rst:108 ../reference_rock/dbms.rst:108
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:115
#: ../doc/reference/reference_rock/dbms.rst:470
#: ../reference/reference_rock/dbms.rst:112
#: ../reference/reference_rock/dbms.rst:467 ../reference_rock/dbms.rst:112
#: ../reference_rock/dbms.rst:467
msgid "See also :ref:`Modules <modules>`."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:119
#: ../doc/reference/reference_rock/dbms.rst:474
#: ../reference/reference_rock/dbms.rst:116
#: ../reference/reference_rock/dbms.rst:471 ../reference_rock/dbms.rst:116
#: ../reference_rock/dbms.rst:471
msgid "With GitHub"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:121
#: ../reference/reference_rock/dbms.rst:118 ../reference_rock/dbms.rst:118
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there, "
"saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:123
#: ../reference/reference_rock/dbms.rst:120 ../reference_rock/dbms.rst:120
msgid ""
"git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:130
#: ../doc/reference/reference_rock/dbms.rst:485
#: ../reference/reference_rock/dbms.rst:127
#: ../reference/reference_rock/dbms.rst:482 ../reference_rock/dbms.rst:127
#: ../reference_rock/dbms.rst:482
msgid ""
"At this point it is a good idea to check that the installation produced a "
"file named ``driver.so``, and to check that this file is on a directory that "
"is searched by the ``require`` request."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:136
#: ../doc/reference/reference_rock/dbms.rst:491
#: ../reference/reference_rock/dbms.rst:133
#: ../reference/reference_rock/dbms.rst:488 ../reference_rock/dbms.rst:133
#: ../reference_rock/dbms.rst:488
msgid "Connecting"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:138
#: ../reference/reference_rock/dbms.rst:135 ../reference_rock/dbms.rst:135
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will assume "
"that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:141
#: ../reference/reference_rock/dbms.rst:138 ../reference_rock/dbms.rst:138
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:145
#: ../doc/reference/reference_rock/dbms.rst:500
#: ../reference/reference_rock/dbms.rst:142
#: ../reference/reference_rock/dbms.rst:497 ../reference_rock/dbms.rst:142
#: ../reference_rock/dbms.rst:497
msgid "Now, say:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:150
#: ../reference/reference_rock/dbms.rst:147 ../reference_rock/dbms.rst:147
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:152
#: ../doc/reference/reference_rock/dbms.rst:507
#: ../reference/reference_rock/dbms.rst:149
#: ../reference/reference_rock/dbms.rst:504 ../reference_rock/dbms.rst:149
#: ../reference_rock/dbms.rst:504
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:154
#: ../doc/reference/reference_rock/dbms.rst:509
#: ../reference/reference_rock/dbms.rst:151
#: ../reference/reference_rock/dbms.rst:506 ../reference_rock/dbms.rst:151
#: ../reference_rock/dbms.rst:506
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:155
#: ../doc/reference/reference_rock/dbms.rst:510
#: ../reference/reference_rock/dbms.rst:152
#: ../reference/reference_rock/dbms.rst:507 ../reference_rock/dbms.rst:152
#: ../reference_rock/dbms.rst:507
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:156
#: ../doc/reference/reference_rock/dbms.rst:511
#: ../reference/reference_rock/dbms.rst:153
#: ../reference/reference_rock/dbms.rst:508 ../reference_rock/dbms.rst:153
#: ../reference_rock/dbms.rst:508
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system user "
"name"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:157
#: ../reference/reference_rock/dbms.rst:154 ../reference_rock/dbms.rst:154
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:158
#: ../doc/reference/reference_rock/dbms.rst:513
#: ../reference/reference_rock/dbms.rst:155
#: ../reference/reference_rock/dbms.rst:510 ../reference_rock/dbms.rst:155
#: ../reference_rock/dbms.rst:510
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:159
#: ../reference/reference_rock/dbms.rst:156 ../reference_rock/dbms.rst:156
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:161
#: ../reference/reference_rock/dbms.rst:158 ../reference_rock/dbms.rst:158
msgid ""
"The option names, except for `raise`, are similar to the names that MySQL's "
"mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/"
"refman/5.6/en/connecting.html`_. The `raise` option should be set to :"
"codenormal:`true` if errors should be raised when encountered. To connect "
"with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :"
"samp:`port = {socket-name}`."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:168
#: ../doc/reference/reference_rock/dbms.rst:517
#: ../reference/reference_rock/dbms.rst:165
#: ../reference/reference_rock/dbms.rst:514 ../reference_rock/dbms.rst:165
#: ../reference_rock/dbms.rst:514
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:170
#: ../reference/reference_rock/dbms.rst:167 ../reference_rock/dbms.rst:167
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:186
#: ../doc/reference/reference_rock/dbms.rst:529
#: ../reference/reference_rock/dbms.rst:183
#: ../reference/reference_rock/dbms.rst:526 ../reference_rock/dbms.rst:183
#: ../reference_rock/dbms.rst:526
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:188
#: ../reference/reference_rock/dbms.rst:185 ../reference_rock/dbms.rst:185
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:204
#: ../doc/reference/reference_rock/dbms.rst:548
#: ../reference/reference_rock/dbms.rst:201
#: ../reference/reference_rock/dbms.rst:545 ../reference_rock/dbms.rst:201
#: ../reference_rock/dbms.rst:545
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:208
#: ../doc/reference/reference_rock/dbms.rst:552
#: ../reference/reference_rock/dbms.rst:205
#: ../reference/reference_rock/dbms.rst:549 ../reference_rock/dbms.rst:205
#: ../reference_rock/dbms.rst:549
msgid "How to ping"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:210
#: ../doc/reference/reference_rock/dbms.rst:554
#: ../reference/reference_rock/dbms.rst:207
#: ../reference/reference_rock/dbms.rst:551 ../reference_rock/dbms.rst:207
#: ../reference_rock/dbms.rst:551
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:215
#: ../doc/reference/reference_rock/dbms.rst:559
#: ../reference/reference_rock/dbms.rst:212
#: ../reference/reference_rock/dbms.rst:556 ../reference_rock/dbms.rst:212
#: ../reference_rock/dbms.rst:556
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:219
#: ../doc/reference/reference_rock/dbms.rst:564
#: ../reference/reference_rock/dbms.rst:216
#: ../reference/reference_rock/dbms.rst:561 ../reference_rock/dbms.rst:216
#: ../reference_rock/dbms.rst:561
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:228
#: ../doc/reference/reference_rock/dbms.rst:573
#: ../reference/reference_rock/dbms.rst:225
#: ../reference/reference_rock/dbms.rst:570 ../reference_rock/dbms.rst:225
#: ../reference_rock/dbms.rst:570
msgid "Executing a statement"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:230
#: ../reference/reference_rock/dbms.rst:227 ../reference_rock/dbms.rst:227
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:235
#: ../doc/reference/reference_rock/dbms.rst:580
#: ../reference/reference_rock/dbms.rst:232
#: ../reference/reference_rock/dbms.rst:577 ../reference_rock/dbms.rst:232
#: ../reference_rock/dbms.rst:577
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:237
#: ../doc/reference/reference_rock/dbms.rst:582
#: ../reference/reference_rock/dbms.rst:234
#: ../reference/reference_rock/dbms.rst:579 ../reference_rock/dbms.rst:234
#: ../reference_rock/dbms.rst:579
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks (\"?\"s) "
"in the SQL statement."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:243
#: ../reference/reference_rock/dbms.rst:240 ../reference_rock/dbms.rst:240
msgid ""
"tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:256
#: ../doc/reference/reference_rock/dbms.rst:600
#: ../reference/reference_rock/dbms.rst:253
#: ../reference/reference_rock/dbms.rst:597 ../reference_rock/dbms.rst:253
#: ../reference_rock/dbms.rst:597
msgid "Closing connection"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:258
#: ../reference/reference_rock/dbms.rst:255 ../reference_rock/dbms.rst:255
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:263
#: ../doc/reference/reference_rock/dbms.rst:607
#: ../reference/reference_rock/dbms.rst:260
#: ../reference/reference_rock/dbms.rst:604 ../reference_rock/dbms.rst:260
#: ../reference_rock/dbms.rst:604
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:267
#: ../doc/reference/reference_rock/dbms.rst:611
#: ../reference/reference_rock/dbms.rst:264
#: ../reference/reference_rock/dbms.rst:608 ../reference_rock/dbms.rst:264
#: ../reference_rock/dbms.rst:608
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:273
#: ../reference/reference_rock/dbms.rst:270 ../reference_rock/dbms.rst:270
msgid ""
"For further information, including examples of rarely-used requests, see the "
"README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:280
#: ../reference/reference_rock/dbms.rst:277 ../reference_rock/dbms.rst:277
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool "
"had been installed in a /usr subdirectory, and a copy of MySQL had been "
"installed on ~/mysql-5.5. The mysqld server is already running on the local "
"host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:284
#: ../reference/reference_rock/dbms.rst:281 ../reference_rock/dbms.rst:281
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:365
#: ../reference/reference_rock/dbms.rst:362 ../reference_rock/dbms.rst:362
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:368
#: ../reference/reference_rock/dbms.rst:365 ../reference_rock/dbms.rst:365
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:376
#: ../reference/reference_rock/dbms.rst:373 ../reference_rock/dbms.rst:373
msgid ""
"Create a Lua function that will connect to the MySQL server, (using some "
"factory default values for the port and user and password), retrieve one "
"row, and display the row. For explanations of the statement types used here, "
"read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:381
#: ../reference/reference_rock/dbms.rst:378 ../reference_rock/dbms.rst:378
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:405
#: ../reference/reference_rock/dbms.rst:402 ../reference_rock/dbms.rst:402
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that was "
"inserted into the MySQL database. And now it's been selected with the "
"Tarantool client."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:412
#: ../reference/reference_rock/dbms.rst:409 ../reference_rock/dbms.rst:409
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:414
#: ../reference/reference_rock/dbms.rst:411 ../reference_rock/dbms.rst:411
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. "
"More recent versions should also work. The package that matters most is the "
"PostgreSQL developer package, typically named something like libpq-dev. On "
"Ubuntu this can be installed with:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:419
#: ../reference/reference_rock/dbms.rst:416 ../reference_rock/dbms.rst:416
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:423
#: ../reference/reference_rock/dbms.rst:420 ../reference_rock/dbms.rst:420
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL files "
"are present and must explicitly state where they are when building the "
"Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what "
"directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:429
#: ../reference/reference_rock/dbms.rst:426 ../reference_rock/dbms.rst:426
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server. After that, "
"one can pass any PostgreSQL statement to the server and receive results."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:437
#: ../reference/reference_rock/dbms.rst:434 ../reference_rock/dbms.rst:434
msgid ""
"Check the instructions for :ref:`Downloading and installing a binary package "
"<user_guide_getting_started-downloading_and_installing_a_binary_package>` "
"that apply for the environment where tarantool was installed. In addition to "
"installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, "
"add the line:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:447
#: ../reference/reference_rock/dbms.rst:444 ../reference_rock/dbms.rst:444
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:460
#: ../reference/reference_rock/dbms.rst:457 ../reference_rock/dbms.rst:457
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:466
#: ../reference/reference_rock/dbms.rst:463 ../reference_rock/dbms.rst:463
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:476
#: ../reference/reference_rock/dbms.rst:473 ../reference_rock/dbms.rst:473
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:478
#: ../reference/reference_rock/dbms.rst:475 ../reference_rock/dbms.rst:475
msgid ""
"git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:493
#: ../reference/reference_rock/dbms.rst:490 ../reference_rock/dbms.rst:490
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume that "
"the name is ``pg`` in further examples."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:496
#: ../reference/reference_rock/dbms.rst:493 ../reference_rock/dbms.rst:493
msgid "pg = require('pg')"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:505
#: ../reference/reference_rock/dbms.rst:502 ../reference_rock/dbms.rst:502
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:512
#: ../reference/reference_rock/dbms.rst:509 ../reference_rock/dbms.rst:509
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, default "
"value is blank"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:515
#: ../reference/reference_rock/dbms.rst:512 ../reference_rock/dbms.rst:512
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:519
#: ../reference/reference_rock/dbms.rst:516 ../reference_rock/dbms.rst:516
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:531
#: ../reference/reference_rock/dbms.rst:528 ../reference_rock/dbms.rst:528
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:575
#: ../reference/reference_rock/dbms.rst:572 ../reference_rock/dbms.rst:572
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:588
#: ../reference/reference_rock/dbms.rst:585 ../reference_rock/dbms.rst:585
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:602
#: ../reference/reference_rock/dbms.rst:599 ../reference_rock/dbms.rst:599
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:617
#: ../reference/reference_rock/dbms.rst:614 ../reference_rock/dbms.rst:614
msgid ""
"For further information, including examples of rarely-used requests, see the "
"README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:624
#: ../reference/reference_rock/dbms.rst:621 ../reference_rock/dbms.rst:621
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool "
"had been installed in a /usr subdirectory, and a copy of PostgreSQL had been "
"installed on /usr. The PostgreSQL server is already running on the local "
"host 127.0.0.1."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:628
#: ../reference/reference_rock/dbms.rst:625 ../reference_rock/dbms.rst:625
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error"
"\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error"
"\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:702
#: ../reference/reference_rock/dbms.rst:699 ../reference_rock/dbms.rst:699
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:705
#: ../reference/reference_rock/dbms.rst:702 ../reference_rock/dbms.rst:702
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:713
#: ../reference/reference_rock/dbms.rst:710 ../reference_rock/dbms.rst:710
msgid ""
"Create a Lua function that will connect to the PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve "
"one row, and display the row. For explanations of the statement types used "
"here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:718
#: ../reference/reference_rock/dbms.rst:715 ../reference_rock/dbms.rst:715
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/dbms.rst:743
#: ../reference/reference_rock/dbms.rst:740 ../reference_rock/dbms.rst:740
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row that "
"was inserted into the PostgreSQL database. And now it's been selected with "
"the Tarantool client."
msgstr ""

#: ../reference_rock/expirationd.rst:30
msgid "Module `expirationd`"
msgstr "Модуль `expirationd`"

#: ../doc/reference/reference_rock/expirationd.rst:35
#: ../reference/reference_rock/expirationd.rst:32
#: ../reference_rock/expirationd.rst:32
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, let "
"us look at expirationd, which Tarantool supplies on GitHub_ with an Artistic "
"license. The expirationd.lua program is lengthy (about 500 lines), so here "
"we will only highlight the matters that will be enhanced by studying the "
"full source later."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:40
#: ../reference/reference_rock/expirationd.rst:37
#: ../reference_rock/expirationd.rst:37
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:48
#: ../reference/reference_rock/expirationd.rst:45
#: ../reference_rock/expirationd.rst:45
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being "
"done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a "
"fiber and turning control over to it so it runs occasionally, goes to sleep, "
"then comes back for more."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:53
#: ../reference/reference_rock/expirationd.rst:50
#: ../reference_rock/expirationd.rst:50
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) "
"do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:62
#: ../reference/reference_rock/expirationd.rst:59
#: ../reference_rock/expirationd.rst:59
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index of "
"the space that is being scanned\", and within it, if the tuple is \"expired"
"\" (for example, if the tuple has a timestamp field which is less than the "
"current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:67
#: ../reference/reference_rock/expirationd.rst:64
#: ../reference_rock/expirationd.rst:64
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:78
#: ../reference/reference_rock/expirationd.rst:75
#: ../reference_rock/expirationd.rst:75
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which "
"does a \"delete\" of a tuple from its original space. First the fun :ref:"
"`fun <fun-module>` module is used, specifically fun.map_. Remembering that :"
"codenormal:`index[0]` is always the space's primary key, and :codenormal:"
"`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field "
"number for key part :codeitalic:`N`, fun.map() is creating a table from the "
"primary-key values of the tuple. The result of fun.map() is passed to :ref:"
"`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:88
#: ../reference/reference_rock/expirationd.rst:85
#: ../reference_rock/expirationd.rst:85
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:93
#: ../reference/reference_rock/expirationd.rst:90
#: ../reference_rock/expirationd.rst:90
msgid ""
"At this point, if the above explanation is worthwhile, it's clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other fibers "
"can operate at the same time, and - whenever it finds a tuple that has "
"expired - deletes it from this space. Now the \"``expirationd_run_task()``\" "
"function can be used in a test which creates sample data, lets the daemon "
"run for a while, and prints results."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:102
#: ../reference/reference_rock/expirationd.rst:99
#: ../reference_rock/expirationd.rst:99
msgid ""
"For those who like to see things run, here are the exact steps to get "
"expirationd through the test."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:105
#: ../reference/reference_rock/expirationd.rst:102
#: ../reference_rock/expirationd.rst:102
msgid ""
"Get ``expirationd.lua``. There are standard ways - it is after all part of a "
"`standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but "
"for this purpose just copy the contents of expirationd.lua_ to a default "
"directory."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:108
#: ../reference/reference_rock/expirationd.rst:105
#: ../reference_rock/expirationd.rst:105
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:109
#: ../reference/reference_rock/expirationd.rst:106
#: ../reference_rock/expirationd.rst:106
msgid "Execute these requests:"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:111
#: ../reference/reference_rock/expirationd.rst:108
#: ../reference_rock/expirationd.rst:108
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:134
#: ../reference/reference_rock/expirationd.rst:131
#: ../reference_rock/expirationd.rst:131
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should already "
"be familiar."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:139
#: ../reference/reference_rock/expirationd.rst:136
#: ../reference_rock/expirationd.rst:136
msgid ""
"The function which will be supplied to expirationd is :codenormal:"
"`is_tuple_expired`, which is saying \"if the second field of the tuple is "
"less than the :ref:`current time <fiber-time>`  , then return true, "
"otherwise return false\"."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:144
#: ../reference/reference_rock/expirationd.rst:141
#: ../reference_rock/expirationd.rst:141
msgid ""
"The key for getting the rock rolling is ``expd = require('expirationd')``. "
"The \"``require``\" function is what reads in the program; it will appear in "
"many later examples in this manual, when it's necessary to get a module "
"that's not part of the Tarantool kernel. After the Lua variable expd has "
"been assigned the value of the expirationd module, it's possible to invoke "
"the module's ``run_task()`` function."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:151
#: ../reference/reference_rock/expirationd.rst:148
#: ../reference_rock/expirationd.rst:148
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had "
"time to do its iterations through the spaces, ``expd.task_stats()`` will "
"print out a report showing how many tuples have expired -- \"expired_count: "
"0\". After sleeping for two more seconds, ``expd.task_stats()`` will print "
"out a report showing how many tuples have expired -- \"expired_count: 1\". "
"This shows that the is_tuple_expired() function eventually returned \"true\" "
"for one of the tuples, because its timestamp field was more than three "
"seconds old."
msgstr ""

#: ../doc/reference/reference_rock/expirationd.rst:161
#: ../reference/reference_rock/expirationd.rst:158
#: ../reference_rock/expirationd.rst:158
msgid ""
"Of course, expirationd can be customized to do different things by passing "
"different parameters, which will be evident after looking in more detail at "
"the source code."
msgstr ""

#: ../reference/reference_rock/index.rst:28
msgid "Rocks reference"
msgstr "Справочник по сторонним библиотекам"

#: ../doc/reference/reference_rock/index.rst:33
#: ../reference/reference_rock/index.rst:30
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../reference_rock/shard.rst:30
msgid "Module `shard`"
msgstr "Модуль `shard`"

#: ../doc/reference/reference_rock/shard.rst:37
#: ../reference/reference_rock/shard.rst:34 ../reference_rock/shard.rst:34
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple nodes, "
"with a Tarantool database server on each node. With this arrangement, each "
"server is handling only a subset of the total data, so larger loads can be "
"handled by simply adding more computers to a network."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:42
#: ../reference/reference_rock/shard.rst:39 ../reference_rock/shard.rst:39
msgid ""
"The Tarantool shard module has facilities for creating shards, as well as "
"analogues for the data-manipulation functions of the box library (select, "
"insert, replace, update, delete)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:46
#: ../reference/reference_rock/shard.rst:43 ../reference_rock/shard.rst:43
msgid "First some terminology:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:49
#: ../reference/reference_rock/shard.rst:46 ../reference_rock/shard.rst:46
msgid "**Consistent Hash**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:51
#: ../reference/reference_rock/shard.rst:48 ../reference_rock/shard.rst:48
msgid ""
"The shard module distributes according to a hash algorithm, that is, it "
"applies a hash function to a tuple's primary-key value in order to decide "
"which shard the tuple belongs to. The hash function is `consistent`_ so that "
"changing the number of servers will not affect results for many keys. The "
"specific hash function that the shard module uses is :ref:`digest.guava "
"<digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:57
#: ../reference/reference_rock/shard.rst:54 ../reference_rock/shard.rst:54
msgid "**Queue**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:59
#: ../reference/reference_rock/shard.rst:56 ../reference_rock/shard.rst:56
msgid ""
"A temporary list of recent update requests. Sometimes called \"batching\". "
"Since updates to a sharded database can be slow, it may speed up throughput "
"to send requests to a queue rather than wait for the update to finish on "
"ever node. The shard module has functions for adding requests to the queue, "
"which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:65
#: ../reference/reference_rock/shard.rst:62 ../reference_rock/shard.rst:62
msgid "**Redundancy**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:67
#: ../reference/reference_rock/shard.rst:64 ../reference_rock/shard.rst:64
msgid "The number of replicas in each shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:68
#: ../reference/reference_rock/shard.rst:65 ../reference_rock/shard.rst:65
msgid "**Replica**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:70
#: ../reference/reference_rock/shard.rst:67 ../reference_rock/shard.rst:67
msgid ""
"A complete copy of the data. The shard module handles both sharding and "
"replication. One shard can contain one or more replicas. When a write "
"occurs, the write is attempted on every replica in turn. The shard module "
"does not use the built-in replication feature."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:74
#: ../reference/reference_rock/shard.rst:71 ../reference_rock/shard.rst:71
msgid "**Shard**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:76
#: ../reference/reference_rock/shard.rst:73 ../reference_rock/shard.rst:73
msgid ""
"A subset of the tuples in the database partitioned according to the value "
"returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:80
#: ../reference/reference_rock/shard.rst:77 ../reference_rock/shard.rst:77
msgid "**Zone**"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:82
#: ../reference/reference_rock/shard.rst:79 ../reference_rock/shard.rst:79
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is a "
"single computer with a single tarantool-server instance. A shard's replicas "
"should be in different zones."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:87
#: ../reference/reference_rock/shard.rst:84 ../reference_rock/shard.rst:84
msgid ""
"The shard package is distributed separately from the main tarantool package. "
"To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:90
#: ../reference/reference_rock/shard.rst:87 ../reference_rock/shard.rst:87
msgid "sudo apt-get install tarantool-shard tarantool-pool"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:94
#: ../reference/reference_rock/shard.rst:91 ../reference_rock/shard.rst:91
msgid ""
"Or, download from github tarantool/shard and compile as described in the "
"README. Then, before using the module, say ``shard = require('shard')``"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:97
#: ../reference/reference_rock/shard.rst:94 ../reference_rock/shard.rst:94
msgid "The most important function is:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:102
#: ../reference/reference_rock/shard.rst:99 ../reference_rock/shard.rst:99
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:104
#: ../reference/reference_rock/shard.rst:101 ../reference_rock/shard.rst:101
msgid ""
"This must be called for every shard. The shard-configuration is a table with "
"these fields:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:107
#: ../reference/reference_rock/shard.rst:104 ../reference_rock/shard.rst:104
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:108
#: ../reference/reference_rock/shard.rst:105 ../reference_rock/shard.rst:105
msgid "login (the user name which applies for accessing via the shard module)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:109
#: ../reference/reference_rock/shard.rst:106 ../reference_rock/shard.rst:106
msgid "password (the password for the login)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:110
#: ../reference/reference_rock/shard.rst:107 ../reference_rock/shard.rst:107
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:111
#: ../reference/reference_rock/shard.rst:108 ../reference_rock/shard.rst:108
msgid ""
"binary (a port number that this host is listening on, on the current host) "
"(distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:114
#: ../reference/reference_rock/shard.rst:111 ../reference_rock/shard.rst:111
msgid ""
"Possible Errors: Redundancy should not be greater than the number of "
"servers; the servers must be alive; two replicas of the same shard should "
"not be in the same zone."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:120
#: ../reference/reference_rock/shard.rst:117 ../reference_rock/shard.rst:117
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:122
#: ../reference/reference_rock/shard.rst:119 ../reference_rock/shard.rst:119
msgid ""
"The number of replicas per shard (redundancy) is 3. The number of servers is "
"3. The shard module will conclude that there is only one shard."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:126
#: ../reference/reference_rock/shard.rst:123 ../reference_rock/shard.rst:123
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:147
#: ../reference/reference_rock/shard.rst:144 ../reference_rock/shard.rst:144
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:149
#: ../reference/reference_rock/shard.rst:146 ../reference_rock/shard.rst:146
msgid ""
"This describes three shards. Each shard has two replicas. Since the number "
"of servers is 7, and the number of replicas per shard is 2, and dividing 7 / "
"2 leaves a remainder of 1, one of the servers will not be used. This is not "
"necessarily an error, because perhaps one of the servers in the list is not "
"alive."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:154
#: ../reference/reference_rock/shard.rst:151 ../reference_rock/shard.rst:151
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:180
#: ../reference/reference_rock/shard.rst:177 ../reference_rock/shard.rst:177
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:187
#: ../reference/reference_rock/shard.rst:184 ../reference_rock/shard.rst:184
msgid ""
"Every data-access function in the box module has an analogue in the shard "
"module, so (for example) to insert in table T in a sharded database one "
"simply says ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``. "
"A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:195
#: ../reference/reference_rock/shard.rst:192 ../reference_rock/shard.rst:192
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:202
#: ../reference/reference_rock/shard.rst:199 ../reference_rock/shard.rst:199
msgid ""
"Every queued data-access function has an analogue in the shard module. The "
"user must add an operation_id. The details of queued data-access functions, "
"and of maintenance-related functions, are on `the shard section of github`_."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:208
#: ../reference/reference_rock/shard.rst:205 ../reference_rock/shard.rst:205
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:210
#: ../reference/reference_rock/shard.rst:207 ../reference_rock/shard.rst:207
msgid ""
"There is only one shard, and that shard contains only one replica. So this "
"isn't illustrating the features of either replication or sharding, it's only "
"illustrating what the syntax is, and what the messages look like, that "
"anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:215
#: ../reference/reference_rock/shard.rst:212 ../reference_rock/shard.rst:212
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:241
#: ../reference/reference_rock/shard.rst:238 ../reference_rock/shard.rst:238
msgid ""
"If one cuts and pastes the above, then the result, showing only the requests "
"and responses for shard.init and shard.tester, should look approximately "
"like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:245
#: ../reference/reference_rock/shard.rst:242 ../reference_rock/shard.rst:242
msgid ""
"tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:274
#: ../reference/reference_rock/shard.rst:271 ../reference_rock/shard.rst:271
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:276
#: ../reference/reference_rock/shard.rst:273 ../reference_rock/shard.rst:273
msgid ""
"There are two shards, and each shard contains one replica. This requires two "
"nodes. In real life the two nodes would be two computers, but for this "
"illustration the requirement is merely: start two shells, which we'll call "
"Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:283
#: ../reference/reference_rock/shard.rst:280 ../reference_rock/shard.rst:280
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:311
#: ../reference/reference_rock/shard.rst:308 ../reference_rock/shard.rst:308
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:313
#: ../reference/reference_rock/shard.rst:310 ../reference_rock/shard.rst:310
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:341
#: ../reference/reference_rock/shard.rst:338 ../reference_rock/shard.rst:338
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It will "
"go on until Terminal #2 process starts."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:345
#: ../reference/reference_rock/shard.rst:342 ../reference_rock/shard.rst:342
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:347
#: ../reference/reference_rock/shard.rst:344 ../reference_rock/shard.rst:344
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:354
#: ../reference/reference_rock/shard.rst:351 ../reference_rock/shard.rst:351
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by Terminal "
"#2, via the shard module."
msgstr ""

#: ../doc/reference/reference_rock/shard.rst:357
#: ../reference/reference_rock/shard.rst:354 ../reference_rock/shard.rst:354
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:31
#: ../reference/reference_rock/tdb.rst:28 ../reference_rock/tdb.rst:28
msgid "Module `tdb`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:33
#: ../reference/reference_rock/tdb.rst:30 ../reference_rock/tdb.rst:30
msgid ""
"The Tarantool Debugger (abbreviation = tdb) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining "
"variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:39
#: ../reference/reference_rock/tdb.rst:36 ../reference_rock/tdb.rst:36
msgid ""
"It is not supplied as part of the Tarantool repository; it must be installed "
"separately. Here is the usual way:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:42
#: ../reference/reference_rock/tdb.rst:39 ../reference_rock/tdb.rst:39
msgid ""
"git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:49
#: ../reference/reference_rock/tdb.rst:46 ../reference_rock/tdb.rst:46
msgid ""
"To initiate tdb within a Lua program and set a breakpoint, edit the program "
"to include these lines:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:52
#: ../reference/reference_rock/tdb.rst:49 ../reference_rock/tdb.rst:49
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:57
#: ../reference/reference_rock/tdb.rst:54 ../reference_rock/tdb.rst:54
msgid ""
"To start the debugging session, execute the Lua program. Execution will stop "
"at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:62
#: ../reference/reference_rock/tdb.rst:59 ../reference_rock/tdb.rst:59
msgid "Debugger Commands"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:66
#: ../reference/reference_rock/tdb.rst:63 ../reference_rock/tdb.rst:63
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:65
#: ../reference/reference_rock/tdb.rst:62 ../reference_rock/tdb.rst:62
msgid ""
"Backtrace -- show the stack (in red), with program/function names and line "
"numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:69
#: ../reference/reference_rock/tdb.rst:66 ../reference_rock/tdb.rst:66
msgid ":codebold:`c`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:69
#: ../reference/reference_rock/tdb.rst:66 ../reference_rock/tdb.rst:66
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:76
#: ../reference/reference_rock/tdb.rst:73 ../reference_rock/tdb.rst:73
msgid ":codebold:`e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:72
#: ../reference/reference_rock/tdb.rst:69 ../reference_rock/tdb.rst:69
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This is "
"particularly useful for displaying the values of the program's variables. "
"Other debugger commands will not work until one exits evaluation mode by "
"typing :codebold:`-e`."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:79
#: ../reference/reference_rock/tdb.rst:76 ../reference_rock/tdb.rst:76
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:79
#: ../reference/reference_rock/tdb.rst:76 ../reference_rock/tdb.rst:76
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:83
#: ../reference/reference_rock/tdb.rst:80 ../reference_rock/tdb.rst:80
msgid ":codebold:`f`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:82
#: ../reference/reference_rock/tdb.rst:79 ../reference_rock/tdb.rst:79
msgid ""
"Display the fiber id, the program name, and the percentage of memory used, "
"as a table."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:86
#: ../reference/reference_rock/tdb.rst:83 ../reference_rock/tdb.rst:83
msgid ":codebold:`n`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:86
#: ../reference/reference_rock/tdb.rst:83 ../reference_rock/tdb.rst:83
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:89
#: ../reference/reference_rock/tdb.rst:86 ../reference_rock/tdb.rst:86
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:89
#: ../reference/reference_rock/tdb.rst:86 ../reference_rock/tdb.rst:86
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:92
#: ../reference/reference_rock/tdb.rst:89 ../reference_rock/tdb.rst:89
msgid ":codebold:`h`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:92
#: ../reference/reference_rock/tdb.rst:89 ../reference_rock/tdb.rst:89
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:96
#: ../reference/reference_rock/tdb.rst:93 ../reference_rock/tdb.rst:93
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:95
#: ../reference/reference_rock/tdb.rst:92 ../reference_rock/tdb.rst:92
msgid ""
"Display names and values of variables, for example the control variables of "
"a Lua \"for\" statement."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:99
#: ../reference/reference_rock/tdb.rst:96 ../reference_rock/tdb.rst:96
msgid ":codebold:`q`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:99
#: ../reference/reference_rock/tdb.rst:96 ../reference_rock/tdb.rst:96
msgid "Quit immediately."
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:103
#: ../reference/reference_rock/tdb.rst:100 ../reference_rock/tdb.rst:100
msgid "Example Session"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:105
#: ../reference/reference_rock/tdb.rst:102 ../reference_rock/tdb.rst:102
msgid ""
"Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:107
#: ../reference/reference_rock/tdb.rst:104 ../reference_rock/tdb.rst:104
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:115
#: ../reference/reference_rock/tdb.rst:112 ../reference_rock/tdb.rst:112
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:120
#: ../reference/reference_rock/tdb.rst:117 ../reference_rock/tdb.rst:117
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:122
#: ../doc/reference/reference_rock/tdb.rst:147
#: ../reference/reference_rock/tdb.rst:119
#: ../reference/reference_rock/tdb.rst:144 ../reference_rock/tdb.rst:119
#: ../reference_rock/tdb.rst:144
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:127
#: ../reference/reference_rock/tdb.rst:124 ../reference_rock/tdb.rst:124
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:134
#: ../reference/reference_rock/tdb.rst:131 ../reference_rock/tdb.rst:131
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and the "
"current line -- line 3 of example.lua -- is the default color. Now enter six "
"debugger commands:"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:138
#: ../reference/reference_rock/tdb.rst:135 ../reference_rock/tdb.rst:135
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:152
#: ../reference/reference_rock/tdb.rst:149 ../reference_rock/tdb.rst:149
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/reference/reference_rock/tdb.rst:169
#: ../reference/reference_rock/tdb.rst:166 ../reference_rock/tdb.rst:166
msgid "Another debugger example can be found here_."
msgstr ""

#: ../tutorials/c_tutorial.rst:28
msgid "C tutorial"
msgstr "Практическое задание на C"

#: ../doc/tutorials/c_tutorial.rst:33 ../tutorials/c_tutorial.rst:30
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

#: ../tutorials/c_tutorial.rst:37
msgid "C stored procedures"
msgstr "Хранимые процедуры на языке C"

#: ../doc/tutorials/c_tutorial.rst:42 ../tutorials/c_tutorial.rst:39
msgid ""
"Tarantool can call C code with :ref:`modules <modules-example_c>`, or with :"
"ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This tutorial "
"only is about the third option, C stored procedures. In fact the routines "
"are always \"C functions\" but the phrase \"stored procedure\" is commonly "
"used for historical reasons."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:49 ../tutorials/c_tutorial.rst:46
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are three tasks. The first -- :"
"code:`easy.c` -- prints \"hello world\". The second -- :code:`harder.c` -- "
"decodes a passed parameter value. The third -- :code:`hardest.c` -- uses the "
"C API to do DBMS work."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:55 ../tutorials/c_tutorial.rst:52
msgid ""
"After following the instructions, and seeing that the results are what is "
"described here, users should feel confident about writing their own stored "
"procedures."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:59 ../tutorials/c_tutorial.rst:56
msgid "**Preparation**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:61 ../tutorials/c_tutorial.rst:58
msgid ""
"Check that these items exist on the computer: |br| * Tarantool 1.7 |br| * A "
"gcc compiler, any modern version should work |br| * \"module.h\" |br| * "
"\"msgpuck.h\" |br|"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:67 ../tutorials/c_tutorial.rst:64
msgid ""
"The \"module.h\" file will exist if Tarantool 1.7 was installed from source. "
"Otherwise Tarantool's \"developer\" package must be installed. For example "
"on Ubuntu say |br| :code:`sudo apt-get install tarantool-dev` |br| or on "
"Fedora say |br| :code:`dnf -y install tarantool-devel`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:74 ../tutorials/c_tutorial.rst:71
msgid ""
"The \"msgpuck.h\" file will exist if Tarantool 1.7 was installed from "
"source. Otherwise the \"msgpuck\" package must be installed from `https://"
"github.com/rtsisyk/msgpuck <https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:78 ../tutorials/c_tutorial.rst:75
msgid ""
"Both module.h and msgpuck.h must be on the include path for the C compiler "
"to see them. For example, if module.h address is /usr/local/include/"
"tarantool/module.h, and msgpuck.h address is /usr/local/include/msgpuck/"
"msgpuck.h, and they are not currently on the include path, say |br| :code:"
"`export CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:84 ../tutorials/c_tutorial.rst:81
msgid ""
"Requests will be done using tarantool as a :ref:`client <administration-"
"using_tarantool_as_a_client>`. Start tarantool, and enter these requests."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:87 ../tutorials/c_tutorial.rst:84
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:95 ../tutorials/c_tutorial.rst:92
msgid ""
"In plainer language: create a space named capi_test, and make a connection "
"to self named capi_connection."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:98 ../tutorials/c_tutorial.rst:95
msgid ""
"Leave the client running. It will be necessary to enter more requests later."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:100 ../tutorials/c_tutorial.rst:97
msgid "**easy.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:102 ../tutorials/c_tutorial.rst:99
msgid ""
"Start another shell. Change directory (cd) so that it is the same as the "
"directory that the client is running on."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:105 ../tutorials/c_tutorial.rst:102
msgid "Create a file. Name it easy.c. Put these six lines in it."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:107 ../tutorials/c_tutorial.rst:104
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:116 ../tutorials/c_tutorial.rst:113
msgid ""
"Compile the program, producing a library file named easy.so: |br| :code:`gcc "
"-shared -o easy.so -fPIC easy.c`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:119 ../doc/tutorials/c_tutorial.rst:188
#: ../doc/tutorials/c_tutorial.rst:271 ../tutorials/c_tutorial.rst:116
#: ../tutorials/c_tutorial.rst:185 ../tutorials/c_tutorial.rst:268
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:121 ../tutorials/c_tutorial.rst:118
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:127 ../tutorials/c_tutorial.rst:124
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of :ref:`box."
"schema.func.create <box_schema-func_create>` and :ref:`box.schema.user.grant "
"<box_schema-user_grant>` and :ref:`conn:call <net_box-call>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:133 ../tutorials/c_tutorial.rst:130
msgid "The function that matters is capi_connection:call('easy')."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:135 ../tutorials/c_tutorial.rst:132
msgid ""
"Its first job is to find the 'easy' function, which should be easy because "
"by default Tarantool looks on the current directory for a file named easy.so."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:139 ../tutorials/c_tutorial.rst:136
msgid ""
"Its second job is to call the 'easy' function. Since the easy() function in "
"easy.c begins with :code:`printf(\"hello world\\n\")`, the words \"hello "
"world\" will appear on the screen."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:143 ../tutorials/c_tutorial.rst:140
msgid ""
"Its third job is to check that the call was successful. Since the easy() "
"function in easy.c ends with :code:`return 0`, there is no error message to "
"display and the request is over."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:147 ../doc/tutorials/c_tutorial.rst:289
#: ../tutorials/c_tutorial.rst:144 ../tutorials/c_tutorial.rst:286
msgid "The result should look like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:149 ../tutorials/c_tutorial.rst:146
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:157 ../tutorials/c_tutorial.rst:154
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:159 ../tutorials/c_tutorial.rst:156
msgid "**harder.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:161 ../tutorials/c_tutorial.rst:158
msgid "Go back to the shell where the easy.c program was created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:163 ../tutorials/c_tutorial.rst:160
msgid "Create a file. Name it harder.c. Put these 17 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:165 ../tutorials/c_tutorial.rst:162
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char *args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:185 ../tutorials/c_tutorial.rst:182
msgid ""
"Compile the program, producing a library file named harder.so: |br| :code:"
"`gcc -shared -o harder.so -fPIC harder.c`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:190 ../tutorials/c_tutorial.rst:187
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:200 ../tutorials/c_tutorial.rst:197
msgid ""
"This time the call is passing a Lua table (passable_table) to the harder() "
"function. The harder() function will see it, it's in the :code:`char *args` "
"parameter."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:204 ../tutorials/c_tutorial.rst:201
msgid ""
"At this point the harder() function will start using functions defined in "
"msgpuck.h, which are documented in `http://rtsisyk.github.io/msgpuck <http://"
"rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\" are "
"msgpuck functions that handle data formatted according to the MsgPack_ "
"specification. Passes and returns are always done with this format so one "
"must become acquainted with msgpuck to become proficient with the C API."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:213 ../tutorials/c_tutorial.rst:210
msgid ""
"For now, though, it's enough to know that mp_decode_array() returns the "
"number of elements in an array, and mp_decode_uint returns an unsigned "
"integer, from :code:`args`. And there's a side effect: when the decoding "
"finishes, :code:`args` has changed and is now pointing to the next element."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:219 ../tutorials/c_tutorial.rst:216
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because there "
"was only one item passed: passable_table. |br| The second displayed line "
"will be \"field_count = 3\" because there are three items in the table. |br| "
"The next three lines will be \"1\" and \"2\" and \"3\" because those are the "
"values in the items in the table."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:226 ../tutorials/c_tutorial.rst:223
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:228 ../tutorials/c_tutorial.rst:225
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:240 ../tutorials/c_tutorial.rst:237
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy at "
"first, but there are routines to do the job, and they're documented, and "
"there aren't very many of them."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:245 ../tutorials/c_tutorial.rst:242
msgid "**hardest.c**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:247 ../tutorials/c_tutorial.rst:244
msgid ""
"Go back to the shell where the easy.c and the harder.c programs were created."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:250 ../tutorials/c_tutorial.rst:247
msgid "Create a file. Name it hardest.c. Put these 13 lines in it:"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:252 ../tutorials/c_tutorial.rst:249
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", strlen(\"capi_test"
"\"));\n"
"  char tuple[1024];\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:268 ../tutorials/c_tutorial.rst:265
msgid ""
"Compile the program, producing a library file named hardest.so: |br| :code:"
"`gcc -shared -o hardest.so -fPIC hardest.c`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:273 ../tutorials/c_tutorial.rst:270
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:280 ../tutorials/c_tutorial.rst:277
msgid ""
"This time the C function is doing three things: (1) finding the numeric "
"identifier of the \"capi_test\" space by calling box_space_id_by_name(); |"
"br| (2) formatting a tuple using more msgpuck.h functions; |br| (3) "
"inserting a row using box_insert."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:286 ../tutorials/c_tutorial.rst:283
msgid ""
"Now, still on the client, execute this request: |br| :code:`box.space."
"capi_test:select()`"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:291 ../tutorials/c_tutorial.rst:288
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:298 ../tutorials/c_tutorial.rst:295
msgid ""
"This proves that the hardest() function succeeded, but where did "
"box_space_id_by_name() and box_insert() come from? Answer: the C API. The "
"whole C API is documented :ref:`here <index-c_api_reference>`. The function "
"box_space_id_by_name() is documented :ref:`here <box-box_space_id_by_name>`. "
"The function box_insert() is documented :ref:`here <box-box_insert>`."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:304 ../tutorials/c_tutorial.rst:301
msgid ""
"Conclusion: the long description of the C API is there for a good reason. "
"All of the functions in it can be called from C functions which are called "
"from Lua. So C \"stored procedures\" have full access to the database."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:310 ../tutorials/c_tutorial.rst:307
msgid "**Cleaning up**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:312 ../tutorials/c_tutorial.rst:309
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`, and get rid of the capi_test space with :ref:`box."
"schema.capi_test:drop() <box_space-drop>`, and remove the .c and .so files "
"that were created for this tutorial."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:317 ../tutorials/c_tutorial.rst:314
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:319 ../tutorials/c_tutorial.rst:316
msgid ""
"Download the source code of Tarantool. Look in a subdirectory :code:`test/"
"box`. Notice that there is a file named :code:`tuple_bench.test.lua` and "
"another file named :code:`tuple_bench.c`. Examine the Lua file and observe "
"that it is calling a function in the C file, using the same techniques that "
"this tutorial has shown."
msgstr ""

#: ../doc/tutorials/c_tutorial.rst:326 ../tutorials/c_tutorial.rst:323
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and "
"they must work, because releases don't happen if Tarantool doesn't pass the "
"tests."
msgstr ""

#: ../tutorials/lua_tutorials.rst:30
msgid "Lua tutorials"
msgstr "Практические задания на Lua"

#: ../doc/tutorials/lua_tutorials.rst:35 ../tutorials/lua_tutorials.rst:32
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:37 ../tutorials/lua_tutorials.rst:34
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure <c_lua_tutorial-"
"insert_one_million_tuples>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:38 ../tutorials/lua_tutorials.rst:35
msgid ""
":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:39 ../tutorials/lua_tutorials.rst:36
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../tutorials/lua_tutorials.rst:42
msgid "Insert one million tuples with a Lua stored procedure"
msgstr "Вставка 1 млн кортежей с помощью хранимой процедуры на языке Lua"

#: ../doc/tutorials/lua_tutorials.rst:47 ../tutorials/lua_tutorials.rst:44
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple "
"should have a constantly-increasing numeric primary-key field and a random "
"alphabetic 10-character string field.”"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:51 ../tutorials/lua_tutorials.rst:48
msgid ""
"The purpose of the exercise is to show what Lua functions look like inside "
"Tarantool. It will be necessary to employ the Lua math library, the Lua "
"string library, the Tarantool box library, the Tarantool box.tuple library, "
"loops, and concatenations. It should be easy to follow even for a person who "
"has not used either Lua or Tarantool before. The only requirement is a "
"knowledge of how other programming languages work and a memory of the first "
"two chapters of this manual. But for better understanding, follow the "
"comments and the links, which point to the Lua manual or to elsewhere in "
"this Tarantool manual. To further enhance learning, type the statements in "
"with the tarantool client while reading along."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:63 ../tutorials/lua_tutorials.rst:60
msgid "Configure"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:65 ../tutorials/lua_tutorials.rst:62
msgid ""
"We are going to use the \"tarantool_sandbox\" that was created in section :"
"ref:`first database <user_guide_getting_started-first_database>`. So there "
"is a single space, and a numeric primary key, and a running tarantool server "
"which also serves as a client."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:71 ../tutorials/lua_tutorials.rst:68
msgid "Delimiter"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:73 ../tutorials/lua_tutorials.rst:70
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed "
"within \"delimiters\". They are no longer necessary, and so they will not be "
"used in this tutorial. However, they are still supported. Users who wish to "
"use delimiters, or users of older versions of Tarantool, should check the "
"syntax description for :ref:`declaring a delimiter <administration-"
"setting_delimiter>` before proceeding."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:82 ../tutorials/lua_tutorials.rst:79
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:84 ../tutorials/lua_tutorials.rst:81
msgid ""
"We will start by making a function that returns a fixed string, “Hello "
"world”."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:86 ../tutorials/lua_tutorials.rst:83
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:92 ../tutorials/lua_tutorials.rst:89
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua. "
"The function name is string_function. The function has one executable "
"statement, ``return \"hello world\"``. The string \"hello world\" is "
"enclosed in double quotes here, although Lua doesn't care -- one could use "
"single quotes instead. The word \"``end``\" means “this is the end of the "
"Lua function declaration.” To confirm that the function works, we can say"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:99 ../tutorials/lua_tutorials.rst:96
msgid "string_function()"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:103 ../tutorials/lua_tutorials.rst:100
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect is "
"that the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:106 ../tutorials/lua_tutorials.rst:103
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For "
"more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:114 ../tutorials/lua_tutorials.rst:111
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:129 ../tutorials/lua_tutorials.rst:126
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:131 ../tutorials/lua_tutorials.rst:128
msgid ""
"Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:134 ../tutorials/lua_tutorials.rst:131
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:142 ../tutorials/lua_tutorials.rst:139
msgid ""
"We begin by declaring a variable \"``string_value``\". The word \"``local``"
"\" means that string_value appears only in ``main_function``. If we didn't "
"use \"``local``\" then ``string_value`` would be visible everywhere - even "
"by other users using other clients connected to this server! Sometimes "
"that's a very desirable feature for inter-client communication, but not this "
"time."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:148 ../tutorials/lua_tutorials.rst:145
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check that "
"it got the value."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:152 ../tutorials/lua_tutorials.rst:149
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables "
"and Blocks\"`_ ."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:158 ../tutorials/lua_tutorials.rst:155
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:175 ../tutorials/lua_tutorials.rst:172
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:177
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal \"Hello "
"world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:181 ../tutorials/lua_tutorials.rst:178
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:191 ../tutorials/lua_tutorials.rst:188
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, "
"they're simply overwritten. The first assignment invokes a random-number "
"function in Lua's math library; the parameters mean “the number must be an "
"integer between 65 and 90.” The second assignment invokes an integer-to-"
"character function in Lua's string library; the parameter is the code point "
"of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value "
"of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:199 ../tutorials/lua_tutorials.rst:196
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:205 ../tutorials/lua_tutorials.rst:202
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() "
"which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:210 ../tutorials/lua_tutorials.rst:207
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:227 ../tutorials/lua_tutorials.rst:224
msgid ""
"... Well, actually it won't always look like this because ``math.random()`` "
"produces random numbers. But for the illustration purposes it won't matter "
"what the random string values are."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:233 ../tutorials/lua_tutorials.rst:230
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:235 ../tutorials/lua_tutorials.rst:232
msgid ""
"Now that it's clear how to produce one-letter random strings, we can reach "
"our goal of producing a ten-letter string by concatenating ten one-letter "
"strings, in a loop."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:239 ../tutorials/lua_tutorials.rst:236
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:252 ../tutorials/lua_tutorials.rst:249
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x "
"equals 10, increment x by 1 for each iteration.” The symbol \"..\" means "
"\"concatenate\", that is, add the string on the right of the \"..\" sign to "
"the string on the left of the \"..\" sign. Since we start by saying that "
"random_string is \"\" (a blank string), the end result is that random_string "
"has 10 random letters. Once again the ``string_function()`` can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:260 ../tutorials/lua_tutorials.rst:257
msgid ""
"For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:266 ../tutorials/lua_tutorials.rst:263
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:288 ../tutorials/lua_tutorials.rst:285
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:290 ../tutorials/lua_tutorials.rst:287
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible to "
"make a tuple that contains a number and a 10-letter random string, by "
"invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:294 ../tutorials/lua_tutorials.rst:291
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:303 ../tutorials/lua_tutorials.rst:300
msgid ""
"Once this is done, t will be the value of a new tuple which has two fields. "
"The first field is numeric: 1. The second field is a random string. Once "
"again the ``string_function()`` can be invoked from ``main_function()`` "
"which can be invoked with  ``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:308 ../tutorials/lua_tutorials.rst:305
msgid ""
"For more about Tarantool tuples see Tarantool manual section :ref:`Submodule "
"box.tuple <box_tuple>`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:312 ../tutorials/lua_tutorials.rst:309
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:330 ../tutorials/lua_tutorials.rst:327
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:332 ../tutorials/lua_tutorials.rst:329
msgid ""
"Now that it's clear how to make a tuple that contains a number and a 10-"
"letter random string, the only trick remaining is putting that tuple into "
"tester. Remember that tester is the first space that was defined in the "
"sandbox, so it's like a database table."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:337 ../tutorials/lua_tutorials.rst:334
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:346 ../tutorials/lua_tutorials.rst:343
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second "
"parameter is the tuple value. To be perfectly correct we could have said "
"``box.space.tester:insert(t)`` here, rather than ``box.space.tester:"
"replace(t)``, but \"replace\" means “insert even if there is already a tuple "
"whose primary-key value is a duplicate”, and that makes it easier to re-run "
"the exercise even if the sandbox database isn't empty. Once this is done, "
"tester will contain a tuple with two fields. The first field will be 1. The "
"second field will be a random 10-letter string. Once again the "
"``string_function(``) can be invoked from ``main_function()`` which can be "
"invoked with ``main_function()``. But ``main_function()`` won't tell the "
"whole story, because it does not return t, it only puts t into the database. "
"To confirm that something got inserted, we'll use a SELECT request."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:360 ../tutorials/lua_tutorials.rst:357
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:365 ../tutorials/lua_tutorials.rst:362
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:370 ../tutorials/lua_tutorials.rst:367
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:391 ../tutorials/lua_tutorials.rst:388
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:393 ../tutorials/lua_tutorials.rst:390
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no big "
"deal to figure out how to scale up: instead of inserting with a literal "
"value = 1 for the primary key, insert with a variable value = between 1 and "
"1 million, in a loop. Since we already saw how to loop, that's a simple "
"thing. The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:399 ../tutorials/lua_tutorials.rst:396
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:414
msgid ""
"The standard Lua function `os.clock() <http://www.lua.org/manual/5.1/manual."
"html#pdf-os.clock>` will return the number of CPU seconds since the start. "
"Therefore, by getting start_time = number of seconds just before the "
"inserting, and then getting end_time = number of seconds just after the "
"inserting, we can calculate (end_time - start_time) = elapsed time in "
"seconds. We will display that value by putting it in a request without any "
"assignments, which causes Tarantool to send the value to the client, which "
"prints it. (Lua's answer to the C ``printf()`` function, which is "
"``print()``, will also work.)"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:424 ../tutorials/lua_tutorials.rst:419
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time"
"\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:430 ../tutorials/lua_tutorials.rst:425
msgid ""
"Since this is the grand finale, we will redo the final versions of all the "
"necessary requests: the request that created ``string_function()``, the "
"request that created ``main_function()``, and the request that invokes "
"``main_function()``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:435 ../tutorials/lua_tutorials.rst:430
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:463 ../tutorials/lua_tutorials.rst:458
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:502 ../tutorials/lua_tutorials.rst:497
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact one "
"can do more with Tarantool's Lua stored procedures than one can do with "
"stored procedures in some SQL DBMSs), and that it's straightforward to "
"combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:507 ../tutorials/lua_tutorials.rst:502
msgid ""
"What has also been shown is that inserting a million tuples took 37 seconds. "
"The host computer was a Linux laptop. By changing :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the test, "
"one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../tutorials/lua_tutorials.rst:510
msgid "Sum a JSON field for all tuples"
msgstr "Подсчет суммы по JSON-полям во всех кортежах"

#: ../doc/tutorials/lua_tutorials.rst:517 ../tutorials/lua_tutorials.rst:512
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is a "
"string formatted as JSON. Inside that string there is a JSON numeric field. "
"For each tuple, find the numeric field's value and add it to a 'sum' "
"variable. At end, return the 'sum' variable.” The purpose of the exercise is "
"to get experience in one way to read and process tuples."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:523 ../tutorials/lua_tutorials.rst:518
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:540 ../tutorials/lua_tutorials.rst:535
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be "
"used in the function. Actually it's not necessary to declare all variables "
"at the start, and in a long function it would be better to declare variables "
"just before using them. In fact it's not even necessary to declare variables "
"at all, but an undeclared variable is \"global\". That's not desirable for "
"any of the variables that are declared in line 1, because all of them are "
"for use only within the function."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:547 ../tutorials/lua_tutorials.rst:542
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there "
"are two ways to do it: with :ref:`box.space.space_object:pairs() <box_space-"
"pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 "
"do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this "
"example."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:552 ../tutorials/lua_tutorials.rst:547
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop "
"will be repeated as long as there is another index key. A tuple is fetched "
"and can be referenced with variable :code:`t`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:556 ../tutorials/lua_tutorials.rst:551
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json."
"decode(t[2]))``, then the function would abort with an error if it "
"encountered something wrong with the JSON string - a missing colon, for "
"example. By putting the function inside \"``pcall``\" (`protected call`_), "
"we're saying: we want to intercept that sort of error, so if there's a "
"problem just set ``is_valid_json = false`` and we will know what to do about "
"it later."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:563 ../tutorials/lua_tutorials.rst:558
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` which "
"means decode a JSON string, and the parameter is t[2] which is a reference "
"to a JSON string. There's a bit of hard coding here, we're assuming that the "
"second field in the tuple is where the JSON string was inserted. For "
"example, we're assuming a tuple looks like"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:573 ../tutorials/lua_tutorials.rst:568
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:576 ../tutorials/lua_tutorials.rst:571
msgid ""
"meaning that the tuple's first field, the primary key field, is a number "
"while the tuple's second field, the JSON string, is a string. Thus the "
"entire statement means \"decode ``t[2]`` (the tuple's second field) as a "
"JSON string; if there's an error set ``is_valid_json = false``; if there's "
"no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table "
"which has the decoded string\"."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:582 ../tutorials/lua_tutorials.rst:577
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua "
"table that came from the JSON string. The value in field_name, which is the "
"parameter for the whole function, must be a name of a JSON field. For "
"example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": "
"15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole "
"function is invoked with ``sum_json_field(\"Quantity\")``, then "
"``field_value = lua_table[field_name]`` is effectively the same as "
"``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table."
"Quantity``. Those are just three different ways of saying: for the Quantity "
"field in the Lua table, get the value and put it in variable :code:"
"`field_value`."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:592 ../tutorials/lua_tutorials.rst:587
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the "
"JSON field is not a number, or is missing. In that case, the function would "
"be aborted when there was an attempt to add it to the sum. By first checking "
"``type(field_value) == \"number\"``, we avoid that abortion. Anyone who "
"knows that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:598 ../tutorials/lua_tutorials.rst:593
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database that was introduced "
"in :ref:`first database <user_guide_getting_started-first_database>`,"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:602 ../tutorials/lua_tutorials.rst:597
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:609 ../tutorials/lua_tutorials.rst:604
msgid ""
"then add some tuples where the first field is a number and the second field "
"is a string."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:612 ../tutorials/lua_tutorials.rst:607
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:619 ../tutorials/lua_tutorials.rst:614
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and the "
"\"waffle iron\" do not have numeric Quantity fields, so must be ignored. "
"Therefore the real sum of the Quantity field in the JSON strings should be: "
"15 + 7 = 22."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:624 ../tutorials/lua_tutorials.rst:619
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:626 ../tutorials/lua_tutorials.rst:621
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:633 ../tutorials/lua_tutorials.rst:628
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that "
"there might have to be an overflow check if some field values are huge, and "
"that the function should contain a \"yield\" instruction if the count of "
"tuples is huge."
msgstr ""

#: ../tutorials/lua_tutorials.rst:637
msgid "Indexed pattern search"
msgstr "Индексированный поиск по шаблонам"

#: ../doc/tutorials/lua_tutorials.rst:644 ../tutorials/lua_tutorials.rst:639
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the "
"first field of a TREE index. |br| * The function will use `Lua pattern "
"matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which allows "
"\"magic characters\" in regular expressions. |br| * The initial characters "
"in the pattern, as far as the first magic character, will be used as an "
"index search key. For each tuple that is found via the index, there will be "
"a match of the whole pattern. |br| * To be :ref:`cooperative <atomic-"
"cooperative_multitasking>`, the function should yield after every 10 tuples, "
"unless there is a reason to delay yielding. |br| With this function, we can "
"take advantage of Tarantool's indexes for speed, and take advantage of Lua's "
"pattern matching for flexibility. It does everything that an SQL \"LIKE\" "
"search can do, and far more."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:661 ../tutorials/lua_tutorials.rst:656
msgid ""
"Read the following Lua code to see how it works. The comments that begin "
"with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:665 ../tutorials/lua_tutorials.rst:660
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == \".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == \"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too short"
"\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\"\n"
"      number_of_tuples_since_last_yield = number_of_tuples_since_last_yield "
"+ 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set + 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:756 ../tutorials/lua_tutorials.rst:751
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed space_name "
"(a string) and field_no (a number). The requirements are: |br| (a) index "
"type must be \"TREE\" because for other index types (HASH, BITSET, RTREE) a "
"search with iterator=GE will not return strings in order by string value; |"
"br| (b) field_no must be the first index part; |br| (c) the field must "
"contain strings, because for other data types (such as \"unsigned\") pattern "
"searches are not possible; |br| If these requirements are not met by any "
"index, then print an error message and return nil."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:768 ../tutorials/lua_tutorials.rst:763
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has passed "
"pattern (a string). The index search key will be the characters in the "
"pattern as far as the first magic character. Lua's magic characters are % ^ "
"$ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", the period is "
"a magic character and therefore the index search key will be \"ABC\". But "
"there is a complication ... If we see \"%\" followed by a punctuation "
"character, that punctuation character is \"escaped\" so remove the \"%\" "
"when making the index search key. For example, if the pattern is \"AB%$E\", "
"the dollar sign is escaped and therefore the index search key will be \"AB$E"
"\". Finally there is a check that the index search key length must be at "
"least three -- this is an arbitrary number, and in fact zero would be okay, "
"but short index search keys will cause long search times."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:785 ../tutorials/lua_tutorials.rst:780
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return a "
"result set, just as box.space.select would. We will fill it within an outer "
"loop that contains an inner loop. The outer loop's job is to execute the "
"inner loop, and possibly yield, until the search ends. The inner loop's job "
"is to find tuples via the index, and put them in the result set if they "
"match the pattern."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:794 ../tutorials/lua_tutorials.rst:789
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(), "
"see the :ref:`explanation of what index iterators are <box_index-"
"index_pairs>`. Within the inner loop, there will be a local variable named "
"\"tuple\" which contains the latest tuple found via the index search key."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:801 ../tutorials/lua_tutorials.rst:796
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator is "
"GE (Greater or Equal), and we must be more specific: if the search index key "
"has N characters, then the leftmost N characters of the result's index field "
"must not be greater than the search index key. For example, if the search "
"index key is 'ABC', then 'ABCDE' is a potential match, but 'ABD' is a signal "
"that no more matches are possible."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:810 ../tutorials/lua_tutorials.rst:805
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This chunk "
"of code is for cooperative multitasking. The number 10 is arbitrary, and "
"usually a larger number would be okay. The simple rule would be \"after "
"checking 10 tuples, yield, and then resume the search (that is, do the inner "
"loop again) starting after the last value that was found\". However, if the "
"index is non-unique or if there is more than one field in the index, then we "
"might have duplicates -- for example {\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", "
"3}\" -- and it would be difficult to decide which \"ABC\" tuple to resume "
"with. Therefore, if the result's index field is the same as the previous "
"result's index field, there is no break."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:823 ../tutorials/lua_tutorials.rst:818
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare "
"the result's index field to the entire pattern. For example, suppose that "
"the caller passed pattern \"ABC.E\" and there is an indexed field containing "
"\"ABCDE\". Therefore the initial index search key is \"ABC\". Therefore a "
"tuple containing an indexed field with \"ABCDE\" will be found by the "
"iterator, because \"ABCDE\" > \"ABC\". In that case string.match will return "
"a value which is not nil. Therefore this tuple can be added to the result "
"set."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:833 ../tutorials/lua_tutorials.rst:828
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three "
"conditions which will cause a break from the inner loop: (1) the for loop "
"ends naturally because there are no more index keys which are greater than "
"or equal to the index search key, (2) the index key is too great as "
"described in NOTE #5, (3) it is time for a yield as described in NOTE #6. If "
"condition (1) or condition (2) is true, then there is nothing more to do, "
"the outer loop ends too. If and only if condition (3) is true, the outer "
"loop must yield and then continue. If it does continue, then the inner loop "
"-- the iterator search -- will happen again with a new value for the index "
"search key."
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:846 ../tutorials/lua_tutorials.rst:841
msgid "EXAMPLE:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:848 ../tutorials/lua_tutorials.rst:843
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search``, and try the following:"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:854 ../tutorials/lua_tutorials.rst:849
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,"
"parts={2,'string',3,'string'}})\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/tutorials/lua_tutorials.rst:873 ../tutorials/lua_tutorials.rst:868
msgid ""
"tarantool> **indexed_pattern_search(\"t\", 2, \"ABC.E.\")**\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../whats_new.rst:32
msgid ""
"Here is a summary of significant changes introduced in specific versions of "
"Tarantool."
msgstr ""
"Здесь собрана информация о существенных изменениях, которые произошли в "
"конкретных версиях Tarantool'а."

#: ../whats_new.rst:35
msgid ""
"For smaller feature changes and bug fixes, see closed `milestones <https://"
"github.com/tarantool/tarantool/milestones?state=closed>`_ at GitHub."
msgstr ""
"Более мелкие изменения и исправления дефектов указаны в отчетах о "
"`выпущенных стабильных релизах (milestone = closed) <https://github.com/"
"tarantool/tarantool/milestones?state=closed>`_ на GitHub."

#: ../whats_new.rst:43
msgid "What's new in Tarantool 1.7?"
msgstr "Что нового в Tarantool 1.7?"

#: ../whats_new.rst:45
msgid ""
"The disk-based storge engine, which was called `sophia` or `phia` in earlier "
"versions, is superseded by the `vinyl` storage engine."
msgstr ""
"Дисковый движок, который в более ранних версиях Tarantool'а назывался "
"`sophia` и `phia`, заменен новым движком под названием `vinyl`."

#: ../whats_new.rst:48
msgid "There are new types for indexed fields."
msgstr "Добавлены новые типы индексируемых полей."

#: ../whats_new.rst:50
msgid "The LuaJIT version is updated."
msgstr "Обновлена версия LuaJIT."

#: ../whats_new.rst:52
msgid ""
"Automatic replication cluster bootstrap (to make it easier to configure a "
"new replication cluster) is supported."
msgstr ""
"У кластера репликации появилась возможность самонастройки, что существенно "
"упрощает настройку нового кластера."

#: ../whats_new.rst:55
msgid "The ``space_object:inc()`` function is removed."
msgstr "Функция ``space_object:inc()`` объявлена устаревшей."

#: ../whats_new.rst:57
msgid "The ``space_object:dec()`` function is removed."
msgstr "Функция ``space_object:dec()`` объявлена устаревшей."

#: ../book/administration.rst:544
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"

#: ../book/box/box_introspection.rst:34
msgid ""
"The ``box.info`` submodule provides access to information about server "
"variables. Some important ones:"
msgstr ""

#: ../book/box/box_introspection.rst:37
msgid ""
"**server.uuid** holds the unique identifier of the server. This value is "
"also in the :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../book/box/box_introspection.rst:39
msgid ""
"**pid** is the process ID of the server. This value is also shown by the :"
"ref:`tarantool <tarantool-build>` module."
msgstr ""

#: ../book/box/box_introspection.rst:41
msgid ""
"**version** is the Tarantool version. This value is also shown by :ref:"
"`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../book/box/box_introspection.rst:43
msgid "**uptime** is the number of seconds since the server started."
msgstr ""

#: ../book/box/box_introspection.rst:59
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.0-1216-g73f7154\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-66-g9093daa\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:100
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store tuples. This can be used "
"to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../book/box/box_introspection.rst:104
#, python-format
msgid ""
"The display of slabs is broken down by the slab size -- 64-byte, 136-byte, "
"and so on. The example omits the slabs which are empty. The example display "
"is saying that: there are 16 items stored in the 64-byte slab (and 16*64=102 "
"so bytes_used = 1024); there is 1 item stored in the 136-byte slab (and "
"136*1=136 so bytes_used = 136); the arena_used value is the total of all the "
"bytes_used values (1024+136 = 1160); the arena_size value is the arena_used "
"value plus the total of all the bytes_free values (1160+4193200+4194088 = "
"8388448). The arena_size and arena_used values are the amount of the % of :"
"ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` that is already "
"distributed to the slab allocator."
msgstr ""

#: ../book/box/box_introspection.rst:116
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../book/replication.rst:96
msgid ""
"However, once a master failure is detected, the recovery is simple: declare "
"that the replica is now the new master, by saying :codenormal:`box.cfg{... "
"listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are "
"updates on the old master that were not propagated before the old master "
"went down, they would have to be re-applied manually."
msgstr ""
"Но когда сбой уже обнаружен, процедура восстановления проста. Сначала нужно "
"назначить одну из реплик на роль нового главного сервера, задав параметр :"
"codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}"
"`. Затем, если на прежнем главном сервере остались изменения, которые не "
"успели примениться на выбранной реплике перед сбоем, нужно применить эти "
"изменения вручную."

#: ../book/replication.rst:153
msgid ""
"In :ref:`box.info <box_introspection-box_info>` there is a ``box.info."
"replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", "
"\"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", "
"then there will be two more fields: |br| ``box.info.replication.idle`` = the "
"number of seconds the replica has been idle, |br| ``box.info.replication."
"lag`` = the number of seconds the replica is behind the master."
msgstr ""
"В пакете :ref:`box.info <box_introspection-box_info>` есть поле :code:`box."
"info.replication.status`, которое отражает статус репликации для данной "
"реплики: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\" или "
"\"disconnected\". |br| Если реплика имеет статус \"follow\", то можно "
"получить уточняющую информацию из еще двух полей: |br| :code:`box.info."
"replication.idle` = время (в секундах), которое реплика провела в состоянии "
"бездействия, |br| :code:`box.info.replication.lag` = время (в секундах), на "
"которое реплика отстает от главного сервера."

#: ../book/replication.rst:295
msgid ""
"Q: What if advanced users want to understand better how it all works? |br| "
"A: See the description of server startup with replication in the :ref:"
"`Internals <b_internals-replication>` appendix."
msgstr ""
"Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем, "
"как работает репликация? |br| Ответ: См. информацию о запуске сервера с "
"репликацией в Приложении B. :ref:`Детали реализации <b_internals-"
"replication>`."

#: ../book/app_server.rst:164
#, python-format
msgid ""
"/* mycmodule - a simple Tarantool module */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"
msgstr ""
"/* mycmodule - простейший C-модуль для Tarantool'а */\n"
"#include <lua.h>\n"
"#include <lauxlib.h>\n"
"#include <lualib.h>\n"
"#include <tarantool.h>\n"
"static int\n"
"myfun(lua_State *L)\n"
"{\n"
"    if (lua_gettop(L) < 1)\n"
"        return luaL_error(L, \"Usage: myfun(name)\");\n"
"\n"
"    /* Get first argument */\n"
"    const char *name = lua_tostring(L, 1);\n"
"\n"
"    /* Push one result to Lua stack */\n"
"    lua_pushfstring(L, \"Hello, %s\", name);\n"
"    return 1; /* the function returns one result */\n"
"}\n"
"\n"
"LUA_API int\n"
"luaopen_mycmodule(lua_State *L)\n"
"{\n"
"    static const struct luaL_reg reg[] = {\n"
"        { \"myfun\", myfun },\n"
"        { NULL, NULL }\n"
"    };\n"
"    luaL_register(L, \"mycmodule\", reg);\n"
"    return 1;\n"
"}"

#: ../book/cookbook.rst:17
msgid "**hello_world.lua**"
msgstr ""

#: ../book/cookbook.rst:29
msgid "**console_start.lua**"
msgstr ""

#: ../book/cookbook.rst:54
msgid "**fio_read.lua**"
msgstr ""

#: ../book/cookbook.rst:74
msgid "**fio_write.lua**"
msgstr ""

#: ../book/cookbook.rst:94
msgid "**ffi_printf.lua**"
msgstr ""

#: ../book/cookbook.rst:112
msgid "**ffi_gettimeofday.lua**"
msgstr ""

#: ../book/cookbook.rst:140
msgid "**ffi_zlib.lua**"
msgstr ""

#: ../book/cookbook.rst:188
msgid "**ffi_meta.lua**"
msgstr ""

#: ../book/cookbook.rst:222
msgid "**print_arrays.lua**"
msgstr ""

#: ../book/cookbook.rst:244
msgid "**count_array.lua**"
msgstr ""

#: ../book/cookbook.rst:258
msgid "**count_array_with_nils.lua**"
msgstr ""

#: ../book/cookbook.rst:286
msgid "**count_array_with_nulls.lua**"
msgstr ""

#: ../book/cookbook.rst:314
msgid "**count_map.lua**"
msgstr ""

#: ../book/cookbook.rst:329
msgid "**swap.lua**"
msgstr ""

#: ../book/cookbook.rst:344
msgid "**uri.lua**"
msgstr ""

#: ../book/cookbook.rst:365
msgid "**class.lua**"
msgstr ""

#: ../book/cookbook.rst:403
msgid "**garbage.lua**"
msgstr ""

#: ../book/cookbook.rst:416
msgid "**fiber_producer_and_consumer.lua**"
msgstr ""

#: ../book/cookbook.rst:475
msgid "**socket_tcpconnect.lua**"
msgstr ""

#: ../book/cookbook.rst:497
msgid "**socket_tcp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:528
msgid "**getaddrinfo.lua**"
msgstr ""

#: ../book/cookbook.rst:556
msgid "**socket_udp_echo.lua**"
msgstr ""

#: ../book/cookbook.rst:634
msgid "**http_get.lua**"
msgstr ""

#: ../book/cookbook.rst:655
msgid "**http_send.lua**"
msgstr ""

#: ../book/cookbook.rst:675
msgid "**http_server.lua**"
msgstr ""

#: ../book/cookbook.rst:695
msgid "**http_generate_html.lua**"
msgstr ""

#: ../book/box/box_index.rst:90
msgid ""
"This method provides iteration support within an index. The :codeitalic:"
"`bitset-value` or :codeitalic:`search-value` parameter specifies what must "
"match within the index. The :codeitalic:`iterator-type` parameter specifies "
"the rule for matching and ordering. Different index types support different "
"iterators. For example, a TREE index maintains a strict order of keys and "
"can return all tuples in ascending or descending order, starting from the "
"specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../book/box/box_index.rst:117
msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
msgstr ""

#: ../book/box/box_index.rst:118
msgid ":samp:`{iterator-type}` = as defined in tables below."
msgstr ""

#: ../book/box/box_index.rst:120
msgid ""
"this method returns an iterator closure, i.e. a function which can be used "
"to get the next value on each invocation"
msgstr ""

#: ../book/box/box_index.rst:122 ../book/box/box_space.rst:873
msgid "function, tuple"
msgstr ""

#: ../book/box/box_index.rst:124
msgid ""
"Possible errors: Selected iteration type is not supported for the index "
"type, or search value is not supported for the iteration type."
msgstr ""

#: ../book/box/box_index.rst:129
msgid ""
"A search-value can be a number (for example ``1234``), a string (for example "
"``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}"
"``). Each part of a search-value will be compared to each part of an index "
"key."
msgstr ""

#: ../book/box/box_space.rst:303
msgid ""
"the tuples whose primary-key fields are equal to the passed field-values. If "
"the number of passed field-values is less than the number of fields in the "
"primary key, then only the passed field-values are compared, so ``select{1,2}"
"`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../book/box/box_space.rst:802
msgid "Deletes all tuples. ."
msgstr ""

#: ../book/box/box_space.rst:816
msgid "Note re storage engine: vinyl does not support ``truncate()``."
msgstr ""

#: ../book/box/box_space.rst:838
msgid "Note re storage engine: vinyl does not support ``auto_increment()``."
msgstr ""

#: ../book/box/box_space.rst:868
msgid "A helper function to prepare for iterating over all tuples in a space."
msgstr ""

#: ../book/box/box_space.rst:872
msgid ""
"function which can be used in a for/end loop. Within the loop, a value is "
"returned for each iteration."
msgstr ""

#: ../book/box/index.rst:43
msgid ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| SPACE 'tester'                             |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | TUPLE SET 'tester'                     | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Tuple: [ 1 ]                      |  | |\n"
"| | | Tuple: [ 2, 'Music' ]             |  | |\n"
"| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | INDEX 'primary'                        | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Key: 1                            |  | |\n"
"| | | Key: 2                            |  | |\n"
"| | | Key: 3                            |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"
msgstr ""
"+--------------------------------------------+\n"
"|                                            |\n"
"| ПРОСТРАНСТВО 'tester'                      |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Кортеж: [ 1 ]                     |  | |\n"
"| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
"| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | ИНДЕКС 'primary'                       | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Ключ: 1                           |  | |\n"
"| | | Ключ: 2                           |  | |\n"
"| | | Ключ: 3                           |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"

#: ../book/box/index.rst:391
msgid ""
"Details about the WAL writer and the recovery process are in the :ref:"
"`Internals <b_internals>` section."
msgstr ""
"См. подробности о работе потока записи в WAL в разделе  :ref:`Детали "
"реализации <b_internals>`."

#: ../book/box/atomic.rst:157
msgid ""
"Despite their resemblance to implicit yield requests, :ref:`truncate "
"<box_space-truncate>` and :ref:`drop <box_space-drop>` do not cause implicit "
"yield. Despite their resemblance to functions of the fio module, functions "
"of the :ref:`os <os-module>` module do not cause implicit yield. Despite its "
"resemblance to commit, :ref:`rollback <atomic-box_rollback>` does not enable "
"yields."
msgstr ""

#: ../book/box/vinyl.rst:50
msgid ""
"With memtx, for index searches, ``nil`` is considered to be equal to any "
"scalar. |br| With vinyl, ``nil`` or missing parts are not allowed."
msgstr ""

#: ../book/box/vinyl.rst:56
msgid ""
"With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-"
"len>` and :ref:`random() <box_index-random>` and :ref:`auto_increment() "
"<box_space-auto_increment>` and :ref:`truncate() <box_space-truncate>` "
"functions are supported. |br| With vinyl, they are not."
msgstr ""

#: ../book/connectors/index.rst:108
msgid ""
"This chapter has examples that show how to connect to the Tarantool server "
"via the Perl, PHP, Python, and C connectors. The examples contain hard code "
"that will work if and only if the following conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и C. "
"Обратите внимание, что в примерах исходного кода указаны фиксированные "
"значения для элементов тестового окружения, поэтому для корректной работы "
"всех примеров нужно соблюсти следующие условия:"

#: ../book/connectors/__php.rst:5
msgid ""
"The PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-"
"php>`_. It is not supplied as part of the Tarantool repository; it must be "
"installed separately. It can be installed with :program:`git`. It requires "
"other modules which should be installed first. For example, on Ubuntu, the "
"installation could look like this:"
msgstr ""
"Tarantool-коннектор для языка PHP называется `tarantool-php <https://github."
"com/tarantool/tarantool-php>`_. Он устанавливается отдельно от Tarantool'а с "
"помощью :program:`git` и требует предварительной установки еще несколько "
"зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#: ../book/connectors/__php.rst:11
msgid ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"
msgstr ""
"$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"

#: ../book/connectors/__php.rst:25
msgid ""
"At this point there is a file named :file:`~/tarantool-php/modules/tarantool."
"so`. PHP will only find it if the PHP initialization file :file:`php.ini` "
"contains a line like :samp:`extension=./tarantool.so`, or if PHP is started "
"with the option :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."
msgstr ""
"После отработки всех команд будет создан файл с именем :file:`~/tarantool-"
"php/modules/tarantool.so`. PHP увидит его, только если в файле "
"инициализации :file:`php.ini` есть строка вида :samp:`extension=./tarantool."
"so`, либо если при запуске PHP вы укажете опцию :samp:`-d extension=~/"
"tarantool-php/modules/tarantool.so`."

#: ../book/connectors/__php.rst:30
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space "
"named ``examples`` via the PHP API. Before trying to run, check that the "
"server is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste "
"the code into a file named :file:`example.php` and say :samp:`php -d "
"extension=~/tarantool-php/modules/tarantool.so example.php`. The program "
"will open a socket connection with the Tarantool server at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"print \"Insert succeeded\". If the tuple already exists, the program will "
"print “Duplicate key exists in unique index 'primary' in space 'examples'”."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``examples`` с "
"помощью Tarantool API для языка PHP. Перед запуском данной программы "
"проверьте, что ваше тестовое окружение настроено так, как :ref:`описано выше "
"<index-connector_setting>` (у Tarantool-сервера задан порт для прослушивания "
"и в базе создано пространство ``examples``). Чтобы запустить тестовую "
"программу, сохраните ее исходный код в файл с именем :file:`example.php` и "
"выполните команду :samp:`php -d extension=~/tarantool-php/modules/tarantool."
"so example.php`. Программа откроет сокет для соединения с Tarantool-сервером "
"по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — выдаст сообщение \"Insert succeeded\". Если окажется, что такой "
"кортеж уже существует, то программа выдаст сообщение об ошибке “Duplicate "
"key exists in unique index 'primary' in space 'examples'”."

#: ../book/connectors/__php.rst:53
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-php project at "
"GitHub <https://github.com/tarantool/tarantool-php>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь "
"к документации из `проекта tarantool-php на GitHub <https://github.com/"
"tarantool/tarantool-php>`_."

#: ../book/connectors/__python.rst:29
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python project "
"at GitHub <http://github.com/tarantool/tarantool-python>`_. For an example "
"of using Python API with `queue managers for Tarantool <https://github.com/"
"tarantool/queue>`_, see `queue-python project at GitHub <https://github.com/"
"tarantool/queue-python>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, "
"обратитесь к документации из `проекта tarantool-python на GitHub <http://"
"github.com/tarantool/tarantool-python>`_. А на странице `проекта queue-"
"python на GitHub <https://github.com/tarantool/queue-python>`_ вы сможете "
"найти примеры использования Python API для работы с `очередями сообщений в "
"Tarantool'е <https://github.com/tarantool/queue>`_."

#: ../book/user_guide_getting_started.rst:211
msgid "Let's try (d)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../book/user_guide_getting_started.rst:217
msgid "Start the tarantoolctl utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../book/user_guide_getting_started.rst:224
msgid ""
"This means \"use the :ref:`tarantoolctl connect utility <administration-"
"tarantoolctl_connect>` to connect to the Tarantool server that's listening "
"on ``localhost:3301``.\""
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../book/user_guide_getting_started.rst:249
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance. When the testing is over: To "
"drop the space: ``s:drop()``. To stop tarantoolctl: Ctrl+C or Ctrl+D. To "
"stop tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop "
"tarantool (from another terminal): ``sudo pkill -f tarantool``. To destroy "
"the test: ``rm -r ~/tarantool_sandbox``."
msgstr ""
"Вы можете повторно вводить команды :code:`box.space...:insert{}` и :code:"
"`box.space...:select{}` сколько угодно раз, на любом экземпляре Tarantool'а. "
"В конце тестирования воспользуйтесь следующими командами. Чтобы удалить "
"пространство: :code:`s:drop()`. Чтобы остановить  ``tarantoolctl``: Ctrl+C "
"или Ctrl+D. Чтобы остановить Tarantool (альтернативный вариант): :ref:`os."
"exit() <os-exit>`. Чтобы остановить Tarantool (с другого терминала): :code:"
"`sudo pkill -f tarantool`. Чтобы удалить тестовую базу: :code:`rm -r ~/"
"tarantool_sandbox`."

#: ../dev_guide/box_protocol.rst:11
msgid "Notion in diagrams"
msgstr "Обозначения на диаграммах"

#: ../dev_guide/box_protocol.rst:13
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""
"0    X\n"
"+----+\n"
"|    | - X байт\n"
"+----+\n"
" TYPE - тип переменной из библиотеки MsgPack (если это объект из библиотеки "
"MsgPack)\n"
"\n"
"+====+\n"
"|    | - объект из библиотеки MsgPack, динамически изменяемого размера\n"
"+====+\n"
" TYPE - тип переменной из библиотеки MsgPack\n"
"\n"
"+~~~~+\n"
"|    | - массив/сопоставление из библиотеки MsgPack, динамически изменяемого "
"размера\n"
"+~~~~+\n"
" TYPE - тип переменной из библиотеки MsgPack"

#: ../dev_guide/box_protocol.rst:61
msgid ""
"The server begins the dialogue by sending a fixed-size (128 bytes) text "
"greeting to the client. The greeting always contains two 64 byte lines of "
"ASCII text, each line ending with newline character ('\\\\n'). The first "
"line contains the server version and protocol type. The second line contains "
"up to 44 bytes of base64-encoded random string, to use in authentication "
"packet, and ends with up to 23 spaces."
msgstr ""

#: ../dev_guide/box_protocol.rst:81
msgid ""
"Tarantool protocol mandates use of a few integer constants serving as keys "
"in maps used in the protocol. These constants are defined in `src/box/"
"iproto_constants.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/"
"iproto_constants.h>`_"
msgstr ""

#: ../dev_guide/box_protocol.rst:85
msgid "Let's list them here too:"
msgstr ""

#: ../dev_guide/box_protocol.rst:107
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>  ::= 0x01\n"
"<insert>  ::= 0x02\n"
"<replace> ::= 0x03\n"
"<update>  ::= 0x04\n"
"<delete>  ::= 0x05\n"
"<call>    ::= 0x06\n"
"<auth>    ::= 0x07\n"
"<eval>    ::= 0x08\n"
"<upsert>  ::= 0x09\n"
"-- Admin command codes\n"
"<ping>    ::= 0x40\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../dev_guide/box_protocol.rst:154
msgid ""
"They only differ in the allowed set of keys and values, the key defines the "
"type of value that follows. If a body has no keys, entire msgpack map for "
"the body may be missing. Such is the case, for example, in <ping> request. "
"``schema_id`` may be absent in request's header, that means that there'll be "
"no version checking, but it must be present in the response. If "
"``schema_id`` is sent in the header, then it'll be checked."
msgstr ""

#: ../dev_guide/box_protocol.rst:329
msgid ""
"It's an error to specify an argument of a type that differs from expected "
"type."
msgstr ""

#: ../dev_guide/box_protocol.rst:347
msgid "CALL: CODE - 0x06 Call a stored function"
msgstr ""

#: ../dev_guide/box_protocol.rst:427
msgid "We'll show whole packets here:"
msgstr ""

#: ../dev_guide/box_protocol.rst:461
msgid ""
"Error message is present in the response only if there is an error :code:"
"`<error>` expects as value a msgpack string"
msgstr ""

#: ../dev_guide/box_protocol.rst:551
msgid "XLOG and SNAP have the same format. They start with:"
msgstr ""

#: ../dev_guide/box_protocol.rst:553
msgid ""
"SNAP\\n\n"
"0.12\\n\n"
"Server: e6eda543-eda7-4a82-8bf4-7ddd442a9275\\n\n"
"VClock: {1: 0}\\n\n"
"\\n\n"
"..."
msgstr ""

#: ../dev_guide/box_protocol.rst:562
msgid "So, **Header** of an SNAP/XLOG consists of:"
msgstr ""

#: ../dev_guide/box_protocol.rst:564
msgid ""
"<format>\\n\n"
"<format_version>\\n\n"
"Server: <server_uuid>\\n\n"
"VClock: <vclock_map>\\n\n"
"\\n"
msgstr ""

#: ../dev_guide/box_protocol.rst:573
msgid ""
"There are two markers: tuple beginning - **0xd5ba0bab** and EOF marker - "
"**0xd510aded**. So, next, between **Header** and EOF marker there's data "
"with the following schema:"
msgstr ""

#: ../dev_guide/internals.rst:7
msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(INSERT, UPDATE, DELETE, REPLACE) into a write-ahead log (WAL) file in the :"
"ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file is created for "
"every :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>` "
"records. Each data change request gets assigned a continuously growing 64-"
"bit log sequence number. The name of the WAL file is based on the log "
"sequence number of the first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../dev_guide/internals.rst:15
msgid ""
"Apart from a log sequence number and the data change request (its format is "
"the same as in :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>`), each WAL record contains a header, some metadata, and "
"then the data formatted according to `msgpack <https://en.wikipedia.org/wiki/"
"MessagePack>`_ rules. For example this is what the WAL file looks like after "
"the first INSERT request (\"s:insert({1})\") for the introductory sandbox "
"exercise \":ref:`Starting Tarantool and making your first database "
"<user_guide_getting_started-first_database>` “. On the left are the "
"hexadecimal bytes that one would see with:"
msgstr ""

#: ../dev_guide/internals.rst:24
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../dev_guide/internals.rst:28
msgid "and on the right are comments."
msgstr ""

#: ../dev_guide/internals.rst:30
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             File header: \"XLOG\\n\"\n"
"30 2e 31 32 0a             File header: \"0.12\\n\" = version\n"
"...                        (not shown = more header + tuples for system "
"spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5 if version "
"0.12\n"
"19 00                      Length, not including length of header, = 25 "
"bytes\n"
"ce 16 a4 38 6f             Record header: previous crc32, current crc32,\n"
"a7 cc 73 7f 00 00 66 39\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Double\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte "
"first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed "
"array={1}"
msgstr ""

#: ../faq.rst:68
msgid ""
"Who is developing Tarantool? |br| There is an engineering team employed by "
"Mail.Ru -- check out our commit logs on github.com/tarantool. The "
"development is fully open. Most of the connectors' authors, and the "
"maintainers for different distributions, come from the wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда "
"разработки в Mail.Ru — см. историю коммитов на github.com/tarantool. Вся "
"разработка ведется открытым образом. Кроме того, активную роль играют члены "
"сообщества разработчиков Tarantool'а. Их силами было создано большинство "
"коннекторов и ведутся доработки под разные дистрибутивы."

#: ../reference/reference_lua/box.rst:35 ../reference_lua/box.rst:30
msgid ""
"The contents of the ``box`` library can be inspected at runtime with "
"``box``, with no arguments. The submodules inside the box library are: ``box."
"schema``, ``box.tuple``, ``box.space``, ``box.index``, ``box.cfg``, ``box."
"info``, ``box.slab``, ``box.stat``. Every submodule contains one or more Lua "
"functions. A few submodules contain members as well as functions. The "
"functions allow data definition (create alter drop), data manipulation "
"(insert delete update upsert select replace), and introspection (inspecting "
"contents of spaces, accessing server configuration)."
msgstr ""

#: ../reference/reference_lua/clock.rst:59 ../reference_lua/clock.rst:59
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and :ref:`os.clock() <os-clock>`."
msgstr ""

#: ../reference/reference_lua/console.rst:147 ../reference_lua/console.rst:147
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user is "
"using tarantool as a client, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../reference/reference_lua/csv.rst:53 ../reference_lua/csv.rst:53
msgid ""
":samp:`chunk-size = {number}` -- number of characters to read at once "
"(usually for file-IO efficiency), default = 4096"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:32
msgid ""
"In the current version of the binary protocol, error message, which is "
"normally more descriptive than error code, is not present in server "
"response. The actual message may contain a file name, a detailed reason or "
"operating system error code. All such messages, however, are logged in the "
"error log. Below follow only general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:66
#: ../reference_lua/fiber_ipc.rst:66
msgid ""
"If timeout is provided, and the channel doesn't become empty for the "
"duration of the timeout, ``channel:put()`` returns false. Otherwise it "
"returns true."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:83
#: ../reference_lua/fiber_ipc.rst:83
msgid "the value placed on the channel by an earlier ``channel:put()``."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:85
#: ../reference_lua/fiber_ipc.rst:85
msgid "lua_object"
msgstr ""

#: ../reference/reference_lua/jit.rst:28 ../reference_lua/jit.rst:28
msgid "Module `jit`"
msgstr ""

#: ../reference/reference_lua/jit.rst:32 ../reference_lua/jit.rst:32
msgid ""
"The ``jit`` module has functions for tracing the LuaJIT Just-In-Time "
"compiler's progress, showing the byte-code or assembler output that the "
"compiler produces, and in general providing information about what LuaJIT "
"does with Lua code."
msgstr ""

#: ../reference/reference_lua/jit.rst:38 ../reference_lua/jit.rst:38
msgid "Prints the byte code of a function."
msgstr ""

#: ../reference/reference_lua/jit.rst:42 ../reference_lua/jit.rst:42
msgid ""
"function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../reference/reference_lua/jit.rst:49 ../reference_lua/jit.rst:49
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:53 ../reference_lua/jit.rst:53
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../reference/reference_lua/jit.rst:57 ../reference_lua/jit.rst:57
msgid ""
"-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../reference/reference_lua/jit.rst:62 ../reference_lua/jit.rst:62
msgid ""
"For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:66 ../reference_lua/jit.rst:66
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../reference/reference_lua/jit.rst:70 ../reference_lua/jit.rst:70
msgid ""
"-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../reference/reference_lua/jit.rst:75 ../reference_lua/jit.rst:75
msgid ""
"For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:80 ../reference_lua/jit.rst:80
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../reference/reference_lua/jit.rst:84 ../reference_lua/jit.rst:84
msgid ""
"-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../reference/reference_lua/jit.rst:95 ../reference_lua/jit.rst:95
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:101 ../reference_lua/jit.rst:101
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../reference/reference_lua/jit.rst:105 ../reference_lua/jit.rst:105
msgid ""
"-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../reference/reference_lua/jit.rst:116 ../reference_lua/jit.rst:116
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../reference/reference_lua/net_box.rst:32 ../reference_lua/net_box.rst:32
msgid ""
"The ``net.box`` module contains connectors to remote database systems. One "
"variant, to be discussed later, is for connecting to MySQL or MariaDB or "
"PostgreSQL — that variant is the subject of the :ref:`SQL DBMS modules "
"<dbms_modules>` appendix. In this section the subject is the built-in "
"variant, ``net.box``. This is for connecting to tarantool servers via a "
"network."
msgstr ""

#: ../reference/reference_lua/net_box.rst:38 ../reference_lua/net_box.rst:38
msgid ""
"Call ``require('net.box')`` to get a ``net.box`` object, which will be "
"called ``net_box`` for examples in this section. Call ``net_box.new()`` to "
"connect and get a connection object, which will be called ``conn`` for "
"examples in this section. Call the other ``net.box()`` routines, passing "
"``conn:``, to execute requests on the remote box. Call :ref:`conn:close "
"<socket-close>` to disconnect."
msgstr ""

#: ../reference/reference_lua/net_box.rst:44 ../reference_lua/net_box.rst:44
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and use "
"the same connection object across multiple concurrent fibers. In fact, it's "
"perhaps the best programming practice with Tarantool. When multiple fibers "
"use the same connection, all requests are pipelined through the same network "
"socket, but each fiber gets back a correct response. Reducing the number of "
"active sockets lowers the overhead of system calls and increases the overall "
"server performance. There are, however, cases when a single connection is "
"not enough — for example when it's necessary to prioritize requests or to "
"use different authentication ids."
msgstr ""

#: ../reference/reference_lua/net_box.rst:57 ../reference_lua/net_box.rst:57
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It is re-established automatically after a "
"disconnect. The returned ``conn`` object supports methods for making remote "
"requests, such as select, update or delete."
msgstr ""

#: ../reference/reference_lua/net_box.rst:62 ../reference_lua/net_box.rst:62
msgid ""
"For the local tarantool server there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = {net_box}."
"self`. However, there is an important difference between the embedded "
"connection and a remote one. With the embedded connection, requests which do "
"not modify data do not yield. When using a remote connection, due to :ref:"
"`the implicit rules <atomic-the_implicit_yield_rules>` any request can "
"yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../reference/reference_lua/net_box.rst:73 ../reference_lua/net_box.rst:73
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../reference/reference_lua/net_box.rst:79 ../reference_lua/net_box.rst:79
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../reference/reference_lua/net_box.rst:149 ../reference_lua/net_box.rst:149
msgid ""
"due to :ref:`the implicit yield rules <atomic-the_implicit_yield_rules>` a "
"local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but "
"a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a remote :"
"samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../reference/reference_lua/net_box.rst:236 ../reference_lua/net_box.rst:236
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../reference/reference_lua/net_box.rst:238 ../reference_lua/net_box.rst:238
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary key. "
"Assume that the database is nearly empty. Assume that the tarantool server "
"is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../reference/reference_lua/os.rst:30 ../reference_lua/os.rst:30
msgid "Module `os`"
msgstr ""

#: ../reference/reference_lua/os.rst:34 ../reference_lua/os.rst:34
msgid ""
"The os module contains the functions :ref:`execute() <os-execute>`, :ref:"
"`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-"
"remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-"
"time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`. Most of "
"these functions are described in the Lua manual Chapter 22 `The Operating "
"System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../reference/reference_lua/os.rst:51 ../reference_lua/os.rst:51
msgid "Execute by passing to the shell."
msgstr ""

#: ../reference/reference_lua/os.rst:53 ../reference_lua/os.rst:53
msgid "what to execute."
msgstr ""

#: ../reference/reference_lua/os.rst:57 ../reference_lua/os.rst:57
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:73 ../reference_lua/os.rst:73
msgid "Rename a file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:75 ../reference_lua/os.rst:75
msgid "name of existing file or directory,"
msgstr ""

#: ../reference/reference_lua/os.rst:76 ../reference_lua/os.rst:76
msgid "changed name of file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:80 ../reference_lua/os.rst:80
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:93 ../reference_lua/os.rst:93
msgid "Get environment variable."
msgstr ""

#: ../reference/reference_lua/os.rst:95 ../reference_lua/os.rst:95
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../reference/reference_lua/os.rst:99 ../reference_lua/os.rst:99
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:110 ../reference_lua/os.rst:110
msgid "Remove file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:112 ../reference_lua/os.rst:112
msgid ""
"Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../reference/reference_lua/os.rst:116 ../reference_lua/os.rst:116
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:127 ../reference_lua/os.rst:127
msgid "Return a formatted date."
msgstr ""

#: ../reference/reference_lua/os.rst:129 ../reference_lua/os.rst:129
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-epoch "
"= number of seconds since 1970-01-01. If time-since-epoch is omitted, it is "
"assumed to be the current time."
msgstr ""

#: ../reference/reference_lua/os.rst:134 ../reference_lua/os.rst:134
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:145 ../reference_lua/os.rst:145
msgid "Exit the program. If this is done on the server, then the server stops."
msgstr ""

#: ../reference/reference_lua/os.rst:149 ../reference_lua/os.rst:149
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../reference/reference_lua/os.rst:158 ../reference_lua/os.rst:158
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../reference/reference_lua/os.rst:162 ../reference_lua/os.rst:162
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:173 ../reference_lua/os.rst:173
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../reference/reference_lua/os.rst:177 ../reference_lua/os.rst:177
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:188 ../reference_lua/os.rst:188
msgid "Return a name for a temporary file."
msgstr ""

#: ../reference/reference_lua/os.rst:192 ../reference_lua/os.rst:192
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../reference/reference_lua/socket.rst:155 ../reference_lua/socket.rst:154
msgid "tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../reference/reference_lua/socket.rst:194 ../reference_lua/socket.rst:193
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that "
"can accept connections. Usually the same objective is accomplished with "
"``box.cfg{listen=...)``."
msgstr ""

#: ../reference/reference_lua/socket.rst:200 ../reference_lua/socket.rst:199
msgid "socket.tcp_server('localhost', 3302, function () end)"
msgstr ""

#: ../reference/reference_lua/socket.rst:289 ../reference_lua/socket.rst:288
msgid ""
"maximum number of bytes to read for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../reference/reference_lua/socket.rst:306 ../reference_lua/socket.rst:305
msgid ""
"Return all available data from the socket buffer if non-blocking. Rarely "
"used. For details see `this description`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:547 ../reference_lua/socket.rst:546
msgid ""
"In this example a connection is made over the internet between the Tarantool "
"server and tarantool.org, then an HTTP \"head\" message is sent, and a "
"response is received: \"``HTTP/1.1 200 OK``\". This is not a useful way to "
"communicate with this particular site, but shows that the system works."
msgstr ""

#: ../reference/reference_lua/socket.rst:552 ../reference_lua/socket.rst:551
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0rnHost: tarantool.orgrnrn\")\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- \"HTTP/1.1 200 OKrn\"\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/tarantool.rst:38
#: ../reference_lua/tarantool.rst:38
msgid ""
"Additionally one can see the uptime and the server version and the process "
"id. Those information items can also be accessed with :ref:`box.info "
"<box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../reference_lua/csv.rst:183
msgid ""
"Form a Lua iterator function for going through CSV records one field at a "
"time."
msgstr ""

#: ../reference_lua/fiber.rst:369
msgid ""
"Local storage within the fiber. The storage can contain any number of named "
"values, subject to memory limitations. Naming may be done with :samp:"
"`{fiber_object}.storage.{name}` or :samp:`fiber_object}.storage['{name}'].` "
"or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be "
"either numbers or strings. The storage is garbage-collected when :samp:"
"`{fiber_object}:cancel()` happens."
msgstr ""

#: ../reference_lua/index.rst:28
msgid "Lua reference"
msgstr "Справочник по Lua API"

#: ../reference_rock/index.rst:29
msgid "Lua rocks reference"
msgstr "Справочник по Lua rocks"

#: ../reference_rock/index.rst:31
msgid "A module is an optional library which enhances Tarantool functionality."
msgstr ""

#: ../reference_rock/index.rst:33
msgid ""
"For examples of creating one's own module with Lua or C, see `this link`_."
msgstr ""

#: ../tutorials/lua_tutorials.rst:174
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal 'Hello "
"world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../tutorials/lua_tutorials.rst:411
msgid ""
"The :ref:`os.clock() <os-clock>` function will return the number of CPU "
"seconds since the start. Therefore, by getting start_time = number of "
"seconds just before the inserting, and then getting end_time = number of "
"seconds just after the inserting, we can calculate (end_time - start_time) = "
"elapsed time in seconds. We will display that value by putting it in a "
"request without any assignments, which causes Tarantool to send the value to "
"the client, which prints it. (Lua's answer to the C ``printf()`` function, "
"which is ``print()``, will also work.)"
msgstr ""

#~ msgid ""
#~ "The two ordinary index types are 'tree' which is the default, and 'hash' "
#~ "which must be unique and which may be faster or smaller. The third type "
#~ "is 'bitset' which is not unique and which works best for combinations of "
#~ "binary values. The fourth type is 'rtree' which is not unique and which "
#~ "works with arrays, instead of 'string' or 'unsigned' values."
#~ msgstr ""
#~ "Чаще всего индекс — это дерево (по умолчанию) или хеш (в этом случае "
#~ "индекс должен быть уникальным; в определенных случаях такой индекс "
#~ "занимает меньше места и поиск по нему работает быстрее). Третий тип "
#~ "индекса — это набор битов (bitset); это неуникальный индекс, "
#~ "предназначенный для работы с различными бинарными значениями. Четвертый "
#~ "тип индекса — это R-дерево; это тоже неуникальный индекс, предназначенный "
#~ "для работы с массивами, а не со строками или беззнаковыми числами."

#~ msgid ""
#~ "**To review...** If you followed all the instructions in this chapter, "
#~ "then so far you have: installed Tarantool from either a binary or a "
#~ "source repository, started up the Tarantool server, inserted and selected "
#~ "tuples."
#~ msgstr ""
#~ "Если вы выполнили все инструкции из этой главы, то к данному моменту вы "
#~ "уже установили Tarantool (из бинарного пакета, либо из исходных файлов), "
#~ "запустили Tarantool-сервер, а также выполнили вставку и выборку кортежей."

#~ msgid "Contributing"
#~ msgstr "Руководство разработчика"

#~ msgid "What documentation there is"
#~ msgstr "Состав документации"

#~ msgid ""
#~ "**Tarantool's disk-based storage engine** is a fusion of ideas from "
#~ "modern filesystems, log-structured merge trees and classical B-trees. All "
#~ "data is organized into **runs**. Each run is represented by a file on "
#~ "disk. Run size is a configuration option and normally is around 64MB. "
#~ "Each run is a collection of pages, serving different purposes. Pages in a "
#~ "fully merged run contain non-overlapping ranges of keys. A run can be "
#~ "partially merged if there were a lot of changes in its key range "
#~ "recently. In that case some pages represent new keys and values in the "
#~ "run. The disk-based storage engine is append only: new data never "
#~ "overwrites old data. The disk-based storage engine is named :ref:`vinyl "
#~ "<index-vinyl>`."
#~ msgstr ""
#~ "**Дисковый движок** (:ref:`vinyl <index-vinyl>`) совмещает в себе "
#~ "подходы, заимствованные из современных файловых систем, журналируемых "
#~ "merge-деверьев (log-structured merge trees) и классических B-деревьев. "
#~ "Все данные в этом движке разбиты по забегам (runs), где каждый забег "
#~ "представляет собой файл на диске. Максимальный размер забега обычно равен "
#~ "64МБ, и его можно настраивать. Каждый забег — это набор страниц, которые "
#~ "нужны для каких-то целей. Если забег полностью смержен, то диапазоны "
#~ "ключей на его страницах не пересекаются. Если же диапазоны ключей в "
#~ "забеге в какой-то момент сильно изменялись, то мы имеем дело с частично "
#~ "смерженным забегом. В этом случае на некоторых страницах появились новые "
#~ "ключи и значения, которых ранее не было в данном забеге. Дисковый движок "
#~ "обновляет данные по принципу дописывания в конец: новые данные никогда не "
#~ "затирают старые."
