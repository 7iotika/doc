# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-23 12:27+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../reference/configuration/cfg_basic.rst:29
#: ../reference/configuration/cfg_basic.rst:4
msgid "Run the server as a background task. The :ref:`logger <cfg_logging-logger>` and :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for this to work."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:32
#: ../reference/configuration/cfg_basic.rst:40
#: ../reference/configuration/cfg_basic.rst:7
#: ../reference/configuration/cfg_basic.rst:15
msgid "Type: boolean |br| Default: false |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:38
#: ../reference/configuration/cfg_basic.rst:13
msgid "Deprecated. Do not use."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:48
#: ../reference/configuration/cfg_basic.rst:23
msgid "Add the given string to the server's :ref:`Process title <administration-proctitle>` (what’s shown in the COMMAND column for :samp:`ps -ef` and :samp:`top -c` commands)."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:51
#: ../reference/configuration/cfg_basic.rst:26
msgid "For example, ordinarily :samp:`ps -ef` shows the Tarantool server process thus:"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:53
#: ../reference/configuration/cfg_basic.rst:28
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:58
#: ../reference/configuration/cfg_basic.rst:33
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:61
#: ../reference/configuration/cfg_basic.rst:36
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:66
#: ../reference/configuration/cfg_basic.rst:41
msgid "Type: string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:74
#: ../reference/configuration/cfg_basic.rst:49
msgid "The read/write data port number or :ref:`URI <index-uri>` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use the :ref:`“admin port” <administration-admin_ports>`. Connections made with :samp:`listen={URI}` are sometimes called \"binary protocol\" or \"primary port\" connections."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:79
#: ../reference/configuration/cfg_basic.rst:54
msgid "A typical value is 3301. The listen parameter may also be set for local hot standby."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:84
#: ../reference/configuration/cfg_basic.rst:59
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:87
#: ../reference/configuration/cfg_basic.rst:62
msgid "Type: integer or string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:95
#: ../reference/configuration/cfg_basic.rst:70
msgid "Store the process id in this file. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:98
#: ../reference/configuration/cfg_basic.rst:140
#: ../reference/configuration/cfg_basic.rst:171
#: ../reference/configuration/cfg_logging.rst:113
#: ../reference/configuration/cfg_basic.rst:73
#: ../reference/configuration/cfg_basic.rst:115
#: ../reference/configuration/cfg_basic.rst:146
#: ../reference/configuration/cfg_logging.rst:88
msgid "Type: string |br| Default: null |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:106
#: ../reference/configuration/cfg_basic.rst:81
msgid "Put the server in read-only mode. After this, any requests that try to change data will fail with error ER_READONLY."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:109
#: ../reference/configuration/cfg_basic.rst:84
msgid "Type: boolean |br| Default: false |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:117
#: ../reference/configuration/cfg_basic.rst:92
msgid "A directory where snapshot (.snap) files will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to work_dir. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:121
#: ../reference/configuration/cfg_basic.rst:132
#: ../reference/configuration/cfg_basic.rst:154
#: ../reference/configuration/cfg_basic.rst:96
#: ../reference/configuration/cfg_basic.rst:107
#: ../reference/configuration/cfg_basic.rst:129
msgid "Type: string |br| Default: \".\" |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_basic.rst:129
#: ../reference/configuration/cfg_basic.rst:104
msgid "A directory where vinyl files or subdirectories will be stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to work_dir."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:138
#: ../reference/configuration/cfg_basic.rst:113
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:148
#: ../reference/configuration/cfg_basic.rst:123
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes wal_dir and :ref:`snap_dir <cfg_basic-snap_dir>` are specified with different values, so that write-ahead log files and snapshot files can be stored on different disks. If not specified, defaults to work_dir."
msgstr ""

#: ../reference/configuration/cfg_basic.rst:162
#: ../reference/configuration/cfg_basic.rst:137
msgid "A directory where database working files will be stored. The server switches to work_dir with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory. Other directory parameters may be relative to work_dir, for example |br| :codenormal:`box.cfg{work_dir='/home/user/A',wal_dir='B',snap_dir='C'}` |br| will put xlog files in /home/user/A/B, snapshot files in /home/user/A/C, and all other files or subdirectories in /home/user/A."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:1
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:1
msgid ":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-panic_on_snap_error>`, |br| :ref:`panic_on_wal_error <cfg_binary_logging_snapshots-panic_on_wal_error>`, |br| :ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`, |br| :ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-snap_io_rate_limit>`, |br| :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`, |br| :ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-wal_dir_rescan_delay>` |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:37
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:12
msgid "If there is an error while reading the snapshot file (at server start), abort."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:40
#: ../reference/configuration/cfg_logging.rst:127
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:15
#: ../reference/configuration/cfg_logging.rst:102
msgid "Type: boolean |br| Default: true |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:48
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:23
msgid "If there is an error while reading a write-ahead log file (at server start or to relay to a replica), abort."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:51
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:26
msgid "Type: boolean |br| Default: true |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:59
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:34
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:64
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:39
msgid "Type: integer |br| Default: 500000 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:72
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:47
msgid "Reduce the throttling effect of :ref:`box.snapshot <admin-snapshot>` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`snap_dir <cfg_basic-snap_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:78
#: ../reference/configuration/cfg_networking.rst:38
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:53
#: ../reference/configuration/cfg_networking.rst:13
msgid "Type: float |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:86
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:61
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:88
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:63
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:89
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid "``write``: fibers wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:91
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:66
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:94
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:69
msgid "Type: string |br| Default: \"write\" |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:102
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:77
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of replication or local hot standby."
msgstr ""

#: ../reference/configuration/cfg_binary_logging_snapshots.rst:106
#: ../reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "Type: float |br| Default: 2 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:30
#: ../reference/configuration/cfg_logging.rst:5
msgid "How verbose the logging is. There are six log verbosity classes:"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:32
#: ../reference/configuration/cfg_logging.rst:7
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:33
#: ../reference/configuration/cfg_logging.rst:8
msgid "2 – ``ERROR``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:34
#: ../reference/configuration/cfg_logging.rst:9
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:35
#: ../reference/configuration/cfg_logging.rst:10
msgid "4 – ``WARNING``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:36
#: ../reference/configuration/cfg_logging.rst:11
msgid "5 – ``INFO``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:37
#: ../reference/configuration/cfg_logging.rst:12
msgid "6 – ``DEBUG``"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:39
#: ../reference/configuration/cfg_logging.rst:14
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`logger <cfg_logging-logger>` configuration parameter."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:44
#: ../reference/configuration/cfg_logging.rst:19
msgid "Type: integer |br| Default: 5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:52
#: ../reference/configuration/cfg_logging.rst:27
msgid "By default, the log is sent to the standard error stream (``stderr``). If ``logger`` is specified, the log is sent to a file, or to a pipe, or to the system logger."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:56
#: ../reference/configuration/cfg_logging.rst:68
#: ../reference/configuration/cfg_logging.rst:82
#: ../reference/configuration/cfg_logging.rst:31
#: ../reference/configuration/cfg_logging.rst:43
#: ../reference/configuration/cfg_logging.rst:57
msgid "Example setting:"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:58
#: ../reference/configuration/cfg_logging.rst:33
msgid "box.cfg{logger = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'file: tarantool.log'}"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:64
#: ../reference/configuration/cfg_logging.rst:39
msgid "This will open the file ``tarantool.log`` for output on the server’s default directory. If the ``logger`` string has no prefix or has the prefix \"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:70
#: ../reference/configuration/cfg_logging.rst:45
msgid "box.cfg{logger = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{logger = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:76
#: ../reference/configuration/cfg_logging.rst:51
msgid "This will start the program ``cronolog`` when the server starts, and will send all log messages to the standard input (``stdin``) of cronolog. If the ``logger`` string begins with '|' or has the prefix \"pipe:\", then the string is interpreted as a Unix `pipeline <https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:84
#: ../reference/configuration/cfg_logging.rst:59
msgid "box.cfg{logger = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{logger = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:92
#: ../reference/configuration/cfg_logging.rst:67
msgid "If the ``logger`` string has the prefix \"syslog:\", then the string is interpreted as a message for the `syslogd <http://www.rfc-base.org/txt/rfc-5424.txt>`_ program which normally is running in the background of any Unix-like platform. One can optionally specify an ``identity``, a ``facility``, or both. The ``identity`` is an arbitrary string, default value = ``tarantool``, which will be placed at the beginning of all messages. The facility is an abbreviation for the name of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ facilities, default value = ``user``, which tell syslogd where the message should go."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:103
#: ../reference/configuration/cfg_logging.rst:78
msgid "Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:107
#: ../reference/configuration/cfg_logging.rst:82
msgid "The ``facility`` setting is currently ignored but will be used in the future."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:109
#: ../reference/configuration/cfg_logging.rst:84
msgid "When logging to a file, tarantool reopens the log on SIGHUP. When log is a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:121
#: ../reference/configuration/cfg_logging.rst:96
msgid "If ``logger_nonblock`` equals true, Tarantool does not block on the log file descriptor when it’s not ready for write, and drops the message instead. If :ref:`log_level <cfg_logging-log_level>` is high, and a lot of messages go to the log file, setting ``logger_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:135
#: ../reference/configuration/cfg_logging.rst:110
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :ref:`log_level <cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:139
#: ../reference/configuration/cfg_logging.rst:114
msgid "Type: float |br| Default: 0.5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:145
#: ../reference/configuration/cfg_logging.rst:120
msgid "**Logging example:**"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:147
#: ../reference/configuration/cfg_logging.rst:122
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server is writing to a log and signals are used when archiving it."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:150
#: ../reference/configuration/cfg_logging.rst:125
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:152
#: ../reference/configuration/cfg_logging.rst:127
msgid "On Terminal #1: start an interactive Tarantool session, then say the logging will go to `Log_file`, then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:155
#: ../reference/configuration/cfg_logging.rst:130
msgid "box.cfg{logger='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:161
#: ../reference/configuration/cfg_logging.rst:136
msgid "On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. The result of this is: the next log message will go to `Log_file.bak`. |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:167
#: ../reference/configuration/cfg_logging.rst:846
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:169
#: ../reference/configuration/cfg_logging.rst:144
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file. |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:171
#: ../reference/configuration/cfg_logging.rst:146
msgid "log.info('Log Line #2')"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:175
#: ../reference/configuration/cfg_logging.rst:150
msgid "On Terminal #2: use ``ps`` to find the process ID of the Tarantool server. |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:180
#: ../reference/configuration/cfg_logging.rst:859
msgid "ps -A | grep tarantool"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:182
#: ../reference/configuration/cfg_logging.rst:157
msgid "On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the Tarantool server. The result of this is: Tarantool will open `Log_file` again, and the next log message will go to `Log_file`. (The same effect could be accomplished by executing log.rotate() on the server.) |br|"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:190
#: ../reference/configuration/cfg_logging.rst:869
msgid "kill -HUP *process_id*"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:192
#: ../reference/configuration/cfg_logging.rst:167
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../reference/configuration/cfg_logging.rst:194
#: ../reference/configuration/cfg_logging.rst:169
msgid "log.info('Log Line #3')"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:198
#: ../reference/configuration/cfg_logging.rst:173
msgid "On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:204
#: ../reference/configuration/cfg_logging.rst:883
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:207
#: ../reference/configuration/cfg_logging.rst:182
msgid "and `Log_file` will have"
msgstr ""

#: ../reference/configuration/cfg_logging.rst:212
#: ../internal padding after reference/configuration/cfg_logging.rst:891
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../reference/configuration/cfg_networking.rst:1
#: ../reference/configuration/cfg_networking.rst:1
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`, |br| :ref:`readahead <cfg_networking-readahead>`  |br|"
msgstr ""

#: ../reference/configuration/cfg_networking.rst:33
#: ../reference/configuration/cfg_networking.rst:8
msgid "The server will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../reference/configuration/cfg_networking.rst:46
#: ../reference/configuration/cfg_networking.rst:21
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../reference/configuration/cfg_networking.rst:55
#: ../reference/configuration/cfg_networking.rst:30
msgid "Type: integer |br| Default: 16320 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_replication.rst:30
#: ../reference/configuration/cfg_replication.rst:5
msgid "If replication_source is not an empty string, the server is considered to be a Tarantool :ref:`replica <index-box_replication>`. The replica server will try to connect to the master which replication_source specifies with a :ref:`URI <index-uri>` (Universal Resource Identifier), for example :samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`."
msgstr ""

#: ../reference/configuration/cfg_replication.rst:35
#: ../reference/configuration/cfg_replication.rst:10
msgid "If there is more than one replication source in a cluster, specify an array of URIs, for example |br| :codenormal:`box.cfg{replication_source = {`:codeitalic:`uri#1,uri#2`:codenormal:`}}` |br|"
msgstr ""

#: ../reference/configuration/cfg_replication.rst:39
#: ../reference/configuration/cfg_replication.rst:14
msgid "If one of the URIs is \"self\" -- that is, if one of the URIs is for the same server that :codenormal:`box.cfg{}` is being executed on -- then it is ignored. Thus it is possible to use the same replication_source specification on multiple servers."
msgstr ""

#: ../reference/configuration/cfg_replication.rst:44
#: ../reference/configuration/cfg_replication.rst:19
msgid "The default user name is ‘guest’. A replica server does not accept data-change requests on the :ref:`listen <cfg_basic-listen>` port. The replication_source parameter is dynamic, that is, to enter master mode, simply set replication_source to an empty string and issue :code:`box.cfg{replication_source=`:samp:`{new-value}`:code:`}`."
msgstr ""

#: ../reference/configuration/cfg_replication.rst:50
#: ../reference/configuration/cfg_replication.rst:25
msgid "Type: string |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:27
#: ../reference/configuration/cfg_snapshot_daemon.rst:2
msgid "The snapshot daemon is a fiber which is constantly running. At intervals, it may make new snapshot (.snap) files and then may remove old snapshot files. If the snapshot daemon removes an old snapshot file, it will also remove any write-ahead log (.xlog) files that are older than the snapshot file and contain information that is present in the snapshot file."
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:35
#: ../reference/configuration/cfg_snapshot_daemon.rst:10
msgid "The :ref:`snapshot_period <cfg_snapshot_daemon-snapshot_period>` and :ref:`snapshot_count <cfg_snapshot_daemon-snapshot_count>` configuration settings determine how long the intervals are, and how many snapshots should exist before removals occur."
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:44
#: ../reference/configuration/cfg_snapshot_daemon.rst:19
msgid "The interval between actions by the snapshot daemon, in seconds. If ``snapshot_period`` is set to a value greater than zero, and there is activity which causes change to a database, then the snapshot daemon will call :ref:`box.snapshot <admin-snapshot>` every ``snapshot_period`` seconds, creating a new snapshot file each time."
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:50
#: ../reference/configuration/cfg_snapshot_daemon.rst:25
msgid "For example: ``box.cfg{snapshot_period=3600}`` will cause the snapshot daemon to create a new database snapshot once per hour."
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:54
#: ../reference/configuration/cfg_snapshot_daemon.rst:29
msgid "Type: integer |br| Default: 0 |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:62
#: ../reference/configuration/cfg_snapshot_daemon.rst:37
msgid "The maximum number of snapshots that may exist on the snap_dir directory before the snapshot daemon will remove old snapshots. If snapshot_count equals zero, then the snapshot daemon does not remove old snapshots. For example:"
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:68
#: ../reference/configuration/cfg_snapshot_daemon.rst:43
msgid "box.cfg{\n"
"    snapshot_period = 3600,\n"
"    snapshot_count  = 10\n"
"}"
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:75
#: ../reference/configuration/cfg_snapshot_daemon.rst:50
msgid "will cause the snapshot daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will remove the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../reference/configuration/cfg_snapshot_daemon.rst:80
#: ../reference/configuration/cfg_snapshot_daemon.rst:55
msgid "Type: integer |br| Default: 6 |br| Dynamic: yes |br|"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:30
#: ../reference/configuration/cfg_storage.rst:5
msgid "How much memory Tarantool allocates to actually store tuples, in gigabytes. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../reference/configuration/cfg_storage.rst:37
#: ../reference/configuration/cfg_storage.rst:12
msgid "Type: float |br| Default: 1.0 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:45
#: ../reference/configuration/cfg_storage.rst:20
msgid "Use slab_alloc_factor as the multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../reference/configuration/cfg_storage.rst:50
#: ../reference/configuration/cfg_storage.rst:25
msgid "Type: float |br| Default: 1.1 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:58
#: ../reference/configuration/cfg_storage.rst:33
msgid "Size of the largest allocation unit. It can be increased if it is necessary to store large tuples."
msgstr ""

#: ../reference/configuration/cfg_storage.rst:61
#: ../reference/configuration/cfg_storage.rst:36
msgid "Type: integer |br| Default: 1048576 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:69
#: ../reference/configuration/cfg_storage.rst:44
msgid "Size of the smallest allocation unit. It can be decreased if most of the tuples are very small. The value must be between 8 and 1048280 inclusive."
msgstr ""

#: ../reference/configuration/cfg_storage.rst:72
#: ../reference/configuration/cfg_storage.rst:47
msgid "Type: integer |br| Default: 16 |br| Dynamic: no |br|"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:80
#: ../reference/configuration/cfg_storage.rst:55
msgid "The default vinyl configuration can be changed with"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:85
#: ../reference/configuration/cfg_storage.rst:433
msgid "vinyl = {\n"
"  run_age_wm = *number*,\n"
"  run_age_period = *number of seconds*,\n"
"  memory_limit = *number of gigabytes*,\n"
"  compact_wm = *number*,\n"
"  threads = *number*,\n"
"  run_age = *number*,\n"
"  run_prio = *number*,\n"
"}"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:95
#: ../reference/configuration/cfg_storage.rst:70
msgid "This method may change in the future."
msgstr ""

#: ../reference/configuration/cfg_storage.rst:97
#: ../reference/configuration/cfg_storage.rst:72
msgid "Default values are:"
msgstr ""

#: ../reference/configuration/cfg_storage.rst:102
#: ../reference/configuration/cfg_storage.rst:450
msgid "vinyl = {\n"
"  run_age_wm = 0,\n"
"  run_age_period = 0,\n"
"  memory_limit = 1,\n"
"  compact_wm = 2,\n"
"  threads = 5,\n"
"  run_age = 0,\n"
"  run_prio = 2,\n"
"}"
msgstr ""

#: ../reference/configuration/index.rst:30
msgid "Configuration reference"
msgstr ""

#: ../reference/configuration/index.rst:32
msgid "This reference covers all options and parameters which can be set for Tarantool on the command line or in an initialization file."
msgstr ""

#: ../reference/configuration/index.rst:35
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../reference/configuration/index.rst:40
msgid "$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../reference/configuration/index.rst:48
msgid "Command options"
msgstr ""

#: ../reference/configuration/index.rst:52
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../reference/configuration/index.rst:58
msgid "Print product name and version, for example:"
msgstr ""

#: ../reference/configuration/index.rst:60
msgid "$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../reference/configuration/index.rst:67
msgid "In this example:"
msgstr ""

#: ../reference/configuration/index.rst:69
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../reference/configuration/index.rst:72
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../reference/configuration/index.rst:80
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../reference/configuration/index.rst:85
msgid "Tarantool uses `git describe <http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository <http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../reference/configuration/index.rst:95
msgid "URI"
msgstr ""

#: ../reference/configuration/index.rst:97
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema <http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or '[::]' is assumed, meaning respectively any IPv4 address or any IPv6 address, on the local machine. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../reference/configuration/index.rst:116
msgid "URI fragment"
msgstr ""

#: ../reference/configuration/index.rst:116
#: ../reference/reference_lua/digest.rst:221
#: ../reference/reference_lua/fiber_ipc.rst:131
#: ../reference/reference_lua/log.rst:66
#: ../reference/reference_lua/msgpack.rst:65
#: ../reference/reference_lua/socket.rst:541
#: ../reference/reference_lua/tap.rst:202
#: ../reference/reference_lua/uuid.rst:135
#: ../reference/reference_lua/yaml.rst:61
#: ../reference/reference_rock/dbms.rst:275
#: ../reference/reference_rock/dbms.rst:619
msgid "Example"
msgstr ""

#: ../reference/configuration/index.rst:118
msgid "port"
msgstr ""

#: ../reference/configuration/index.rst:118
msgid "3301"
msgstr ""

#: ../reference/configuration/index.rst:120
msgid "host:port"
msgstr ""

#: ../reference/configuration/index.rst:120
msgid "127.0.0.1:3301"
msgstr ""

#: ../reference/configuration/index.rst:122
msgid "username:password@host:port"
msgstr ""

#: ../reference/configuration/index.rst:122
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../reference/configuration/index.rst:125
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../reference/configuration/index.rst:129
msgid "A method for parsing URIs is illustrated in :ref:`Cookbook recipes <cookbook-uri>`."
msgstr ""

#: ../reference/configuration/index.rst:135
msgid "Initialization file"
msgstr ""

#: ../reference/configuration/index.rst:137
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../reference/configuration/index.rst:145
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../reference/configuration/index.rst:156
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../reference/configuration/index.rst:160
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../reference/configuration/index.rst:174
msgid "If one wishes to start an interactive session on the same terminal after initialization is complete, one can use :ref:`console.start() <console-start>`."
msgstr ""

#: ../reference/configuration/index.rst:190
msgid "Configuration parameters"
msgstr ""

#: ../reference/configuration/index.rst:192
msgid "Configuration parameters have the form: |br| :extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../reference/configuration/index.rst:195
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../reference/configuration/index.rst:200
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../reference/configuration/index.rst:205
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../reference/configuration/index.rst:208
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, and for logging."
msgstr ""

#: ../reference/configuration/index.rst:213
msgid "Basic parameters"
msgstr ""

#: ../reference/configuration/index.rst:219
msgid "Configuring the storage"
msgstr ""

#: ../reference/configuration/index.rst:227
msgid "Snapshot daemon"
msgstr ""

#: ../reference/configuration/index.rst:233
msgid "Binary logging and snapshots"
msgstr ""

#: ../reference/configuration/index.rst:239
msgid "Replication"
msgstr ""

#: ../reference/configuration/index.rst:245
msgid "Networking"
msgstr ""

#: ../reference/configuration/index.rst:251
msgid "Logging"
msgstr ""

#: ../reference/index.rst:30
msgid "Reference"
msgstr ""

#: ../reference/reference_lua/box.rst:30
msgid "Module `box`"
msgstr ""

#: ../reference/reference_lua/box.rst:32
msgid "As well as executing Lua chunks or defining their own functions, you can exploit Tarantool's storage functionality with the ``box`` module and its submodules."
msgstr ""

#: ../reference/reference_lua/box.rst:35
msgid "The contents of the ``box`` library can be inspected at runtime with ``box``, with no arguments. The submodules inside the box library are: ``box.schema``, ``box.tuple``, ``box.space``, ``box.index``, ``box.cfg``, ``box.info``, ``box.slab``, ``box.stat``. Every submodule contains one or more Lua functions. A few submodules contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../reference/reference_lua/box_error.rst:28
msgid "Submodule `box.error`"
msgstr ""

#: ../reference/reference_lua/box_error.rst:32
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in ``error()`` function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../reference/reference_lua/box_error.rst:39
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../reference/reference_lua/box_error.rst:47
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../reference/reference_lua/box_error.rst:52
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../reference/reference_lua/box_error.rst:58
msgid "number of a pre-defined error"
msgstr ""

#: ../reference/reference_lua/box_error.rst:59
msgid "part of the message which will accompany the error"
msgstr ""

#: ../reference/reference_lua/box_error.rst:61
#: ../reference/reference_rock/dbms.rst:106
#: ../reference/reference_rock/dbms.rst:461
msgid "For example:"
msgstr ""

#: ../reference/reference_lua/box_error.rst:63
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../reference/reference_lua/box_error.rst:69
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../reference/reference_lua/box_error.rst:71
#: ../reference/reference_lua/box_error.rst:107
#: ../reference/reference_lua/clock.rst:51
#: ../reference/reference_lua/clock.rst:72
#: ../reference/reference_lua/clock.rst:90
#: ../reference/reference_lua/clock.rst:108
#: ../reference/reference_lua/clock.rst:130
#: ../reference/reference_lua/console.rst:71
#: ../reference/reference_lua/console.rst:104
#: ../reference/reference_lua/console.rst:129
#: ../reference/reference_lua/crypto.rst:64
#: ../reference/reference_lua/crypto.rst:93
#: ../reference/reference_lua/csv.rst:70
#: ../reference/reference_lua/csv.rst:149
#: ../reference/reference_lua/csv.rst:192
#: ../reference/reference_lua/fiber.rst:88
#: ../reference/reference_lua/fiber.rst:112
#: ../reference/reference_lua/fiber.rst:132
#: ../reference/reference_lua/fiber.rst:152
#: ../reference/reference_lua/fiber.rst:166
#: ../reference/reference_lua/fiber.rst:183
#: ../reference/reference_lua/fiber.rst:202
#: ../reference/reference_lua/fiber.rst:229
#: ../reference/reference_lua/fiber.rst:245
#: ../reference/reference_lua/fiber.rst:265
#: ../reference/reference_lua/fiber.rst:286
#: ../reference/reference_lua/fiber.rst:311
#: ../reference/reference_lua/fiber.rst:331
#: ../reference/reference_lua/fiber.rst:356
#: ../reference/reference_lua/fiber.rst:376
#: ../reference/reference_lua/fiber.rst:421
#: ../reference/reference_lua/fiber.rst:440
#: ../reference/reference_lua/fio.rst:52
#: ../reference/reference_lua/fio.rst:72
#: ../reference/reference_lua/fio.rst:90
#: ../reference/reference_lua/fio.rst:112
#: ../reference/reference_lua/fio.rst:132
#: ../reference/reference_lua/fio.rst:170
#: ../reference/reference_lua/fio.rst:191
#: ../reference/reference_lua/fio.rst:206
#: ../reference/reference_lua/fio.rst:219
#: ../reference/reference_lua/fio.rst:243
#: ../reference/reference_lua/fio.rst:266
#: ../reference/reference_lua/fio.rst:285
#: ../reference/reference_lua/fio.rst:308
#: ../reference/reference_lua/fio.rst:324
#: ../reference/reference_lua/fio.rst:357
#: ../reference/reference_lua/fio.rst:379
#: ../reference/reference_lua/fio.rst:402
#: ../reference/reference_lua/fio.rst:432
#: ../reference/reference_lua/fio.rst:450
#: ../reference/reference_lua/fio.rst:473
#: ../reference/reference_lua/fio.rst:491
#: ../reference/reference_lua/fio.rst:523
#: ../reference/reference_lua/jit.rst:40
#: ../reference/reference_lua/jit.rst:55
#: ../reference/reference_lua/jit.rst:68
#: ../reference/reference_lua/jit.rst:82
#: ../reference/reference_lua/jit.rst:103
#: ../reference/reference_lua/json.rst:48
#: ../reference/reference_lua/json.rst:86
#: ../reference/reference_lua/json.rst:112
#: ../reference/reference_lua/net_box.rst:77
#: ../reference/reference_lua/net_box.rst:93
#: ../reference/reference_lua/net_box.rst:107
#: ../reference/reference_lua/net_box.rst:120
#: ../reference/reference_lua/net_box.rst:136
#: ../reference/reference_lua/net_box.rst:194
#: ../reference/reference_lua/net_box.rst:210
#: ../reference/reference_lua/net_box.rst:221
#: ../reference/reference_lua/os.rst:55
#: ../reference/reference_lua/os.rst:78
#: ../reference/reference_lua/os.rst:97
#: ../reference/reference_lua/os.rst:114
#: ../reference/reference_lua/os.rst:132
#: ../reference/reference_lua/os.rst:147
#: ../reference/reference_lua/os.rst:160
#: ../reference/reference_lua/os.rst:175
#: ../reference/reference_lua/os.rst:190
#: ../reference/reference_lua/other.rst:40
#: ../reference/reference_lua/other.rst:77
#: ../reference/reference_lua/pickle.rst:89
#: ../reference/reference_lua/pickle.rst:134
#: ../reference/reference_lua/socket.rst:135
#: ../reference/reference_lua/socket.rst:153
#: ../reference/reference_lua/socket.rst:170
#: ../reference/reference_lua/socket.rst:198
#: ../reference/reference_lua/socket.rst:232
#: ../reference/reference_lua/socket.rst:379
#: ../reference/reference_lua/strict.rst:41
#: ../reference/reference_lua/tap.rst:93
#: ../reference/reference_lua/tap.rst:135
#: ../reference/reference_lua/tarantool.rst:42
#: ../reference/reference_rock/dbms.rst:214
#: ../reference/reference_rock/dbms.rst:238
#: ../reference/reference_rock/dbms.rst:262
#: ../reference/reference_rock/dbms.rst:559
#: ../reference/reference_rock/dbms.rst:583
#: ../reference/reference_rock/dbms.rst:606
msgid "**Example:**"
msgstr ""

#: ../reference/reference_lua/box_error.rst:73
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../reference/reference_lua/box_error.rst:90
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../reference/reference_lua/box_error.rst:100
msgid "rtype: table"
msgstr ""

#: ../reference/reference_lua/box_error.rst:104
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../reference/reference_lua/box_error.rst:109
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference/reference_lua/box_once.rst:30
msgid "Function `box.once`"
msgstr ""

#: ../reference/reference_lua/box_once.rst:34
msgid "Execute a function, provided it has not been executed before. A passed value is checked to see whether the function has already been executed. If it has been executed before, nothing happens. If it has not been executed before, the function is invoked. For an explanation why ``box.once`` is useful, see the section :ref:`Preventing Duplicate Actions <index-preventing_duplicate_actions>`."
msgstr ""

#: ../reference/reference_lua/box_once.rst:40
msgid "a value that will be checked"
msgstr ""

#: ../reference/reference_lua/box_once.rst:41
msgid "a function"
msgstr ""

#: ../reference/reference_lua/box_once.rst:42
msgid "arguments, that must be passed to function"
msgstr ""

#: ../reference/reference_lua/clock.rst:30
msgid "Module `clock`"
msgstr ""

#: ../reference/reference_lua/clock.rst:32
msgid "The ``clock`` module returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the module return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../reference/reference_lua/clock.rst:44
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). This is the best function for knowing what the official time is, as determined by the system administrator."
msgstr ""

#: ../reference/reference_lua/clock.rst:48
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../reference/reference_lua/clock.rst:49
#: ../reference/reference_lua/clock.rst:70
#: ../reference/reference_lua/clock.rst:88
#: ../reference/reference_lua/clock.rst:106
msgid "number or number64"
msgstr ""

#: ../reference/reference_lua/clock.rst:53
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../reference/reference_lua/clock.rst:59
msgid "See also :ref:`fiber.time64 <fiber-time64>` and :ref:`os.clock() <os-clock>`."
msgstr ""

#: ../reference/reference_lua/clock.rst:64
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../reference/reference_lua/clock.rst:69
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../reference/reference_lua/clock.rst:74
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../reference/reference_lua/clock.rst:83
msgid "The processor time. Derived from C function clock_gettime(CLOCK_PROCESS_CPUTIME_ID). This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../reference/reference_lua/clock.rst:87
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../reference/reference_lua/clock.rst:92
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../reference/reference_lua/clock.rst:101
msgid "The thread time. Derived from C function clock_gettime(CLOCK_THREAD_CPUTIME_ID). This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../reference/reference_lua/clock.rst:105
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../reference/reference_lua/clock.rst:110
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../reference/reference_lua/clock.rst:118
msgid "The time that a function takes within a processor. This function uses clock.proc(), therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../reference/reference_lua/clock.rst:122
#: ../reference/reference_lua/socket.rst:227
msgid "Parameters:"
msgstr ""

#: ../reference/reference_lua/clock.rst:124
msgid ":samp:`{function}` = function or function reference;"
msgstr ""

#: ../reference/reference_lua/clock.rst:125
msgid ":samp:`{function parameters}` = whatever values are required by the function."
msgstr ""

#: ../reference/reference_lua/clock.rst:127
msgid "table. first element = seconds of CPU time; second element = whatever the function returns."
msgstr ""

#: ../reference/reference_lua/clock.rst:128
#: ../reference/reference_lua/csv.rst:68
#: ../reference/reference_lua/fiber.rst:200
#: ../reference/reference_lua/fio.rst:130
#: ../reference/reference_lua/fio.rst:187
#: ../reference/reference_lua/fio.rst:489
#: ../reference/reference_lua/json.rst:84
#: ../reference/reference_lua/msgpack.rst:55
#: ../reference/reference_lua/pickle.rst:132
#: ../reference/reference_lua/socket.rst:168
#: ../reference/reference_lua/socket.rst:523
#: ../reference/reference_lua/socket.rst:535
#: ../reference/reference_lua/yaml.rst:51
msgid "table"
msgstr ""

#: ../reference/reference_lua/clock.rst:132
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f,10)"
msgstr ""

#: ../reference/reference_lua/console.rst:30
msgid "Module `console`"
msgstr ""

#: ../reference/reference_lua/console.rst:32
msgid "The console module allows one Tarantool server to access another Tarantool server, and allows one Tarantool server to start listening on an :ref:`admin port <administration-admin_ports>`."
msgstr ""

#: ../reference/reference_lua/console.rst:41
msgid "Connect to the server at :ref:`URI <index-uri>`, change the prompt from ':samp:`tarantool>`' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types :code:`control-D`."
msgstr ""

#: ../reference/reference_lua/console.rst:45
msgid "The console.connect function allows one Tarantool server, in interactive mode, to access another Tarantool server. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote server and the local server is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote server. Results are displayed on the local server. To return to local mode, enter :code:`control-D`."
msgstr ""

#: ../reference/reference_lua/console.rst:54
msgid "If the Tarantool server at :samp:`uri` requires authentication, the connection might look something like: :code:`console.connect('admin:secretpassword@distanthost.com:3301')`."
msgstr ""

#: ../reference/reference_lua/console.rst:58
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote server is done with user name = 'guest'. The remote server could allow for this by granting at least one privilege: :code:`box.schema.user.grant('guest','execute','universe')`."
msgstr ""

#: ../reference/reference_lua/console.rst:64
msgid "the URI of the remote server"
msgstr ""

#: ../reference/reference_lua/console.rst:66
#: ../reference/reference_lua/fiber.rst:309
#: ../reference/reference_lua/fiber.rst:352
#: ../reference/reference_lua/log.rst:56
#: ../reference/reference_lua/msgpack.rst:170
#: ../reference/reference_lua/tap.rst:61
#: ../reference/reference_lua/tap.rst:72
#: ../reference/reference_lua/tap.rst:79
#: ../reference/reference_lua/tap.rst:133
msgid "nil"
msgstr ""

#: ../reference/reference_lua/console.rst:68
msgid "Possible errors: the connection will fail if the target Tarantool server was not initiated with :code:`box.cfg{listen=...}`."
msgstr ""

#: ../reference/reference_lua/console.rst:73
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that server is remote"
msgstr ""

#: ../reference/reference_lua/console.rst:87
msgid "Listen on :ref:`URI <index-uri>`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in :code:`box.cfg{listen=...}`. The alternative way of listening is via the URI specified in :code:`console.listen(...)`. This alternative way is called \"administrative\" or simply :ref:`\"admin port\" <administration-admin_ports>`. The listening is usually over a local host with a Unix domain socket."
msgstr ""

#: ../reference/reference_lua/console.rst:94
msgid "the URI of the local server"
msgstr ""

#: ../reference/reference_lua/console.rst:96
msgid "The \"admin\" address is the URI to listen on. It has no default value, so it must be specified if connections will occur via an admin port. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../reference/reference_lua/console.rst:106
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../reference/reference_lua/console.rst:127
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../reference/reference_lua/console.rst:131
msgid "A special use of ``console.start()`` is with :ref:`initialization files <index-init_label>`. Normally, if one starts the tarantool server with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../reference/reference_lua/console.rst:138
msgid "console = require('console')\n"
"console.start()"
msgstr ""

#: ../reference/reference_lua/console.rst:147
msgid "Set the auto-completion flag. If auto-completion is `true`, and the user is using tarantool as a client, then hitting the TAB key may cause tarantool to complete a word automatically. The default auto-completion value is `true`."
msgstr ""

#: ../reference/reference_lua/crypto.rst:30
msgid "Module `crypto`"
msgstr ""

#: ../reference/reference_lua/crypto.rst:34
msgid "\"Crypto\" is short for \"Cryptography\", which generally refers to the production of a digest value from a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's crypto module supports ten types of cryptographic hash functions (AES_, DES_, DSS_, MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto functionality is also present in the :ref:`digest` module. The functions in crypto are:"
msgstr ""

#: ../reference/reference_lua/crypto.rst:46
msgid "Pass or return a cipher derived from the string, key, and (optionally, sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../reference/reference_lua/crypto.rst:49
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:50
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:51
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:52
msgid "des    - des (with 56-bit binary strings using DES, though DES is not recommended)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:55
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../reference/reference_lua/crypto.rst:57
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../reference/reference_lua/crypto.rst:58
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../reference/reference_lua/crypto.rst:59
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../reference/reference_lua/crypto.rst:60
msgid "ofb - Output Feedback"
msgstr ""

#: ../reference/reference_lua/crypto.rst:62
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../reference/reference_lua/crypto.rst:66
msgid "crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../reference/reference_lua/crypto.rst:77
msgid "Pass or return a digest derived from the string. The twelve choices of algorithms:"
msgstr ""

#: ../reference/reference_lua/crypto.rst:80
msgid "dss - dss (using DSS)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:81
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:82
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:83
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:84
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:85
msgid "ripemd160 -"
msgstr ""

#: ../reference/reference_lua/crypto.rst:86
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:87
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:88
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:89
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:90
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../reference/reference_lua/crypto.rst:91
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../reference/reference_lua/crypto.rst:95
msgid "crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../reference/reference_lua/crypto.rst:102
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../reference/reference_lua/crypto.rst:104
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports for all crypto functions.."
msgstr ""

#: ../reference/reference_lua/crypto.rst:110
msgid "crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../reference/reference_lua/crypto.rst:134
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../reference/reference_lua/crypto.rst:136
msgid "The following functions are equivalent. For example, the ``digest`` function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../reference/reference_lua/crypto.rst:139
msgid "crypto.cipher.aes256.cbc.encrypt('string', 'key') == digest.aes256cbc.encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../reference/reference_lua/csv.rst:28
msgid "Module `csv`"
msgstr ""

#: ../reference/reference_lua/csv.rst:32
msgid "The csv module handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../reference/reference_lua/csv.rst:35
msgid "The default formatting rules are:"
msgstr ""

#: ../reference/reference_lua/csv.rst:37
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../reference/reference_lua/csv.rst:39
msgid "Commas designate end-of-field,"
msgstr ""

#: ../reference/reference_lua/csv.rst:40
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../reference/reference_lua/csv.rst:41
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../reference/reference_lua/csv.rst:42
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../reference/reference_lua/csv.rst:43
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../reference/reference_lua/csv.rst:49
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../reference/reference_lua/csv.rst:51
msgid ":samp:`delimiter = {string}` -- single-byte character to designate end-of-field, default = comma"
msgstr ""

#: ../reference/reference_lua/csv.rst:52
msgid ":samp:`quote_char = {string}` -- single-byte character to designate encloser of string, default = quote mark"
msgstr ""

#: ../reference/reference_lua/csv.rst:53
msgid ":samp:`chunk-size = {number}` -- number of characters to read at once (usually for file-IO efficiency), default = 4096"
msgstr ""

#: ../reference/reference_lua/csv.rst:54
msgid ":samp:`skip_head_lines = {number}` -- number of lines to skip at the start (usually for a header), default 0"
msgstr ""

#: ../reference/reference_lua/csv.rst:60
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../reference/reference_lua/csv.rst:64
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../reference/reference_lua/csv.rst:66
#: ../reference/reference_lua/csv.rst:188
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../reference/reference_lua/csv.rst:67
msgid "loaded_value"
msgstr ""

#: ../reference/reference_lua/csv.rst:72
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../reference/reference_lua/csv.rst:74
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:86
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../reference/reference_lua/csv.rst:89
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:96
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../reference/reference_lua/csv.rst:98
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:106
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of fio is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../reference/reference_lua/csv.rst:110
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close(nn)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:137
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-load>`."
msgstr ""

#: ../reference/reference_lua/csv.rst:143
#: ../reference/reference_lua/csv.rst:187
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../reference/reference_lua/csv.rst:144
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../reference/reference_lua/csv.rst:145
msgid "any object which has a write() method"
msgstr ""

#: ../reference/reference_lua/csv.rst:146
msgid "dumped_value"
msgstr ""

#: ../reference/reference_lua/csv.rst:147
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../reference/reference_lua/csv.rst:151
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../reference/reference_lua/csv.rst:153
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:165
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../reference/reference_lua/csv.rst:167
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference/reference_lua/csv.rst:183
msgid "Form a Lua iterator function for going through CSV records one field at a time. Use of an iterator is strongly recommended if the amount of data is large (ten or more megabytes)."
msgstr ""

#: ../reference/reference_lua/csv.rst:189
msgid "Lua iterator function"
msgstr ""

#: ../reference/reference_lua/csv.rst:190
msgid "iterator function"
msgstr ""

#: ../reference/reference_lua/csv.rst:194
msgid ":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() <csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is a function which is the same as the :ref:`csv.load() <csv-load>` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../reference/reference_lua/csv.rst:198
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../reference/reference_lua/digest.rst:30
msgid "Module `digest`"
msgstr ""

#: ../reference/reference_lua/digest.rst:34
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool's digest module supports several types of cryptographic hash functions (AES_, MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). Some of the digest functionality is also present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../reference/reference_lua/digest.rst:42
msgid "The functions in digest are:"
msgstr ""

#: ../reference/reference_lua/digest.rst:47
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../reference/reference_lua/digest.rst:51
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../reference/reference_lua/digest.rst:55
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../reference/reference_lua/digest.rst:59
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../reference/reference_lua/digest.rst:63
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../reference/reference_lua/digest.rst:67
msgid "Returns 160-bit binary string = digest made with SHA-0.|br| Not recommended."
msgstr ""

#: ../reference/reference_lua/digest.rst:72
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../reference/reference_lua/digest.rst:76
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../reference/reference_lua/digest.rst:80
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../reference/reference_lua/digest.rst:84
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../reference/reference_lua/digest.rst:88
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../reference/reference_lua/digest.rst:92
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../reference/reference_lua/digest.rst:96
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../reference/reference_lua/digest.rst:100
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../reference/reference_lua/digest.rst:104
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../reference/reference_lua/digest.rst:108
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../reference/reference_lua/digest.rst:112
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../reference/reference_lua/digest.rst:116
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../reference/reference_lua/digest.rst:120
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../reference/reference_lua/digest.rst:124
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../reference/reference_lua/digest.rst:128
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../reference/reference_lua/digest.rst:130
msgid "The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../reference/reference_lua/digest.rst:135
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../reference/reference_lua/digest.rst:142
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../reference/reference_lua/digest.rst:144
msgid "use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => 0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../reference/reference_lua/digest.rst:151
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../reference/reference_lua/digest.rst:157
msgid "Initiates incremental crc32. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../reference/reference_lua/digest.rst:164
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../reference/reference_lua/digest.rst:166
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../reference/reference_lua/digest.rst:171
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../reference/reference_lua/digest.rst:181
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../reference/reference_lua/digest.rst:186
msgid "Initiates incremental MurmurHash. See :ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../reference/reference_lua/digest.rst:193
msgid "Incremental methods in the digest module"
msgstr ""

#: ../reference/reference_lua/digest.rst:195
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../reference/reference_lua/digest.rst:201
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../reference/reference_lua/digest.rst:223
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../reference/reference_lua/digest.rst:227
msgid "tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../reference/reference_lua/digest.rst:253
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../reference/reference_lua/digest.rst:256
msgid "tarantool> password_insert('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:30
msgid "Database error codes"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:32
msgid "In the current version of the binary protocol, error message, which is normally more descriptive than error code, is not present in server response. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below follow only general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:43
msgid "**List of error codes**"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:49
msgid "ER_NONMASTER"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:49
msgid "Can't modify data on a replication slave."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:51
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:51
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:54
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:54
msgid "Out of memory: :ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena>` limit has been reached."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:58
msgid "ER_WAL_IO"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:58
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:62
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:62
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:65
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:65
msgid "The specified space does not exist."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:68
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:68
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:71
msgid "ER_PROC_LUA"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:71
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:74
msgid "ER_FIBER_STACK"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:74
msgid "The recursion limit was reached when creating a new fiber. This usually indicates that a stored procedure is recursively invoking itself too often."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:79
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:79
msgid "An error occurred during update of a field."
msgstr ""

#: ../reference/reference_lua/errcodes.rst:82
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../reference/reference_lua/errcodes.rst:82
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../reference/reference_lua/fiber.rst:28
msgid "Module `fiber`"
msgstr ""

#: ../reference/reference_lua/fiber.rst:30
msgid "The ``fiber`` module allows for creating, running and managing *fibers*."
msgstr ""

#: ../reference/reference_lua/fiber.rst:32
msgid "A fiber is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber module are associated with a user-supplied function called the *fiber function*. A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :ref:`fiber.create() <fiber-create>`, it is running. When a fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../reference/reference_lua/fiber.rst:40
msgid "All fibers are part of the fiber registry. This registry can be searched with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../reference/reference_lua/fiber.rst:44
msgid "A runaway fiber can be stopped with :ref:`fiber_object.cancel <fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-cancel>` is advisory — it works only if the runaway fiber calls :ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*`` functions, such as :ref:`box.space...delete() <box_space-delete>` or :ref:`box.space...update() <box_space-update>`, do call :ref:`fiber.testcancel() <fiber-testcancel>` but :ref:`box.space...select{} <box_space-select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been cancelled."
msgstr ""

#: ../reference/reference_lua/fiber.rst:55
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :ref:`fiber.kill() <fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() <fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../reference/reference_lua/fiber.rst:62
msgid "Like all Lua objects, dead fibers are garbage collected. The garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../reference/reference_lua/fiber.rst:67
msgid "A fiber has all the features of a Lua coroutine_ and all the programming concepts that apply for Lua coroutines will apply for fibers as well. However, Tarantool has made some enhancements for fibers and has used fibers internally. So, although use of coroutines is possible and supported, use of fibers is recommended."
msgstr ""

#: ../reference/reference_lua/fiber.rst:80
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../reference/reference_lua/fiber.rst:82
msgid "the function to be associated with the fiber"
msgstr ""

#: ../reference/reference_lua/fiber.rst:83
msgid "what will be passed to function"
msgstr ""

#: ../reference/reference_lua/fiber.rst:85
msgid "created fiber object"
msgstr ""

#: ../reference/reference_lua/fiber.rst:86
#: ../reference/reference_lua/fiber.rst:110
#: ../reference/reference_lua/fiber.rst:130
#: ../reference/reference_lua/fiber_ipc.rst:55
#: ../reference/reference_lua/fio.rst:353
#: ../reference/reference_lua/net_box.rst:75
#: ../reference/reference_lua/socket.rst:133
#: ../reference/reference_lua/socket.rst:151
#: ../reference/reference_lua/socket.rst:322
#: ../reference/reference_lua/socket.rst:348
#: ../reference/reference_lua/tap.rst:47
msgid "userdata"
msgstr ""

#: ../reference/reference_lua/fiber.rst:90
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:109
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:114
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:127
msgid "numeric identifier of the fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:129
msgid "fiber object for the specified fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:134
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:147
msgid "Yield control to the transaction processor thread and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../reference/reference_lua/fiber.rst:150
msgid "number of seconds to sleep."
msgstr ""

#: ../reference/reference_lua/fiber.rst:154
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:164
msgid "Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) <fiber-sleep>`."
msgstr ""

#: ../reference/reference_lua/fiber.rst:168
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:178
msgid "Return the status of the current fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:180
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference/reference_lua/fiber.rst:181
#: ../reference/reference_lua/fiber.rst:284
#: ../reference/reference_lua/fiber.rst:329
#: ../reference/reference_lua/fio.rst:50
#: ../reference/reference_lua/fio.rst:70
#: ../reference/reference_lua/fio.rst:88
#: ../reference/reference_lua/json.rst:46
#: ../reference/reference_lua/msgpack.rst:43
#: ../reference/reference_lua/pickle.rst:85
#: ../reference/reference_lua/socket.rst:269
#: ../reference/reference_lua/socket.rst:300
#: ../reference/reference_lua/yaml.rst:43
msgid "string"
msgstr ""

#: ../reference/reference_lua/fiber.rst:185
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:196
msgid "Return information about all fibers."
msgstr ""

#: ../reference/reference_lua/fiber.rst:198
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:204
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:222
msgid "Locate a fiber by its numeric id and cancel it. In other words, :ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../reference/reference_lua/fiber.rst:226
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../reference/reference_lua/fiber.rst:227
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../reference/reference_lua/fiber.rst:231
msgid "tarantool> fiber.kill(fiber.id())\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:242
msgid "Check if the current fiber has been cancelled and throw an exception if this is the case."
msgstr ""

#: ../reference/reference_lua/fiber.rst:247
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:260
#: ../reference/reference_lua/fiber.rst:281
#: ../reference/reference_lua/fiber.rst:305
#: ../reference/reference_lua/fiber.rst:325
#: ../reference/reference_lua/fiber.rst:349
msgid "fiber object, for example the fiber object returned by :ref:`fiber.create <fiber-create>`"
msgstr ""

#: ../reference/reference_lua/fiber.rst:262
msgid "id of the fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:263
#: ../reference/reference_lua/fiber_ipc.rst:99
#: ../reference/reference_lua/fio.rst:110
#: ../reference/reference_lua/fio.rst:469
#: ../reference/reference_lua/socket.rst:249
#: ../reference/reference_lua/socket.rst:363
msgid "number"
msgstr ""

#: ../reference/reference_lua/fiber.rst:267
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:283
msgid "name of the fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:288
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:299
msgid "Change the fiber name. By default the Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../reference/reference_lua/fiber.rst:307
msgid "the new name of the fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:313
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:323
msgid "Return the status of the specified fiber."
msgstr ""

#: ../reference/reference_lua/fiber.rst:328
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference/reference_lua/fiber.rst:333
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:344
msgid "Cancel a fiber. Running and suspended fibers can be cancelled. After a fiber has been cancelled, attempts to operate on it will cause errors, for example :ref:`fiber_object:id() <fiber_object-id>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../reference/reference_lua/fiber.rst:354
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../reference/reference_lua/fiber.rst:358
msgid "tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:369
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`{fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The storage is garbage-collected when :samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../reference/reference_lua/fiber.rst:378
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:409
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../reference/reference_lua/fiber.rst:415
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../reference/reference_lua/fiber.rst:419
#: ../reference/reference_lua/fiber.rst:438
msgid "num"
msgstr ""

#: ../reference/reference_lua/fiber.rst:423
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:435
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../reference/reference_lua/fiber.rst:442
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:452
msgid "Example Of Fiber Use"
msgstr ""

#: ../reference/reference_lua/fiber.rst:454
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop (``while 0 == 0`` is always true). Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../reference/reference_lua/fiber.rst:459
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:472
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../reference/reference_lua/fiber.rst:475
msgid "tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:483
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../reference/reference_lua/fiber.rst:485
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:491
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../reference/reference_lua/fiber.rst:496
msgid "tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber.rst:503
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../reference/reference_lua/fiber.rst:508
msgid "tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:28
msgid "Submodule `fiber-ipc`"
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:30
msgid "The ``fiber-ipc`` submodule allows sending and receiving messages between different processes. The words \"different processes\" in this context mean different connections, different sessions, or different fibers."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:34
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section. Call the other ``fiber-ipc`` routines, via channel, to send messages, receive messages, or check ipc status. Message exchange is synchronous. The channel is garbage collected when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:48
msgid "Create a new communication channel."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:50
msgid "positive integer as great as the maximum number of slots (spaces for ``get`` or ``put`` messages) that might be pending at any given time."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:54
msgid "new channel."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:61
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` blocks until there is a free slot in the channel."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:66
msgid "If timeout is provided, and the channel doesn't become empty for the duration of the timeout, ``channel:put()`` returns false. Otherwise it returns true."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:69
#: ../reference/reference_lua/fiber_ipc.rst:92
#: ../reference/reference_lua/fiber_ipc.rst:106
#: ../reference/reference_lua/fiber_ipc.rst:114
#: ../reference/reference_lua/fiber_ipc.rst:122
#: ../reference/reference_lua/fiber_ipc.rst:127
#: ../reference/reference_lua/fio.rst:168
#: ../reference/reference_lua/fio.rst:264
#: ../reference/reference_lua/fio.rst:306
#: ../reference/reference_lua/fio.rst:322
#: ../reference/reference_lua/fio.rst:377
#: ../reference/reference_lua/fio.rst:448
#: ../reference/reference_lua/net_box.rst:91
#: ../reference/reference_lua/net_box.rst:105
#: ../reference/reference_lua/net_box.rst:118
#: ../reference/reference_lua/socket.rst:230
#: ../reference/reference_lua/socket.rst:400
#: ../reference/reference_lua/socket.rst:411
#: ../reference/reference_lua/tap.rst:91
#: ../reference/reference_lua/tap.rst:123
#: ../reference/reference_lua/tap.rst:154
#: ../reference/reference_lua/tap.rst:165
#: ../reference/reference_lua/tap.rst:182
#: ../reference/reference_lua/tap.rst:190
msgid "boolean"
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:73
msgid "Close the channel. All waiters in the channel will be woken up. All following ``channel:put()`` or ``channel:get()`` operations will return an error (``nil``)."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:79
msgid "Fetch a message from a channel. If the channel is empty, ``channel:get()`` blocks until there is a message."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:83
msgid "the value placed on the channel by an earlier ``channel:put()``."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:85
msgid "lua_object"
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:89
msgid "Check whether the specified channel is empty (has no messages)."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:91
msgid "true if the specified channel is empty"
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:96
msgid "Find out how many messages are on the channel. The answer is 0 if the channel is empty."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:98
msgid "the number of messages."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:103
msgid "Check whether the specified channel is full."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:105
msgid "true if the specified channel is full (has no room for a new message)."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:110
msgid "Check whether the specified channel is empty and has readers waiting for a message (because they have issued ``channel:get()`` and then blocked)."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:113
#: ../reference/reference_lua/fiber_ipc.rst:121
msgid "true if blocked users are waiting. Otherwise false."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:118
msgid "Check whether the specified channel is full and has writers waiting (because they have issued ``channel:put()`` and then blocked due to lack of room)."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:126
msgid "true if the specified channel is already closed. Otherwise false."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:133
msgid "This example should give a rough idea of what some functions for fibers should look like. It's assumed that the functions would be referenced in :ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../reference/reference_lua/fiber_ipc.rst:138
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../reference/reference_lua/fio.rst:30
msgid "Module `fio`"
msgstr ""

#: ../reference/reference_lua/fio.rst:34
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../reference/reference_lua/fio.rst:42
msgid "Common pathname manipulations"
msgstr ""

#: ../reference/reference_lua/fio.rst:46
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../reference/reference_lua/fio.rst:48
msgid "one or more strings to be concatenated."
msgstr ""

#: ../reference/reference_lua/fio.rst:49
#: ../reference/reference_lua/fio.rst:66
#: ../reference/reference_lua/fio.rst:85
msgid "path name"
msgstr ""

#: ../reference/reference_lua/fio.rst:54
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:63
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../reference/reference_lua/fio.rst:67
msgid "suffix"
msgstr ""

#: ../reference/reference_lua/fio.rst:69
msgid "file name"
msgstr ""

#: ../reference/reference_lua/fio.rst:74
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:83
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../reference/reference_lua/fio.rst:87
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../reference/reference_lua/fio.rst:92
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:101
msgid "Common file manipulations"
msgstr ""

#: ../reference/reference_lua/fio.rst:105
msgid "Set the mask bits used when creating files or directories. For a detailed description type \"man 2 umask\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:108
msgid "mask bits."
msgstr ""

#: ../reference/reference_lua/fio.rst:109
msgid "previous mask bits."
msgstr ""

#: ../reference/reference_lua/fio.rst:114
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:124
msgid "Returns information about a file object. For details type \"man 2 lstat\" or \"man 2 stat\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:127
msgid "path name of file."
msgstr ""

#: ../reference/reference_lua/fio.rst:128
msgid "fields which describe the file's block size, creation time, size, and other attributes."
msgstr ""

#: ../reference/reference_lua/fio.rst:134
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:160
msgid "Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2 rmdir\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:163
msgid "path of directory."
msgstr ""

#: ../reference/reference_lua/fio.rst:164
msgid "Mode bits can be passed as a number or as string constants, for example ''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../reference/reference_lua/fio.rst:167
#: ../reference/reference_lua/fio.rst:263
#: ../reference/reference_lua/fio.rst:305
#: ../reference/reference_lua/fio.rst:321
#: ../reference/reference_lua/fio.rst:447
#: ../reference/reference_lua/fio.rst:521
msgid "true if success, false if failure."
msgstr ""

#: ../reference/reference_lua/fio.rst:172
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:181
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:185
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../reference/reference_lua/fio.rst:186
msgid "list of files whose names match the input string"
msgstr ""

#: ../reference/reference_lua/fio.rst:189
#: ../reference/reference_lua/fio.rst:355
#: ../reference/reference_lua/fio.rst:471
#: ../reference/reference_lua/socket.rst:350
msgid "Possible errors: nil."
msgstr ""

#: ../reference/reference_lua/fio.rst:193
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:204
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../reference/reference_lua/fio.rst:208
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:217
msgid "Return the name of the current working directory."
msgstr ""

#: ../reference/reference_lua/fio.rst:221
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:233
msgid "Functions to create and delete links. For details type \"man readlink\", \"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../reference/reference_lua/fio.rst:236
msgid "existing file name."
msgstr ""

#: ../reference/reference_lua/fio.rst:237
msgid "linked name."
msgstr ""

#: ../reference/reference_lua/fio.rst:239
msgid "``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if success, false if failure. ``fio.readlink`` returns the link value if success, nil if failure."
msgstr ""

#: ../reference/reference_lua/fio.rst:245
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:258
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:260
msgid "original name."
msgstr ""

#: ../reference/reference_lua/fio.rst:261
msgid "new name."
msgstr ""

#: ../reference/reference_lua/fio.rst:268
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:278
msgid "Manage the rights to file objects, or ownership of file objects. For details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:281
msgid "new user uid."
msgstr ""

#: ../reference/reference_lua/fio.rst:282
msgid "new group uid."
msgstr ""

#: ../reference/reference_lua/fio.rst:283
msgid "new permissions"
msgstr ""

#: ../reference/reference_lua/fio.rst:287
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:300
msgid "Reduce file size to a specified value. For details type \"man 2 truncate\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:310
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:319
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:326
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:340
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../reference/reference_lua/fio.rst:343
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces."
msgstr ""

#: ../reference/reference_lua/fio.rst:347
msgid "Mode bits can be passed as a number or as string constants, for example ''`S_IWUSR`\". Mode bits are significant if flags include `O_CREATE` or `O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../reference/reference_lua/fio.rst:352
msgid "file handle (later - fh)"
msgstr ""

#: ../reference/reference_lua/fio.rst:359
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:373
msgid "Close a file that was opened with ``fio.open``. For details type \"man 2 close\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:375
#: ../reference/reference_lua/fio.rst:395
#: ../reference/reference_lua/fio.rst:426
#: ../reference/reference_lua/fio.rst:446
#: ../reference/reference_lua/fio.rst:464
#: ../reference/reference_lua/fio.rst:487
#: ../reference/reference_lua/fio.rst:520
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../reference/reference_lua/fio.rst:376
msgid "true if success, false on failure."
msgstr ""

#: ../reference/reference_lua/fio.rst:381
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:391
msgid "Perform read/write random-access operation on a file, without affecting the current seek position of the file. For details type \"man 2 pread\" or \"man 2 pwrite\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:396
#: ../reference/reference_lua/fio.rst:427
msgid "number of bytes to read"
msgstr ""

#: ../reference/reference_lua/fio.rst:397
#: ../reference/reference_lua/fio.rst:428
msgid "value to write"
msgstr ""

#: ../reference/reference_lua/fio.rst:398
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../reference/reference_lua/fio.rst:399
msgid "``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` returns the data that was read, or nil if failure."
msgstr ""

#: ../reference/reference_lua/fio.rst:404
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:416
msgid "Perform non-random-access read or write on a file. For details type \"man 2 read\" or \"man 2 write\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:421
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../reference/reference_lua/fio.rst:429
msgid "``fh:write`` returns true if success, false if failure. ``fh:read`` returns the data that was read, or nil if failure."
msgstr ""

#: ../reference/reference_lua/fio.rst:434
msgid "tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:443
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../reference/reference_lua/fio.rst:452
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:461
msgid "Shift position in the file to the specified position. For details type \"man 2 seek\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:465
msgid "position to seek to"
msgstr ""

#: ../reference/reference_lua/fio.rst:466
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../reference/reference_lua/fio.rst:468
msgid "the new position if success"
msgstr ""

#: ../reference/reference_lua/fio.rst:475
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:484
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type \"man 2 stat\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:488
msgid "details about the file."
msgstr ""

#: ../reference/reference_lua/fio.rst:493
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../reference/reference_lua/fio.rst:516
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type \"man 2 fsync\" or \"man 2 fdatasync\"."
msgstr ""

#: ../reference/reference_lua/fio.rst:525
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/fun.rst:30
msgid "Module `fun`"
msgstr ""

#: ../reference/reference_lua/fun.rst:32
msgid "Lua fun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the module are \"sequence processors\" such as map, filter, reduce, zip -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the module are \"generators\" such as range, tabulate, and rands -- they return a bounded or boundless series of values. Within the module are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../reference/reference_lua/fun.rst:44
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual :code:`require` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the :code:`require` request. For example:"
msgstr ""

#: ../reference/reference_lua/fun.rst:52
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/index.rst:28
msgid "Built-in library reference"
msgstr ""

#: ../reference/reference_lua/index.rst:30
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../reference/reference_lua/index.rst:34
msgid "Some functions in these modules are analogs to functions from `standard Lua libraries <http://www.lua.org/manual/>`_. For better results, we recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../reference/reference_lua/jit.rst:28
msgid "Module `jit`"
msgstr ""

#: ../reference/reference_lua/jit.rst:32
msgid "The ``jit`` module has functions for tracing the LuaJIT Just-In-Time compiler's progress, showing the byte-code or assembler output that the compiler produces, and in general providing information about what LuaJIT does with Lua code."
msgstr ""

#: ../reference/reference_lua/jit.rst:38
msgid "Prints the byte code of a function."
msgstr ""

#: ../reference/reference_lua/jit.rst:42
msgid "function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../reference/reference_lua/jit.rst:49
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:53
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../reference/reference_lua/jit.rst:57
msgid "-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../reference/reference_lua/jit.rst:62
msgid "For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:66
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../reference/reference_lua/jit.rst:70
msgid "-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../reference/reference_lua/jit.rst:75
msgid "For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:80
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../reference/reference_lua/jit.rst:84
msgid "-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../reference/reference_lua/jit.rst:95
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../reference/reference_lua/jit.rst:101
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../reference/reference_lua/jit.rst:105
msgid "-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../reference/reference_lua/jit.rst:116
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../reference/reference_lua/json.rst:30
msgid "Module `json`"
msgstr ""

#: ../reference/reference_lua/json.rst:32
msgid "The json module provides JSON manipulation routines. It is based on the `Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON please read `the official documentation`_."
msgstr ""

#: ../reference/reference_lua/json.rst:42
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../reference/reference_lua/json.rst:44
#: ../reference/reference_lua/msgpack.rst:41
#: ../reference/reference_lua/yaml.rst:41
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../reference/reference_lua/json.rst:45
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../reference/reference_lua/json.rst:50
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../reference/reference_lua/json.rst:80
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../reference/reference_lua/json.rst:82
msgid "a string formatted as JSON."
msgstr ""

#: ../reference/reference_lua/json.rst:83
#: ../reference/reference_lua/yaml.rst:50
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../reference/reference_lua/json.rst:88
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../reference/reference_lua/json.rst:110
#: ../reference/reference_lua/msgpack.rst:61
#: ../reference/reference_lua/yaml.rst:57
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../reference/reference_lua/json.rst:114
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'}\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../reference/reference_lua/json.rst:136
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference/reference_lua/json.rst:138
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../reference/reference_lua/json.rst:139
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../reference/reference_lua/json.rst:141
#: ../reference/reference_lua/yaml.rst:94
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../reference/reference_lua/json.rst:143
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../reference/reference_lua/json.rst:167
msgid "Configuration settings"
msgstr ""

#: ../reference/reference_lua/json.rst:169
msgid "There are configuration settings which affect the way that Tarantool encodes invalid numbers or types. They are all boolean ``true``/``false`` values"
msgstr ""

#: ../reference/reference_lua/json.rst:172
msgid "``cfg.encode_invalid_numbers`` - allow nan and inf (default is true)"
msgstr ""

#: ../reference/reference_lua/json.rst:173
msgid "``cfg.encode_use_tostring`` - use tostring for unrecognizable types (default is false)"
msgstr ""

#: ../reference/reference_lua/json.rst:174
msgid "``cfg.encode_invalid_as_nil`` - use null for all unrecognizable types (default is false)"
msgstr ""

#: ../reference/reference_lua/json.rst:175
msgid "``cfg.encode_load_metatables`` - load metatables (default is false)"
msgstr ""

#: ../reference/reference_lua/json.rst:177
msgid "For example, the following code will interpret 0/0 (which is \"not a number\") and 1/0 (which is \"infinity\") as special values rather than nulls or errors:"
msgstr ""

#: ../reference/reference_lua/json.rst:180
msgid "json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../reference/reference_lua/json.rst:188
msgid "The result of the json.encode request will look like this:"
msgstr ""

#: ../reference/reference_lua/json.rst:190
msgid "tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../reference/reference_lua/json.rst:197
msgid "The same configuration settings exist for json, for :ref:`MsgPack <msgpack-module>`, and for :ref:`YAML <yaml-module>`. >>>>>>> Fix every NOTE to be highlighted on site + JSON cfg rewritten"
msgstr ""

#: ../reference/reference_lua/log.rst:30
msgid "Module `log`"
msgstr ""

#: ../reference/reference_lua/log.rst:34
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`logger <cfg_logging-logger>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the ``log.log_level_function_name`` function."
msgstr ""

#: ../reference/reference_lua/log.rst:44
msgid "Output a user-generated message to the :ref:`log file <cfg_logging-logger>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``debug``."
msgstr ""

#: ../reference/reference_lua/log.rst:47
msgid "The actual output will be a line containing the current timestamp, a module name, 'E' or 'W' or 'I' or 'D' or 'R' depending on ``log_level_function_name``, and ``message``. Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <cfg_logging-log_level>`. Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s',{x},{y})` will work if x is a number and y is a string."
msgstr ""

#: ../reference/reference_lua/log.rst:68
msgid "$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()\n"
"$ less tarantool.txt"
msgstr ""

#: ../reference/reference_lua/log.rst:81
msgid "2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...1 [5261] main/101/spawner C> initialized\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../reference/reference_lua/log.rst:86
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../reference/reference_lua/log.rst:88
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:30
msgid "Module `msgpack`"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:32
msgid "The ``msgpack`` module takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:39
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:42
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:47
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:49
msgid "a string formatted as MsgPack."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:52
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:53
msgid "the number of bytes that were decoded."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:67
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:90
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:92
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:93
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:95
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:99
msgid "function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:119
msgid "**Result:**"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:124
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:127
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:132
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../reference/reference_lua/msgpack.rst:134
msgid "and the second encoding means:"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:139
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:141
msgid "Here are examples for all the common types, with the Lua-table representation on the left, with the MsgPack format name and encoding on the right."
msgstr ""

#: ../reference/reference_lua/msgpack.rst:149
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:155
msgid "{}"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:155
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:158
msgid "'a'"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:158
msgid "'fixstr' = a1 61"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:160
msgid "false"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:160
msgid "'false' = c2"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:162
msgid "true"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:162
msgid "'true' = c3"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:164
msgid "127"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:164
msgid "'positive fixint' = 7f"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:166
msgid "65535"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:166
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:168
msgid "4294967295"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:168
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:170
msgid "'nil' = c0"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:172
msgid "msgpack.NULL"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:172
msgid "same as nil"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:174
msgid "[0] = 5"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:174
msgid "'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for the value) = 81 00 05"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:177
msgid "[0] = nil"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:177
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:180
msgid "1.5"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:180
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../reference/reference_lua/msgpack.rst:183
msgid "Also, some MsgPack configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:30
msgid "Module `net.box`"
msgstr ""

#: ../reference/reference_lua/net_box.rst:32
msgid "The ``net.box`` module contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS modules <dbms_modules>` appendix. In this section the subject is the built-in variant, ``net.box``. This is for connecting to tarantool servers via a network."
msgstr ""

#: ../reference/reference_lua/net_box.rst:38
msgid "Call ``require('net.box')`` to get a ``net.box`` object, which will be called ``net_box`` for examples in this section. Call ``net_box.new()`` to connect and get a connection object, which will be called ``conn`` for examples in this section. Call the other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote box. Call :ref:`conn:close <socket-close>` to disconnect."
msgstr ""

#: ../reference/reference_lua/net_box.rst:44
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact, it's perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. There are, however, cases when a single connection is not enough — for example when it's necessary to prioritize requests or to use different authentication ids."
msgstr ""

#: ../reference/reference_lua/net_box.rst:57
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It is re-established automatically after a disconnect. The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../reference/reference_lua/net_box.rst:62
msgid "For the local tarantool server there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.new('localhost:3301')` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, due to :ref:`the implicit rules <atomic-the_implicit_yield_rules>` any request can yield, and database state may have changed by the time it regains control."
msgstr ""

#: ../reference/reference_lua/net_box.rst:72
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../reference/reference_lua/net_box.rst:73
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../reference/reference_lua/net_box.rst:74
msgid "conn object"
msgstr ""

#: ../reference/reference_lua/net_box.rst:79
msgid "conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../reference/reference_lua/net_box.rst:88
msgid "Execute a PING command."
msgstr ""

#: ../reference/reference_lua/net_box.rst:90
msgid "true on success, false on error"
msgstr ""

#: ../reference/reference_lua/net_box.rst:95
msgid "net_box.self:ping()"
msgstr ""

#: ../reference/reference_lua/net_box.rst:101
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../reference/reference_lua/net_box.rst:104
msgid "true when connected, false on failure."
msgstr ""

#: ../reference/reference_lua/net_box.rst:109
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../reference/reference_lua/net_box.rst:115
msgid "Show whether connection is active or closed."
msgstr ""

#: ../reference/reference_lua/net_box.rst:117
msgid "true if connected, false on failure."
msgstr ""

#: ../reference/reference_lua/net_box.rst:122
msgid "net_box.self:is_connected()"
msgstr ""

#: ../reference/reference_lua/net_box.rst:129
msgid "Close a connection."
msgstr ""

#: ../reference/reference_lua/net_box.rst:131
msgid "Connection objects are garbage collected just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../reference/reference_lua/net_box.rst:138
msgid "conn:close()"
msgstr ""

#: ../reference/reference_lua/net_box.rst:144
msgid ":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:149
msgid "due to :ref:`the implicit yield rules <atomic-the_implicit_yield_rules>` a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so global variables or database tuples data may change when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../reference/reference_lua/net_box.rst:158
msgid ":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:163
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:168
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:173
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:178
msgid ":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:183
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:190
msgid "``conn:call('func', '1', '2', '3')`` is the remote-call equivalent of ``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-procedure call."
msgstr ""

#: ../reference/reference_lua/net_box.rst:196
msgid "conn:call('function5')"
msgstr ""

#: ../reference/reference_lua/net_box.rst:204
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <authentication-privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../reference/reference_lua/net_box.rst:212
msgid "conn:eval('return 5+5')"
msgstr ""

#: ../reference/reference_lua/net_box.rst:218
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it."
msgstr ""

#: ../reference/reference_lua/net_box.rst:223
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../reference/reference_lua/net_box.rst:227
msgid "All remote calls support execution timeouts. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../reference/reference_lua/net_box.rst:236
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../reference/reference_lua/net_box.rst:238
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. Assume that the database is nearly empty. Assume that the tarantool server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../reference/reference_lua/net_box.rst:243
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:30
msgid "Module `os`"
msgstr ""

#: ../reference/reference_lua/os.rst:34
msgid "The os module contains the functions :ref:`execute() <os-execute>`, :ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() <os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, :ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-tmpname>`. Most of these functions are described in the Lua manual Chapter 22 `The Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../reference/reference_lua/os.rst:51
msgid "Execute by passing to the shell."
msgstr ""

#: ../reference/reference_lua/os.rst:53
msgid "what to execute."
msgstr ""

#: ../reference/reference_lua/os.rst:57
msgid "tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:73
msgid "Rename a file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:75
msgid "name of existing file or directory,"
msgstr ""

#: ../reference/reference_lua/os.rst:76
msgid "changed name of file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:80
msgid "tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:93
msgid "Get environment variable."
msgstr ""

#: ../reference/reference_lua/os.rst:95
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../reference/reference_lua/os.rst:99
msgid "tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:110
msgid "Remove file or directory."
msgstr ""

#: ../reference/reference_lua/os.rst:112
msgid "Parameters: (string) name = name of file or directory which will be removed."
msgstr ""

#: ../reference/reference_lua/os.rst:116
msgid "tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:127
msgid "Return a formatted date."
msgstr ""

#: ../reference/reference_lua/os.rst:129
msgid "Parameters: (string) format-string = instructions; (string) time-since-epoch = number of seconds since 1970-01-01. If time-since-epoch is omitted, it is assumed to be the current time."
msgstr ""

#: ../reference/reference_lua/os.rst:134
msgid "tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:145
msgid "Exit the program. If this is done on the server, then the server stops."
msgstr ""

#: ../reference/reference_lua/os.rst:149
msgid "tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../reference/reference_lua/os.rst:158
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../reference/reference_lua/os.rst:162
msgid "tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:173
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../reference/reference_lua/os.rst:177
msgid "tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../reference/reference_lua/os.rst:188
msgid "Return a name for a temporary file."
msgstr ""

#: ../reference/reference_lua/os.rst:192
msgid "tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../reference/reference_lua/other.rst:28
msgid "Miscellaneous"
msgstr ""

#: ../reference/reference_lua/other.rst:34
msgid "Convert a string or a Lua number to a 64-bit integer. The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../reference/reference_lua/other.rst:42
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../reference/reference_lua/other.rst:65
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../reference/reference_lua/other.rst:69
msgid "Lua code"
msgstr ""

#: ../reference/reference_lua/other.rst:70
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../reference/reference_lua/other.rst:73
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../reference/reference_lua/other.rst:75
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../reference/reference_lua/other.rst:79
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference/reference_lua/pickle.rst:28
msgid "Module `pickle`"
msgstr ""

#: ../reference/reference_lua/pickle.rst:34
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../reference/reference_lua/pickle.rst:40
msgid "**Format specifiers**"
msgstr ""

#: ../reference/reference_lua/pickle.rst:45
msgid "b, B"
msgstr ""

#: ../reference/reference_lua/pickle.rst:45
msgid "converts Lua variable to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../reference/reference_lua/pickle.rst:48
msgid "s, S"
msgstr ""

#: ../reference/reference_lua/pickle.rst:48
msgid "converts Lua variable to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/reference_lua/pickle.rst:52
msgid "i, I"
msgstr ""

#: ../reference/reference_lua/pickle.rst:52
msgid "converts Lua variable to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/reference_lua/pickle.rst:56
msgid "l, L"
msgstr ""

#: ../reference/reference_lua/pickle.rst:56
msgid "converts Lua variable to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/reference_lua/pickle.rst:60
msgid "n"
msgstr ""

#: ../reference/reference_lua/pickle.rst:60
msgid "converts Lua variable to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../reference/reference_lua/pickle.rst:64
msgid "N"
msgstr ""

#: ../reference/reference_lua/pickle.rst:64
msgid "converts Lua variable to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../reference/reference_lua/pickle.rst:67
msgid "q, Q"
msgstr ""

#: ../reference/reference_lua/pickle.rst:67
msgid "converts Lua variable to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../reference/reference_lua/pickle.rst:71
msgid "f"
msgstr ""

#: ../reference/reference_lua/pickle.rst:71
msgid "converts Lua variable to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../reference/reference_lua/pickle.rst:74
msgid "d"
msgstr ""

#: ../reference/reference_lua/pickle.rst:74
msgid "converts Lua variable to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../reference/reference_lua/pickle.rst:77
msgid "a, A"
msgstr ""

#: ../reference/reference_lua/pickle.rst:77
msgid "converts Lua variable to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../reference/reference_lua/pickle.rst:81
msgid "string containing format specifiers"
msgstr ""

#: ../reference/reference_lua/pickle.rst:82
msgid "scalar values to be formatted"
msgstr ""

#: ../reference/reference_lua/pickle.rst:83
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../reference/reference_lua/pickle.rst:87
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../reference/reference_lua/pickle.rst:91
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../reference/reference_lua/pickle.rst:125
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../reference/reference_lua/pickle.rst:131
msgid "A list of strings or numbers."
msgstr ""

#: ../reference/reference_lua/pickle.rst:136
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/socket.rst:30
msgid "Module `socket`"
msgstr ""

#: ../reference/reference_lua/socket.rst:32
msgid "The ``socket`` module allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:38
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../reference/reference_lua/socket.rst:49
msgid "**Socket functions**"
msgstr ""

#: ../reference/reference_lua/socket.rst:54
msgid "Purposes"
msgstr ""

#: ../reference/reference_lua/socket.rst:54
msgid "Names"
msgstr ""

#: ../reference/reference_lua/socket.rst:56
msgid "setup"
msgstr ""

#: ../reference/reference_lua/socket.rst:56
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:58
#: ../reference/reference_lua/socket.rst:60
#: ../reference/reference_lua/socket.rst:62
#: ../reference/reference_lua/socket.rst:64
#: ../reference/reference_lua/socket.rst:68
#: ../reference/reference_lua/socket.rst:70
#: ../reference/reference_lua/socket.rst:74
#: ../reference/reference_lua/socket.rst:76
#: ../reference/reference_lua/socket.rst:80
#: ../reference/reference_lua/socket.rst:82
#: ../reference/reference_lua/socket.rst:86
#: ../reference/reference_lua/socket.rst:90
#: ../reference/reference_lua/socket.rst:94
#: ../reference/reference_lua/socket.rst:98
#: ../reference/reference_lua/socket.rst:100
#: ../reference/reference_lua/socket.rst:102
#: ../reference/reference_lua/socket.rst:106
#: ../reference/reference_lua/socket.rst:108
msgid "\"\""
msgstr ""

#: ../reference/reference_lua/socket.rst:58
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:60
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:64
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:66
msgid "sending"
msgstr ""

#: ../reference/reference_lua/socket.rst:66
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:68
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:70
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:72
msgid "receiving"
msgstr ""

#: ../reference/reference_lua/socket.rst:72
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:74
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:76
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:78
msgid "flag setting"
msgstr ""

#: ../reference/reference_lua/socket.rst:78
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:80
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:82
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:84
msgid "client/server"
msgstr ""

#: ../reference/reference_lua/socket.rst:84
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:86
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:88
msgid "teardown"
msgstr ""

#: ../reference/reference_lua/socket.rst:88
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:90
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:92
msgid "error checking"
msgstr ""

#: ../reference/reference_lua/socket.rst:92
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:94
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:96
msgid "information"
msgstr ""

#: ../reference/reference_lua/socket.rst:96
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:98
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:100
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:102
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:104
msgid "state checking"
msgstr ""

#: ../reference/reference_lua/socket.rst:104
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:106
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:108
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../reference/reference_lua/socket.rst:111
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. To prevent a fiber containing socket functions from \"blocking\" other fibers, the :ref:`implicit yield rules <atomic-the_implicit_yield_rules>` will cause a yield so that other processes may take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../reference/reference_lua/socket.rst:120
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../reference/reference_lua/socket.rst:129
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:132
msgid "an unconnected socket, or nil."
msgstr ""

#: ../reference/reference_lua/socket.rst:137
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../reference/reference_lua/socket.rst:145
msgid "Connect a socket to a remote host."
msgstr ""

#: ../reference/reference_lua/socket.rst:147
msgid "URL or IP address"
msgstr ""

#: ../reference/reference_lua/socket.rst:148
msgid "port number"
msgstr ""

#: ../reference/reference_lua/socket.rst:149
msgid "timeout"
msgstr ""

#: ../reference/reference_lua/socket.rst:150
msgid "a connected socket, if no error."
msgstr ""

#: ../reference/reference_lua/socket.rst:155
msgid "tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../reference/reference_lua/socket.rst:163
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed."
msgstr ""

#: ../reference/reference_lua/socket.rst:167
#: ../reference/reference_lua/socket.rst:522
#: ../reference/reference_lua/socket.rst:534
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../reference/reference_lua/socket.rst:172
msgid "``socket.getaddrinfo('tarantool.org', 'http')`` will return variable information such as"
msgstr ""

#: ../reference/reference_lua/socket.rst:175
msgid "---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../reference/reference_lua/socket.rst:194
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with ``box.cfg{listen=...)``."
msgstr ""

#: ../reference/reference_lua/socket.rst:200
msgid "socket.tcp_server('localhost', 3302, function () end)"
msgstr ""

#: ../reference/reference_lua/socket.rst:210
msgid "Connect an existing socket to a remote host. The argument values are the same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../reference/reference_lua/socket.rst:217
msgid "Either:"
msgstr ""

#: ../reference/reference_lua/socket.rst:216
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../reference/reference_lua/socket.rst:218
msgid "port - a number."
msgstr ""

#: ../reference/reference_lua/socket.rst:220
#: ../reference/reference_lua/socket.rst:227
msgid "Or:"
msgstr ""

#: ../reference/reference_lua/socket.rst:220
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../reference/reference_lua/socket.rst:221
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../reference/reference_lua/socket.rst:223
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../reference/reference_lua/socket.rst:225
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../reference/reference_lua/socket.rst:229
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../reference/reference_lua/socket.rst:234
msgid "socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../reference/reference_lua/socket.rst:245
msgid "Send data over a connected socket."
msgstr ""

#: ../reference/reference_lua/socket.rst:248
#: ../reference/reference_lua/socket.rst:362
msgid "the number of bytes sent."
msgstr ""

#: ../reference/reference_lua/socket.rst:251
msgid "Possible errors: nil on error."
msgstr ""

#: ../reference/reference_lua/socket.rst:257
msgid "Write as much as possible data to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:264
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../reference/reference_lua/socket.rst:268
msgid "a string of the requested length on success."
msgstr ""

#: ../reference/reference_lua/socket.rst:271
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../reference/reference_lua/socket.rst:284
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../reference/reference_lua/socket.rst:289
msgid "maximum number of bytes to read for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../reference/reference_lua/socket.rst:291
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../reference/reference_lua/socket.rst:293
msgid "maximum number of seconds to wait for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../reference/reference_lua/socket.rst:296
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../reference/reference_lua/socket.rst:306
msgid "Return all available data from the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:313
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :ref:`socket_object.recvfrom <socket-recvfrom>`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../reference/reference_lua/socket.rst:321
msgid "a socket object on success"
msgstr ""

#: ../reference/reference_lua/socket.rst:324
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../reference/reference_lua/socket.rst:330
msgid "Start listening for incoming connections."
msgstr ""

#: ../reference/reference_lua/socket.rst:332
msgid "On Linux the listen ``backlog`` backlog may be from /proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../reference/reference_lua/socket.rst:336
msgid "true for success, false for error."
msgstr ""

#: ../reference/reference_lua/socket.rst:337
msgid "boolean."
msgstr ""

#: ../reference/reference_lua/socket.rst:343
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../reference/reference_lua/socket.rst:347
msgid "new socket if success."
msgstr ""

#: ../reference/reference_lua/socket.rst:356
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../reference/reference_lua/socket.rst:365
#: ../reference/reference_lua/socket.rst:377
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../reference/reference_lua/socket.rst:371
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../reference/reference_lua/socket.rst:374
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../reference/reference_lua/socket.rst:375
msgid "string, table"
msgstr ""

#: ../reference/reference_lua/socket.rst:381
msgid "After ``message_content, message_sender = recvfrom(1)`` the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing"
msgstr ""

#: ../reference/reference_lua/socket.rst:385
msgid "message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../reference/reference_lua/socket.rst:395
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../reference/reference_lua/socket.rst:397
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../reference/reference_lua/socket.rst:399
#: ../reference/reference_lua/tap.rst:90
#: ../reference/reference_lua/tap.rst:122
#: ../reference/reference_lua/tap.rst:153
#: ../reference/reference_lua/tap.rst:164
#: ../reference/reference_lua/tap.rst:181
#: ../reference/reference_lua/tap.rst:189
msgid "true or false."
msgstr ""

#: ../reference/reference_lua/socket.rst:406
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when its userdata is garbage collected by Lua."
msgstr ""

#: ../reference/reference_lua/socket.rst:409
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../reference/reference_lua/socket.rst:418
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../reference/reference_lua/socket.rst:421
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../reference/reference_lua/socket.rst:423
msgid "number, string"
msgstr ""

#: ../reference/reference_lua/socket.rst:429
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../reference/reference_lua/socket.rst:433
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../reference/reference_lua/socket.rst:434
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../reference/reference_lua/socket.rst:435
msgid "SO_BROADCAST"
msgstr ""

#: ../reference/reference_lua/socket.rst:436
msgid "SO_DEBUG"
msgstr ""

#: ../reference/reference_lua/socket.rst:437
msgid "SO_DOMAIN"
msgstr ""

#: ../reference/reference_lua/socket.rst:438
msgid "SO_ERROR"
msgstr ""

#: ../reference/reference_lua/socket.rst:439
msgid "SO_DONTROUTE"
msgstr ""

#: ../reference/reference_lua/socket.rst:440
msgid "SO_KEEPALIVE"
msgstr ""

#: ../reference/reference_lua/socket.rst:441
msgid "SO_MARK"
msgstr ""

#: ../reference/reference_lua/socket.rst:442
msgid "SO_OOBINLINE"
msgstr ""

#: ../reference/reference_lua/socket.rst:443
msgid "SO_PASSCRED"
msgstr ""

#: ../reference/reference_lua/socket.rst:444
msgid "SO_PEERCRED"
msgstr ""

#: ../reference/reference_lua/socket.rst:445
msgid "SO_PRIORITY"
msgstr ""

#: ../reference/reference_lua/socket.rst:446
msgid "SO_PROTOCOL"
msgstr ""

#: ../reference/reference_lua/socket.rst:447
msgid "SO_RCVBUF"
msgstr ""

#: ../reference/reference_lua/socket.rst:448
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../reference/reference_lua/socket.rst:449
msgid "SO_RCVLOWAT"
msgstr ""

#: ../reference/reference_lua/socket.rst:450
msgid "SO_SNDLOWAT"
msgstr ""

#: ../reference/reference_lua/socket.rst:451
msgid "SO_RCVTIMEO"
msgstr ""

#: ../reference/reference_lua/socket.rst:452
msgid "SO_SNDTIMEO"
msgstr ""

#: ../reference/reference_lua/socket.rst:453
msgid "SO_REUSEADDR"
msgstr ""

#: ../reference/reference_lua/socket.rst:454
msgid "SO_SNDBUF"
msgstr ""

#: ../reference/reference_lua/socket.rst:455
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../reference/reference_lua/socket.rst:456
msgid "SO_TIMESTAMP"
msgstr ""

#: ../reference/reference_lua/socket.rst:457
msgid "SO_TYPE"
msgstr ""

#: ../reference/reference_lua/socket.rst:459
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../reference/reference_lua/socket.rst:465
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../reference/reference_lua/socket.rst:471
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../reference/reference_lua/socket.rst:476
msgid "new active and timeout values."
msgstr ""

#: ../reference/reference_lua/socket.rst:482
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../reference/reference_lua/socket.rst:483
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../reference/reference_lua/socket.rst:484
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../reference/reference_lua/socket.rst:486
msgid "This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../reference/reference_lua/socket.rst:493
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../reference/reference_lua/socket.rst:495
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../reference/reference_lua/socket.rst:501
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../reference/reference_lua/socket.rst:503
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../reference/reference_lua/socket.rst:509
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../reference/reference_lua/socket.rst:511
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../reference/reference_lua/socket.rst:517
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../reference/reference_lua/socket.rst:529
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../reference/reference_lua/socket.rst:545
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../reference/reference_lua/socket.rst:547
msgid "In this example a connection is made over the internet between the Tarantool server and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\". This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../reference/reference_lua/socket.rst:552
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0rnHost: tarantool.orgrnrn\")\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- \"HTTP/1.1 200 OKrn\"\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/socket.rst:583
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../reference/reference_lua/socket.rst:585
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../reference/reference_lua/socket.rst:591
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/socket.rst:628
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../reference/reference_lua/socket.rst:630
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../reference/reference_lua/socket.rst:635
msgid "Start two shells. The first shell will be the server. The second shell will be the client."
msgstr ""

#: ../reference/reference_lua/socket.rst:638
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../reference/reference_lua/socket.rst:640
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../reference/reference_lua/socket.rst:655
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../reference/reference_lua/socket.rst:662
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../reference/reference_lua/socket.rst:667
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server's host and port:"
msgstr ""

#: ../reference/reference_lua/socket.rst:670
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../reference/reference_lua/socket.rst:674
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../reference/reference_lua/strict.rst:28
msgid "Module `strict`"
msgstr ""

#: ../reference/reference_lua/strict.rst:32
msgid "The :code:`strict` module has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../reference/reference_lua/strict.rst:37
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../reference/reference_lua/strict.rst:43
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/tap.rst:28
msgid "Module `tap`"
msgstr ""

#: ../reference/reference_lua/tap.rst:30
msgid "The tap module streamlines the testing of other modules. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../reference/reference_lua/tap.rst:39
msgid "Initialize."
msgstr ""

#: ../reference/reference_lua/tap.rst:41
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../reference/reference_lua/tap.rst:45
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../reference/reference_lua/tap.rst:46
msgid "taptest"
msgstr ""

#: ../reference/reference_lua/tap.rst:49
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../reference/reference_lua/tap.rst:58
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../reference/reference_lua/tap.rst:65
msgid "Checks the number of tests performed. This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script."
msgstr ""

#: ../reference/reference_lua/tap.rst:69
msgid "Will display ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../reference/reference_lua/tap.rst:76
msgid "Display a diagnostic message."
msgstr ""

#: ../reference/reference_lua/tap.rst:78
msgid "the message to be displayed."
msgstr ""

#: ../reference/reference_lua/tap.rst:83
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../reference/reference_lua/tap.rst:87
msgid "an expression which is true or false"
msgstr ""

#: ../reference/reference_lua/tap.rst:88
#: ../reference/reference_lua/tap.rst:120
#: ../reference/reference_lua/tap.rst:131
#: ../reference/reference_lua/tap.rst:152
#: ../reference/reference_lua/tap.rst:162
#: ../reference/reference_lua/tap.rst:179
#: ../reference/reference_lua/tap.rst:194
msgid "name of test"
msgstr ""

#: ../reference/reference_lua/tap.rst:95
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/tap.rst:117
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../reference/reference_lua/tap.rst:127
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../reference/reference_lua/tap.rst:137
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_lua/tap.rst:147
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../reference/reference_lua/tap.rst:150
#: ../reference/reference_lua/tap.rst:160
#: ../reference/reference_lua/tap.rst:192
msgid "actual result"
msgstr ""

#: ../reference/reference_lua/tap.rst:151
#: ../reference/reference_lua/tap.rst:161
#: ../reference/reference_lua/tap.rst:193
msgid "expected result"
msgstr ""

#: ../reference/reference_lua/tap.rst:158
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../reference/reference_lua/tap.rst:175
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../reference/reference_lua/tap.rst:186
msgid "Recursive version of ``taptest:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../reference/reference_lua/tap.rst:204
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../reference/reference_lua/tap.rst:208
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../reference/reference_lua/tap.rst:222
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../reference/reference_lua/tap.rst:224
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../reference/reference_lua/tarantool.rst:28
msgid "Module `tarantool`"
msgstr ""

#: ../reference/reference_lua/tarantool.rst:32
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../reference/reference_lua/tarantool.rst:38
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :ref:`box.info <box_introspection-box_info>` but use of the tarantool module is recommended."
msgstr ""

#: ../reference/reference_lua/tarantool.rst:44
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../reference/reference_lua/uuid.rst:28
msgid "Module `uuid`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:30
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../reference/reference_lua/uuid.rst:36
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../reference/reference_lua/uuid.rst:38
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:39
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:40
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:42
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../reference/reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:45
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:46
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:47
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:49
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../reference/reference_lua/uuid.rst:51
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../reference/reference_lua/uuid.rst:57
msgid "A nil object"
msgstr ""

#: ../reference/reference_lua/uuid.rst:63
#: ../reference/reference_lua/uuid.rst:70
#: ../reference/reference_lua/uuid.rst:77
msgid "a UUID"
msgstr ""

#: ../reference/reference_lua/uuid.rst:64
#: ../reference/reference_lua/uuid.rst:86
#: ../reference/reference_lua/uuid.rst:94
msgid "cdata"
msgstr ""

#: ../reference/reference_lua/uuid.rst:71
msgid "16-byte string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:78
msgid "36-byte binary string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:84
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:85
#: ../reference/reference_lua/uuid.rst:93
msgid "converted UUID"
msgstr ""

#: ../reference/reference_lua/uuid.rst:92
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:102
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../reference/reference_lua/uuid.rst:104
msgid "'l' - little-endian,"
msgstr ""

#: ../reference/reference_lua/uuid.rst:105
msgid "'b' - big-endian,"
msgstr ""

#: ../reference/reference_lua/uuid.rst:106
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../reference/reference_lua/uuid.rst:107
msgid "'n' - endianness depends on network"
msgstr ""

#: ../reference/reference_lua/uuid.rst:109
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../reference/reference_lua/uuid.rst:111
#: ../reference/reference_lua/uuid.rst:118
msgid "UUID converted from cdata input value."
msgstr ""

#: ../reference/reference_lua/uuid.rst:112
msgid "16-byte binary string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:119
msgid "36-byte hexadecimal string"
msgstr ""

#: ../reference/reference_lua/uuid.rst:125
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../reference/reference_lua/uuid.rst:130
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../reference/reference_lua/uuid.rst:131
msgid "bool"
msgstr ""

#: ../reference/reference_lua/uuid.rst:137
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uui:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../reference/reference_lua/yaml.rst:30
msgid "Module `yaml`"
msgstr ""

#: ../reference/reference_lua/yaml.rst:32
msgid "The ``yaml`` module takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../reference/reference_lua/yaml.rst:39
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../reference/reference_lua/yaml.rst:42
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../reference/reference_lua/yaml.rst:47
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../reference/reference_lua/yaml.rst:49
msgid "a string formatted as YAML."
msgstr ""

#: ../reference/reference_lua/yaml.rst:63
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_lua/yaml.rst:86
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../reference/reference_lua/yaml.rst:89
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../reference/reference_lua/yaml.rst:90
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../reference/reference_lua/yaml.rst:91
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../reference/reference_lua/yaml.rst:92
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../reference/reference_lua/yaml.rst:97
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../reference/reference_lua/yaml.rst:133
msgid "Also, some YAML configuration settings for encoding can be changed, in the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../reference/reference_rock/dbms.rst:30
msgid "SQL DBMS Modules"
msgstr ""

#: ../reference/reference_rock/dbms.rst:32
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../reference/reference_rock/dbms.rst:36
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../reference/reference_rock/dbms.rst:41
msgid "Tarantool supplies DBMS connector modules with the module manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../reference/reference_rock/dbms.rst:44
msgid "The Tarantool rocks allow for connecting to an SQL server and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the module also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-module>` module."
msgstr ""

#: ../reference/reference_rock/dbms.rst:55
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../reference/reference_rock/dbms.rst:63
msgid "MySQL Example"
msgstr ""

#: ../reference/reference_rock/dbms.rst:65
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use ``find`` or ``whereis`` to see what directories these files are installed in."
msgstr ""

#: ../reference/reference_rock/dbms.rst:72
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server. After that, one can pass any MySQL statement to the server and receive results, including multiple result sets."
msgstr ""

#: ../reference/reference_rock/dbms.rst:78
#: ../reference/reference_rock/dbms.rst:432
msgid "Installation"
msgstr ""

#: ../reference/reference_rock/dbms.rst:80
msgid "Check the instructions for :ref:`Downloading and installing a binary package <user_guide_getting_started-downloading_and_installing_a_binary_package>` that apply for the environment where tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line"
msgstr ""

#: ../reference/reference_rock/dbms.rst:85
#: ../reference/reference_rock/dbms.rst:440
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../reference/reference_rock/dbms.rst:89
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:93
#: ../reference/reference_rock/dbms.rst:448
msgid "With LuaRocks"
msgstr ""

#: ../reference/reference_rock/dbms.rst:95
#: ../reference/reference_rock/dbms.rst:450
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:102
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../reference/reference_rock/dbms.rst:108
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../reference/reference_rock/dbms.rst:112
#: ../reference/reference_rock/dbms.rst:467
msgid "See also :ref:`Modules <modules>`."
msgstr ""

#: ../reference/reference_rock/dbms.rst:116
#: ../reference/reference_rock/dbms.rst:471
msgid "With GitHub"
msgstr ""

#: ../reference/reference_rock/dbms.rst:118
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:120
msgid "git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../reference/reference_rock/dbms.rst:127
#: ../reference/reference_rock/dbms.rst:482
msgid "At this point it is a good idea to check that the installation produced a file named ``driver.so``, and to check that this file is on a directory that is searched by the ``require`` request."
msgstr ""

#: ../reference/reference_rock/dbms.rst:133
#: ../reference/reference_rock/dbms.rst:488
msgid "Connecting"
msgstr ""

#: ../reference/reference_rock/dbms.rst:135
msgid "Begin by making a ``require`` request for the mysql driver. We will assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../reference/reference_rock/dbms.rst:138
msgid "mysql = require('mysql')"
msgstr ""

#: ../reference/reference_rock/dbms.rst:142
#: ../reference/reference_rock/dbms.rst:497
msgid "Now, say:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:147
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../reference/reference_rock/dbms.rst:149
#: ../reference/reference_rock/dbms.rst:504
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:151
#: ../reference/reference_rock/dbms.rst:506
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../reference/reference_rock/dbms.rst:152
#: ../reference/reference_rock/dbms.rst:507
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../reference/reference_rock/dbms.rst:153
#: ../reference/reference_rock/dbms.rst:508
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../reference/reference_rock/dbms.rst:154
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../reference/reference_rock/dbms.rst:155
#: ../reference/reference_rock/dbms.rst:510
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../reference/reference_rock/dbms.rst:156
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../reference/reference_rock/dbms.rst:158
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../reference/reference_rock/dbms.rst:165
#: ../reference/reference_rock/dbms.rst:514
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:167
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../reference/reference_rock/dbms.rst:183
#: ../reference/reference_rock/dbms.rst:526
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:185
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:201
#: ../reference/reference_rock/dbms.rst:545
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../reference/reference_rock/dbms.rst:205
#: ../reference/reference_rock/dbms.rst:549
msgid "How to ping"
msgstr ""

#: ../reference/reference_rock/dbms.rst:207
#: ../reference/reference_rock/dbms.rst:551
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:212
#: ../reference/reference_rock/dbms.rst:556
msgid "*connection-name*:ping()"
msgstr ""

#: ../reference/reference_rock/dbms.rst:216
#: ../reference/reference_rock/dbms.rst:561
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:225
#: ../reference/reference_rock/dbms.rst:570
msgid "Executing a statement"
msgstr ""

#: ../reference/reference_rock/dbms.rst:227
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:232
#: ../reference/reference_rock/dbms.rst:577
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../reference/reference_rock/dbms.rst:234
#: ../reference/reference_rock/dbms.rst:579
msgid "where ``sql-statement`` is a string, and the optional ``parameters`` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../reference/reference_rock/dbms.rst:240
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:253
#: ../reference/reference_rock/dbms.rst:597
msgid "Closing connection"
msgstr ""

#: ../reference/reference_rock/dbms.rst:255
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:260
#: ../reference/reference_rock/dbms.rst:604
msgid "*connection-name*:close()"
msgstr ""

#: ../reference/reference_rock/dbms.rst:264
#: ../reference/reference_rock/dbms.rst:608
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:270
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../reference/reference_rock/dbms.rst:277
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server is already running on the local host 127.0.0.1."
msgstr ""

#: ../reference/reference_rock/dbms.rst:281
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../reference/reference_rock/dbms.rst:362
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../reference/reference_rock/dbms.rst:365
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:373
msgid "Create a Lua function that will connect to the MySQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../reference/reference_rock/dbms.rst:378
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:402
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../reference/reference_rock/dbms.rst:409
msgid "PostgreSQL Example"
msgstr ""

#: ../reference/reference_rock/dbms.rst:411
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:416
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../reference/reference_rock/dbms.rst:420
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../reference/reference_rock/dbms.rst:426
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server. After that, one can pass any PostgreSQL statement to the server and receive results."
msgstr ""

#: ../reference/reference_rock/dbms.rst:434
msgid "Check the instructions for :ref:`Downloading and installing a binary package <user_guide_getting_started-downloading_and_installing_a_binary_package>` that apply for the environment where tarantool was installed. In addition to installing ``tarantool``, install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:444
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:457
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../reference/reference_rock/dbms.rst:463
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../reference/reference_rock/dbms.rst:473
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:475
msgid "git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../reference/reference_rock/dbms.rst:490
msgid "Begin by making a ``require`` request for the pg driver. We will assume that the name is ``pg`` in further examples."
msgstr ""

#: ../reference/reference_rock/dbms.rst:493
msgid "pg = require('pg')"
msgstr ""

#: ../reference/reference_rock/dbms.rst:502
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../reference/reference_rock/dbms.rst:509
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../reference/reference_rock/dbms.rst:512
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../reference/reference_rock/dbms.rst:516
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../reference/reference_rock/dbms.rst:528
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:572
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:585
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:599
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../reference/reference_rock/dbms.rst:614
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../reference/reference_rock/dbms.rst:621
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server is already running on the local host 127.0.0.1."
msgstr ""

#: ../reference/reference_rock/dbms.rst:625
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../reference/reference_rock/dbms.rst:699
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../reference/reference_rock/dbms.rst:702
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:710
msgid "Create a Lua function that will connect to the PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../reference/reference_rock/dbms.rst:715
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../reference/reference_rock/dbms.rst:740
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:30
msgid "Module `expirationd`"
msgstr ""

#: ../reference/reference_rock/expirationd.rst:32
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at expirationd, which Tarantool supplies on GitHub_ with an Artistic license. The expirationd.lua program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:37
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:45
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:50
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:59
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:64
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../reference/reference_rock/expirationd.rst:75
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-module>` module is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:85
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:90
msgid "At this point, if the above explanation is worthwhile, it's clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and - whenever it finds a tuple that has expired - deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:99
msgid "For those who like to see things run, here are the exact steps to get expirationd through the test."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:102
msgid "Get ``expirationd.lua``. There are standard ways - it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but for this purpose just copy the contents of expirationd.lua_ to a default directory."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:105
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:106
msgid "Execute these requests:"
msgstr ""

#: ../reference/reference_rock/expirationd.rst:108
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../reference/reference_rock/expirationd.rst:131
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:136
msgid "The function which will be supplied to expirationd is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:141
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The \"``require``\" function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a module that's not part of the Tarantool kernel. After the Lua variable expd has been assigned the value of the expirationd module, it's possible to invoke the module's ``run_task()`` function."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:148
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\". After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the is_tuple_expired() function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../reference/reference_rock/expirationd.rst:158
msgid "Of course, expirationd can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code."
msgstr ""

#: ../reference/reference_rock/index.rst:28
msgid "Rocks reference"
msgstr ""

#: ../reference/reference_rock/index.rst:30
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../reference/reference_rock/shard.rst:30
msgid "Module `shard`"
msgstr ""

#: ../reference/reference_rock/shard.rst:34
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server on each node. With this arrangement, each server is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../reference/reference_rock/shard.rst:39
msgid "The Tarantool shard module has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../reference/reference_rock/shard.rst:43
msgid "First some terminology:"
msgstr ""

#: ../reference/reference_rock/shard.rst:46
msgid "**Consistent Hash**"
msgstr ""

#: ../reference/reference_rock/shard.rst:48
msgid "The shard module distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the shard module uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../reference/reference_rock/shard.rst:54
msgid "**Queue**"
msgstr ""

#: ../reference/reference_rock/shard.rst:56
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on ever node. The shard module has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../reference/reference_rock/shard.rst:62
msgid "**Redundancy**"
msgstr ""

#: ../reference/reference_rock/shard.rst:64
msgid "The number of replicas in each shard."
msgstr ""

#: ../reference/reference_rock/shard.rst:65
msgid "**Replica**"
msgstr ""

#: ../reference/reference_rock/shard.rst:67
msgid "A complete copy of the data. The shard module handles both sharding and replication. One shard can contain one or more replicas. When a write occurs, the write is attempted on every replica in turn. The shard module does not use the built-in replication feature."
msgstr ""

#: ../reference/reference_rock/shard.rst:71
msgid "**Shard**"
msgstr ""

#: ../reference/reference_rock/shard.rst:73
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../reference/reference_rock/shard.rst:77
msgid "**Zone**"
msgstr ""

#: ../reference/reference_rock/shard.rst:79
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single tarantool-server instance. A shard's replicas should be in different zones."
msgstr ""

#: ../reference/reference_rock/shard.rst:84
msgid "The shard package is distributed separately from the main tarantool package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../reference/reference_rock/shard.rst:87
msgid "sudo apt-get install tarantool-shard tarantool-pool"
msgstr ""

#: ../reference/reference_rock/shard.rst:91
msgid "Or, download from github tarantool/shard and compile as described in the README. Then, before using the module, say ``shard = require('shard')``"
msgstr ""

#: ../reference/reference_rock/shard.rst:94
msgid "The most important function is:"
msgstr ""

#: ../reference/reference_rock/shard.rst:99
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../reference/reference_rock/shard.rst:101
msgid "This must be called for every shard. The shard-configuration is a table with these fields:"
msgstr ""

#: ../reference/reference_rock/shard.rst:104
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../reference/reference_rock/shard.rst:105
msgid "login (the user name which applies for accessing via the shard module)"
msgstr ""

#: ../reference/reference_rock/shard.rst:106
msgid "password (the password for the login)"
msgstr ""

#: ../reference/reference_rock/shard.rst:107
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../reference/reference_rock/shard.rst:108
msgid "binary (a port number that this host is listening on, on the current host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../reference/reference_rock/shard.rst:111
msgid "Possible Errors: Redundancy should not be greater than the number of servers; the servers must be alive; two replicas of the same shard should not be in the same zone."
msgstr ""

#: ../reference/reference_rock/shard.rst:117
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../reference/reference_rock/shard.rst:119
msgid "The number of replicas per shard (redundancy) is 3. The number of servers is 3. The shard module will conclude that there is only one shard."
msgstr ""

#: ../reference/reference_rock/shard.rst:123
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/shard.rst:144
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../reference/reference_rock/shard.rst:146
msgid "This describes three shards. Each shard has two replicas. Since the number of servers is 7, and the number of replicas per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../reference/reference_rock/shard.rst:151
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference/reference_rock/shard.rst:177
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../reference/reference_rock/shard.rst:184
msgid "Every data-access function in the box module has an analogue in the shard module, so (for example) to insert in table T in a sharded database one simply says ``shard.T:insert{...}`` instead of ``box.space.T:insert{...}``. A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../reference/reference_rock/shard.rst:192
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../reference/reference_rock/shard.rst:199
msgid "Every queued data-access function has an analogue in the shard module. The user must add an operation_id. The details of queued data-access functions, and of maintenance-related functions, are on `the shard section of github`_."
msgstr ""

#: ../reference/reference_rock/shard.rst:205
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../reference/reference_rock/shard.rst:207
msgid "There is only one shard, and that shard contains only one replica. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../reference/reference_rock/shard.rst:212
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference/reference_rock/shard.rst:238
msgid "If one cuts and pastes the above, then the result, showing only the requests and responses for shard.init and shard.tester, should look approximately like this:"
msgstr ""

#: ../reference/reference_rock/shard.rst:242
msgid "tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference/reference_rock/shard.rst:271
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../reference/reference_rock/shard.rst:273
msgid "There are two shards, and each shard contains one replica. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../reference/reference_rock/shard.rst:278
msgid "On Terminal #1, say:"
msgstr ""

#: ../reference/reference_rock/shard.rst:280
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference/reference_rock/shard.rst:308
msgid "On Terminal #2, say:"
msgstr ""

#: ../reference/reference_rock/shard.rst:310
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../reference/reference_rock/shard.rst:338
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../reference/reference_rock/shard.rst:342
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../reference/reference_rock/shard.rst:344
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference/reference_rock/shard.rst:351
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the shard module."
msgstr ""

#: ../reference/reference_rock/shard.rst:354
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../reference/reference_rock/tdb.rst:28
msgid "Module `tdb`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:30
msgid "The Tarantool Debugger (abbreviation = tdb) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../reference/reference_rock/tdb.rst:36
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../reference/reference_rock/tdb.rst:39
msgid "git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../reference/reference_rock/tdb.rst:46
msgid "To initiate tdb within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../reference/reference_rock/tdb.rst:49
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../reference/reference_rock/tdb.rst:54
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../reference/reference_rock/tdb.rst:59
msgid "Debugger Commands"
msgstr ""

#: ../reference/reference_rock/tdb.rst:63
msgid ":codebold:`bt`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:62
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../reference/reference_rock/tdb.rst:66
msgid ":codebold:`c`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:66
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../reference/reference_rock/tdb.rst:73
msgid ":codebold:`e`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:69
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../reference/reference_rock/tdb.rst:76
msgid ":codebold:`-e`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:76
msgid "Exit evaluation mode."
msgstr ""

#: ../reference/reference_rock/tdb.rst:80
msgid ":codebold:`f`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:79
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../reference/reference_rock/tdb.rst:83
msgid ":codebold:`n`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:83
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../reference/reference_rock/tdb.rst:86
msgid ":codebold:`globals`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:86
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../reference/reference_rock/tdb.rst:89
msgid ":codebold:`h`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:89
msgid "Display a list of debugger commands."
msgstr ""

#: ../reference/reference_rock/tdb.rst:93
msgid ":codebold:`locals`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:92
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../reference/reference_rock/tdb.rst:96
msgid ":codebold:`q`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:96
msgid "Quit immediately."
msgstr ""

#: ../reference/reference_rock/tdb.rst:100
msgid "Example Session"
msgstr ""

#: ../reference/reference_rock/tdb.rst:102
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../reference/reference_rock/tdb.rst:104
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../reference/reference_rock/tdb.rst:112
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../reference/reference_rock/tdb.rst:117
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:119
#: ../reference/reference_rock/tdb.rst:144
msgid "The screen should now look like this:"
msgstr ""

#: ../reference/reference_rock/tdb.rst:124
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../reference/reference_rock/tdb.rst:131
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../reference/reference_rock/tdb.rst:135
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../reference/reference_rock/tdb.rst:149
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../reference/reference_rock/tdb.rst:166
msgid "Another debugger example can be found here_."
msgstr ""

