# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-06-23 13:32+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../reference/box.rst:28
msgid "Package `box`"
msgstr ""

#: ../reference/box.rst:30
msgid "The contents of the ``box`` library can be inspected at runtime with ``box``, with no arguments. The packages inside the box library are: ``box.schema``, ``box.tuple``, ``box.space``, ``box.index``, ``net.box``, ``box.cfg``, ``box.info``, ``box.slab``, ``box.stat``. Every package contains one or more Lua functions. A few packages contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../reference/box_error.rst:28
msgid "Package `box.error`"
msgstr ""

#: ../reference/box_error.rst:32
msgid "The ``box.error`` function is for raising an error. The difference between this function and Lua's built-in ``error()`` function is that when the error reaches the client, its error code is preserved. In contrast, a Lua error would always be presented to the client as :errcode:`ER_PROC_LUA`."
msgstr ""

#: ../reference/box_error.rst:39
msgid "When called with a Lua-table argument, the code and reason have any user-desired values. The result will be those values."
msgstr ""

#: ../reference/box_error.rst:47
msgid "When called without arguments, ``box.error()`` re-throws whatever the last error was."
msgstr ""

#: ../reference/box_error.rst:52
msgid "Emulate a request error, with text based on one of the pre-defined Tarantool errors defined in the file `errcode.h <https://github.com/tarantool/tarantool/blob/master/src/box/errcode.h>`_ in the source tree. Lua constants which correspond to those Tarantool errors are defined as members of ``box.error``, for example ``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../reference/box_error.rst:58
msgid "number of a pre-defined error"
msgstr ""

#: ../reference/box_error.rst:59
msgid "part of the message which will accompany the error"
msgstr ""

#: ../reference/box_error.rst:61
msgid "For example:"
msgstr ""

#: ../reference/box_error.rst:63
msgid "the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it includes one \"``%s``\" component which will be replaced with errtext. Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or ``box.error(45, 'joe')`` will result in an error with the accompanying message \"``User 'joe' is not found``\"."
msgstr ""

#: ../reference/box_error.rst:69
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../reference/box_error.rst:71
#: ../reference/box_error.rst:107
#: ../reference/clock.rst:51
#: ../reference/clock.rst:70
#: ../reference/clock.rst:88
#: ../reference/clock.rst:106
#: ../reference/clock.rst:128
#: ../reference/console.rst:70
#: ../reference/console.rst:102
#: ../reference/console.rst:125
#: ../reference/csv.rst:68
#: ../reference/csv.rst:145
#: ../reference/csv.rst:186
#: ../reference/fiber.rst:76
#: ../reference/fiber.rst:98
#: ../reference/fiber.rst:116
#: ../reference/fiber.rst:134
#: ../reference/fiber.rst:161
#: ../reference/fiber.rst:178
#: ../reference/fiber.rst:203
#: ../reference/fiber.rst:217
#: ../reference/fiber.rst:235
#: ../reference/fiber.rst:254
#: ../reference/fiber.rst:277
#: ../reference/fiber.rst:295
#: ../reference/fiber.rst:318
#: ../reference/fiber.rst:337
#: ../reference/fiber.rst:378
#: ../reference/fiber.rst:395
#: ../reference/fio.rst:50
#: ../reference/fio.rst:70
#: ../reference/fio.rst:88
#: ../reference/fio.rst:110
#: ../reference/fio.rst:130
#: ../reference/fio.rst:161
#: ../reference/fio.rst:182
#: ../reference/fio.rst:197
#: ../reference/fio.rst:210
#: ../reference/fio.rst:234
#: ../reference/fio.rst:257
#: ../reference/fio.rst:276
#: ../reference/fio.rst:299
#: ../reference/fio.rst:315
#: ../reference/fio.rst:338
#: ../reference/fio.rst:360
#: ../reference/fio.rst:383
#: ../reference/fio.rst:413
#: ../reference/fio.rst:431
#: ../reference/fio.rst:454
#: ../reference/fio.rst:472
#: ../reference/fio.rst:504
#: ../reference/jit.rst:40
#: ../reference/jit.rst:55
#: ../reference/jit.rst:68
#: ../reference/jit.rst:82
#: ../reference/jit.rst:103
#: ../reference/json.rst:44
#: ../reference/json.rst:80
#: ../reference/json.rst:104
#: ../reference/net_box.rst:79
#: ../reference/net_box.rst:99
#: ../reference/net_box.rst:113
#: ../reference/net_box.rst:126
#: ../reference/other.rst:38
#: ../reference/other.rst:75
#: ../reference/pickle.rst:89
#: ../reference/pickle.rst:134
#: ../reference/strict.rst:41
#: ../reference/tap.rst:93
#: ../reference/tap.rst:135
#: ../reference/tarantool.rst:42
msgid "**Example:**"
msgstr ""

#: ../reference/box_error.rst:73
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../reference/box_error.rst:90
msgid "Returns a description of the last error, as a Lua table with five members: \"line\" (number) Tarantool source file line number, \"code\" (number) error's number, \"type\", (string) error's C++ class, \"message\" (string) error's message, \"file\" (string) Tarantool source file. Additionally, if the error is a system error (for example due to a failure in socket or file io), there may be a sixth member: \"errno\" (number) C standard error number."
msgstr ""

#: ../reference/box_error.rst:100
msgid "rtype: table"
msgstr ""

#: ../reference/box_error.rst:104
msgid "Clears the record of errors, so functions like `box.error()` or `box.error.last()` will have no effect."
msgstr ""

#: ../reference/box_error.rst:109
msgid "tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an underscore)\n"
"  file: /tmp/buildd/tarantool-1.6.6.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference/capi.rst:28
msgid "Module C API"
msgstr ""

#: ../reference/capi.rst:0
msgid "Defines"
msgstr ""

#: ../reference/capi.rst:0
msgid "Typedefs"
msgstr ""

#: ../reference/capi.rst:0
msgid "Enums"
msgstr ""

#: ../reference/capi.rst:0
msgid "Functions"
msgstr ""

#: ../reference/capi.rst:0
msgid "Variables"
msgstr ""

#: ../reference/clock.rst:28
msgid "Package `clock`"
msgstr ""

#: ../reference/clock.rst:30
msgid "The ``clock`` package returns time values derived from the Posix / C CLOCK_GETTIME_ function or equivalent. Most functions in the package return a number of seconds; functions whose names end in \"64\" return a 64-bit number of nanoseconds."
msgstr ""

#: ../reference/clock.rst:42
msgid "The wall clock time. Derived from C function clock_gettime(CLOCK_REALTIME). Approximately the same as os.clock(). This is the best function for knowing what the official time is, as determined by the system administrator. |br| See also :func:`fiber.time64 <fiber.time64>`."
msgstr ""

#: ../reference/clock.rst:48
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../reference/clock.rst:49
#: ../reference/clock.rst:68
#: ../reference/clock.rst:86
#: ../reference/clock.rst:104
msgid "number or number64"
msgstr ""

#: ../reference/clock.rst:53
msgid "-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../reference/clock.rst:62
msgid "The monotonic time. Derived from C function clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock time but is not affected by changes to or from daylight saving time, or by changes done by a user. This is the best function to use with benchmarks that need to calculate elapsed time."
msgstr ""

#: ../reference/clock.rst:67
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../reference/clock.rst:72
msgid "-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../reference/clock.rst:81
msgid "The processor time. Derived from C function clock_gettime(CLOCK_PROCESS_CPUTIME_ID). This is the best function to use with benchmarks that need to calculate how much time has been spent within a CPU."
msgstr ""

#: ../reference/clock.rst:85
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../reference/clock.rst:90
msgid "-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../reference/clock.rst:99
msgid "The thread time. Derived from C function clock_gettime(CLOCK_THREAD_CPUTIME_ID). This is the best function to use with benchmarks that need to calculate how much time has been spent within a thread within a CPU."
msgstr ""

#: ../reference/clock.rst:103
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../reference/clock.rst:108
msgid "-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../reference/clock.rst:116
msgid "The time that a function takes within a processor. This function uses clock.proc(), therefore it calculates elapsed CPU time. Therefore it is not useful for showing actual elapsed time."
msgstr ""

#: ../reference/clock.rst:120
#: ../reference/socket.rst:205
msgid "Parameters:"
msgstr ""

#: ../reference/clock.rst:122
msgid ":samp:`{function}` = function or function reference;"
msgstr ""

#: ../reference/clock.rst:123
msgid ":samp:`{function parameters}` = whatever values are required by the function."
msgstr ""

#: ../reference/clock.rst:125
msgid "table. first element = seconds of CPU time; second element = whatever the function returns."
msgstr ""

#: ../reference/clock.rst:126
#: ../reference/csv.rst:66
#: ../reference/fiber.rst:176
#: ../reference/fio.rst:128
#: ../reference/fio.rst:178
#: ../reference/fio.rst:470
#: ../reference/json.rst:78
#: ../reference/msgpack.rst:49
#: ../reference/pickle.rst:132
#: ../reference/socket.rst:149
#: ../reference/socket.rst:455
#: ../reference/socket.rst:465
#: ../reference/yaml.rst:49
msgid "table"
msgstr ""

#: ../reference/clock.rst:130
msgid "-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f,10)"
msgstr ""

#: ../reference/console.rst:30
msgid "Package `console`"
msgstr ""

#: ../reference/console.rst:32
msgid "The console package allows one Tarantool server to access another Tarantool server, and allows one Tarantool server to start listening on an administrative host/port."
msgstr ""

#: ../reference/console.rst:40
msgid "Connect to the server at :ref:`URI`, change the prompt from ':samp:`tarantool>`' to ':samp:`{uri}>`', and act henceforth as a client until the user ends the session or types :code:`control-D`."
msgstr ""

#: ../reference/console.rst:44
msgid "The console.connect function allows one Tarantool server, in interactive mode, to access another Tarantool server. Subsequent requests will appear to be handled locally, but in reality the requests are being sent to the remote server and the local server is acting as a client. Once connection is successful, the prompt will change and subsequent requests are sent to, and executed on, the remote server. Results are displayed on the local server. To return to local mode, enter :code:`control-D`."
msgstr ""

#: ../reference/console.rst:53
msgid "If the Tarantool server at :samp:`uri` requires authentication, the connection might look something like: :code:`console.connect('admin:secretpassword@distanthost.com:3301')`."
msgstr ""

#: ../reference/console.rst:57
msgid "There are no restrictions on the types of requests that can be entered, except those which are due to privilege restrictions -- by default the login to the remote server is done with user name = 'guest'. The remote server could allow for this by granting at least one privilege: :code:`box.schema.user.grant('guest','execute','universe')`."
msgstr ""

#: ../reference/console.rst:63
msgid "the URI of the remote server"
msgstr ""

#: ../reference/console.rst:65
#: ../reference/fiber.rst:275
#: ../reference/fiber.rst:314
#: ../reference/log.rst:54
#: ../reference/tap.rst:61
#: ../reference/tap.rst:72
#: ../reference/tap.rst:79
#: ../reference/tap.rst:133
msgid "nil"
msgstr ""

#: ../reference/console.rst:67
msgid "Possible errors: the connection will fail if the target Tarantool server was not initiated with :code:`box.cfg{listen=...}`."
msgstr ""

#: ../reference/console.rst:72
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that server is remote"
msgstr ""

#: ../reference/console.rst:84
msgid "Listen on :ref:`URI`. The primary way of listening for incoming requests is via the connection-information string, or URI, specified in :code:`box.cfg{listen=...}`. The alternative way of listening is via the URI specified in :code:`console.listen(...)`. This alternative way is called \"administrative\" or simply \"admin port\". The listening is usually over a local host with a Unix socket, specified with host = 'unix/', port = 'path/to/something.sock'."
msgstr ""

#: ../reference/console.rst:92
msgid "the URI of the local server"
msgstr ""

#: ../reference/console.rst:94
msgid "The \"admin\" address is the URI to listen on for administrative connections. It has no default value, so it must be specified if connections will occur via telnet. The parameter is expressed with URI = Universal Resource Identifier format, for example \"/tmpdir/unix_domain_socket.sock\", or as a numeric TCP port. Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../reference/console.rst:104
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../reference/console.rst:123
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../reference/console.rst:127
msgid "A special use of ``console.start()`` is with :ref:`initialization files <init-label>`. Normally, if one starts the tarantool server with :samp:`tarantool {initialization file}` there is no console. This can be remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../reference/console.rst:134
msgid "console = require('console')\n"
"console.start()"
msgstr ""

#: ../reference/csv.rst:28
msgid "Package `csv`"
msgstr ""

#: ../reference/csv.rst:32
msgid "The csv package handles records formatted according to Comma-Separated-Values (CSV) rules."
msgstr ""

#: ../reference/csv.rst:35
msgid "The default formatting rules are:"
msgstr ""

#: ../reference/csv.rst:37
msgid "Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings but not within files,"
msgstr ""

#: ../reference/csv.rst:39
msgid "Commas designate end-of-field,"
msgstr ""

#: ../reference/csv.rst:40
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../reference/csv.rst:41
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../reference/csv.rst:42
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../reference/csv.rst:43
msgid "When enclosed by quote marks, commas and line feeds and spaces are treated as ordinary characters, and a pair of quote marks \"\" is treated as a single quote mark."
msgstr ""

#: ../reference/csv.rst:49
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../reference/csv.rst:51
msgid ":samp:`delimiter = {string}` -- single-byte character to designate end-of-field, default = comma"
msgstr ""

#: ../reference/csv.rst:52
msgid ":samp:`quote_char = {string}` -- single-byte character to designate encloser of string, default = quote mark"
msgstr ""

#: ../reference/csv.rst:53
msgid ":samp:`chunk-size = {number}` -- number of characters to read at once (usually for file-IO efficiency), default = 4096"
msgstr ""

#: ../reference/csv.rst:54
msgid ":samp:`skip_head_lines = {number}` -- number of lines to skip at the start (usually for a header), default 0"
msgstr ""

#: ../reference/csv.rst:58
msgid "Get CSV-formatted input from ``readable`` and return a table as output. Usually ``readable`` is either a string or a file opened for reading. Usually :samp:`{options}` is not specified."
msgstr ""

#: ../reference/csv.rst:62
msgid "a string, or any object which has a read() method, formatted according to the CSV rules"
msgstr ""

#: ../reference/csv.rst:64
#: ../reference/csv.rst:182
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../reference/csv.rst:65
msgid "loaded_value"
msgstr ""

#: ../reference/csv.rst:70
msgid "Readable string has 3 fields, field#2 has comma and space so use quote marks:"
msgstr ""

#: ../reference/csv.rst:72
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../reference/csv.rst:84
msgid "Readable string contains 2-byte character = Cyrillic Letter Palochka: (This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../reference/csv.rst:87
msgid "tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../reference/csv.rst:94
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../reference/csv.rst:96
msgid "tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../reference/csv.rst:104
msgid "Readable file :file:`./file.csv` contains two CSV records. Explanation of fio is in section :ref:`fio <fio-section>`. Source CSV file and example respectively:"
msgstr ""

#: ../reference/csv.rst:108
msgid "tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close(nn)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/csv.rst:133
msgid "Get table input from ``csv-table`` and return a CSV-formatted string as output. Or, get table input from ``csv-table`` and put the output in ``writable``. Usually :samp:`{options}` is not specified. Usually ``writable``, if specified, is a file opened for writing. :func:`csv.dump()` is the reverse of :func:`csv.load()`."
msgstr ""

#: ../reference/csv.rst:139
#: ../reference/csv.rst:181
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../reference/csv.rst:140
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../reference/csv.rst:141
msgid "any object which has a write() method"
msgstr ""

#: ../reference/csv.rst:142
msgid "dumped_value"
msgstr ""

#: ../reference/csv.rst:143
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../reference/csv.rst:147
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../reference/csv.rst:149
msgid "tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference/csv.rst:161
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../reference/csv.rst:163
msgid "tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference/csv.rst:178
msgid "Form a Lua iterator function for going through CSV records one field at a time."
msgstr ""

#: ../reference/csv.rst:183
msgid "Lua iterator function"
msgstr ""

#: ../reference/csv.rst:184
msgid "iterator function"
msgstr ""

#: ../reference/csv.rst:188
msgid "func:`csv.iterate()` is the low level of func:`csv.load()` and :func:`csv.dump()`. To illustrate that, here is a function which is the same as the :func:`csv.load()` function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../reference/csv.rst:192
msgid "tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../reference/digest.rst:28
msgid "Package `digest`"
msgstr ""

#: ../reference/digest.rst:32
msgid "A \"digest\" is a value which is returned by a function (usually a `Cryptographic hash function`_), applied against a string. Tarantool supports five types of cryptographic hash functions (SHA-0_, SHA-1_, SHA-2_, MD4_, MD5) as well as a checksum function (CRC32_), two functions for base64_, and two non-cryptographic hash functions (guava_, murmur_). The functions in digest are:"
msgstr ""

#: ../reference/digest.rst:38
msgid ":func:`digest.sha() <digest.sha>`, |br| :func:`digest.sha_hex() <digest.sha_hex>`, |br| :func:`digest.sha1() <digest.sha1>`, |br| :func:`digest.sha1_hex() <digest.sha1_hex>`, |br| :func:`digest.sha224() <digest.sha224>`, |br| :func:`digest.sha224_hex() <digest.sha224_hex>`, |br| :func:`digest.sha256() <digest.sha256>`, |br| :func:`digest.sha256_hex() <digest.sha256_hex>`, |br| :func:`digest.sha384() <digest.sha384>`, |br| :func:`digest.sha384_hex() <digest.sha384_hex>`, |br| :func:`digest.sha512() <digest.sha512>`, |br| :func:`digest.sha512_hex() <digest.sha512_hex>`, |br| :func:`digest.md4() <digest.md4>`, |br| :func:`digest.md4_hex() <digest.md4_hex>`, |br| :func:`digest.md5() <digest.md5>`, |br| :func:`digest.md5_hex() <digest.md5_hex>`, |br| :func:`digest.crc32() <digest.crc32>`, |br| :func:`digest.crc32.update() <digest.crc32.update>`, |br| :func:`digest.crc32.new() <digest.crc32.new>`, |br| :func:`digest.base64_encode() <digest.base64_encode>`, |br| :func:`digest.base64_decode() <digest.base64_decode>`, |br| :func:`digest.urandom() <digest.urandom>`, |br| :func:`digest.guava() <digest.guava>`, |br| :func:`digest.murmur() <digest.murmur>`, |br| :func:`digest.murmur.new() <digest.murmur.new>` |br|"
msgstr ""

#: ../reference/digest.rst:67
msgid "Returns 160-bit digest made with SHA-0. Not recommended."
msgstr ""

#: ../reference/digest.rst:72
msgid "Returns hexadecimal of a digest calculated with sha."
msgstr ""

#: ../reference/digest.rst:77
msgid "Returns 160-bit digest made with SHA-1."
msgstr ""

#: ../reference/digest.rst:82
msgid "Returns hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../reference/digest.rst:87
msgid "Returns 224-bit digest made with SHA-2."
msgstr ""

#: ../reference/digest.rst:92
msgid "Returns hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../reference/digest.rst:97
msgid "Returns 256-bit digest made with SHA-2."
msgstr ""

#: ../reference/digest.rst:102
msgid "Returns hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../reference/digest.rst:107
msgid "Returns 384-bit digest made with SHA-2."
msgstr ""

#: ../reference/digest.rst:112
msgid "Returns hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../reference/digest.rst:117
msgid "Returns 512-bit digest made with SHA-2."
msgstr ""

#: ../reference/digest.rst:122
msgid "Returns hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../reference/digest.rst:127
msgid "Returns 128-bit digest made with MD4."
msgstr ""

#: ../reference/digest.rst:132
msgid "Returns hexadecimal of a digest calculated with md4."
msgstr ""

#: ../reference/digest.rst:137
msgid "Returns 256-bit digest made with MD5."
msgstr ""

#: ../reference/digest.rst:142
msgid "Returns hexadecimal of a digest calculated with md5."
msgstr ""

#: ../reference/digest.rst:147
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../reference/digest.rst:149
msgid "The crc32 and crc32_update function use the `CRC-32C (Castagnoli)`_ polynomial value: 0x11EDC6F41 / 4812730177. If it is necessary to be compatible with other checksum functions in other programming languages, ensure that the other functions use the same polynomial value. |br| For example, in Python, install the crcmod package and say:"
msgstr ""

#: ../reference/digest.rst:156
msgid ">>> import crcmod\n"
">>> fun = crcmod.mkCrcFun('4812730177')\n"
">>> fun('string')\n"
"3304160206L"
msgstr ""

#: ../reference/digest.rst:168
msgid "Returns update of a checksum calculated with CRC32. See :func:`digest.crc32() <digest.crc32>` notes."
msgstr ""

#: ../reference/digest.rst:173
msgid "Initiates incremental crc32. See :func:`incremental digests <digest.murmur.new>` notes."
msgstr ""

#: ../reference/digest.rst:178
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../reference/digest.rst:183
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../reference/digest.rst:188
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../reference/digest.rst:193
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../reference/digest.rst:195
msgid "The guava function uses the `Consistent Hashing`_ algorithm of the Google guava library. The first parameter should be a hash code; the second parameter should be the number of buckets; the returned value will be an integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../reference/digest.rst:201
msgid "tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../reference/digest.rst:211
msgid "Returns 32-bit digest made with MurmurHash."
msgstr ""

#: ../reference/digest.rst:216
msgid "Initiates incremental MurmurHash."
msgstr ""

#: ../reference/digest.rst:218
msgid "Suppose that a digest is done for a string 'A', then a new part 'B' is appended to the string, then a new digest is required. The new digest could be recomputed for the whole string 'AB', but it is faster to take what was computed before for 'A' and apply changes based on the new part 'B'. This is called multi-step or \"incremental\" digesting, which Tarantool supports with crc32 and with murmur ..."
msgstr ""

#: ../reference/digest.rst:227
msgid "digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../reference/digest.rst:247
#: ../reference/fiber-ipc.rst:129
#: ../reference/log.rst:62
#: ../reference/msgpack.rst:57
#: ../reference/socket.rst:471
#: ../reference/tap.rst:202
#: ../reference/uuid.rst:115
#: ../reference/yaml.rst:57
msgid "Example"
msgstr ""

#: ../reference/digest.rst:249
msgid "In the following example, the user creates two functions, ``password_insert()`` which inserts a SHA-1_ digest of the word \"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` which requires input of a password."
msgstr ""

#: ../reference/digest.rst:253
msgid "tarantool> digest = require('diges')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{12345, digest.sha1('^S^e^c^ret Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     print('Password is valid')\n"
"         >   else\n"
"         >     print('Password is not valid')\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../reference/digest.rst:280
msgid "If a later user calls the ``password_check()`` function and enters the wrong password, the result is an error."
msgstr ""

#: ../reference/digest.rst:283
msgid "tarantool> password_check('Secret Password')\n"
"Password is not valid\n"
"---\n"
"..."
msgstr ""

#: ../reference/expirationd.rst:28
msgid "Package `expirationd`"
msgstr ""

#: ../reference/expirationd.rst:30
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at expirationd, which Tarantool supplies on GitHub_ with an Artistic license. The expirationd.lua program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../reference/expirationd.rst:35
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../reference/expirationd.rst:43
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with :doc:`fiber`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../reference/expirationd.rst:47
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../reference/expirationd.rst:56
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (that is, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../reference/expirationd.rst:61
msgid "-- put expired tuple in archive\n"
"local function put_tuple_to_archive(space_id, args, tuple)\n"
"    -- delete expired tuple\n"
"    box.space[space_id]:delete{tuple[1]}\n"
"    local email = get_field(tuple, 2)\n"
"    if args.archive_space_id ~= nil and email ~= nil then\n"
"        box.space[args.archive_space_id]:replace{email, os.time()}\n"
"    end\n"
"end"
msgstr ""

#: ../reference/expirationd.rst:73
msgid "Ultimately the tuple-expiry process leads to ``put_tuple_to_archive()`` which does a \"delete\" of a tuple from its original space, and an \"insert\" of the same tuple into another space. Tarantool's \"replace\" function is the same as an \"insert\" function without an error message if a tuple with the same content already exists in the target space."
msgstr ""

#: ../reference/expirationd.rst:79
msgid "function expirationd.do_test(space_id, archive_space_id)\n"
"..."
msgstr ""

#: ../reference/expirationd.rst:84
msgid "At this point, if the above explanation is worthwhile, it's clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and - whenever it finds a tuple that has expired - deletes it from this space and puts it in another space. Now the \"``do_test()``\" function can be used to create some sample spaces, let the daemon run for a while, and print results."
msgstr ""

#: ../reference/expirationd.rst:92
msgid "For those who like to see things run, here are the exact steps to get expirationd through the test."
msgstr ""

#: ../reference/expirationd.rst:95
msgid "Get ``expirationd.lua``. There are standard ways - it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but for this purpose just copy the contents of expirationd.lua_ to a default directory."
msgstr ""

#: ../reference/expirationd.rst:98
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../reference/expirationd.rst:99
msgid "Execute these requests:"
msgstr ""

#: ../reference/expirationd.rst:101
msgid "box.cfg{}\n"
"a = box.schema.space.create('origin')\n"
"a:create_index('first', {type = 'tree', parts = {1, 'NUM'}})\n"
"b = box.schema.space.create('archive')\n"
"b:create_index('first', {type = 'tree', parts = {1, 'STR'}})\n"
"expd = require('expirationd')\n"
"expd._debug = true\n"
"expd.do_test('origin', 'archive')\n"
"os.exit()"
msgstr ""

#: ../reference/expirationd.rst:113
msgid "The database-specific requests (``cfg``, ``space.create``, ``create_index``) should already be familiar. The key for getting the rock rolling is ``expd = require('expirationd')``. The \"``require``\" function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a package that's not part of the Tarantool kernel. After the Lua variable expd has been assigned the value of the expirationd package, it's possible to invoke the package's ``do_test()`` function."
msgstr ""

#: ../reference/expirationd.rst:121
msgid "After a while, when the task has had time to do its iterations through the spaces, ``do_test()`` will print out a report showing the tuples that were originally in the original space, the tuples that have now been moved to the archive space, and some statistics. Of course, expirationd can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code."
msgstr ""

#: ../reference/fiber.rst:28
msgid "Package `fiber`"
msgstr ""

#: ../reference/fiber.rst:30
msgid "The ``fiber`` package allows for creating, running and managing *fibers*."
msgstr ""

#: ../reference/fiber.rst:32
msgid "A fiber is a set of instructions which are executed with cooperative multitasking. Fibers managed by the fiber package are associated with a user-supplied function called the *fiber function*. A fiber has three possible states: **running**, **suspended** or **dead**. When a fiber is created with :func:`fiber.create()`, it is running. When a fiber yields control with :func:`fiber.sleep()`, it is suspended. When a fiber ends (because the fiber function ends), it is dead."
msgstr ""

#: ../reference/fiber.rst:40
msgid "All fibers are part of the fiber registry. This registry can be searched with :func:`fiber.find()` - via fiber id (fid), which is a numeric identifier."
msgstr ""

#: ../reference/fiber.rst:43
msgid "A runaway fiber can be stopped with :func:`fiber_object.cancel`. However, :func:`fiber_object.cancel` is advisory — it works only if the runaway fiber calls :func:`fiber.testcancel()` occasionally. Most ``box.*`` functions, such as :func:`box.space...delete() <space_object.delete>` or :func:`box.space...update() <space_object.update>`, do call :func:`fiber.testcancel()` but :func:`box.space...select{} <space_object.select>` does not. In practice, a runaway fiber can only become unresponsive if it does many computations and does not check whether it has been canceled."
msgstr ""

#: ../reference/fiber.rst:52
msgid "The other potential problem comes from fibers which never get scheduled, because they are not subscribed to any events, or because no relevant events occur. Such morphing fibers can be killed with :func:`fiber.kill()` at any time, since :func:`fiber.kill()` sends an asynchronous wakeup event to the fiber, and :func:`fiber.testcancel()` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../reference/fiber.rst:59
msgid "Like all Lua objects, dead fibers are garbage collected. The garbage collector frees pool allocator memory owned by the fiber, resets all fiber data, and returns the fiber (now called a fiber carcass) to the fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../reference/fiber.rst:68
msgid "Create and start a fiber. The fiber is created and begins to run immediately."
msgstr ""

#: ../reference/fiber.rst:70
msgid "the function to be associated with the fiber"
msgstr ""

#: ../reference/fiber.rst:71
msgid "what will be passed to function"
msgstr ""

#: ../reference/fiber.rst:73
msgid "created fiber object"
msgstr ""

#: ../reference/fiber.rst:74
#: ../reference/fiber.rst:96
#: ../reference/fiber.rst:114
#: ../reference/fiber-ipc.rst:53
#: ../reference/fio.rst:334
#: ../reference/net_box.rst:77
#: ../reference/socket.rst:131
#: ../reference/socket.rst:140
#: ../reference/socket.rst:208
#: ../reference/socket.rst:284
#: ../reference/socket.rst:307
#: ../reference/tap.rst:47
msgid "userdata"
msgstr ""

#: ../reference/fiber.rst:78
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:95
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../reference/fiber.rst:100
msgid "tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference/fiber.rst:111
msgid "numeric identifier of the fiber."
msgstr ""

#: ../reference/fiber.rst:113
msgid "fiber object for the specified fiber."
msgstr ""

#: ../reference/fiber.rst:118
msgid "tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference/fiber.rst:129
msgid "Yield control to the scheduler and sleep for the specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../reference/fiber.rst:132
msgid "number of seconds to sleep."
msgstr ""

#: ../reference/fiber.rst:136
msgid "tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:144
msgid "Yield control to the scheduler. Equivalent to :func:`fiber.sleep(0) <fiber.sleep>`."
msgstr ""

#: ../reference/fiber.rst:146
#: ../reference/socket.rst:151
msgid "Example:"
msgstr ""

#: ../reference/fiber.rst:148
msgid "tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:156
msgid "Return the status of the current fiber."
msgstr ""

#: ../reference/fiber.rst:158
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference/fiber.rst:159
#: ../reference/fiber.rst:252
#: ../reference/fiber.rst:293
#: ../reference/fio.rst:48
#: ../reference/fio.rst:68
#: ../reference/fio.rst:86
#: ../reference/json.rst:42
#: ../reference/msgpack.rst:41
#: ../reference/pickle.rst:85
#: ../reference/socket.rst:237
#: ../reference/socket.rst:266
#: ../reference/yaml.rst:41
msgid "string"
msgstr ""

#: ../reference/fiber.rst:163
msgid "tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference/fiber.rst:172
msgid "Return information about all fibers."
msgstr ""

#: ../reference/fiber.rst:174
msgid "number of context switches, backtrace, id, total memory, used memory, name for each fiber."
msgstr ""

#: ../reference/fiber.rst:180
msgid "tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../reference/fiber.rst:196
msgid "Locate a fiber by its numeric id and cancel it. In other words, :func:`fiber.kill()` combines :func:`fiber.find()` and :func:`fiber_object:cancel() <fiber_object.cancel>`."
msgstr ""

#: ../reference/fiber.rst:200
msgid "the id of the fiber to be canceled."
msgstr ""

#: ../reference/fiber.rst:201
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../reference/fiber.rst:205
msgid "tarantool> fiber.kill(fiber.id())\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/fiber.rst:214
msgid "Check if the current fiber has been canceled and throw an exception if this is the case."
msgstr ""

#: ../reference/fiber.rst:219
msgid "tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/fiber.rst:230
#: ../reference/fiber.rst:249
#: ../reference/fiber.rst:271
#: ../reference/fiber.rst:289
#: ../reference/fiber.rst:311
msgid "fiber object, for example the fiber object returned by :func:`fiber.create`"
msgstr ""

#: ../reference/fiber.rst:232
msgid "id of the fiber."
msgstr ""

#: ../reference/fiber.rst:233
#: ../reference/fiber-ipc.rst:97
#: ../reference/fio.rst:108
#: ../reference/fio.rst:450
#: ../reference/socket.rst:221
#: ../reference/socket.rst:320
msgid "number"
msgstr ""

#: ../reference/fiber.rst:237
msgid "tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../reference/fiber.rst:251
msgid "name of the fiber."
msgstr ""

#: ../reference/fiber.rst:256
msgid "tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../reference/fiber.rst:265
msgid "Change the fiber name. By default the Tarantool server's interactive-mode fiber is named 'interactive' and new fibers created due to :func:`fiber.create` are named 'lua'. Giving fibers distinct names makes it easier to distinguish them when using :func:`fiber.info`."
msgstr ""

#: ../reference/fiber.rst:273
msgid "the new name of the fiber."
msgstr ""

#: ../reference/fiber.rst:279
msgid "tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:287
msgid "Return the status of the specified fiber."
msgstr ""

#: ../reference/fiber.rst:292
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference/fiber.rst:297
msgid "tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference/fiber.rst:306
msgid "Cancel a fiber. Running and suspended fibers can be canceled. After a fiber has been canceled, attempts to operate on it will cause errors, for example :func:`fiber_object:id() <fiber_object.id>` will cause ``error: the fiber is dead``."
msgstr ""

#: ../reference/fiber.rst:316
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../reference/fiber.rst:320
msgid "tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference/fiber.rst:329
msgid "Local storage within the fiber. The storage can contain any number of named values, subject to memory limitations. Naming may be done with :samp:`{fiber_object}.storage.{name}` or :samp:`fiber_object}.storage['{name}'].` or with a number :samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or strings. The storage is garbage-collected when :samp:`{fiber_object}:cancel()` happens. |br| See also :data:`box.session.storage <box.session.storage>`."
msgstr ""

#: ../reference/fiber.rst:339
msgid "tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the fiber is dead'\n"
"..."
msgstr ""

#: ../reference/fiber.rst:372
msgid "current system time (in seconds since the epoch) as a Lua number. The time is taken from the event loop clock, which makes this call very cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../reference/fiber.rst:376
#: ../reference/fiber.rst:393
msgid "num"
msgstr ""

#: ../reference/fiber.rst:380
msgid "tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../reference/fiber.rst:390
msgid "current system time (in microseconds since the epoch) as a 64-bit integer. The time is taken from the event loop clock."
msgstr ""

#: ../reference/fiber.rst:397
msgid "tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../reference/fiber.rst:407
msgid "Show all running fibers, with their stack. Mainly useful for debugging."
msgstr ""

#: ../reference/fiber.rst:411
msgid "Example Of Fiber Use"
msgstr ""

#: ../reference/fiber.rst:413
msgid "Make the function which will be associated with the fiber. This function contains an infinite loop (``while 0 == 0`` is always true). Each iteration of the loop adds 1 to a global variable named gvar, then goes to sleep for 2 seconds. The sleep causes an implicit :func:`fiber.yield()`."
msgstr ""

#: ../reference/fiber.rst:418
msgid "tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while true do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:431
msgid "Make a fiber, associate function_x with the fiber, and start function_x. It will immediately \"detach\" so it will be running independently of the caller."
msgstr ""

#: ../reference/fiber.rst:434
msgid "tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:440
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../reference/fiber.rst:442
msgid "tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:448
msgid "Pause for a while, while the detached function runs. Then ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit depending how long the pause lasted). The status is suspended because the fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../reference/fiber.rst:453
msgid "tarantool> printf('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber.rst:460
msgid "Pause for a while, while the detached function runs. Then ... Cancel the fiber. Then, once again ... Display the fiber id, the fiber status, and gvar (gvar will have gone up a bit more depending how long the pause lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../reference/fiber.rst:465
msgid "tarantool> fiber_of_x:cancel()\n"
"... fiber `lua` has been cancelled\n"
"... fiber `lua` exiting\n"
"---\n"
"- error:\n"
"...\n"
"tarantool> printf('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../reference/fiber-ipc.rst:28
msgid "Package `fiber-ipc`"
msgstr ""

#: ../reference/fiber-ipc.rst:30
msgid "The ``fiber-ipc`` package allows sending and receiving messages between different processes. The words \"different processes\" in this context mean different connections, different sessions, or different fibers."
msgstr ""

#: ../reference/fiber-ipc.rst:34
msgid "Call ``fiber.channel()`` to allocate space and get a channel object, which will be called channel for examples in this section. Call the other ``fiber-ipc`` routines, via channel, to send messages, receive messages, or check ipc status. Message exchange is synchronous. The channel is garbage collected when no one is using it, as with any other Lua object. Use object-oriented syntax, for example ``channel:put(message)`` rather than ``fiber.channel.put(message)``."
msgstr ""

#: ../reference/fiber-ipc.rst:46
msgid "Create a new communication channel."
msgstr ""

#: ../reference/fiber-ipc.rst:48
msgid "positive integer as great as the maximum number of slots (spaces for ``get`` or ``put`` messages) that might be pending at any given time."
msgstr ""

#: ../reference/fiber-ipc.rst:52
msgid "new channel."
msgstr ""

#: ../reference/fiber-ipc.rst:59
msgid "Send a message using a channel. If the channel is full, ``channel:put()`` blocks until there is a free slot in the channel."
msgstr ""

#: ../reference/fiber-ipc.rst:64
msgid "If timeout is provided, and the channel doesn't become empty for the duration of the timeout, ``channel:put()`` returns false. Otherwise it returns true."
msgstr ""

#: ../reference/fiber-ipc.rst:67
#: ../reference/fiber-ipc.rst:90
#: ../reference/fiber-ipc.rst:104
#: ../reference/fiber-ipc.rst:112
#: ../reference/fiber-ipc.rst:120
#: ../reference/fiber-ipc.rst:125
#: ../reference/fio.rst:159
#: ../reference/fio.rst:255
#: ../reference/fio.rst:297
#: ../reference/fio.rst:313
#: ../reference/fio.rst:358
#: ../reference/fio.rst:429
#: ../reference/net_box.rst:97
#: ../reference/net_box.rst:111
#: ../reference/net_box.rst:124
#: ../reference/socket.rst:353
#: ../reference/socket.rst:362
#: ../reference/tap.rst:91
#: ../reference/tap.rst:123
#: ../reference/tap.rst:154
#: ../reference/tap.rst:165
#: ../reference/tap.rst:182
#: ../reference/tap.rst:190
msgid "boolean"
msgstr ""

#: ../reference/fiber-ipc.rst:71
msgid "Close the channel. All waiters in the channel will be woken up. All following ``channel:put()`` or ``channel:get()`` operations will return an error (``nil``)."
msgstr ""

#: ../reference/fiber-ipc.rst:77
msgid "Fetch a message from a channel. If the channel is empty, ``channel:get()`` blocks until there is a message."
msgstr ""

#: ../reference/fiber-ipc.rst:81
msgid "the value placed on the channel by an earlier ``channel:put()``."
msgstr ""

#: ../reference/fiber-ipc.rst:83
msgid "lua_object"
msgstr ""

#: ../reference/fiber-ipc.rst:87
msgid "Check whether the specified channel is empty (has no messages)."
msgstr ""

#: ../reference/fiber-ipc.rst:89
msgid "true if the specified channel is empty"
msgstr ""

#: ../reference/fiber-ipc.rst:94
msgid "Find out how many messages are on the channel. The answer is 0 if the channel is empty."
msgstr ""

#: ../reference/fiber-ipc.rst:96
msgid "the number of messages."
msgstr ""

#: ../reference/fiber-ipc.rst:101
msgid "Check whether the specified channel is full."
msgstr ""

#: ../reference/fiber-ipc.rst:103
msgid "true if the specified channel is full (has no room for a new message)."
msgstr ""

#: ../reference/fiber-ipc.rst:108
msgid "Check whether the specified channel is empty and has readers waiting for a message (because they have issued ``channel:get()`` and then blocked)."
msgstr ""

#: ../reference/fiber-ipc.rst:111
#: ../reference/fiber-ipc.rst:119
msgid "true if blocked users are waiting. Otherwise false."
msgstr ""

#: ../reference/fiber-ipc.rst:116
msgid "Check whether the specified channel is full and has writers waiting (because they have issued ``channel:put()`` and then blocked due to lack of room)."
msgstr ""

#: ../reference/fiber-ipc.rst:124
msgid "true if the specified channel is already closed. Otherwise false."
msgstr ""

#: ../reference/fiber-ipc.rst:131
msgid "fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../reference/fio.rst:28
msgid "Package `fio`"
msgstr ""

#: ../reference/fio.rst:32
msgid "Tarantool supports file input/output with an API that is similar to POSIX syscalls. All operations are performed asynchronously. Multiple fibers can access the same file simultaneously."
msgstr ""

#: ../reference/fio.rst:40
msgid "Common pathname manipulations"
msgstr ""

#: ../reference/fio.rst:44
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../reference/fio.rst:46
msgid "one or more strings to be concatenated."
msgstr ""

#: ../reference/fio.rst:47
#: ../reference/fio.rst:64
#: ../reference/fio.rst:83
msgid "path name"
msgstr ""

#: ../reference/fio.rst:52
msgid "tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../reference/fio.rst:61
msgid "Given a full path name, remove all but the final part (the file name). Also remove the suffix, if it is passed."
msgstr ""

#: ../reference/fio.rst:65
msgid "suffix"
msgstr ""

#: ../reference/fio.rst:67
msgid "file name"
msgstr ""

#: ../reference/fio.rst:72
msgid "tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../reference/fio.rst:81
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../reference/fio.rst:85
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../reference/fio.rst:90
msgid "tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../reference/fio.rst:99
msgid "Common file manipulations"
msgstr ""

#: ../reference/fio.rst:103
msgid "Set the mask bits used when creating files or directories. For a detailed description type \"man 2 umask\"."
msgstr ""

#: ../reference/fio.rst:106
msgid "mask bits."
msgstr ""

#: ../reference/fio.rst:107
msgid "previous mask bits."
msgstr ""

#: ../reference/fio.rst:112
msgid "tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../reference/fio.rst:122
msgid "Returns information about a file object. For details type \"man 2 lstat\" or \"man 2 stat\"."
msgstr ""

#: ../reference/fio.rst:125
msgid "path name of file."
msgstr ""

#: ../reference/fio.rst:126
msgid "fields which describe the file's block size, creation time, size, and other attributes."
msgstr ""

#: ../reference/fio.rst:132
msgid "tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../reference/fio.rst:154
msgid "Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2 rmdir\"."
msgstr ""

#: ../reference/fio.rst:157
msgid "path of directory."
msgstr ""

#: ../reference/fio.rst:158
#: ../reference/fio.rst:254
#: ../reference/fio.rst:296
#: ../reference/fio.rst:312
#: ../reference/fio.rst:428
#: ../reference/fio.rst:502
msgid "true if success, false if failure."
msgstr ""

#: ../reference/fio.rst:163
msgid "tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../reference/fio.rst:172
msgid "Return a list of files that match an input string. The list is constructed with a single flag that controls the behavior of the function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../reference/fio.rst:176
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../reference/fio.rst:177
msgid "list of files whose names match the input string"
msgstr ""

#: ../reference/fio.rst:180
#: ../reference/fio.rst:336
#: ../reference/fio.rst:452
#: ../reference/socket.rst:309
msgid "Possible errors: nil."
msgstr ""

#: ../reference/fio.rst:184
msgid "tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../reference/fio.rst:195
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../reference/fio.rst:199
msgid "tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../reference/fio.rst:208
msgid "Return the name of the current working directory."
msgstr ""

#: ../reference/fio.rst:212
msgid "tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../reference/fio.rst:224
msgid "Functions to create and delete links. For details type \"man readlink\", \"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../reference/fio.rst:227
msgid "existing file name."
msgstr ""

#: ../reference/fio.rst:228
msgid "linked name."
msgstr ""

#: ../reference/fio.rst:230
msgid "``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if success, false if failure. ``fio.readlink`` returns the link value if success, nil if failure."
msgstr ""

#: ../reference/fio.rst:236
msgid "tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:249
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../reference/fio.rst:251
msgid "original name."
msgstr ""

#: ../reference/fio.rst:252
msgid "new name."
msgstr ""

#: ../reference/fio.rst:259
msgid "tarantool> fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:269
msgid "Manage the rights to file objects, or ownership of file objects. For details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../reference/fio.rst:272
msgid "new user uid."
msgstr ""

#: ../reference/fio.rst:273
msgid "new group uid."
msgstr ""

#: ../reference/fio.rst:274
msgid "new permissions"
msgstr ""

#: ../reference/fio.rst:278
msgid "tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:291
msgid "Reduce file size to a specified value. For details type \"man 2 truncate\"."
msgstr ""

#: ../reference/fio.rst:301
msgid "tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:310
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../reference/fio.rst:317
msgid "tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:326
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../reference/fio.rst:329
msgid "Flags can be passed as a number or as string constants, for example '``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by enclosing them in braces."
msgstr ""

#: ../reference/fio.rst:333
msgid "file handle (later - fh)"
msgstr ""

#: ../reference/fio.rst:340
msgid "tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../reference/fio.rst:354
msgid "Close a file that was opened with ``fio.open``. For details type \"man 2 close\"."
msgstr ""

#: ../reference/fio.rst:356
#: ../reference/fio.rst:376
#: ../reference/fio.rst:407
#: ../reference/fio.rst:427
#: ../reference/fio.rst:445
#: ../reference/fio.rst:468
#: ../reference/fio.rst:501
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../reference/fio.rst:357
msgid "true if success, false on failure."
msgstr ""

#: ../reference/fio.rst:362
msgid "tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:372
msgid "Perform read/write random-access operation on a file, without affecting the current seek position of the file. For details type \"man 2 pread\" or \"man 2 pwrite\"."
msgstr ""

#: ../reference/fio.rst:377
#: ../reference/fio.rst:408
msgid "number of bytes to read"
msgstr ""

#: ../reference/fio.rst:378
#: ../reference/fio.rst:409
msgid "value to write"
msgstr ""

#: ../reference/fio.rst:379
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../reference/fio.rst:380
msgid "``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` returns the data that was read, or nil if failure."
msgstr ""

#: ../reference/fio.rst:385
msgid "tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../reference/fio.rst:397
msgid "Perform non-random-access read or write on a file. For details type \"man 2 read\" or \"man 2 write\"."
msgstr ""

#: ../reference/fio.rst:402
msgid "``fh:read`` and ``fh:write`` affect the seek position within the file, and this must be taken into account when working on the same file from multiple fibers. It is possible to limit or prevent file access from other fibers with ``fiber.ipc``."
msgstr ""

#: ../reference/fio.rst:410
msgid "``fh:write`` returns true if success, false if failure. ``fh:read`` returns the data that was read, or nil if failure."
msgstr ""

#: ../reference/fio.rst:415
msgid "tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:424
msgid "Change the size of an open file. Differs from ``fio.truncate``, which changes the size of a closed file."
msgstr ""

#: ../reference/fio.rst:433
msgid "tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fio.rst:442
msgid "Shift position in the file to the specified position. For details type \"man 2 seek\"."
msgstr ""

#: ../reference/fio.rst:446
msgid "position to seek to"
msgstr ""

#: ../reference/fio.rst:447
msgid "'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, '``SEEK_SET``' = start of file."
msgstr ""

#: ../reference/fio.rst:449
msgid "the new position if success"
msgstr ""

#: ../reference/fio.rst:456
msgid "tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../reference/fio.rst:465
msgid "Return statistics about an open file. This differs from ``fio.stat`` which return statistics about a closed file. For details type \"man 2 stat\"."
msgstr ""

#: ../reference/fio.rst:469
msgid "details about the file."
msgstr ""

#: ../reference/fio.rst:474
msgid "tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../reference/fio.rst:497
msgid "Ensure that file changes are written to disk, for an open file. Compare ``fio.sync``, which is for all files. For details type \"man 2 fsync\" or \"man 2 fdatasync\"."
msgstr ""

#: ../reference/fio.rst:506
msgid "tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/fun.rst:28
msgid "Package `fun`"
msgstr ""

#: ../reference/fun.rst:30
msgid "Lua fun, also known as the Lua Functional Library, takes advantage of the features of LuaJIT to help users create complex functions. Inside the package are \"sequence processors\" such as map, filter, reduce, zip -- they take a user-written function as an argument and run it against every element in a sequence, which can be faster or more convenient than a user-written loop. Inside the package are \"generators\" such as range, tabulate, and rands -- they return a bounded or boundless series of values. Within the package are \"reducers\", \"filters\", \"composers\" ... or, in short, all the important features found in languages like Standard ML, Haskell, or Erlang."
msgstr ""

#: ../reference/fun.rst:42
msgid "The full documentation is `On the luafun section of github`_. However, the first chapter can be skipped because installation is already done, it's inside Tarantool. All that is needed is the usual :code:`require` request. After that, all the operations described in the Lua fun manual will work, provided they are preceded by the name returned by the :code:`require` request. For example:"
msgstr ""

#: ../reference/fun.rst:50
msgid "tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun_range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../reference/index.rst:28
msgid "Reference Manual"
msgstr ""

#: ../reference/jit.rst:28
msgid "Package `jit`"
msgstr ""

#: ../reference/jit.rst:32
msgid "The ``jit`` package has functions for tracing the LuaJIT Just-In-Time compiler's progress, showing the byte-code or assembler output that the compiler produces, and in general providing information about what LuaJIT does with Lua code."
msgstr ""

#: ../reference/jit.rst:38
msgid "Prints the byte code of a function."
msgstr ""

#: ../reference/jit.rst:42
msgid "function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../reference/jit.rst:49
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../reference/jit.rst:53
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../reference/jit.rst:57
msgid "-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../reference/jit.rst:62
msgid "For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../reference/jit.rst:66
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../reference/jit.rst:70
msgid "-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../reference/jit.rst:75
msgid "For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../reference/jit.rst:80
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../reference/jit.rst:84
msgid "-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../reference/jit.rst:95
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../reference/jit.rst:101
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../reference/jit.rst:105
msgid "-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../reference/jit.rst:116
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../reference/json.rst:28
msgid "Package `json`"
msgstr ""

#: ../reference/json.rst:30
msgid "The json package provides JSON manipulation routines. It is based on the `Lua-CJSON package by Mark Pulford`_. For a complete manual on Lua-CJSON please read `the official documentation`_."
msgstr ""

#: ../reference/json.rst:38
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../reference/json.rst:40
#: ../reference/msgpack.rst:39
#: ../reference/yaml.rst:39
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../reference/json.rst:41
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../reference/json.rst:46
msgid "tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../reference/json.rst:74
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../reference/json.rst:76
msgid "a string formatted as JSON."
msgstr ""

#: ../reference/json.rst:77
#: ../reference/msgpack.rst:48
#: ../reference/yaml.rst:48
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../reference/json.rst:82
msgid "tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../reference/json.rst:102
#: ../reference/msgpack.rst:53
#: ../reference/yaml.rst:53
msgid "A value comparable to Lua \"nil\" which may be useful as a placeholder in a tuple."
msgstr ""

#: ../reference/json.rst:106
msgid "-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'}\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../reference/json.rst:128
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference/json.rst:130
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../reference/json.rst:131
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../reference/json.rst:133
#: ../reference/yaml.rst:90
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results:"
msgstr ""

#: ../reference/json.rst:135
msgid "tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../reference/log.rst:28
msgid "Package `log`"
msgstr ""

#: ../reference/log.rst:32
msgid "The Tarantool server puts all diagnostic messages in a log file specified by the :ref:`logger <log-label>` configuration parameter. Diagnostic messages may be either system-generated by the server's internal code, or user-generated with the ``log.log_level_function_name`` function."
msgstr ""

#: ../reference/log.rst:42
msgid "Output a user-generated message to the :ref:`log file <log-label>`, given log_level_function_name = ``error`` or ``warn`` or ``info`` or ``debug``."
msgstr ""

#: ../reference/log.rst:45
msgid "The actual output will be a line containing the current timestamp, a module name, 'E' or 'W' or 'I' or 'D' or 'R' depending on ``log_level_function_name``, and ``message``. Output will not occur if ``log_level_function_name`` is for a type greater than :ref:`log_level <log-label>`. Messages may contain C-style format specifiers %d or %s, so :samp:`log.error('...%d...%s',{x},{y})` will work if x is a number and y is a string."
msgstr ""

#: ../reference/log.rst:64
msgid "$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()\n"
"$ less tarantool.txt"
msgstr ""

#: ../reference/log.rst:77
msgid "2...0 [5257] main/101/interactive C> version 1.6.3-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...1 [5261] main/101/spawner C> initialized\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../reference/log.rst:82
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../reference/log.rst:84
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../reference/msgpack.rst:28
msgid "Package `msgpack`"
msgstr ""

#: ../reference/msgpack.rst:30
msgid "The ``msgpack`` package takes strings in MsgPack_ format and decodes them, or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../reference/msgpack.rst:37
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../reference/msgpack.rst:40
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../reference/msgpack.rst:45
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../reference/msgpack.rst:47
#: ../reference/yaml.rst:47
msgid "a string formatted as YAML."
msgstr ""

#: ../reference/msgpack.rst:59
msgid "tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../reference/msgpack.rst:82
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference/msgpack.rst:84
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../reference/msgpack.rst:85
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../reference/msgpack.rst:87
msgid "Serializing 'A' and 'B' with different ``__serialize`` values causes different results. To show this, here is a routine which encodes `{'A','B'}` both as an array and as a map, then displays each result in hexadecimal."
msgstr ""

#: ../reference/msgpack.rst:91
msgid "local function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #m do\n"
"        result = result .. string.format(\"%x\", string.byte(m, i)) .. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"local msgpack = require('msgpack')\n"
"local m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }\n"
"local m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../reference/msgpack.rst:111
msgid "**Result:**"
msgstr ""

#: ../reference/msgpack.rst:116
msgid "**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 1 a1 41 2 a1 42"
msgstr ""

#: ../reference/msgpack.rst:119
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../reference/msgpack.rst:124
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../reference/msgpack.rst:126
msgid "and the second encoding means:"
msgstr ""

#: ../reference/msgpack.rst:131
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../reference/net_box.rst:30
msgid "Package `net.box`"
msgstr ""

#: ../reference/net_box.rst:32
msgid "The ``net.box`` package contains connectors to remote database systems. One variant, to be discussed later, is for connecting to MySQL or MariaDB or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS plugins <dbms-plugins>` appendix. In this section the subject is the built-in variant, ``net.box``. This is for connecting to tarantool servers via a network."
msgstr ""

#: ../reference/net_box.rst:38
msgid "Call ``require('net.box')`` to get a ``net.box`` object, which will be called ``net_box`` for examples in this section. Call ``net_box.new()`` to connect and get a connection object, which will be called ``conn`` for examples in this section. Call the other ``net.box()`` routines, passing ``conn:``, to execute requests on the remote box. Call :func:`conn:close <socket_object.close>` to disconnect."
msgstr ""

#: ../reference/net_box.rst:44
msgid "All ``net.box`` methods are fiber-safe, that is, it is safe to share and use the same connection object across multiple concurrent fibers. In fact, it's perhaps the best programming practice with Tarantool. When multiple fibers use the same connection, all requests are pipelined through the same network socket, but each fiber gets back a correct response. Reducing the number of active sockets lowers the overhead of system calls and increases the overall server performance. There are, however, cases when a single connection is not enough — for example when it's necessary to prioritize requests or to use different authentication ids."
msgstr ""

#: ../reference/net_box.rst:57
msgid "Create a new connection. The connection is established on demand, at the time of the first request. It is re-established automatically after a disconnect. The returned ``conn`` object supports methods for making remote requests, such as select, update or delete."
msgstr ""

#: ../reference/net_box.rst:62
msgid "For the local tarantool server there is a pre-created always-established connection object named :samp:`{net_box}.self`. Its purpose is to make polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = {net_box}.new('localhost', 3301)` can be replaced by :samp:`conn = {net_box}.self`. However, there is an important difference between the embedded connection and a remote one. With the embedded connection, requests which do not modify data do not yield. When using a remote connection, any request can yield, and local database state may have changed by the time it returns."
msgstr ""

#: ../reference/net_box.rst:76
msgid "conn object"
msgstr ""

#: ../reference/net_box.rst:81
msgid "conn = net_box.new('localhost', 3301)\n"
"conn = net_box.new('127.0.0.1', box.cfg.listen, {\n"
"  wait_connect = false,\n"
"  user = 'boxer',\n"
"  password = ''\n"
"})"
msgstr ""

#: ../reference/net_box.rst:94
msgid "Execute a PING command."
msgstr ""

#: ../reference/net_box.rst:96
msgid "true on success, false on error"
msgstr ""

#: ../reference/net_box.rst:101
msgid "net_box.self:ping()"
msgstr ""

#: ../reference/net_box.rst:107
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../reference/net_box.rst:110
msgid "true when connected, false on failure."
msgstr ""

#: ../reference/net_box.rst:115
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../reference/net_box.rst:121
msgid "Show whether connection is active or closed."
msgstr ""

#: ../reference/net_box.rst:123
msgid "true if connected, false on failure."
msgstr ""

#: ../reference/net_box.rst:128
msgid "net_box.self:is_connected()"
msgstr ""

#: ../reference/net_box.rst:135
msgid "Close a connection."
msgstr ""

#: ../reference/net_box.rst:137
msgid "Connection objects are garbage collected just like any other objects in Lua, so an explicit destruction is not mandatory. However, since close() is a system call, it is good programming practice to close a connection explicitly when it is no longer needed, to avoid lengthy stalls of the garbage collector."
msgstr ""

#: ../reference/net_box.rst:142
msgid "Example: ``conn:close()``"
msgstr ""

#: ../reference/net_box.rst:146
msgid ":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:select`:code:`{...}`. Please note this difference: a local :samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does yield, so local data may change while a remote :samp:`conn.space.{space-name}:select`:code:`{...}` is running."
msgstr ""

#: ../reference/net_box.rst:155
msgid ":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../reference/net_box.rst:160
msgid ":samp:`conn.space.{space-name}:replace(...)` is the remote-call equivalent of the local call :samp:`box.space.space-name:replace(...)`."
msgstr ""

#: ../reference/net_box.rst:165
msgid ":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent of the local call :samp:`box.space.space-name:update(...)`."
msgstr ""

#: ../reference/net_box.rst:170
msgid ":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent of the local call :samp:`box.space.space-name:delete(...)`."
msgstr ""

#: ../reference/net_box.rst:175
msgid ":samp:`conn:call('func', '1', '2', '3')` is the remote-call equivalent of :samp:`func('1', '2', '3')`. That is, ``conn:call`` is a remote stored-procedure call."
msgstr ""

#: ../reference/net_box.rst:179
msgid "Example: ``conn:call('function5')``"
msgstr ""

#: ../reference/net_box.rst:183
msgid ":samp:`conn:eval({Lua-string})` evaluates and executes the expression in Lua-string, which may be any statement or series of statements. An :ref:`execute privilege <privileges>` is required; if the user does not have it, an administrator may grant it with :samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../reference/net_box.rst:189
msgid "Example: ``conn:eval('return 5+5')``"
msgstr ""

#: ../reference/net_box.rst:193
msgid "``timeout(...)`` is a wrapper which sets a timeout for the request that follows it."
msgstr ""

#: ../reference/net_box.rst:196
msgid "Example: ``conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})``"
msgstr ""

#: ../reference/net_box.rst:198
msgid "All remote calls support execution timeouts. Using a wrapper object makes the remote connection API compatible with the local one, removing the need for a separate ``timeout`` argument, which the local version would ignore. Once a request is sent, it cannot be revoked from the remote server even if a timeout expires: the timeout expiration only aborts the wait for the remote server response, not the request itself."
msgstr ""

#: ../reference/net_box.rst:207
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../reference/net_box.rst:209
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. Assume that the database is nearly empty. Assume that the tarantool server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../reference/net_box.rst:214
msgid "tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not 3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...} was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1', 3301)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, 'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../reference/other.rst:28
msgid "Miscellaneous"
msgstr ""

#: ../reference/other.rst:32
msgid "Convert a string or a Lua number to a 64-bit integer. The result can be used in arithmetic, and the arithmetic will be 64-bit integer arithmetic rather than floating-point arithmetic. (Operations on an unconverted Lua number use floating-point arithmetic.) The ``tonumber64()`` function is added by Tarantool; the name is global."
msgstr ""

#: ../reference/other.rst:40
msgid "tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../reference/other.rst:63
msgid "Parse and execute an arbitrary chunk of Lua code. This function is mainly useful to define and run Lua code without having to introduce changes to the global Lua environment."
msgstr ""

#: ../reference/other.rst:67
msgid "Lua code"
msgstr ""

#: ../reference/other.rst:68
msgid "zero or more scalar values which will be appended to, or substitute for, items in the Lua chunk."
msgstr ""

#: ../reference/other.rst:71
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../reference/other.rst:73
msgid "Possible errors: If there is a compilation error, it is raised as a Lua error."
msgstr ""

#: ../reference/other.rst:77
msgid "tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference/pickle.rst:28
msgid "Package `pickle`"
msgstr ""

#: ../reference/pickle.rst:34
msgid "To use Tarantool binary protocol primitives from Lua, it's necessary to convert Lua variables to binary format. The ``pickle.pack()`` helper function is prototyped after Perl 'pack_'."
msgstr ""

#: ../reference/pickle.rst:40
msgid "**Format specifiers**"
msgstr ""

#: ../reference/pickle.rst:45
msgid "b, B"
msgstr ""

#: ../reference/pickle.rst:45
msgid "converts Lua variable to a 1-byte integer, and stores the integer in the resulting string"
msgstr ""

#: ../reference/pickle.rst:48
msgid "s, S"
msgstr ""

#: ../reference/pickle.rst:48
msgid "converts Lua variable to a 2-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/pickle.rst:52
msgid "i, I"
msgstr ""

#: ../reference/pickle.rst:52
msgid "converts Lua variable to a 4-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/pickle.rst:56
msgid "l, L"
msgstr ""

#: ../reference/pickle.rst:56
msgid "converts Lua variable to an 8-byte integer, and stores the integer in the resulting string, low byte first"
msgstr ""

#: ../reference/pickle.rst:60
msgid "n"
msgstr ""

#: ../reference/pickle.rst:60
msgid "converts Lua variable to a 2-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../reference/pickle.rst:64
msgid "N"
msgstr ""

#: ../reference/pickle.rst:64
msgid "converts Lua variable to a 4-byte integer, and stores the integer in the resulting string, big"
msgstr ""

#: ../reference/pickle.rst:67
msgid "q, Q"
msgstr ""

#: ../reference/pickle.rst:67
msgid "converts Lua variable to an 8-byte integer, and stores the integer in the resulting string, big endian,"
msgstr ""

#: ../reference/pickle.rst:71
msgid "f"
msgstr ""

#: ../reference/pickle.rst:71
msgid "converts Lua variable to a 4-byte float, and stores the float in the resulting string"
msgstr ""

#: ../reference/pickle.rst:74
msgid "d"
msgstr ""

#: ../reference/pickle.rst:74
msgid "converts Lua variable to a 8-byte double, and stores the double in the resulting string"
msgstr ""

#: ../reference/pickle.rst:77
msgid "a, A"
msgstr ""

#: ../reference/pickle.rst:77
msgid "converts Lua variable to a sequence of bytes, and stores the sequence in the resulting string"
msgstr ""

#: ../reference/pickle.rst:81
msgid "string containing format specifiers"
msgstr ""

#: ../reference/pickle.rst:82
msgid "scalar values to be formatted"
msgstr ""

#: ../reference/pickle.rst:83
msgid "a binary string containing all arguments, packed according to the format specifiers."
msgstr ""

#: ../reference/pickle.rst:87
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../reference/pickle.rst:91
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../reference/pickle.rst:125
msgid "Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is used, it must be the last item."
msgstr ""

#: ../reference/pickle.rst:131
msgid "A list of strings or numbers."
msgstr ""

#: ../reference/pickle.rst:136
msgid "tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../reference/shard.rst:28
msgid "Package `shard`"
msgstr ""

#: ../reference/shard.rst:32
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server on each node. With this arrangement, each server is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../reference/shard.rst:37
msgid "The Tarantool shard package has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../reference/shard.rst:41
msgid "First some terminology:"
msgstr ""

#: ../reference/shard.rst:44
msgid "Consistent Hash"
msgstr ""

#: ../reference/shard.rst:46
msgid "The shard package distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the shard package uses is :func:`digest.guava` in the :codeitalic:`digest` package."
msgstr ""

#: ../reference/shard.rst:52
msgid "Queue"
msgstr ""

#: ../reference/shard.rst:54
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on ever node. The shard package has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../reference/shard.rst:60
msgid "Redundancy"
msgstr ""

#: ../reference/shard.rst:62
msgid "The number of replicas in each shard."
msgstr ""

#: ../reference/shard.rst:63
msgid "Replica"
msgstr ""

#: ../reference/shard.rst:65
msgid "A complete copy of the data. The shard package handles both sharding and replication. One shard can contain one or more replicas. When a write occurs, the write is attempted on every replica in turn. The shard package does not use the built-in replication feature."
msgstr ""

#: ../reference/shard.rst:69
msgid "Shard"
msgstr ""

#: ../reference/shard.rst:71
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../reference/shard.rst:75
msgid "Zone"
msgstr ""

#: ../reference/shard.rst:77
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single tarantool-server instance. A shard's replicas should be in different zones."
msgstr ""

#: ../reference/shard.rst:82
msgid "The shard package is distributed separately from the main tarantool package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../reference/shard.rst:85
msgid "sudo apt-get install tarantool-shard tarantool-pool"
msgstr ""

#: ../reference/shard.rst:89
msgid "Or, download from github tarantool/shard and compile as described in the README. Then, before using the package, say ``shard = require('shard')``"
msgstr ""

#: ../reference/shard.rst:92
msgid "The most important function is:"
msgstr ""

#: ../reference/shard.rst:97
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../reference/shard.rst:99
msgid "This must be called for every shard. The shard-configuration is a table with these fields:"
msgstr ""

#: ../reference/shard.rst:102
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../reference/shard.rst:103
msgid "login (the user name which applies for accessing via the shard package)"
msgstr ""

#: ../reference/shard.rst:104
msgid "password (the password for the login)"
msgstr ""

#: ../reference/shard.rst:105
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../reference/shard.rst:106
msgid "binary (a port number that this host is listening on, on the current host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../reference/shard.rst:109
msgid "Possible Errors: Redundancy should not be greater than the number of servers; the servers must be alive; two replicas of the same shard should not be in the same zone."
msgstr ""

#: ../reference/shard.rst:115
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../reference/shard.rst:117
msgid "The number of replicas per shard (redundancy) is 3. The number of servers is 3. The shard package will conclude that there is only one shard."
msgstr ""

#: ../reference/shard.rst:121
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'loclhost:33131', zone = '1' },\n"
"         >     { uri = 'loclhost:33132', zone = '2' },\n"
"         >     { uri = 'loclhost:33133', zone = '3' },1\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3'\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> server.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference/shard.rst:142
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../reference/shard.rst:144
msgid "This describes three shards. Each shard has two replicas. Since the number of servers is 7, and the number of replicas per server is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../reference/shard.rst:149
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'loclhost:33131', zone = '1' },\n"
"         >     { uri = 'loclhost:33131', zone = '2' },\n"
"         >     { uri = 'loclhost:33132', zone = '1' },\n"
"         >     { uri = 'loclhost:33133', zone = '2' },\n"
"         >     { uri = 'loclhost:33131', zone = '1' },\n"
"         >     { uri = 'loclhost:33132', zone = '2' },\n"
"         >     { uri = 'loclhost:33133', zone = '1' },\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3'\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> server.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference/shard.rst:175
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../reference/shard.rst:182
msgid "Every data-access function in the box package has an analogue in the shard package, so (for example) to insert in table T in a sharded database one simply says ``shard.T:insert{...}`` instead of ``box.T:insert{...}``. A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../reference/shard.rst:190
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../reference/shard.rst:197
msgid "Every queued data-access function has an analogue in the shard package. The user must add an operation_id. The details of queued data-access functions, and of maintenance-related functions, are on `the shard section of github`_."
msgstr ""

#: ../reference/shard.rst:203
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../reference/shard.rst:205
msgid "There is only one shard, and that shard contains only one replica. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../reference/shard.rst:210
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-master/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference/shard.rst:236
msgid "If one cuts and pastes the above, then the result, showing only the requests and responses for shard.init and shard.tester, should look approximately like this:"
msgstr ""

#: ../reference/shard.rst:240
msgid "tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference/shard.rst:269
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../reference/shard.rst:271
msgid "There are two shards, and each shard contains one replica. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../reference/shard.rst:276
msgid "On Terminal #1, say:"
msgstr ""

#: ../reference/shard.rst:278
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-master/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference/shard.rst:306
msgid "On Terminal #2, say:"
msgstr ""

#: ../reference/shard.rst:308
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-master/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../reference/shard.rst:336
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../reference/shard.rst:340
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../reference/shard.rst:342
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference/shard.rst:349
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the shard package."
msgstr ""

#: ../reference/shard.rst:352
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../reference/socket.rst:28
msgid "Package `socket`"
msgstr ""

#: ../reference/socket.rst:30
msgid "The ``socket`` package allows exchanging data via BSD sockets with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode. Semantics of the calls in the ``socket`` API closely follow semantics of the corresponding POSIX calls. Function names and signatures are mostly compatible with `luasocket`_."
msgstr ""

#: ../reference/socket.rst:36
msgid "The functions for setting up and connecting are ``socket``, ``sysconnect``, ``tcp_connect``. The functions for sending data are ``send``, ``sendto``, ``write``, ``syswrite``. The functions for receiving data are ``recv``, ``recvfrom``, ``read``. The functions for waiting before sending/receiving data are ``wait``, ``readable``, ``writable``. The functions for setting flags are ``nonblock``, ``setsockopt``. The functions for stopping and disconnecting are ``shutdown``, ``close``. The functions for error checking are ``errno``, ``error``."
msgstr ""

#: ../reference/socket.rst:47
msgid "**Socket functions**"
msgstr ""

#: ../reference/socket.rst:52
msgid "Purposes"
msgstr ""

#: ../reference/socket.rst:52
msgid "Names"
msgstr ""

#: ../reference/socket.rst:54
msgid "setup"
msgstr ""

#: ../reference/socket.rst:54
msgid ":func:`socket() <socket.__call>`"
msgstr ""

#: ../reference/socket.rst:56
#: ../reference/socket.rst:58
#: ../reference/socket.rst:60
#: ../reference/socket.rst:62
#: ../reference/socket.rst:66
#: ../reference/socket.rst:68
#: ../reference/socket.rst:72
#: ../reference/socket.rst:74
#: ../reference/socket.rst:78
#: ../reference/socket.rst:80
#: ../reference/socket.rst:84
#: ../reference/socket.rst:88
#: ../reference/socket.rst:92
#: ../reference/socket.rst:96
#: ../reference/socket.rst:98
#: ../reference/socket.rst:100
#: ../reference/socket.rst:104
#: ../reference/socket.rst:106
msgid "\"\""
msgstr ""

#: ../reference/socket.rst:56
msgid ":func:`socket.tcp_connect() <socket.tcp_connect>`"
msgstr ""

#: ../reference/socket.rst:58
msgid ":func:`socket.tcp_server() <socket.tcp_server>`"
msgstr ""

#: ../reference/socket.rst:60
msgid ":func:`socket_object:sysconnect() <socket_object.sysconnect>`"
msgstr ""

#: ../reference/socket.rst:62
msgid ":func:`socket_object:send() <socket_object.send>`"
msgstr ""

#: ../reference/socket.rst:64
msgid "sending"
msgstr ""

#: ../reference/socket.rst:64
msgid ":func:`socket_object:sendto() <socket_object.sendto>`"
msgstr ""

#: ../reference/socket.rst:66
msgid ":func:`socket_object:write() <socket_object.write>`"
msgstr ""

#: ../reference/socket.rst:68
msgid ":func:`socket_object:syswrite() <socket_object.syswrite>`"
msgstr ""

#: ../reference/socket.rst:70
msgid "receiving"
msgstr ""

#: ../reference/socket.rst:70
msgid ":func:`socket_object:recv() <socket_object.recv>`"
msgstr ""

#: ../reference/socket.rst:72
msgid ":func:`socket_object:recvfrom() <socket_object.recvfrom>`"
msgstr ""

#: ../reference/socket.rst:74
msgid ":func:`socket_object:read() <socket_object.read>`"
msgstr ""

#: ../reference/socket.rst:76
msgid "flag setting"
msgstr ""

#: ../reference/socket.rst:76
msgid ":func:`socket_object:nonblock() <socket_object.nonblock>`"
msgstr ""

#: ../reference/socket.rst:78
msgid ":func:`socket_object:setsockopt() <socket_object.setsockopt>`"
msgstr ""

#: ../reference/socket.rst:80
msgid ":func:`socket_object:linger() <socket_object.linger>`"
msgstr ""

#: ../reference/socket.rst:82
msgid "client/server"
msgstr ""

#: ../reference/socket.rst:82
msgid ":func:`socket_object:listen() <socket_object.listen>`"
msgstr ""

#: ../reference/socket.rst:84
msgid ":func:`socket_object:accept() <socket_object.accept>`"
msgstr ""

#: ../reference/socket.rst:86
msgid "teardown"
msgstr ""

#: ../reference/socket.rst:86
msgid ":func:`socket_object:shutdown() <socket_object.shutdown>`"
msgstr ""

#: ../reference/socket.rst:88
msgid ":func:`socket_object:close() <socket_object.close>`"
msgstr ""

#: ../reference/socket.rst:90
msgid "error checking"
msgstr ""

#: ../reference/socket.rst:90
msgid ":func:`socket_object:error() <socket_object.error>`"
msgstr ""

#: ../reference/socket.rst:92
msgid ":func:`socket_object:errno() <socket_object.errno>`"
msgstr ""

#: ../reference/socket.rst:94
msgid "information"
msgstr ""

#: ../reference/socket.rst:94
msgid ":func:`socket.getaddrinfo() <socket.getaddrinfo>`"
msgstr ""

#: ../reference/socket.rst:96
msgid ":func:`socket_object:getsockopt() <socket_object.getsockopt>`"
msgstr ""

#: ../reference/socket.rst:98
msgid ":func:`socket_object:peer() <socket_object.peer>`"
msgstr ""

#: ../reference/socket.rst:100
msgid ":func:`socket_object:name() <socket_object.name>`"
msgstr ""

#: ../reference/socket.rst:102
msgid "state checking"
msgstr ""

#: ../reference/socket.rst:102
msgid ":func:`socket_object:readable() <socket_object.readable>`"
msgstr ""

#: ../reference/socket.rst:104
msgid ":func:`socket_object:writable() <socket_object.writable>`"
msgstr ""

#: ../reference/socket.rst:106
msgid ":func:`socket_object:wait() <socket_object.wait>`"
msgstr ""

#: ../reference/socket.rst:109
msgid "Typically a socket session will begin with the setup functions, will set one or more flags, will have a loop with sending and receiving functions, will end with the teardown functions -- as an example at the end of this section will show. Throughout, there may be error-checking and waiting functions for synchronization. Some functions may \"block\" if a non-default option flag is set, therefore the fiber that they are in will yield so that other processes may take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../reference/socket.rst:117
msgid "For all examples in this section the socket name will be sock and the function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../reference/socket.rst:124
msgid "Create a new TCP or UDP socket. The argument values are the same as in the `Linux socket(2) man page <http://man7.org/linux/man-pages/man2/socket.2.html>`_."
msgstr ""

#: ../reference/socket.rst:130
msgid "a new socket, or nil."
msgstr ""

#: ../reference/socket.rst:135
msgid "Connect a socket to a remote host."
msgstr ""

#: ../reference/socket.rst:137
msgid "URL or IP address"
msgstr ""

#: ../reference/socket.rst:138
msgid "port number"
msgstr ""

#: ../reference/socket.rst:139
#: ../reference/socket.rst:207
msgid "a connected socket, if no error."
msgstr ""

#: ../reference/socket.rst:144
msgid "The ``socket.getaddrinfo()`` function is useful for finding information about a remote site so that the correct arguments for ``sock:sysconnect()`` can be passed."
msgstr ""

#: ../reference/socket.rst:148
#: ../reference/socket.rst:454
#: ../reference/socket.rst:464
msgid "A table containing these fields: \"host\", \"family\", \"type\", \"protocol\", \"port\"."
msgstr ""

#: ../reference/socket.rst:153
msgid "tarantool> socket.getaddrinfo('tarantool.org', 'http')"
msgstr ""

#: ../reference/socket.rst:157
msgid "will return variable information such as"
msgstr ""

#: ../reference/socket.rst:159
msgid "---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../reference/socket.rst:176
msgid "The ``socket.tcp_server()`` function makes Tarantool act as a server that can accept connections. Usually the same objective is accomplished with ``box.cfg{listen=...)``."
msgstr ""

#: ../reference/socket.rst:180
msgid "socket.tcp_server('localhost', 3302, function () end)"
msgstr ""

#: ../reference/socket.rst:188
msgid "Connect a socket to a remote host. The argument values are the same as in the `Linux connect(2) man page <http://man7.org/linux/man-pages/man2/connect.2.html>`_. The host must be an IP address."
msgstr ""

#: ../reference/socket.rst:195
msgid "Either:"
msgstr ""

#: ../reference/socket.rst:194
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../reference/socket.rst:196
msgid "port - a number."
msgstr ""

#: ../reference/socket.rst:198
#: ../reference/socket.rst:205
msgid "Or:"
msgstr ""

#: ../reference/socket.rst:198
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../reference/socket.rst:199
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../reference/socket.rst:201
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../reference/socket.rst:203
msgid "port - a number. If a port number is 0 (zero), the socket will be bound to a random local port."
msgstr ""

#: ../reference/socket.rst:210
msgid "sock:sysconnect('127.0.0.1', 80)"
msgstr ""

#: ../reference/socket.rst:217
msgid "Send data over a connected socket."
msgstr ""

#: ../reference/socket.rst:220
#: ../reference/socket.rst:319
msgid "the number of bytes sent."
msgstr ""

#: ../reference/socket.rst:223
msgid "Possible errors: nil on error."
msgstr ""

#: ../reference/socket.rst:227
msgid "Write as much as possible data to the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../reference/socket.rst:232
msgid "Read ``size`` bytes from a connected socket. An internal read-ahead buffer is used to reduce the cost of this call."
msgstr ""

#: ../reference/socket.rst:236
msgid "a string of the requested length on success."
msgstr ""

#: ../reference/socket.rst:239
msgid "Possible errors: On error, returns an empty string, followed by status, errno, errstr. In case the writing side has closed its end, returns the remainder read from the socket (possibly an empty string), followed by \"eof\" status."
msgstr ""

#: ../reference/socket.rst:250
msgid "Read from a connected socket until some condition is true, and return the bytes that were read. Reading goes on until ``limit`` bytes have been read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../reference/socket.rst:255
msgid "maximum number of bytes to read for example 50 means \"stop after 50 bytes\""
msgstr ""

#: ../reference/socket.rst:257
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../reference/socket.rst:259
msgid "maximum number of seconds to wait for example 50 means \"stop after 50 seconds\"."
msgstr ""

#: ../reference/socket.rst:262
msgid "an empty string if there is nothing more to read, or a nil value if error, or a string up to ``limit`` bytes long, which may include the bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../reference/socket.rst:270
msgid "Return all available data from the socket buffer if non-blocking. Rarely used. For details see `this description`_."
msgstr ""

#: ../reference/socket.rst:275
msgid "Bind a socket to the given host/port. A UDP socket after binding can be used to receive data (see :func:`socket_object.recvfrom`). A TCP socket can be used to accept new connections, after it has been put in listen mode."
msgstr ""

#: ../reference/socket.rst:283
msgid "a socket object on success"
msgstr ""

#: ../reference/socket.rst:286
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../reference/socket.rst:291
msgid "Start listening for incoming connections."
msgstr ""

#: ../reference/socket.rst:293
msgid "On Linux the listen ``backlog`` backlog may be from /proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../reference/socket.rst:297
msgid "true for success, false for error."
msgstr ""

#: ../reference/socket.rst:298
msgid "boolean."
msgstr ""

#: ../reference/socket.rst:302
msgid "Accept a new client connection and create a new connected socket. It is good practice to set the socket's blocking mode explicitly after accepting."
msgstr ""

#: ../reference/socket.rst:306
msgid "new socket if success."
msgstr ""

#: ../reference/socket.rst:313
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../reference/socket.rst:322
#: ../reference/socket.rst:332
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../reference/socket.rst:326
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../reference/socket.rst:329
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../reference/socket.rst:330
msgid "string, table"
msgstr ""

#: ../reference/socket.rst:334
msgid "After"
msgstr ""

#: ../reference/socket.rst:336
msgid "message_content, message_sender = recvfrom(1)"
msgstr ""

#: ../reference/socket.rst:340
msgid "the value of ``message_content`` might be a string containing 'X' and the value of ``message_sender`` might be a table containing ``message_sender.host = '18.44.0.1'``, ``message_sender.family = 'AF_INET'``, ``message_sender.port = 43065``."
msgstr ""

#: ../reference/socket.rst:348
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../reference/socket.rst:350
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../reference/socket.rst:352
#: ../reference/tap.rst:90
#: ../reference/tap.rst:122
#: ../reference/tap.rst:153
msgid "true or false."
msgstr ""

#: ../reference/socket.rst:357
msgid "Close (destroy) a socket. A closed socket should not be used any more. A socket is closed automatically when its userdata is garbage collected by Lua."
msgstr ""

#: ../reference/socket.rst:360
msgid "true on success, false on error. For example, if sock is already closed, sock:close() returns false."
msgstr ""

#: ../reference/socket.rst:367
msgid "Retrieve information about the last error that occurred on a socket, if any. Errors do not cause throwing of exceptions so these functions are usually necessary."
msgstr ""

#: ../reference/socket.rst:370
msgid "result for ``sock:errno()``, result for ``sock:error()``. If there is no error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../reference/socket.rst:372
msgid "number, string"
msgstr ""

#: ../reference/socket.rst:376
msgid "Set socket flags. The argument values are the same as in the `Linux getsockopt(2) man page <http://man7.org/linux/man-pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../reference/socket.rst:380
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../reference/socket.rst:381
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../reference/socket.rst:382
msgid "SO_BROADCAST"
msgstr ""

#: ../reference/socket.rst:383
msgid "SO_DEBUG"
msgstr ""

#: ../reference/socket.rst:384
msgid "SO_DOMAIN"
msgstr ""

#: ../reference/socket.rst:385
msgid "SO_ERROR"
msgstr ""

#: ../reference/socket.rst:386
msgid "SO_DONTROUTE"
msgstr ""

#: ../reference/socket.rst:387
msgid "SO_KEEPALIVE"
msgstr ""

#: ../reference/socket.rst:388
msgid "SO_MARK"
msgstr ""

#: ../reference/socket.rst:389
msgid "SO_OOBINLINE"
msgstr ""

#: ../reference/socket.rst:390
msgid "SO_PASSCRED"
msgstr ""

#: ../reference/socket.rst:391
msgid "SO_PEERCRED"
msgstr ""

#: ../reference/socket.rst:392
msgid "SO_PRIORITY"
msgstr ""

#: ../reference/socket.rst:393
msgid "SO_PROTOCOL"
msgstr ""

#: ../reference/socket.rst:394
msgid "SO_RCVBUF"
msgstr ""

#: ../reference/socket.rst:395
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../reference/socket.rst:396
msgid "SO_RCVLOWAT"
msgstr ""

#: ../reference/socket.rst:397
msgid "SO_SNDLOWAT"
msgstr ""

#: ../reference/socket.rst:398
msgid "SO_RCVTIMEO"
msgstr ""

#: ../reference/socket.rst:399
msgid "SO_SNDTIMEO"
msgstr ""

#: ../reference/socket.rst:400
msgid "SO_REUSEADDR"
msgstr ""

#: ../reference/socket.rst:401
msgid "SO_SNDBUF"
msgstr ""

#: ../reference/socket.rst:402
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../reference/socket.rst:403
msgid "SO_TIMESTAMP"
msgstr ""

#: ../reference/socket.rst:404
msgid "SO_TYPE"
msgstr ""

#: ../reference/socket.rst:406
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../reference/socket.rst:410
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../reference/socket.rst:414
msgid "Set or clear the SO_LINGER flag. For a description of the flag, see the `Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../reference/socket.rst:419
msgid "new active and timeout values."
msgstr ""

#: ../reference/socket.rst:423
msgid "``sock:nonblock()`` returns the current flag value. |br| ``sock:nonblock(false)`` sets the flag to false and returns false. |br| ``sock:nonblock(true)`` sets the flag to true and returns true. This function may be useful before invoking a function which might otherwise block indefinitely."
msgstr ""

#: ../reference/socket.rst:431
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../reference/socket.rst:433
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../reference/socket.rst:437
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../reference/socket.rst:439
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../reference/socket.rst:443
msgid "Wait until something is either readable or writable, or until a timeout value expires."
msgstr ""

#: ../reference/socket.rst:445
msgid "'R' if the socket is now readable, 'W' if the socket is now writable, 'RW' if the socket is now both readable and writable, '' (empty string) if timeout expired;"
msgstr ""

#: ../reference/socket.rst:449
msgid "The ``sock:name()`` function is used to get information about the near side of the connection. If a socket was bound to ``xyz.com:45``, then ``sock:name`` will return information about ``[host:xyz.com, port:45]``. The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../reference/socket.rst:459
msgid "The ``sock:peer()`` function is used to get information about the far side of a connection. If a TCP connection has been made to a distant host ``tarantool.org:80``, ``sock:peer()`` will return information about ``[host:tarantool.org, port:80]``. The equivalent POSIX function is ``getpeername()``."
msgstr ""

#: ../reference/socket.rst:475
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../reference/socket.rst:477
msgid "In this example a connection is made over the internet between the Tarantool server and tarantool.org, then an HTTP \"head\" message is sent, and a response is received: \"``HTTP/1.1 200 OK``\". This is not a useful way to communicate with this particular site, but shows that the system works."
msgstr ""

#: ../reference/socket.rst:482
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0rnHost: tarantool.orgrnrn\")\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- \"HTTP/1.1 200 OKrn\"\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/socket.rst:513
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../reference/socket.rst:515
msgid "Here is an example with datagrams. Set up two connections on 127.0.0.1 (localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message to ``sock_1``. Using ``sock_1``, receive a message. Display the received message. Close both connections. |br| This is not a useful way for a computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../reference/socket.rst:521
msgid "tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/socket.rst:558
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../reference/socket.rst:560
msgid "Here is an example of the tcp_server function, reading strings from the client and printing them. On the client side, the Linux socat utility will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../reference/socket.rst:565
msgid "Start two shells. The first shell will be the server. The second shell will be the client."
msgstr ""

#: ../reference/socket.rst:568
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../reference/socket.rst:570
msgid "box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../reference/socket.rst:585
msgid "The above code means: use `tcp_server()` to wait for a connection from any host on port 3302. When it happens, enter a loop that reads on the socket and prints what it reads. The \"delimiter\" for the read function is \"\\\\n\" so each `read()` will read a string as far as the next line feed, including the line feed."
msgstr ""

#: ../reference/socket.rst:592
msgid "On the second shell, create a file that contains a few lines. The contents don't matter. Suppose the first line contains A, the second line contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../reference/socket.rst:597
msgid "On the second shell, use the socat utility to ship the tmp.txt file to the server's host and port:"
msgstr ""

#: ../reference/socket.rst:600
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../reference/socket.rst:604
msgid "Now watch what happens on the first shell. The strings \"A\", \"B\", \"C\" are printed."
msgstr ""

#: ../reference/strict.rst:28
msgid "Package `strict`"
msgstr ""

#: ../reference/strict.rst:32
msgid "The :code:`strict` package has functions for turning \"strict mode\" on or off. When strict mode is on, an attempt to use an undeclared global variable will cause an error. A global variable is considered \"undeclared\" if it has never had a value assigned to it. Often this is an indication of a programming error."
msgstr ""

#: ../reference/strict.rst:37
msgid "By default strict mode is off, unless tarantool was built with the ``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build options in section :ref:`building-from-source`."
msgstr ""

#: ../reference/strict.rst:43
msgid "tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../reference/tap.rst:28
msgid "Package `tap`"
msgstr ""

#: ../reference/tap.rst:30
msgid "The tap package streamlines the testing of other packages. It allows writing of tests in the `TAP protocol`_. The results from the tests can be parsed by standard TAP-analyzers so they can be passed to utilities such as `prove`_. Thus one can run tests and then use the results for statistics, decision-making, and so on."
msgstr ""

#: ../reference/tap.rst:39
msgid "Initialize."
msgstr ""

#: ../reference/tap.rst:41
msgid "The result of ``tap.test`` is an object, which will be called taptest in the rest of this discussion, which is necessary for ``taptest:plan()`` and all the other methods."
msgstr ""

#: ../reference/tap.rst:45
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../reference/tap.rst:46
msgid "taptest"
msgstr ""

#: ../reference/tap.rst:49
msgid "tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../reference/tap.rst:58
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../reference/tap.rst:65
msgid "Checks the number of tests performed. This check should only be done after all planned tests are complete, so ordinarily ``taptest:check()`` will only appear at the end of a script."
msgstr ""

#: ../reference/tap.rst:69
msgid "Will display ``# bad plan: ...`` if the number of completed tests is not equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../reference/tap.rst:76
msgid "Display a diagnostic message."
msgstr ""

#: ../reference/tap.rst:78
msgid "the message to be displayed."
msgstr ""

#: ../reference/tap.rst:83
msgid "This is a basic function which is used by other functions. Depending on the value of ``condition``, print 'ok' or 'not ok' along with debugging information. Displays the message."
msgstr ""

#: ../reference/tap.rst:87
msgid "an expression which is true or false"
msgstr ""

#: ../reference/tap.rst:88
#: ../reference/tap.rst:120
#: ../reference/tap.rst:131
#: ../reference/tap.rst:152
#: ../reference/tap.rst:162
#: ../reference/tap.rst:179
#: ../reference/tap.rst:194
msgid "name of test"
msgstr ""

#: ../reference/tap.rst:95
msgid "tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/tap.rst:117
msgid "``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. Displays the message."
msgstr ""

#: ../reference/tap.rst:127
msgid "``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# skip')``. Displays the message."
msgstr ""

#: ../reference/tap.rst:137
msgid "tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference/tap.rst:147
msgid "Check whether the first argument equals the second argument. Displays extensive message if the result is false."
msgstr ""

#: ../reference/tap.rst:150
#: ../reference/tap.rst:160
#: ../reference/tap.rst:192
msgid "actual result"
msgstr ""

#: ../reference/tap.rst:151
#: ../reference/tap.rst:161
#: ../reference/tap.rst:193
msgid "expected result"
msgstr ""

#: ../reference/tap.rst:158
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../reference/tap.rst:164
#: ../reference/tap.rst:181
#: ../reference/tap.rst:189
msgid "true of false."
msgstr ""

#: ../reference/tap.rst:175
msgid "Test whether a value has a particular type. Displays a long message if the value is not of the specified type."
msgstr ""

#: ../reference/tap.rst:186
msgid "Recursive version of ``tap-test:is(...)``, which can be be used to compare tables as well as scalar values."
msgstr ""

#: ../reference/tap.rst:204
msgid "To run this example: put the script in a file named ./tap.lua, then make tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../reference/tap.rst:208
msgid "#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../reference/tap.rst:222
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../reference/tap.rst:224
msgid "TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../reference/tarantool.rst:28
msgid "Package `tarantool`"
msgstr ""

#: ../reference/tarantool.rst:32
msgid "By saying ``require('tarantool')``, one can answer some questions about how the tarantool server was built, such as \"what flags were used\", or \"what was the version of the compiler\"."
msgstr ""

#: ../reference/tarantool.rst:38
msgid "Additionally one can see the uptime and the server version and the process id. Those information items can also be accessed with :func:`box.info` but use of the tarantool package is recommended."
msgstr ""

#: ../reference/tarantool.rst:44
msgid "tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_TRACE=ON -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector -fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.6.8-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../reference/uuid.rst:28
msgid "Package `uuid`"
msgstr ""

#: ../reference/uuid.rst:30
msgid "A \"UUID\" is a `Universally unique identifier`_. If an application requires that a value be unique only within a single computer or on a single database, then a simple counter is better than a UUID, because getting a UUID is time-consuming (it requires a syscall_). For clusters of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../reference/uuid.rst:36
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../reference/uuid.rst:38
msgid ":func:`uuid() <uuid.__call>`"
msgstr ""

#: ../reference/uuid.rst:39
msgid ":func:`uuid.bin()`"
msgstr ""

#: ../reference/uuid.rst:40
msgid ":func:`uuid.str()`"
msgstr ""

#: ../reference/uuid.rst:42
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../reference/uuid.rst:44
msgid ":func:`uuid_object:bin() <uuid_object.bin>`"
msgstr ""

#: ../reference/uuid.rst:45
msgid ":func:`uuid_object:str() <uuid_object.str>`"
msgstr ""

#: ../reference/uuid.rst:46
msgid ":func:`uuid.fromstr()`"
msgstr ""

#: ../reference/uuid.rst:47
msgid ":func:`uuid.frombin()`"
msgstr ""

#: ../reference/uuid.rst:49
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../reference/uuid.rst:51
msgid ":func:`uuid_object:isnil() <uuid_object.isnil>`"
msgstr ""

#: ../reference/uuid.rst:57
msgid "A nil object"
msgstr ""

#: ../reference/uuid.rst:61
#: ../reference/uuid.rst:66
#: ../reference/uuid.rst:71
msgid "a UUID"
msgstr ""

#: ../reference/uuid.rst:62
#: ../reference/uuid.rst:78
#: ../reference/uuid.rst:84
msgid "cdata"
msgstr ""

#: ../reference/uuid.rst:67
msgid "16-byte string"
msgstr ""

#: ../reference/uuid.rst:72
msgid "36-byte binary string"
msgstr ""

#: ../reference/uuid.rst:76
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../reference/uuid.rst:77
#: ../reference/uuid.rst:83
msgid "converted UUID"
msgstr ""

#: ../reference/uuid.rst:82
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../reference/uuid.rst:90
msgid "|br| 'l' - little-endian, |br| 'b' - big-endian, |br| 'h' - endianness depends on host (default), |br| 'n' - endianness depends on network"
msgstr ""

#: ../reference/uuid.rst:95
#: ../reference/uuid.rst:100
msgid "UUID converted from cdata input value."
msgstr ""

#: ../reference/uuid.rst:96
msgid "16-byte binary string"
msgstr ""

#: ../reference/uuid.rst:101
msgid "36-byte hexadecimal string"
msgstr ""

#: ../reference/uuid.rst:105
msgid "The all-zero UUID value can be expressed as uuid.NULL, or as ``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison with an all-zero value can also be expressed as ``uuid_with_type_cdata == uuid.NULL``."
msgstr ""

#: ../reference/uuid.rst:110
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../reference/uuid.rst:111
msgid "bool"
msgstr ""

#: ../reference/uuid.rst:117
msgid "tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uui:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../reference/yaml.rst:28
msgid "Package `yaml`"
msgstr ""

#: ../reference/yaml.rst:30
msgid "The ``yaml`` package takes strings in YAML_ format and decodes them, or takes a series of non-YAML values and encodes them."
msgstr ""

#: ../reference/yaml.rst:37
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../reference/yaml.rst:40
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../reference/yaml.rst:45
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../reference/yaml.rst:59
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../reference/yaml.rst:82
msgid "The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be specified with ``__serialize``:"
msgstr ""

#: ../reference/yaml.rst:85
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../reference/yaml.rst:86
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../reference/yaml.rst:87
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../reference/yaml.rst:88
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../reference/yaml.rst:93
msgid "tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { __serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

