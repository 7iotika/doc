# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-07-26 11:39+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../reference_rock/dbms.rst:30
msgid "SQL DBMS Modules"
msgstr ""

#: ../reference_rock/dbms.rst:32
msgid "The discussion here in the reference is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../reference_rock/dbms.rst:36
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../reference_rock/dbms.rst:41
msgid "Tarantool supplies DBMS connector modules with the package manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../reference_rock/dbms.rst:44
msgid "The Tarantool rocks allow for connecting to an SQL server and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the plugin also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <net_box-package>` package."
msgstr ""

#: ../reference_rock/dbms.rst:55
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../reference_rock/dbms.rst:63
msgid "MySQL Example"
msgstr ""

#: ../reference_rock/dbms.rst:65
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been installed. Recent MariaDB versions will also work, the MariaDB C connector is used. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use :code:`find` or :code:`whereis` to see what directories these files are installed in."
msgstr ""

#: ../reference_rock/dbms.rst:73
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server. After that, one can pass any MySQL statement to the server and receive results, including multiple result sets."
msgstr ""

#: ../reference_rock/dbms.rst:79
#: ../reference_rock/dbms.rst:434
msgid "Installation"
msgstr ""

#: ../reference_rock/dbms.rst:81
msgid "Check the instructions for :ref:`Downloading and installing a binary package <user_guide_getting_started-downloading_and_installing_a_binary_package>` that apply for the environment where tarantool was installed. In addition to installing :code:`tarantool`, install :code:`tarantool-dev`. For example, on Ubuntu, add the line"
msgstr ""

#: ../reference_rock/dbms.rst:86
#: ../reference_rock/dbms.rst:442
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../reference_rock/dbms.rst:90
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../reference_rock/dbms.rst:94
#: ../reference_rock/dbms.rst:450
msgid "With LuaRocks"
msgstr ""

#: ../reference_rock/dbms.rst:96
#: ../reference_rock/dbms.rst:452
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../reference_rock/dbms.rst:103
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../reference_rock/dbms.rst:107
#: ../reference_rock/dbms.rst:463
msgid "For example:"
msgstr ""

#: ../reference_rock/dbms.rst:109
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../reference_rock/dbms.rst:113
#: ../reference_rock/dbms.rst:469
msgid "See also :ref:`Modules, LuaRocks, and requiring packages <administration-modules_luarocks_and_requiring_packages>`."
msgstr ""

#: ../reference_rock/dbms.rst:117
#: ../reference_rock/dbms.rst:473
msgid "With GitHub"
msgstr ""

#: ../reference_rock/dbms.rst:119
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../reference_rock/dbms.rst:121
msgid "git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../reference_rock/dbms.rst:128
#: ../reference_rock/dbms.rst:484
msgid "At this point it is a good idea to check that the installation produced a file named :code:`driver.so`, and to check that this file is on a directory that is searched by the :code:`require` request."
msgstr ""

#: ../reference_rock/dbms.rst:134
#: ../reference_rock/dbms.rst:490
msgid "Connecting"
msgstr ""

#: ../reference_rock/dbms.rst:136
msgid "Begin by making a :code:`require` request for the mysql driver. We will assume that the name is :code:`mysql` in further examples."
msgstr ""

#: ../reference_rock/dbms.rst:139
msgid "mysql = require('mysql')"
msgstr ""

#: ../reference_rock/dbms.rst:143
#: ../reference_rock/dbms.rst:499
msgid "Now, say:"
msgstr ""

#: ../reference_rock/dbms.rst:148
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../reference_rock/dbms.rst:150
#: ../reference_rock/dbms.rst:506
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../reference_rock/dbms.rst:152
#: ../reference_rock/dbms.rst:508
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../reference_rock/dbms.rst:153
#: ../reference_rock/dbms.rst:509
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../reference_rock/dbms.rst:154
#: ../reference_rock/dbms.rst:510
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../reference_rock/dbms.rst:155
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../reference_rock/dbms.rst:156
#: ../reference_rock/dbms.rst:512
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../reference_rock/dbms.rst:157
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../reference_rock/dbms.rst:159
msgid "The option names, except for `raise`, are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option should be set to :codenormal:`true` if errors should be raised when encountered. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../reference_rock/dbms.rst:167
#: ../reference_rock/dbms.rst:516
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../reference_rock/dbms.rst:169
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../reference_rock/dbms.rst:185
#: ../reference_rock/dbms.rst:528
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../reference_rock/dbms.rst:187
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:203
#: ../reference_rock/dbms.rst:547
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../reference_rock/dbms.rst:207
#: ../reference_rock/dbms.rst:551
msgid "How to ping"
msgstr ""

#: ../reference_rock/dbms.rst:209
#: ../reference_rock/dbms.rst:553
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../reference_rock/dbms.rst:214
#: ../reference_rock/dbms.rst:558
msgid "*connection-name*:ping()"
msgstr ""

#: ../reference_rock/dbms.rst:216
#: ../reference_rock/dbms.rst:240
#: ../reference_rock/dbms.rst:264
#: ../reference_rock/dbms.rst:561
#: ../reference_rock/dbms.rst:585
#: ../reference_rock/dbms.rst:608
msgid "**Example:**"
msgstr ""

#: ../reference_rock/dbms.rst:218
#: ../reference_rock/dbms.rst:563
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:227
#: ../reference_rock/dbms.rst:572
msgid "Executing a statement"
msgstr ""

#: ../reference_rock/dbms.rst:229
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../reference_rock/dbms.rst:234
#: ../reference_rock/dbms.rst:579
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../reference_rock/dbms.rst:236
#: ../reference_rock/dbms.rst:581
msgid "where :code:`sql-statement` is a string, and the optional :code:`parameters` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../reference_rock/dbms.rst:242
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:255
#: ../reference_rock/dbms.rst:599
msgid "Closing connection"
msgstr ""

#: ../reference_rock/dbms.rst:257
msgid "To end a session that began with :code:`mysql.connect`, the request is:"
msgstr ""

#: ../reference_rock/dbms.rst:262
#: ../reference_rock/dbms.rst:606
msgid "*connection-name*:close()"
msgstr ""

#: ../reference_rock/dbms.rst:266
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:272
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../reference_rock/dbms.rst:277
#: ../reference_rock/dbms.rst:619
msgid "Example"
msgstr ""

#: ../reference_rock/dbms.rst:279
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server is already running on the local host 127.0.0.1."
msgstr ""

#: ../reference_rock/dbms.rst:283
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../reference_rock/dbms.rst:364
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../reference_rock/dbms.rst:367
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:375
msgid "Create a Lua function that will connect to the MySQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../reference_rock/dbms.rst:380
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:404
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../reference_rock/dbms.rst:411
msgid "PostgreSQL Example"
msgstr ""

#: ../reference_rock/dbms.rst:413
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../reference_rock/dbms.rst:418
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../reference_rock/dbms.rst:422
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use :code:`find` or :code:`whereis` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../reference_rock/dbms.rst:428
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server. After that, one can pass any PostgreSQL statement to the server and receive results."
msgstr ""

#: ../reference_rock/dbms.rst:436
msgid "Check the instructions for :ref:`Downloading and installing a binary package <user_guide_getting_started-downloading_and_installing_a_binary_package>` that apply for the environment where tarantool was installed. In addition to installing :code:`tarantool`, install :code:`tarantool-dev`. For example, on Ubuntu, add the line:"
msgstr ""

#: ../reference_rock/dbms.rst:446
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../reference_rock/dbms.rst:459
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../reference_rock/dbms.rst:465
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../reference_rock/dbms.rst:475
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../reference_rock/dbms.rst:477
msgid "git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../reference_rock/dbms.rst:492
msgid "Begin by making a :code:`require` request for the pg driver. We will assume that the name is :code:`pg` in further examples."
msgstr ""

#: ../reference_rock/dbms.rst:495
msgid "pg = require('pg')"
msgstr ""

#: ../reference_rock/dbms.rst:504
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../reference_rock/dbms.rst:511
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../reference_rock/dbms.rst:514
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../reference_rock/dbms.rst:518
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../reference_rock/dbms.rst:530
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:574
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../reference_rock/dbms.rst:587
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:601
msgid "To end a session that began with :code:`pg.connect`, the request is:"
msgstr ""

#: ../reference_rock/dbms.rst:610
msgid "tarantool> conn:close() |br| --- |br| ..."
msgstr ""

#: ../reference_rock/dbms.rst:614
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../reference_rock/dbms.rst:621
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server is already running on the local host 127.0.0.1."
msgstr ""

#: ../reference_rock/dbms.rst:625
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../reference_rock/dbms.rst:699
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../reference_rock/dbms.rst:702
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:710
msgid "Create a Lua function that will connect to the PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../reference_rock/dbms.rst:716
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../reference_rock/dbms.rst:741
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../reference_rock/expirationd.rst:30
msgid "Package `expirationd`"
msgstr ""

#: ../reference_rock/expirationd.rst:32
msgid "For a commercial-grade example of a Lua rock that works with Tarantool, let us look at expirationd, which Tarantool supplies on GitHub_ with an Artistic license. The expirationd.lua program is lengthy (about 500 lines), so here we will only highlight the matters that will be enhanced by studying the full source later."
msgstr ""

#: ../reference_rock/expirationd.rst:37
msgid "task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../reference_rock/expirationd.rst:45
msgid "Whenever one hears \"daemon\" in Tarantool, one should suspect it's being done with a :doc:`fiber<../reference_lua/fiber>`. The program is making a fiber and turning control over to it so it runs occasionally, goes to sleep, then comes back for more."
msgstr ""

#: ../reference_rock/expirationd.rst:50
msgid "for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../reference_rock/expirationd.rst:59
msgid "The \"for\" instruction can be translated as \"iterate through the index of the space that is being scanned\", and within it, if the tuple is \"expired\" (for example, if the tuple has a timestamp field which is less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../reference_rock/expirationd.rst:64
msgid "-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../reference_rock/expirationd.rst:75
msgid "Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` which does a \"delete\" of a tuple from its original space. First the fun :ref:`fun <fun-package>` package is used, specifically fun.map_. Remembering that :codenormal:`index[0]` is always the space's primary key, and :codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is always the field number for key part :codeitalic:`N`, fun.map() is creating a table from the primary-key values of the tuple. The result of fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../reference_rock/expirationd.rst:85
msgid "local function expirationd_run_task(name, space_id, is_tuple_expired, options)\n"
"..."
msgstr ""

#: ../reference_rock/expirationd.rst:90
msgid "At this point, if the above explanation is worthwhile, it's clear that ``expirationd.lua`` starts a background routine (fiber) which iterates through all the tuples in a space, sleeps cooperatively so that other fibers can operate at the same time, and - whenever it finds a tuple that has expired - deletes it from this space. Now the \"``expirationd_run_task()``\" function can be used in a test which creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../reference_rock/expirationd.rst:99
msgid "For those who like to see things run, here are the exact steps to get expirationd through the test."
msgstr ""

#: ../reference_rock/expirationd.rst:102
msgid "Get ``expirationd.lua``. There are standard ways - it is after all part of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_  - but for this purpose just copy the contents of expirationd.lua_ to a default directory."
msgstr ""

#: ../reference_rock/expirationd.rst:105
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../reference_rock/expirationd.rst:106
msgid "Execute these requests:"
msgstr ""

#: ../reference_rock/expirationd.rst:108
msgid "fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../reference_rock/expirationd.rst:131
msgid "The database-specific requests (``cfg``, :ref:`space.create <box_schema-space_create>`, :ref:`create_index <box_space-create_index>`) should already be familiar."
msgstr ""

#: ../reference_rock/expirationd.rst:136
msgid "The function which will be supplied to expirationd is :codenormal:`is_tuple_expired`, which is saying \"if the second field of the tuple is less than the :ref:`current time <fiber-time>`  , then return true, otherwise return false\"."
msgstr ""

#: ../reference_rock/expirationd.rst:141
msgid "The key for getting the rock rolling is ``expd = require('expirationd')``. The \"``require``\" function is what reads in the program; it will appear in many later examples in this manual, when it's necessary to get a package that's not part of the Tarantool kernel. After the Lua variable expd has been assigned the value of the expirationd package, it's possible to invoke the package's ``run_task()`` function."
msgstr ""

#: ../reference_rock/expirationd.rst:148
msgid "After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has had time to do its iterations through the spaces, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 0\". After sleeping for two more seconds, ``expd.task_stats()`` will print out a report showing how many tuples have expired -- \"expired_count: 1\". This shows that the is_tuple_expired() function eventually returned \"true\" for one of the tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../reference_rock/expirationd.rst:158
msgid "Of course, expirationd can be customized to do different things by passing different parameters, which will be evident after looking in more detail at the source code."
msgstr ""

#: ../reference_rock/index.rst:29
msgid "Lua rocks reference"
msgstr ""

#: ../reference_rock/index.rst:31
msgid "A module is an optional library which enhances Tarantool functionality."
msgstr ""

#: ../reference_rock/index.rst:33
msgid "For examples of creating one's own module with Lua or C, see `this link`_."
msgstr ""

#: ../reference_rock/shard.rst:30
msgid "Package `shard`"
msgstr ""

#: ../reference_rock/shard.rst:34
msgid "With sharding, the tuples of a tuple set are distributed to multiple nodes, with a Tarantool database server on each node. With this arrangement, each server is handling only a subset of the total data, so larger loads can be handled by simply adding more computers to a network."
msgstr ""

#: ../reference_rock/shard.rst:39
msgid "The Tarantool shard package has facilities for creating shards, as well as analogues for the data-manipulation functions of the box library (select, insert, replace, update, delete)."
msgstr ""

#: ../reference_rock/shard.rst:43
msgid "First some terminology:"
msgstr ""

#: ../reference_rock/shard.rst:46
msgid "**Consistent Hash**"
msgstr ""

#: ../reference_rock/shard.rst:48
msgid "The shard package distributes according to a hash algorithm, that is, it applies a hash function to a tuple's primary-key value in order to decide which shard the tuple belongs to. The hash function is `consistent`_ so that changing the number of servers will not affect results for many keys. The specific hash function that the shard package uses is :ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` package."
msgstr ""

#: ../reference_rock/shard.rst:54
msgid "**Queue**"
msgstr ""

#: ../reference_rock/shard.rst:56
msgid "A temporary list of recent update requests. Sometimes called \"batching\". Since updates to a sharded database can be slow, it may speed up throughput to send requests to a queue rather than wait for the update to finish on ever node. The shard package has functions for adding requests to the queue, which it will process without further intervention. Queuing is optional."
msgstr ""

#: ../reference_rock/shard.rst:62
msgid "**Redundancy**"
msgstr ""

#: ../reference_rock/shard.rst:64
msgid "The number of replicas in each shard."
msgstr ""

#: ../reference_rock/shard.rst:65
msgid "**Replica**"
msgstr ""

#: ../reference_rock/shard.rst:67
msgid "A complete copy of the data. The shard package handles both sharding and replication. One shard can contain one or more replicas. When a write occurs, the write is attempted on every replica in turn. The shard package does not use the built-in replication feature."
msgstr ""

#: ../reference_rock/shard.rst:71
msgid "**Shard**"
msgstr ""

#: ../reference_rock/shard.rst:73
msgid "A subset of the tuples in the database partitioned according to the value returned by the consistent hash function. Usually each shard is on a separate node, or a separate set of nodes (for example if redundancy = 3 then the shard will be on three nodes)."
msgstr ""

#: ../reference_rock/shard.rst:77
msgid "**Zone**"
msgstr ""

#: ../reference_rock/shard.rst:79
msgid "A physical location where the nodes are closely connected, with the same security and backup and access points. The simplest example of a zone is a single computer with a single tarantool-server instance. A shard's replicas should be in different zones."
msgstr ""

#: ../reference_rock/shard.rst:84
msgid "The shard package is distributed separately from the main tarantool package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../reference_rock/shard.rst:87
msgid "sudo apt-get install tarantool-shard tarantool-pool"
msgstr ""

#: ../reference_rock/shard.rst:91
msgid "Or, download from github tarantool/shard and compile as described in the README. Then, before using the package, say ``shard = require('shard')``"
msgstr ""

#: ../reference_rock/shard.rst:94
msgid "The most important function is:"
msgstr ""

#: ../reference_rock/shard.rst:99
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../reference_rock/shard.rst:101
msgid "This must be called for every shard. The shard-configuration is a table with these fields:"
msgstr ""

#: ../reference_rock/shard.rst:104
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../reference_rock/shard.rst:105
msgid "login (the user name which applies for accessing via the shard package)"
msgstr ""

#: ../reference_rock/shard.rst:106
msgid "password (the password for the login)"
msgstr ""

#: ../reference_rock/shard.rst:107
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../reference_rock/shard.rst:108
msgid "binary (a port number that this host is listening on, on the current host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../reference_rock/shard.rst:111
msgid "Possible Errors: Redundancy should not be greater than the number of servers; the servers must be alive; two replicas of the same shard should not be in the same zone."
msgstr ""

#: ../reference_rock/shard.rst:117
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../reference_rock/shard.rst:119
msgid "The number of replicas per shard (redundancy) is 3. The number of servers is 3. The shard package will conclude that there is only one shard."
msgstr ""

#: ../reference_rock/shard.rst:123
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/shard.rst:144
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../reference_rock/shard.rst:146
msgid "This describes three shards. Each shard has two replicas. Since the number of servers is 7, and the number of replicas per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of the servers will not be used. This is not necessarily an error, because perhaps one of the servers in the list is not alive."
msgstr ""

#: ../reference_rock/shard.rst:151
msgid "tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../reference_rock/shard.rst:177
msgid "shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../reference_rock/shard.rst:184
msgid "Every data-access function in the box package has an analogue in the shard package, so (for example) to insert in table T in a sharded database one simply says ``shard.T:insert{...}`` instead of ``box.T:insert{...}``. A ``shard.T:select{}`` request without a primary key will search all shards."
msgstr ""

#: ../reference_rock/shard.rst:192
msgid "shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../reference_rock/shard.rst:199
msgid "Every queued data-access function has an analogue in the shard package. The user must add an operation_id. The details of queued data-access functions, and of maintenance-related functions, are on `the shard section of github`_."
msgstr ""

#: ../reference_rock/shard.rst:205
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../reference_rock/shard.rst:207
msgid "There is only one shard, and that shard contains only one replica. So this isn't illustrating the features of either replication or sharding, it's only illustrating what the syntax is, and what the messages look like, that anyone could duplicate in a minute or two with the magic of cut-and-paste."
msgstr ""

#: ../reference_rock/shard.rst:212
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference_rock/shard.rst:238
msgid "If one cuts and pastes the above, then the result, showing only the requests and responses for shard.init and shard.tester, should look approximately like this:"
msgstr ""

#: ../reference_rock/shard.rst:242
msgid "tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference_rock/shard.rst:271
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../reference_rock/shard.rst:273
msgid "There are two shards, and each shard contains one replica. This requires two nodes. In real life the two nodes would be two computers, but for this illustration the requirement is merely: start two shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../reference_rock/shard.rst:278
msgid "On Terminal #1, say:"
msgstr ""

#: ../reference_rock/shard.rst:280
msgid "$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../reference_rock/shard.rst:308
msgid "On Terminal #2, say:"
msgstr ""

#: ../reference_rock/shard.rst:310
msgid "$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../reference_rock/shard.rst:338
msgid "What will appear on Terminal #1 is: a loop of error messages saying \"Connection refused\" and \"server check failure\". This is normal. It will go on until Terminal #2 process starts."
msgstr ""

#: ../reference_rock/shard.rst:342
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../reference_rock/shard.rst:344
msgid "tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../reference_rock/shard.rst:351
msgid "This shows that what was inserted by Terminal #1 can be selected by Terminal #2, via the shard package."
msgstr ""

#: ../reference_rock/shard.rst:354
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../reference_rock/tdb.rst:28
msgid "Package `tdb`"
msgstr ""

#: ../reference_rock/tdb.rst:30
msgid "The Tarantool Debugger (abbreviation = tdb) can be used with any Lua program. The operational features include: setting breakpoints, examining variables, going forward one line at a time, backtracing, and showing information about fibers. The display features include: using different colors for different situations, including line numbers, and adding hints."
msgstr ""

#: ../reference_rock/tdb.rst:36
msgid "It is not supplied as part of the Tarantool repository; it must be installed separately. Here is the usual way:"
msgstr ""

#: ../reference_rock/tdb.rst:39
msgid "git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../reference_rock/tdb.rst:46
msgid "To initiate tdb within a Lua program and set a breakpoint, edit the program to include these lines:"
msgstr ""

#: ../reference_rock/tdb.rst:49
msgid "tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../reference_rock/tdb.rst:54
msgid "To start the debugging session, execute the Lua program. Execution will stop at the breakpoint, and it will be possible to enter debugging commands."
msgstr ""

#: ../reference_rock/tdb.rst:59
msgid "Debugger Commands"
msgstr ""

#: ../reference_rock/tdb.rst:63
msgid ":codebold:`bt`"
msgstr ""

#: ../reference_rock/tdb.rst:62
msgid "Backtrace -- show the stack (in red), with program/function names and line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../reference_rock/tdb.rst:66
msgid ":codebold:`c`"
msgstr ""

#: ../reference_rock/tdb.rst:66
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../reference_rock/tdb.rst:73
msgid ":codebold:`e`"
msgstr ""

#: ../reference_rock/tdb.rst:69
msgid "Enter evaluation mode. When the program is in evaluation mode, one can execute certain Lua statements that would be valid in the context. This is particularly useful for displaying the values of the program's variables. Other debugger commands will not work until one exits evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../reference_rock/tdb.rst:76
msgid ":codebold:`-e`"
msgstr ""

#: ../reference_rock/tdb.rst:76
msgid "Exit evaluation mode."
msgstr ""

#: ../reference_rock/tdb.rst:80
msgid ":codebold:`f`"
msgstr ""

#: ../reference_rock/tdb.rst:79
msgid "Display the fiber id, the program name, and the percentage of memory used, as a table."
msgstr ""

#: ../reference_rock/tdb.rst:83
msgid ":codebold:`n`"
msgstr ""

#: ../reference_rock/tdb.rst:83
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../reference_rock/tdb.rst:86
msgid ":codebold:`globals`"
msgstr ""

#: ../reference_rock/tdb.rst:86
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../reference_rock/tdb.rst:89
msgid ":codebold:`h`"
msgstr ""

#: ../reference_rock/tdb.rst:89
msgid "Display a list of debugger commands."
msgstr ""

#: ../reference_rock/tdb.rst:93
msgid ":codebold:`locals`"
msgstr ""

#: ../reference_rock/tdb.rst:92
msgid "Display names and values of variables, for example the control variables of a Lua \"for\" statement."
msgstr ""

#: ../reference_rock/tdb.rst:96
msgid ":codebold:`q`"
msgstr ""

#: ../reference_rock/tdb.rst:96
msgid "Quit immediately."
msgstr ""

#: ../reference_rock/tdb.rst:100
msgid "Example Session"
msgstr ""

#: ../reference_rock/tdb.rst:102
msgid "Put the following program in a default directory and call it \"example.lua\":"
msgstr ""

#: ../reference_rock/tdb.rst:104
msgid "tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../reference_rock/tdb.rst:112
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../reference_rock/tdb.rst:117
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../reference_rock/tdb.rst:119
#: ../reference_rock/tdb.rst:144
msgid "The screen should now look like this:"
msgstr ""

#: ../reference_rock/tdb.rst:124
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../reference_rock/tdb.rst:131
msgid "Debugger prompts are blue, debugger hints and information are green, and the current line -- line 3 of example.lua -- is the default color. Now enter six debugger commands:"
msgstr ""

#: ../reference_rock/tdb.rst:135
msgid "n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../reference_rock/tdb.rst:149
msgid "$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../reference_rock/tdb.rst:166
msgid "Another debugger example can be found here_."
msgstr ""

