# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-07-18 11:33+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../reference_lua/box.rst:28
msgid "Package `box`"
msgstr ""

#: ../reference_lua/box.rst:30
msgid ""
"The contents of the ``box`` library can be inspected at runtime with "
"``box``, with no arguments. The packages inside the box library are: "
"``box.schema``, ``box.tuple``, ``box.space``, ``box.index``, ``box.cfg``,"
" ``box.info``, ``box.slab``, ``box.stat``. Every package contains one or "
"more Lua functions. A few packages contain members as well as functions. "
"The functions allow data definition (create alter drop), data "
"manipulation (insert delete update upsert select replace), and "
"introspection (inspecting contents of spaces, accessing server "
"configuration)."
msgstr ""

#: ../reference_lua/box_error.rst:28
msgid "Package `box.error`"
msgstr ""

#: ../reference_lua/box_error.rst:32
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in ``error()`` function is that "
"when the error reaches the client, its error code is preserved. In "
"contrast, a Lua error would always be presented to the client as "
":errcode:`ER_PROC_LUA`."
msgstr ""

#: ../reference_lua/box_error.rst:39
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""

#: ../reference_lua/box_error.rst:47
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""

#: ../reference_lua/box_error.rst:52
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_ in "
"the source tree. Lua constants which correspond to those Tarantool errors"
" are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../reference_lua/box_error.rst:58
msgid "number of a pre-defined error"
msgstr ""

#: ../reference_lua/box_error.rst:59
msgid "part of the message which will accompany the error"
msgstr ""

#: ../reference_lua/box_error.rst:61
msgid "For example:"
msgstr ""

#: ../reference_lua/box_error.rst:63
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""

#: ../reference_lua/box_error.rst:69
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../reference_lua/box_error.rst:71 ../reference_lua/box_error.rst:107
#: ../reference_lua/clock.rst:50 ../reference_lua/clock.rst:69
#: ../reference_lua/clock.rst:87 ../reference_lua/clock.rst:105
#: ../reference_lua/clock.rst:127 ../reference_lua/console.rst:72
#: ../reference_lua/console.rst:106 ../reference_lua/console.rst:131
#: ../reference_lua/csv.rst:70 ../reference_lua/csv.rst:149
#: ../reference_lua/csv.rst:191 ../reference_lua/fiber.rst:88
#: ../reference_lua/fiber.rst:112 ../reference_lua/fiber.rst:132
#: ../reference_lua/fiber.rst:152 ../reference_lua/fiber.rst:183
#: ../reference_lua/fiber.rst:202 ../reference_lua/fiber.rst:229
#: ../reference_lua/fiber.rst:245 ../reference_lua/fiber.rst:265
#: ../reference_lua/fiber.rst:286 ../reference_lua/fiber.rst:311
#: ../reference_lua/fiber.rst:331 ../reference_lua/fiber.rst:356
#: ../reference_lua/fiber.rst:377 ../reference_lua/fiber.rst:420
#: ../reference_lua/fiber.rst:439 ../reference_lua/fio.rst:50
#: ../reference_lua/fio.rst:70 ../reference_lua/fio.rst:88
#: ../reference_lua/fio.rst:110 ../reference_lua/fio.rst:130
#: ../reference_lua/fio.rst:168 ../reference_lua/fio.rst:189
#: ../reference_lua/fio.rst:204 ../reference_lua/fio.rst:217
#: ../reference_lua/fio.rst:241 ../reference_lua/fio.rst:264
#: ../reference_lua/fio.rst:283 ../reference_lua/fio.rst:306
#: ../reference_lua/fio.rst:322 ../reference_lua/fio.rst:355
#: ../reference_lua/fio.rst:377 ../reference_lua/fio.rst:400
#: ../reference_lua/fio.rst:430 ../reference_lua/fio.rst:448
#: ../reference_lua/fio.rst:471 ../reference_lua/fio.rst:489
#: ../reference_lua/fio.rst:521 ../reference_lua/jit.rst:40
#: ../reference_lua/jit.rst:55 ../reference_lua/jit.rst:68
#: ../reference_lua/jit.rst:82 ../reference_lua/jit.rst:103
#: ../reference_lua/json.rst:48 ../reference_lua/json.rst:86
#: ../reference_lua/json.rst:112 ../reference_lua/net_box.rst:77
#: ../reference_lua/net_box.rst:93 ../reference_lua/net_box.rst:107
#: ../reference_lua/net_box.rst:120 ../reference_lua/other.rst:40
#: ../reference_lua/other.rst:77 ../reference_lua/pickle.rst:89
#: ../reference_lua/pickle.rst:134 ../reference_lua/strict.rst:41
#: ../reference_lua/tap.rst:93 ../reference_lua/tap.rst:135
#: ../reference_lua/tarantool.rst:42
msgid "**Example:**"
msgstr ""

#: ../reference_lua/box_error.rst:73
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../reference_lua/box_error.rst:90
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""

#: ../reference_lua/box_error.rst:100
msgid "rtype: table"
msgstr ""

#: ../reference_lua/box_error.rst:104
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""

#: ../reference_lua/box_error.rst:109
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference_lua/box_once.rst:30
msgid "Function `box.once`"
msgstr ""

#: ../reference_lua/box_once.rst:32
msgid ""
":codenormal:`box.`:codebold:`once`:codenormal:`(`:codeitalic:`key, "
"function`:codenormal:`)`"
msgstr ""

#: ../reference_lua/box_once.rst:34
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked. For an explanation why "
"``box.once`` is useful, see the section :ref:`Preventing Duplicate "
"Actions <index-preventing_duplicate_actions>`."
msgstr ""

#: ../reference_lua/box_once.rst:41
msgid ""
"Parameters: :codebold:`key` (:codeitalic:`string`) = a value that will be"
" checked, :codebold:`function` = a function name."
msgstr ""

#: ../reference_lua/clock.rst:28
msgid "Package `clock`"
msgstr ""

#: ../reference_lua/clock.rst:30
msgid ""
"The ``clock`` package returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the package "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""

#: ../reference_lua/clock.rst:42
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator. |br| "
"See also :ref:`fiber.time64 <fiber-time64>` and :ref:`os.clock() <os-"
"clock>`."
msgstr ""

#: ../reference_lua/clock.rst:47
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../reference_lua/clock.rst:48 ../reference_lua/clock.rst:67
#: ../reference_lua/clock.rst:85 ../reference_lua/clock.rst:103
msgid "number or number64"
msgstr ""

#: ../reference_lua/clock.rst:52
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../reference_lua/clock.rst:61
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""

#: ../reference_lua/clock.rst:66
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../reference_lua/clock.rst:71
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../reference_lua/clock.rst:80
msgid ""
"The processor time. Derived from C function "
"clock_gettime(CLOCK_PROCESS_CPUTIME_ID). This is the best function to use"
" with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""

#: ../reference_lua/clock.rst:84
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../reference_lua/clock.rst:89
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../reference_lua/clock.rst:98
msgid ""
"The thread time. Derived from C function "
"clock_gettime(CLOCK_THREAD_CPUTIME_ID). This is the best function to use "
"with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""

#: ../reference_lua/clock.rst:102
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../reference_lua/clock.rst:107
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../reference_lua/clock.rst:115
msgid ""
"The time that a function takes within a processor. This function uses "
"clock.proc(), therefore it calculates elapsed CPU time. Therefore it is "
"not useful for showing actual elapsed time."
msgstr ""

#: ../reference_lua/clock.rst:119 ../reference_lua/socket.rst:216
msgid "Parameters:"
msgstr ""

#: ../reference_lua/clock.rst:121
msgid ":samp:`{function}` = function or function reference;"
msgstr ""

#: ../reference_lua/clock.rst:122
msgid ""
":samp:`{function parameters}` = whatever values are required by the "
"function."
msgstr ""

#: ../reference_lua/clock.rst:124
msgid ""
"table. first element = seconds of CPU time; second element = whatever the"
" function returns."
msgstr ""

#: ../reference_lua/clock.rst:125 ../reference_lua/csv.rst:68
#: ../reference_lua/fiber.rst:200 ../reference_lua/fio.rst:128
#: ../reference_lua/fio.rst:185 ../reference_lua/fio.rst:487
#: ../reference_lua/json.rst:84 ../reference_lua/msgpack.rst:51
#: ../reference_lua/pickle.rst:132 ../reference_lua/socket.rst:161
#: ../reference_lua/socket.rst:505 ../reference_lua/socket.rst:517
#: ../reference_lua/yaml.rst:51
msgid "table"
msgstr ""

#: ../reference_lua/clock.rst:129
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f,10)"
msgstr ""

#: ../reference_lua/console.rst:30
msgid "Package `console`"
msgstr ""

#: ../reference_lua/console.rst:32
msgid ""
"The console package allows one Tarantool server to access another "
"Tarantool server, and allows one Tarantool server to start listening on "
"an administrative host/port."
msgstr ""

#: ../reference_lua/console.rst:42
msgid ""
"Connect to the server at :ref:`URI <index-uri>`, change the prompt from "
"':samp:`tarantool>`' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types :code:`control-D`."
msgstr ""

#: ../reference_lua/console.rst:46
msgid ""
"The console.connect function allows one Tarantool server, in interactive "
"mode, to access another Tarantool server. Subsequent requests will appear"
" to be handled locally, but in reality the requests are being sent to the"
" remote server and the local server is acting as a client. Once "
"connection is successful, the prompt will change and subsequent requests "
"are sent to, and executed on, the remote server. Results are displayed on"
" the local server. To return to local mode, enter :code:`control-D`."
msgstr ""

#: ../reference_lua/console.rst:55
msgid ""
"If the Tarantool server at :samp:`uri` requires authentication, the "
"connection might look something like: "
":code:`console.connect('admin:secretpassword@distanthost.com:3301')`."
msgstr ""

#: ../reference_lua/console.rst:59
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote server is done with user name = 'guest'. The remote "
"server could allow for this by granting at least one privilege: "
":code:`box.schema.user.grant('guest','execute','universe')`."
msgstr ""

#: ../reference_lua/console.rst:65
msgid "the URI of the remote server"
msgstr ""

#: ../reference_lua/console.rst:67 ../reference_lua/fiber.rst:309
#: ../reference_lua/fiber.rst:352 ../reference_lua/log.rst:56
#: ../reference_lua/msgpack.rst:166 ../reference_lua/tap.rst:61
#: ../reference_lua/tap.rst:72 ../reference_lua/tap.rst:79
#: ../reference_lua/tap.rst:133
msgid "nil"
msgstr ""

#: ../reference_lua/console.rst:69
msgid ""
"Possible errors: the connection will fail if the target Tarantool server "
"was not initiated with :code:`box.cfg{listen=...}`."
msgstr ""

#: ../reference_lua/console.rst:74
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that server is remote"
msgstr ""

#: ../reference_lua/console.rst:88
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in :code:`box.cfg{listen=...}`. The alternative way of "
"listening is via the URI specified in :code:`console.listen(...)`. This "
"alternative way is called \"administrative\" or simply \"admin port\". "
"The listening is usually over a local host with a Unix socket, specified "
"with host = 'unix/', port = 'path/to/something.sock'."
msgstr ""

#: ../reference_lua/console.rst:96
msgid "the URI of the local server"
msgstr ""

#: ../reference_lua/console.rst:98
msgid ""
"The \"admin\" address is the URI to listen on for administrative "
"connections. It has no default value, so it must be specified if "
"connections will occur via telnet. The parameter is expressed with URI = "
"Universal Resource Identifier format, for example "
"\"/tmpdir/unix_domain_socket.sock\", or as a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../reference_lua/console.rst:108
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../reference_lua/console.rst:129
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../reference_lua/console.rst:133
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the tarantool server with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../reference_lua/console.rst:140
msgid ""
"console = require('console')\n"
"console.start()"
msgstr ""

#: ../reference_lua/console.rst:149
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using tarantool as a client, then hitting the TAB key may cause "
"tarantool to complete a word automatically. The default auto-completion "
"value is `true`."
msgstr ""

#: ../reference_lua/crypto.rst:30
msgid "Package `crypto`"
msgstr ""

#: ../reference_lua/crypto.rst:34
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's crypto package "
"supports ten  types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` package. The functions"
" in crypto are:"
msgstr ""

#: ../reference_lua/crypto.rst:42
msgid ""
":codebold:`crypto.cipher.`:codeitalic:`{aes128|aes192|aes256|des}.{cbc|cfg|ecb|ofb}.{encrypt|decrypt}`"
" (:codeitalic:`string`, :codeitalic:`key` "
":codenormal:`[,`:codeitalic:`initialization vector`:codenormal:`])` |br| "
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices "
":codenormal:`aes128|aes192|aes256|des` indicate whether the algorithm "
"will be aes-128 (with 192-bit binary strings using AES), aes-192 (with "
"192-bit binary strings using AES), aes-256 (with 256-bit binary strings "
"using AES), or des (with 56-bit binary strings using DES, though DES is "
"not recommended). |br| Examples; |br| "
":codenormal:`crypto.cipher.aes192.cbc.encrypt('string', 'key', "
"'initialization')` |br| "
":codenormal:`crypto.cipher.aes256.ecb.decrypt('string', 'key')` |br|"
msgstr ""

#: ../reference_lua/crypto.rst:52
msgid ""
":codebold:`crypto.digest.`:codeitalic:`{dss|dss1|md4|md5|mdc2|ripemd160|sha|sha1|sha224|sha256|sha384|sha512}`:codenormal:`(`:codeitalic:`string`:codenormal:`)`"
" |br| Pass or return a digest derived from the string. The twelve choices"
" "
":codenormal:`dss|dss1|md4|md5|mdc2|ripemd160|sha|sha1|sha224|sha256|sha384|sha512`"
" indicate whether the algorithm will be dss (using DSS), dss (using "
"DSS-1), md4 (with 128-bit binary strings using MD4), md5 (with 128-bit "
"binary strings using MD5), mdc2 (using MDC2), sha (with 160-bit binary "
"strings using SHA-0), sha-1 (with 160-bit binary strings using SHA-1), "
"sha-224 (with 224-bit binary strings using SHA-2), sha-256 (with 256-bit "
"binary strings using SHA_2), sha-384 (with 384-bit binary strings using "
"SHA_2), or sha-512 (with 512-bit binary strings using SHA-2). |br| "
"Examples: |br| :codenormal:`crypto.digest.md4('string')` |br| "
":codenormal:`crypto.digest.sha512('string')` |br|"
msgstr ""

#: ../reference_lua/crypto.rst:66
msgid "Incremental methods in the crypto package"
msgstr ""

#: ../reference_lua/crypto.rst:68
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions ..."
msgstr ""

#: ../reference_lua/crypto.rst:77
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../reference_lua/crypto.rst:101
msgid "Getting the same results from digest and crypto packages"
msgstr ""

#: ../reference_lua/crypto.rst:103
msgid ""
"The following functions are equivalent. For example, the digest function "
"and the crypto function x will both produce the same result."
msgstr ""

#: ../reference_lua/crypto.rst:107
msgid ""
":codenormal:`crypto.cipher.aes256.cbc.encrypt('string', 'key') == "
"digest.aes256cbc.encrypt('string', 'key')` |br| "
":codenormal:`crypto.digest.md4('string') == digest.md4('string')` |br| "
":codenormal:`crypto.digest.md5('string') == digest.md5('string')` |br| "
":codenormal:`crypto.digest.sha('string') == digest.sha('string')` |br| "
":codenormal:`crypto.digest.sha1('string') == digest.sha1('string')` |br| "
":codenormal:`crypto.digest.sha224('string') == digest.sha224('string')` "
"|br| :codenormal:`crypto.digest.sha256('string') == "
"digest.sha256('string')` |br| :codenormal:`crypto.digest.sha384('string')"
" == digest.sha384('string')` |br| "
":codenormal:`crypto.digest.sha512('string') == digest.sha512('string')` "
"|br|"
msgstr ""

#: ../reference_lua/csv.rst:28
msgid "Package `csv`"
msgstr ""

#: ../reference_lua/csv.rst:32
msgid ""
"The csv package handles records formatted according to Comma-Separated-"
"Values (CSV) rules."
msgstr ""

#: ../reference_lua/csv.rst:35
msgid "The default formatting rules are:"
msgstr ""

#: ../reference_lua/csv.rst:37
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""

#: ../reference_lua/csv.rst:39
msgid "Commas designate end-of-field,"
msgstr ""

#: ../reference_lua/csv.rst:40
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../reference_lua/csv.rst:41
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../reference_lua/csv.rst:42
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../reference_lua/csv.rst:43
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""

#: ../reference_lua/csv.rst:49
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../reference_lua/csv.rst:51
msgid ""
":samp:`delimiter = {string}` -- single-byte character to designate end-"
"of-field, default = comma"
msgstr ""

#: ../reference_lua/csv.rst:52
msgid ""
":samp:`quote_char = {string}` -- single-byte character to designate "
"encloser of string, default = quote mark"
msgstr ""

#: ../reference_lua/csv.rst:53
msgid ""
":samp:`chunk-size = {number}` -- number of characters to read at once "
"(usually for file-IO efficiency), default = 4096"
msgstr ""

#: ../reference_lua/csv.rst:54
msgid ""
":samp:`skip_head_lines = {number}` -- number of lines to skip at the "
"start (usually for a header), default 0"
msgstr ""

#: ../reference_lua/csv.rst:60
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""

#: ../reference_lua/csv.rst:64
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr ""

#: ../reference_lua/csv.rst:66 ../reference_lua/csv.rst:187
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../reference_lua/csv.rst:67
msgid "loaded_value"
msgstr ""

#: ../reference_lua/csv.rst:72
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""

#: ../reference_lua/csv.rst:74
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:86
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../reference_lua/csv.rst:89
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:96
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../reference_lua/csv.rst:98
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:106
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" fio is in section :ref:`fio <fio-section>`. Source CSV file and example "
"respectively:"
msgstr ""

#: ../reference_lua/csv.rst:110
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close(nn)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:137
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""

#: ../reference_lua/csv.rst:143 ../reference_lua/csv.rst:186
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../reference_lua/csv.rst:144
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../reference_lua/csv.rst:145
msgid "any object which has a write() method"
msgstr ""

#: ../reference_lua/csv.rst:146
msgid "dumped_value"
msgstr ""

#: ../reference_lua/csv.rst:147
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../reference_lua/csv.rst:151
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../reference_lua/csv.rst:153
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:165
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../reference_lua/csv.rst:167
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../reference_lua/csv.rst:183
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time."
msgstr ""

#: ../reference_lua/csv.rst:188
msgid "Lua iterator function"
msgstr ""

#: ../reference_lua/csv.rst:189
msgid "iterator function"
msgstr ""

#: ../reference_lua/csv.rst:193
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../reference_lua/csv.rst:197
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../reference_lua/digest.rst:30
msgid "Package `digest`"
msgstr ""

#: ../reference_lua/digest.rst:34
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"digest package supports five types of cryptographic hash functions (AES_,"
" MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function "
"(CRC32_), two functions for base64_, and two non-cryptographic hash "
"functions (guava_, murmur_). Some of the digest functionality is also "
"present in the :ref:`crypto <crypto>` package. The functions in digest "
"are:"
msgstr ""

#: ../reference_lua/digest.rst:43
msgid ""
":codebold:`digest.aes256cbc.encrypt(`:codeitalic:`string`, "
":codeitalic:`key`) |br| Returns 256-bit binary string = digest made with "
"AES."
msgstr ""

#: ../reference_lua/digest.rst:46
msgid ""
":codebold:`digest.md4(`:codeitalic:`string`) |br| Returns 128-bit binary "
"string = digest made with MD4. |br|"
msgstr ""

#: ../reference_lua/digest.rst:49
msgid ""
":codebold:`digest.md4_hex(`:codeitalic:`string`) |br| Returns 32-byte "
"string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../reference_lua/digest.rst:52
msgid ""
":codebold:`digest.md5(`:codeitalic:`string`) |br| Returns 128-bit binary "
"string = digest made with MD5."
msgstr ""

#: ../reference_lua/digest.rst:55
msgid ""
":codebold:`digest.md5_hex(`:codeitalic:`string`) |br| Returns 32-byte "
"string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../reference_lua/digest.rst:58
msgid ""
":codebold:`digest.sha(`:codeitalic:`string`) |br| Returns 160-bit binary "
"string = digest made with SHA-0. Not recommended."
msgstr ""

#: ../reference_lua/digest.rst:61
msgid ""
":codebold:`digest.sha_hex(`:codeitalic:`string`) |br| Returns 40-byte "
"string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../reference_lua/digest.rst:64
msgid ""
":codebold:`digest.sha1(`:codeitalic:`string`) |br| Returns 160-bit binary"
" string = digest made with SHA-1."
msgstr ""

#: ../reference_lua/digest.rst:67
msgid ""
":codebold:`digest.sha1_hex(`:codeitalic:`string`) |br| Returns 40-byte "
"string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../reference_lua/digest.rst:70
msgid ""
":codebold:`digest.sha224(`:codeitalic:`string`) |br| Returns 224-bit "
"binary string = digest made with SHA-2."
msgstr ""

#: ../reference_lua/digest.rst:73
msgid ""
":codebold:`digest.sha224_hex(`:codeitalic:`string`) |br| Returns 56-byte "
"string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../reference_lua/digest.rst:76
msgid ""
":codebold:`digest.sha256(`:codeitalic:`string`) |br| Returns 256-bit "
"binary string =  digest made with SHA-2."
msgstr ""

#: ../reference_lua/digest.rst:79
msgid ""
":codebold:`digest.sha256_hex(`:codeitalic:`string`) |br| Returns 64-byte "
"string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../reference_lua/digest.rst:82
msgid ""
":codebold:`digest.sha384(`:codeitalic:`string`) |br| Returns 384-bit "
"binary string =  digest made with SHA-2."
msgstr ""

#: ../reference_lua/digest.rst:85
msgid ""
":codebold:`digest.sha384_hex(`:codeitalic:`string`) |br| Returns 96-byte "
"string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../reference_lua/digest.rst:88
msgid ""
":codebold:`digest.sha512(`:codeitalic:`string`) |br| Returns 512-bit "
"binary tring = digest made with SHA-2."
msgstr ""

#: ../reference_lua/digest.rst:91
msgid ""
":codebold:`digest.sha512_hex(`:codeitalic:`string`) |br| Returns 128-byte"
" string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../reference_lua/digest.rst:94
msgid ""
":codebold:`digest.base64_encode(`:codeitalic:`string`) |br| Returns "
"base64 encoding from a regular string."
msgstr ""

#: ../reference_lua/digest.rst:97
msgid ""
":codebold:`digest.base64_decode(`:codeitalic:`string`) |br| Returns a "
"regular string from a base64 encoding."
msgstr ""

#: ../reference_lua/digest.rst:100
msgid ""
":codebold:`digest.urandom(`:codeitalic:`integer`) |br| Returns array of "
"random bytes with length = integer."
msgstr ""

#: ../reference_lua/digest.rst:103
msgid ""
":codebold:`digest.crc32(`:codeitalic:`string`) |br| Returns 32-bit "
"checksum made with CRC32."
msgstr ""

#: ../reference_lua/digest.rst:106
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ "
"polynomial value: 0x1EDC6F41 / 4812730177. If it is necessary to be "
"compatible with other checksum functions in other programming languages, "
"ensure that the other functions use the same polynomial value."
msgstr ""

#: ../reference_lua/digest.rst:112
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../reference_lua/digest.rst:119
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../reference_lua/digest.rst:121
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../reference_lua/digest.rst:128
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../reference_lua/digest.rst:132
msgid ""
":codebold:`digest.crc32.new()` |br| Initiates incremental crc32. See "
":ref:`incremental methods <digest-incremental_digests>` notes."
msgstr ""

#: ../reference_lua/digest.rst:138
msgid ""
":codebold:`digest.guava(`:codeitalic:`integer, integer`) |br| Returns a "
"number made with consistent hash."
msgstr ""

#: ../reference_lua/digest.rst:141
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../reference_lua/digest.rst:147
msgid ""
":codenormal:`tarantool>` :codebold:`digest.guava(10863919174838991, 11)` "
"|br| :codenormal:`---` |br| :codenormal:`- 8` |br| :codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/digest.rst:152
msgid ""
":codebold:`digest.murmur(`:codeitalic:`string`) |br| Returns 32-bit "
"binary string = digest made with MurmurHash."
msgstr ""

#: ../reference_lua/digest.rst:155
msgid ""
":codebold:`digest.murmur.new([`:codeitalic:`seed`]) |br| Initiates "
"incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../reference_lua/digest.rst:163
msgid "Incremental methods in the digest package"
msgstr ""

#: ../reference_lua/digest.rst:165
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur ..."
msgstr ""

#: ../reference_lua/digest.rst:174
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../reference_lua/digest.rst:194 ../reference_lua/fiber_ipc.rst:129
#: ../reference_lua/log.rst:66 ../reference_lua/msgpack.rst:61
#: ../reference_lua/socket.rst:523 ../reference_lua/tap.rst:202
#: ../reference_lua/uuid.rst:131 ../reference_lua/yaml.rst:61
msgid "Example"
msgstr ""

#: ../reference_lua/digest.rst:196
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""

#: ../reference_lua/digest.rst:200
msgid ""
":codenormal:`tarantool>` :codebold:`digest = require('digest')` |br| "
":codenormal:`---` |br| :codenormal:`...` |br| :codenormal:`tarantool>` "
":codebold:`function password_insert()` |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :codenormal:`>`   :codebold:`box.space.tester:insert{12345,"
" digest.sha1('^S^e^c^ret Wordpass')}` |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :codenormal:`>`   :codebold:`return 'OK'` |br| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :codenormal:`>` :codebold:`end` |br| "
":codenormal:`---` |br| :codenormal:`...` |br| :codenormal:`tarantool>` "
":codebold:`function password_check(password)` |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :codenormal:`>` |nbsp| :codebold:`local t` |br| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :codenormal:`>` |nbsp| "
":codebold:`local t = box.space.tester:select{12345}` |br| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| :codenormal:`>` |nbsp| :codebold:`if "
"digest.sha1(password) == t[2] then` |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :codenormal:`>` |nbsp| |nbsp| |nbsp| "
":codebold:`print('Password is valid')` |br| |nbsp| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| :codenormal:`>` |nbsp| :codebold:`else` |br| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| :codenormal:`>` |nbsp| |nbsp| |nbsp| "
":codebold:`print('Password is not valid')` |br| |nbsp| |nbsp| |nbsp| "
"|nbsp| |nbsp| |nbsp| :codenormal:`>` |nbsp| :codebold:`end` |br| |nbsp| "
"|nbsp| |nbsp| |nbsp| |nbsp| |nbsp| :codenormal:`>` :codebold:`end` |br| "
":codenormal:`---` |br| :codenormal:`...` |br| :codenormal:`tarantool>` "
":codebold:`password_insert()` |br| :codenormal:`---` |br| :codenormal:`- "
"'OK'` |br| :codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/digest.rst:225
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""

#: ../reference_lua/digest.rst:228
msgid ""
":codenormal:`tarantool>` :codebold:`password_check('Secret Password')` "
"|br| :codenormal:`Password is not valid` |br| :codenormal:`---` |br| "
":codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/fiber.rst:28
msgid "Package `fiber`"
msgstr ""

#: ../reference_lua/fiber.rst:30
msgid "The ``fiber`` package allows for creating, running and managing *fibers*."
msgstr ""

#: ../reference_lua/fiber.rst:32
msgid ""
"A fiber is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber package are associated with a "
"user-supplied function called the *fiber function*. A fiber has three "
"possible states: **running**, **suspended** or **dead**. When a fiber is "
"created with :ref:`fiber.create() <fiber-create>`, it is running. When a "
"fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is "
"suspended. When a fiber ends (because the fiber function ends), it is "
"dead."
msgstr ""

#: ../reference_lua/fiber.rst:40
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../reference_lua/fiber.rst:44
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""

#: ../reference_lua/fiber.rst:55
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../reference_lua/fiber.rst:62
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../reference_lua/fiber.rst:67
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""

#: ../reference_lua/fiber.rst:80
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""

#: ../reference_lua/fiber.rst:82
msgid "the function to be associated with the fiber"
msgstr ""

#: ../reference_lua/fiber.rst:83
msgid "what will be passed to function"
msgstr ""

#: ../reference_lua/fiber.rst:85
msgid "created fiber object"
msgstr ""

#: ../reference_lua/fiber.rst:86 ../reference_lua/fiber.rst:110
#: ../reference_lua/fiber.rst:130 ../reference_lua/fiber_ipc.rst:53
#: ../reference_lua/fio.rst:351 ../reference_lua/net_box.rst:75
#: ../reference_lua/socket.rst:133 ../reference_lua/socket.rst:147
#: ../reference_lua/socket.rst:308 ../reference_lua/socket.rst:334
#: ../reference_lua/tap.rst:47
msgid "userdata"
msgstr ""

#: ../reference_lua/fiber.rst:90
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:109
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../reference_lua/fiber.rst:114
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:127
msgid "numeric identifier of the fiber."
msgstr ""

#: ../reference_lua/fiber.rst:129
msgid "fiber object for the specified fiber."
msgstr ""

#: ../reference_lua/fiber.rst:134
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:147
msgid ""
"Yield control to the transaction processor thread and sleep for the "
"specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../reference_lua/fiber.rst:150
msgid "number of seconds to sleep."
msgstr ""

#: ../reference_lua/fiber.rst:154
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:164
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`."
msgstr ""

#: ../reference_lua/fiber.rst:166
msgid "Example:"
msgstr ""

#: ../reference_lua/fiber.rst:168
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:178
msgid "Return the status of the current fiber."
msgstr ""

#: ../reference_lua/fiber.rst:180
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference_lua/fiber.rst:181 ../reference_lua/fiber.rst:284
#: ../reference_lua/fiber.rst:329 ../reference_lua/fio.rst:48
#: ../reference_lua/fio.rst:68 ../reference_lua/fio.rst:86
#: ../reference_lua/json.rst:46 ../reference_lua/msgpack.rst:43
#: ../reference_lua/pickle.rst:85 ../reference_lua/socket.rst:255
#: ../reference_lua/socket.rst:286 ../reference_lua/yaml.rst:43
msgid "string"
msgstr ""

#: ../reference_lua/fiber.rst:185
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:196
msgid "Return information about all fibers."
msgstr ""

#: ../reference_lua/fiber.rst:198
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""

#: ../reference_lua/fiber.rst:204
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:222
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../reference_lua/fiber.rst:226
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../reference_lua/fiber.rst:227
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../reference_lua/fiber.rst:231
msgid ""
"tarantool> fiber.kill(fiber.id())\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:242
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""

#: ../reference_lua/fiber.rst:247
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:260 ../reference_lua/fiber.rst:281
#: ../reference_lua/fiber.rst:305 ../reference_lua/fiber.rst:325
#: ../reference_lua/fiber.rst:349
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create"
" <fiber-create>`"
msgstr ""

#: ../reference_lua/fiber.rst:262
msgid "id of the fiber."
msgstr ""

#: ../reference_lua/fiber.rst:263 ../reference_lua/fiber_ipc.rst:97
#: ../reference_lua/fio.rst:108 ../reference_lua/fio.rst:467
#: ../reference_lua/socket.rst:235 ../reference_lua/socket.rst:349
msgid "number"
msgstr ""

#: ../reference_lua/fiber.rst:267
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:283
msgid "name of the fiber."
msgstr ""

#: ../reference_lua/fiber.rst:288
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:299
msgid ""
"Change the fiber name. By default the Tarantool server's interactive-mode"
" fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../reference_lua/fiber.rst:307
msgid "the new name of the fiber."
msgstr ""

#: ../reference_lua/fiber.rst:313
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:323
msgid "Return the status of the specified fiber."
msgstr ""

#: ../reference_lua/fiber.rst:328
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../reference_lua/fiber.rst:333
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:344
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:id() <fiber_object-id>` will cause "
"``error: the fiber is dead``."
msgstr ""

#: ../reference_lua/fiber.rst:354
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../reference_lua/fiber.rst:358
msgid ""
"tarantool> fiber.self():cancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:369
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The storage is garbage-collected when "
":samp:`{fiber_object}:cancel()` happens. |br| See also "
":ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../reference_lua/fiber.rst:379
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: "
"fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:414
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../reference_lua/fiber.rst:418 ../reference_lua/fiber.rst:437
msgid "num"
msgstr ""

#: ../reference_lua/fiber.rst:422
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:434
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""

#: ../reference_lua/fiber.rst:441
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:451
msgid "Example Of Fiber Use"
msgstr ""

#: ../reference_lua/fiber.rst:453
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each "
"iteration of the loop adds 1 to a global variable named gvar, then goes "
"to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() "
"<fiber-yield>`."
msgstr ""

#: ../reference_lua/fiber.rst:458
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:471
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""

#: ../reference_lua/fiber.rst:474
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:482
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../reference_lua/fiber.rst:484
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:490
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../reference_lua/fiber.rst:495
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber.rst:502
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../reference_lua/fiber.rst:507
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:28
msgid "Package `fiber-ipc`"
msgstr ""

#: ../reference_lua/fiber_ipc.rst:30
msgid ""
"The ``fiber-ipc`` package allows sending and receiving messages between "
"different processes. The words \"different processes\" in this context "
"mean different connections, different sessions, or different fibers."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:34
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section. Call the other"
" ``fiber-ipc`` routines, via channel, to send messages, receive messages,"
" or check ipc status. Message exchange is synchronous. The channel is "
"garbage collected when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:46
msgid "Create a new communication channel."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:48
msgid ""
"positive integer as great as the maximum number of slots (spaces for "
"``get`` or ``put`` messages) that might be pending at any given time."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:52
msgid "new channel."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:59
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" blocks until there is a free slot in the channel."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:64
msgid ""
"If timeout is provided, and the channel doesn't become empty for the "
"duration of the timeout, ``channel:put()`` returns false. Otherwise it "
"returns true."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:67 ../reference_lua/fiber_ipc.rst:90
#: ../reference_lua/fiber_ipc.rst:104 ../reference_lua/fiber_ipc.rst:112
#: ../reference_lua/fiber_ipc.rst:120 ../reference_lua/fiber_ipc.rst:125
#: ../reference_lua/fio.rst:166 ../reference_lua/fio.rst:262
#: ../reference_lua/fio.rst:304 ../reference_lua/fio.rst:320
#: ../reference_lua/fio.rst:375 ../reference_lua/fio.rst:446
#: ../reference_lua/net_box.rst:91 ../reference_lua/net_box.rst:105
#: ../reference_lua/net_box.rst:118 ../reference_lua/socket.rst:219
#: ../reference_lua/socket.rst:383 ../reference_lua/socket.rst:394
#: ../reference_lua/tap.rst:91 ../reference_lua/tap.rst:123
#: ../reference_lua/tap.rst:154 ../reference_lua/tap.rst:165
#: ../reference_lua/tap.rst:182 ../reference_lua/tap.rst:190
msgid "boolean"
msgstr ""

#: ../reference_lua/fiber_ipc.rst:71
msgid ""
"Close the channel. All waiters in the channel will be woken up. All "
"following ``channel:put()`` or ``channel:get()`` operations will return "
"an error (``nil``)."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:77
msgid ""
"Fetch a message from a channel. If the channel is empty, "
"``channel:get()`` blocks until there is a message."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:81
msgid "the value placed on the channel by an earlier ``channel:put()``."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:83
msgid "lua_object"
msgstr ""

#: ../reference_lua/fiber_ipc.rst:87
msgid "Check whether the specified channel is empty (has no messages)."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:89
msgid "true if the specified channel is empty"
msgstr ""

#: ../reference_lua/fiber_ipc.rst:94
msgid ""
"Find out how many messages are on the channel. The answer is 0 if the "
"channel is empty."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:96
msgid "the number of messages."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:101
msgid "Check whether the specified channel is full."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:103
msgid "true if the specified channel is full (has no room for a new message)."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:108
msgid ""
"Check whether the specified channel is empty and has readers waiting for "
"a message (because they have issued ``channel:get()`` and then blocked)."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:111 ../reference_lua/fiber_ipc.rst:119
msgid "true if blocked users are waiting. Otherwise false."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:116
msgid ""
"Check whether the specified channel is full and has writers waiting "
"(because they have issued ``channel:put()`` and then blocked due to lack "
"of room)."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:124
msgid "true if the specified channel is already closed. Otherwise false."
msgstr ""

#: ../reference_lua/fiber_ipc.rst:131
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../reference_lua/fio.rst:28
msgid "Package `fio`"
msgstr ""

#: ../reference_lua/fio.rst:32
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""

#: ../reference_lua/fio.rst:40
msgid "Common pathname manipulations"
msgstr ""

#: ../reference_lua/fio.rst:44
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../reference_lua/fio.rst:46
msgid "one or more strings to be concatenated."
msgstr ""

#: ../reference_lua/fio.rst:47 ../reference_lua/fio.rst:64
#: ../reference_lua/fio.rst:83
msgid "path name"
msgstr ""

#: ../reference_lua/fio.rst:52
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:61
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""

#: ../reference_lua/fio.rst:65
msgid "suffix"
msgstr ""

#: ../reference_lua/fio.rst:67
msgid "file name"
msgstr ""

#: ../reference_lua/fio.rst:72
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:81
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../reference_lua/fio.rst:85
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../reference_lua/fio.rst:90
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:99
msgid "Common file manipulations"
msgstr ""

#: ../reference_lua/fio.rst:103
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type \"man 2 umask\"."
msgstr ""

#: ../reference_lua/fio.rst:106
msgid "mask bits."
msgstr ""

#: ../reference_lua/fio.rst:107
msgid "previous mask bits."
msgstr ""

#: ../reference_lua/fio.rst:112
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:122
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\""
" or \"man 2 stat\"."
msgstr ""

#: ../reference_lua/fio.rst:125
msgid "path name of file."
msgstr ""

#: ../reference_lua/fio.rst:126
msgid ""
"fields which describe the file's block size, creation time, size, and "
"other attributes."
msgstr ""

#: ../reference_lua/fio.rst:132
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:158
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2"
" rmdir\"."
msgstr ""

#: ../reference_lua/fio.rst:161
msgid "path of directory."
msgstr ""

#: ../reference_lua/fio.rst:162
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../reference_lua/fio.rst:165 ../reference_lua/fio.rst:261
#: ../reference_lua/fio.rst:303 ../reference_lua/fio.rst:319
#: ../reference_lua/fio.rst:445 ../reference_lua/fio.rst:519
msgid "true if success, false if failure."
msgstr ""

#: ../reference_lua/fio.rst:170
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:179
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../reference_lua/fio.rst:183
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../reference_lua/fio.rst:184
msgid "list of files whose names match the input string"
msgstr ""

#: ../reference_lua/fio.rst:187 ../reference_lua/fio.rst:353
#: ../reference_lua/fio.rst:469 ../reference_lua/socket.rst:336
msgid "Possible errors: nil."
msgstr ""

#: ../reference_lua/fio.rst:191
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:202
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../reference_lua/fio.rst:206
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:215
msgid "Return the name of the current working directory."
msgstr ""

#: ../reference_lua/fio.rst:219
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:231
msgid ""
"Functions to create and delete links. For details type \"man readlink\", "
"\"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../reference_lua/fio.rst:234
msgid "existing file name."
msgstr ""

#: ../reference_lua/fio.rst:235
msgid "linked name."
msgstr ""

#: ../reference_lua/fio.rst:237
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if "
"success, false if failure. ``fio.readlink`` returns the link value if "
"success, nil if failure."
msgstr ""

#: ../reference_lua/fio.rst:243
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:256
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../reference_lua/fio.rst:258
msgid "original name."
msgstr ""

#: ../reference_lua/fio.rst:259
msgid "new name."
msgstr ""

#: ../reference_lua/fio.rst:266
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:276
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../reference_lua/fio.rst:279
msgid "new user uid."
msgstr ""

#: ../reference_lua/fio.rst:280
msgid "new group uid."
msgstr ""

#: ../reference_lua/fio.rst:281
msgid "new permissions"
msgstr ""

#: ../reference_lua/fio.rst:285
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:298
msgid ""
"Reduce file size to a specified value. For details type \"man 2 "
"truncate\"."
msgstr ""

#: ../reference_lua/fio.rst:308
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:317
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../reference_lua/fio.rst:324
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:338
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../reference_lua/fio.rst:341
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces."
msgstr ""

#: ../reference_lua/fio.rst:345
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREATE` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../reference_lua/fio.rst:350
msgid "file handle (later - fh)"
msgstr ""

#: ../reference_lua/fio.rst:357
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:371
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 "
"close\"."
msgstr ""

#: ../reference_lua/fio.rst:373 ../reference_lua/fio.rst:393
#: ../reference_lua/fio.rst:424 ../reference_lua/fio.rst:444
#: ../reference_lua/fio.rst:462 ../reference_lua/fio.rst:485
#: ../reference_lua/fio.rst:518
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../reference_lua/fio.rst:374
msgid "true if success, false on failure."
msgstr ""

#: ../reference_lua/fio.rst:379
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:389
msgid ""
"Perform read/write random-access operation on a file, without affecting "
"the current seek position of the file. For details type \"man 2 pread\" "
"or \"man 2 pwrite\"."
msgstr ""

#: ../reference_lua/fio.rst:394 ../reference_lua/fio.rst:425
msgid "number of bytes to read"
msgstr ""

#: ../reference_lua/fio.rst:395 ../reference_lua/fio.rst:426
msgid "value to write"
msgstr ""

#: ../reference_lua/fio.rst:396
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../reference_lua/fio.rst:397
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../reference_lua/fio.rst:402
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:414
msgid ""
"Perform non-random-access read or write on a file. For details type \"man"
" 2 read\" or \"man 2 write\"."
msgstr ""

#: ../reference_lua/fio.rst:419
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""

#: ../reference_lua/fio.rst:427
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../reference_lua/fio.rst:432
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:441
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""

#: ../reference_lua/fio.rst:450
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:459
msgid ""
"Shift position in the file to the specified position. For details type "
"\"man 2 seek\"."
msgstr ""

#: ../reference_lua/fio.rst:463
msgid "position to seek to"
msgstr ""

#: ../reference_lua/fio.rst:464
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""

#: ../reference_lua/fio.rst:466
msgid "the new position if success"
msgstr ""

#: ../reference_lua/fio.rst:473
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:482
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type \"man 2 "
"stat\"."
msgstr ""

#: ../reference_lua/fio.rst:486
msgid "details about the file."
msgstr ""

#: ../reference_lua/fio.rst:491
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../reference_lua/fio.rst:514
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type \"man 2 fsync\" or"
" \"man 2 fdatasync\"."
msgstr ""

#: ../reference_lua/fio.rst:523
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/fun.rst:30
msgid "Package `fun`"
msgstr ""

#: ../reference_lua/fun.rst:32
msgid ""
"Lua fun, also known as the Lua Functional Library, takes advantage of the"
" features of LuaJIT to help users create complex functions. Inside the "
"package are \"sequence processors\" such as map, filter, reduce, zip -- "
"they take a user-written function as an argument and run it against every"
" element in a sequence, which can be faster or more convenient than a "
"user-written loop. Inside the package are \"generators\" such as range, "
"tabulate, and rands -- they return a bounded or boundless series of "
"values. Within the package are \"reducers\", \"filters\", \"composers\" "
"... or, in short, all the important features found in languages like "
"Standard ML, Haskell, or Erlang."
msgstr ""

#: ../reference_lua/fun.rst:44
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual :code:`require` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
":code:`require` request. For example:"
msgstr ""

#: ../reference_lua/fun.rst:52
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/index.rst:28
msgid "Lua reference"
msgstr ""

#: ../reference_lua/jit.rst:28
msgid "Package `jit`"
msgstr ""

#: ../reference_lua/jit.rst:32
msgid ""
"The ``jit`` package has functions for tracing the LuaJIT Just-In-Time "
"compiler's progress, showing the byte-code or assembler output that the "
"compiler produces, and in general providing information about what LuaJIT"
" does with Lua code."
msgstr ""

#: ../reference_lua/jit.rst:38
msgid "Prints the byte code of a function."
msgstr ""

#: ../reference_lua/jit.rst:42
msgid ""
"function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../reference_lua/jit.rst:49
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../reference_lua/jit.rst:53
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../reference_lua/jit.rst:57
msgid ""
"-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../reference_lua/jit.rst:62
msgid "For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../reference_lua/jit.rst:66
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../reference_lua/jit.rst:70
msgid ""
"-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../reference_lua/jit.rst:75
msgid "For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../reference_lua/jit.rst:80
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../reference_lua/jit.rst:84
msgid ""
"-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../reference_lua/jit.rst:95
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../reference_lua/jit.rst:101
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../reference_lua/jit.rst:105
msgid ""
"-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../reference_lua/jit.rst:116
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../reference_lua/json.rst:30
msgid "Package `json`"
msgstr ""

#: ../reference_lua/json.rst:32
msgid ""
"The json package provides JSON manipulation routines. It is based on the "
"`Lua-CJSON package by Mark Pulford`_. For a complete manual on Lua-CJSON "
"please read `the official documentation`_."
msgstr ""

#: ../reference_lua/json.rst:42
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../reference_lua/json.rst:44 ../reference_lua/msgpack.rst:41
#: ../reference_lua/yaml.rst:41
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../reference_lua/json.rst:45
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../reference_lua/json.rst:50
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../reference_lua/json.rst:80
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../reference_lua/json.rst:82
msgid "a string formatted as JSON."
msgstr ""

#: ../reference_lua/json.rst:83 ../reference_lua/msgpack.rst:50
#: ../reference_lua/yaml.rst:50
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../reference_lua/json.rst:88
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../reference_lua/json.rst:110 ../reference_lua/msgpack.rst:57
#: ../reference_lua/yaml.rst:57
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""

#: ../reference_lua/json.rst:114
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'}\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../reference_lua/json.rst:136
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference_lua/json.rst:138
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../reference_lua/json.rst:139
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../reference_lua/json.rst:141 ../reference_lua/yaml.rst:94
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""

#: ../reference_lua/json.rst:143
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../reference_lua/json.rst:165
msgid ""
"A NOTE ABOUT CONFIGURATION SETTINGS: There are configuration settings "
"which affect the way that Tarantool encodes invalid numbers or types. "
"They are all boolean true/false values. |br| "
":codenormal:`cfg.encode_invalid_numbers     default = true    /* allow "
"nan and inf */` |br| :codenormal:`cfg.encode_use_tostring        default "
"= false   /* use tostring for unrecognizable types */` |br| "
":codenormal:`cfg.encode_invalid_as_nil      default = false   /* use null"
" for all unrecognizable types */` |br| "
":codenormal:`cfg.encode_load_metatables     default = true    /* load "
"metatables */` |br| For example, the following code will interpret 0/0 "
"(which is \"not a number\") and 1/0 (which is \"infinity\") as special "
"values rather than nulls or errors: |br| :codenormal:`json = "
"require('json')` |br| :codenormal:`json.cfg{encode_invalid_numbers = "
"true}` |br| :codenormal:`x = 0/0` |br| :codenormal:`y = 1/0` |br| "
":codenormal:`json.encode({1,x,y,2})` |br| The result of the json.encode "
"request will look like this: |br| :codenormal:`tarantool>` "
":codebold:`json.encode({1,x,y,2})` |br| :codenormal:`---` |br| "
":codenormal:`- '[1,nan,inf,2]` |br| :codenormal:`...` |br| The same "
"configuration settings exist for json, for :ref:`MsgPack <msgpack-"
"package>`, and for :ref:`yaml <yaml-package>`."
msgstr ""

#: ../reference_lua/log.rst:30
msgid "Package `log`"
msgstr ""

#: ../reference_lua/log.rst:34
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`logger <cfg_logging-logger>` configuration parameter. "
"Diagnostic messages may be either system-generated by the server's "
"internal code, or user-generated with the ``log.log_level_function_name``"
" function."
msgstr ""

#: ../reference_lua/log.rst:44
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-"
"logger>`, given log_level_function_name = ``error`` or ``warn`` or "
"``info`` or ``debug``."
msgstr ""

#: ../reference_lua/log.rst:47
#, python-format
msgid ""
"The actual output will be a line containing the current timestamp, a "
"module name, 'E' or 'W' or 'I' or 'D' or 'R' depending on "
"``log_level_function_name``, and ``message``. Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`. Messages may contain C-style format specifiers "
"%d or %s, so :samp:`log.error('...%d...%s',{x},{y})` will work if x is a "
"number and y is a string."
msgstr ""

#: ../reference_lua/log.rst:68
#, python-format
msgid ""
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()\n"
"$ less tarantool.txt"
msgstr ""

#: ../reference_lua/log.rst:81
msgid ""
"2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...1 [5261] main/101/spawner C> initialized\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../reference_lua/log.rst:86
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../reference_lua/log.rst:88
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../reference_lua/msgpack.rst:30
msgid "Package `msgpack`"
msgstr ""

#: ../reference_lua/msgpack.rst:32
msgid ""
"The ``msgpack`` package takes strings in MsgPack_ format and decodes "
"them, or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../reference_lua/msgpack.rst:39
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../reference_lua/msgpack.rst:42
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../reference_lua/msgpack.rst:47
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../reference_lua/msgpack.rst:49
msgid "a string formatted as MsgPack."
msgstr ""

#: ../reference_lua/msgpack.rst:63
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../reference_lua/msgpack.rst:86
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../reference_lua/msgpack.rst:88
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../reference_lua/msgpack.rst:89
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../reference_lua/msgpack.rst:91
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""

#: ../reference_lua/msgpack.rst:95
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../reference_lua/msgpack.rst:115
msgid "**Result:**"
msgstr ""

#: ../reference_lua/msgpack.rst:120
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 1 a1 41 2 a1 42"
msgstr ""

#: ../reference_lua/msgpack.rst:123
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../reference_lua/msgpack.rst:128
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../reference_lua/msgpack.rst:130
msgid "and the second encoding means:"
msgstr ""

#: ../reference_lua/msgpack.rst:135
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../reference_lua/msgpack.rst:137
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""

#: ../reference_lua/msgpack.rst:145
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../reference_lua/msgpack.rst:151
msgid "{}"
msgstr ""

#: ../reference_lua/msgpack.rst:151
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../reference_lua/msgpack.rst:154
msgid "'a'"
msgstr ""

#: ../reference_lua/msgpack.rst:154
msgid "'fixstr' = a1 61"
msgstr ""

#: ../reference_lua/msgpack.rst:156
msgid "false"
msgstr ""

#: ../reference_lua/msgpack.rst:156
msgid "'false' = c2"
msgstr ""

#: ../reference_lua/msgpack.rst:158
msgid "true"
msgstr ""

#: ../reference_lua/msgpack.rst:158
msgid "'true' = c3"
msgstr ""

#: ../reference_lua/msgpack.rst:160
msgid "127"
msgstr ""

#: ../reference_lua/msgpack.rst:160
msgid "'positive fixint' = 7f"
msgstr ""

#: ../reference_lua/msgpack.rst:162
msgid "65535"
msgstr ""

#: ../reference_lua/msgpack.rst:162
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../reference_lua/msgpack.rst:164
msgid "4294967295"
msgstr ""

#: ../reference_lua/msgpack.rst:164
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../reference_lua/msgpack.rst:166
msgid "'nil' = c0"
msgstr ""

#: ../reference_lua/msgpack.rst:168
msgid "msgpack.NULL"
msgstr ""

#: ../reference_lua/msgpack.rst:168
msgid "same as nil"
msgstr ""

#: ../reference_lua/msgpack.rst:170
msgid "[0] = 5"
msgstr ""

#: ../reference_lua/msgpack.rst:170
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""

#: ../reference_lua/msgpack.rst:173
msgid "[0] = nil"
msgstr ""

#: ../reference_lua/msgpack.rst:173
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../reference_lua/msgpack.rst:176
msgid "1.5"
msgstr ""

#: ../reference_lua/msgpack.rst:176
msgid "'float 64' = cb 3f f8 0 0 0 0 0 0"
msgstr ""

#: ../reference_lua/msgpack.rst:179
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in"
" the same way that they can be changed for :ref:`JSON <json-"
"package_cfg>`."
msgstr ""

#: ../reference_lua/net_box.rst:30
msgid "Package `net.box`"
msgstr ""

#: ../reference_lua/net_box.rst:32
msgid ""
"The ``net.box`` package contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS "
"plugins <dbms_packages>` appendix. In this section the subject is the "
"built-in variant, ``net.box``. This is for connecting to tarantool "
"servers via a network."
msgstr ""

#: ../reference_lua/net_box.rst:38
msgid ""
"Call ``require('net.box')`` to get a ``net.box`` object, which will be "
"called ``net_box`` for examples in this section. Call ``net_box.new()`` "
"to connect and get a connection object, which will be called ``conn`` for"
" examples in this section. Call the other ``net.box()`` routines, passing"
" ``conn:``, to execute requests on the remote box. Call :ref:`conn:close "
"<socket-close>` to disconnect."
msgstr ""

#: ../reference_lua/net_box.rst:44
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example when "
"it's necessary to prioritize requests or to use different authentication "
"ids."
msgstr ""

#: ../reference_lua/net_box.rst:57
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It is re-established automatically after a "
"disconnect. The returned ``conn`` object supports methods for making "
"remote requests, such as select, update or delete."
msgstr ""

#: ../reference_lua/net_box.rst:62
msgid ""
"For the local tarantool server there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-"
"the_implicit_yield_rules>` any request can yield, and database state may "
"have changed by the time it regains control."
msgstr ""

#: ../reference_lua/net_box.rst:72
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../reference_lua/net_box.rst:73
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../reference_lua/net_box.rst:74
msgid "conn object"
msgstr ""

#: ../reference_lua/net_box.rst:79
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../reference_lua/net_box.rst:88
msgid "Execute a PING command."
msgstr ""

#: ../reference_lua/net_box.rst:90
msgid "true on success, false on error"
msgstr ""

#: ../reference_lua/net_box.rst:95
msgid "net_box.self:ping()"
msgstr ""

#: ../reference_lua/net_box.rst:101
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../reference_lua/net_box.rst:104
msgid "true when connected, false on failure."
msgstr ""

#: ../reference_lua/net_box.rst:109
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../reference_lua/net_box.rst:115
msgid "Show whether connection is active or closed."
msgstr ""

#: ../reference_lua/net_box.rst:117
msgid "true if connected, false on failure."
msgstr ""

#: ../reference_lua/net_box.rst:122
msgid "net_box.self:is_connected()"
msgstr ""

#: ../reference_lua/net_box.rst:129
msgid "Close a connection."
msgstr ""

#: ../reference_lua/net_box.rst:131
msgid ""
"Connection objects are garbage collected just like any other objects in "
"Lua, so an explicit destruction is not mandatory. However, since close() "
"is a system call, it is good programming practice to close a connection "
"explicitly when it is no longer needed, to avoid lengthy stalls of the "
"garbage collector."
msgstr ""

#: ../reference_lua/net_box.rst:136
msgid "Example: ``conn:close()``"
msgstr ""

#: ../reference_lua/net_box.rst:140
msgid ""
":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`. Please note this difference: due to :ref:`the"
" implicit yield rules <atomic-the_implicit_yield_rules>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../reference_lua/net_box.rst:150
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:155
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:160
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:165
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:170
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:175
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../reference_lua/net_box.rst:180
msgid ""
":samp:`conn:call('func', '1', '2', '3')` is the remote-call equivalent of"
" :samp:`func('1', '2', '3')`. That is, ``conn:call`` is a remote stored-"
"procedure call."
msgstr ""

#: ../reference_lua/net_box.rst:184
msgid "Example: ``conn:call('function5')``"
msgstr ""

#: ../reference_lua/net_box.rst:188
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-privileges>` is required; if the "
"user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../reference_lua/net_box.rst:194
msgid "Example: ``conn:eval('return 5+5')``"
msgstr ""

#: ../reference_lua/net_box.rst:198
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it."
msgstr ""

#: ../reference_lua/net_box.rst:201
msgid "Example: ``conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})``"
msgstr ""

#: ../reference_lua/net_box.rst:203
msgid ""
"All remote calls support execution timeouts. Using a wrapper object makes"
" the remote connection API compatible with the local one, removing the "
"need for a separate ``timeout`` argument, which the local version would "
"ignore. Once a request is sent, it cannot be revoked from the remote "
"server even if a timeout expires: the timeout expiration only aborts the "
"wait for the remote server response, not the request itself."
msgstr ""

#: ../reference_lua/net_box.rst:212
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../reference_lua/net_box.rst:214
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. Assume that the database is nearly empty. Assume that the tarantool "
"server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../reference_lua/net_box.rst:219
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../reference_lua/os.rst:30
msgid "Package `os`"
msgstr ""

#: ../reference_lua/os.rst:34
msgid ""
"The os package contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`. Most of these functions are described in the Lua manual "
"Chapter 22 `The Operating System Library "
"<https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../reference_lua/os.rst:49
msgid ""
":codenormal:`os.`:codebold:`execute`:codenormal:`(`:codeitalic:`shell-"
"command`:codenormal:`)`"
msgstr ""

#: ../reference_lua/os.rst:51
msgid "Execute by passing to the shell."
msgstr ""

#: ../reference_lua/os.rst:53
msgid "Parameters: (string) shell-command = what to execute."
msgstr ""

#: ../reference_lua/os.rst:55
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.execute('ls -l "
"/usr')` |br| :codenormal:`total 200` |br| :codenormal:`drwxr-xr-x   2 "
"root root 65536 Apr 22 15:49 bin` |br| :codenormal:`drwxr-xr-x  59 root "
"root 20480 Apr 18 07:58 include` |br| :codenormal:`drwxr-xr-x 210 root "
"root 65536 Apr 18 07:59 lib` |br| :codenormal:`drwxr-xr-x  12 root root  "
"4096 Apr 22 15:49 local` |br| :codenormal:`drwxr-xr-x   2 root root 12288"
" Jan 31 09:50 sbin` |br|"
msgstr ""

#: ../reference_lua/os.rst:66
msgid ""
":codenormal:`os.`:codebold:`rename`:codenormal:`(`:codeitalic:`old-name"
",new-name`:codenormal:`)`"
msgstr ""

#: ../reference_lua/os.rst:68
msgid "Rename a file or directory."
msgstr ""

#: ../reference_lua/os.rst:70
msgid ""
"Parameters: (string) old-name = name of existing file or directory, "
"(string) new-name = changed name of file or directory."
msgstr ""

#: ../reference_lua/os.rst:73
msgid ""
"**Example:** |br| :codenormal:`tarantool>` "
":codebold:`os.rename('local','foreign')` |br| :codenormal:`---` |br| "
":codenormal:`- null` |br| :codenormal:`- 'local: No such file or "
"directory'` |br| :codenormal:`- 2` |br| :codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/os.rst:83
msgid ""
":codenormal:`os.`:codebold:`getenv`:codenormal:`(`:codeitalic:`variable-"
"name`:codenormal:`)`"
msgstr ""

#: ../reference_lua/os.rst:85
msgid "Get environment variable."
msgstr ""

#: ../reference_lua/os.rst:87
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../reference_lua/os.rst:89
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.getenv('PATH')` "
"|br| :codenormal:`---` |br| :codenormal:`- "
"/usr/local/sbin:/usr/local/bin:/usr/sbin` |br| :codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/os.rst:97
msgid ":codenormal:`os.`:codebold:`remove`:codenormal:`(`:codeitalic:`name`:codenormal:`)`"
msgstr ""

#: ../reference_lua/os.rst:99
msgid "Remove file or directory."
msgstr ""

#: ../reference_lua/os.rst:101
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""

#: ../reference_lua/os.rst:103
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.remove('file')` "
"|br| :codenormal:`---` |br| :codenormal:`- true` |br| :codenormal:`...` "
"|br|"
msgstr ""

#: ../reference_lua/os.rst:111
msgid ""
":codenormal:`os.`:codebold:`date`:codenormal:`(`:codeitalic:`format-"
"string` :codenormal:`[,`:codeitalic:`time-since-epoch`:codenormal:`])`"
msgstr ""

#: ../reference_lua/os.rst:113
msgid "Return a formatted date."
msgstr ""

#: ../reference_lua/os.rst:115
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""

#: ../reference_lua/os.rst:118
#, python-format
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.date(\"%A %B "
"%d\")` |br| :codenormal:`---` |br| :codenormal:`- Sunday April 24` |br| "
":codenormal:`...`"
msgstr ""

#: ../reference_lua/os.rst:126
msgid ":codenormal:`os.`:codebold:`exit`:codenormal:`()`"
msgstr ""

#: ../reference_lua/os.rst:128
msgid "Exit the program. If this is done on the server, then the server stops."
msgstr ""

#: ../reference_lua/os.rst:130
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.exit()` |br| "
":codenormal:`user@user-shell:~/tarantool_sandbox$``"
msgstr ""

#: ../reference_lua/os.rst:136
msgid ":codenormal:`os.`:codebold:`time`:codenormal:`()`"
msgstr ""

#: ../reference_lua/os.rst:138
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../reference_lua/os.rst:140
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.time()` |br| "
":codenormal:`---` |br| :codenormal:`- 1461516945` |br| :codenormal:`...` "
"|br|"
msgstr ""

#: ../reference_lua/os.rst:148
msgid ":codenormal:`os.`:codebold:`clock`:codenormal:`()`"
msgstr ""

#: ../reference_lua/os.rst:150
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../reference_lua/os.rst:152
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.clock()` |br| "
":codenormal:`---` |br| :codenormal:`- 0.05` |br| :codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/os.rst:160
msgid ":codenormal:`os.`:codebold:`tmpname`:codenormal:`()`"
msgstr ""

#: ../reference_lua/os.rst:162
msgid "Return a name for a temporary file."
msgstr ""

#: ../reference_lua/os.rst:164
msgid ""
"**Example:** |br| :codenormal:`tarantool>` :codebold:`os.tmpname()` |br| "
":codenormal:`---` |br| :codenormal:`- /tmp/lua_7SW1m2` |br| "
":codenormal:`...` |br|"
msgstr ""

#: ../reference_lua/other.rst:28
msgid "Miscellaneous"
msgstr ""

#: ../reference_lua/other.rst:34
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The result can be "
"used in arithmetic, and the arithmetic will be 64-bit integer arithmetic "
"rather than floating-point arithmetic. (Operations on an unconverted Lua "
"number use floating-point arithmetic.) The ``tonumber64()`` function is "
"added by Tarantool; the name is global."
msgstr ""

#: ../reference_lua/other.rst:42
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../reference_lua/other.rst:65
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""

#: ../reference_lua/other.rst:69
msgid "Lua code"
msgstr ""

#: ../reference_lua/other.rst:70
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""

#: ../reference_lua/other.rst:73
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../reference_lua/other.rst:75
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr ""

#: ../reference_lua/other.rst:79
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../reference_lua/pickle.rst:28
msgid "Package `pickle`"
msgstr ""

#: ../reference_lua/pickle.rst:34
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""

#: ../reference_lua/pickle.rst:40
msgid "**Format specifiers**"
msgstr ""

#: ../reference_lua/pickle.rst:45
msgid "b, B"
msgstr ""

#: ../reference_lua/pickle.rst:45
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../reference_lua/pickle.rst:48
msgid "s, S"
msgstr ""

#: ../reference_lua/pickle.rst:48
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../reference_lua/pickle.rst:52
msgid "i, I"
msgstr ""

#: ../reference_lua/pickle.rst:52
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../reference_lua/pickle.rst:56
msgid "l, L"
msgstr ""

#: ../reference_lua/pickle.rst:56
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, low byte first"
msgstr ""

#: ../reference_lua/pickle.rst:60
msgid "n"
msgstr ""

#: ../reference_lua/pickle.rst:60
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../reference_lua/pickle.rst:64
msgid "N"
msgstr ""

#: ../reference_lua/pickle.rst:64
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../reference_lua/pickle.rst:67
msgid "q, Q"
msgstr ""

#: ../reference_lua/pickle.rst:67
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, big endian,"
msgstr ""

#: ../reference_lua/pickle.rst:71
msgid "f"
msgstr ""

#: ../reference_lua/pickle.rst:71
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""

#: ../reference_lua/pickle.rst:74
msgid "d"
msgstr ""

#: ../reference_lua/pickle.rst:74
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the "
"resulting string"
msgstr ""

#: ../reference_lua/pickle.rst:77
msgid "a, A"
msgstr ""

#: ../reference_lua/pickle.rst:77
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in "
"the resulting string"
msgstr ""

#: ../reference_lua/pickle.rst:81
msgid "string containing format specifiers"
msgstr ""

#: ../reference_lua/pickle.rst:82
msgid "scalar values to be formatted"
msgstr ""

#: ../reference_lua/pickle.rst:83
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../reference_lua/pickle.rst:87
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../reference_lua/pickle.rst:91
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../reference_lua/pickle.rst:125
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""

#: ../reference_lua/pickle.rst:131
msgid "A list of strings or numbers."
msgstr ""

#: ../reference_lua/pickle.rst:136
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/socket.rst:30
msgid "Package `socket`"
msgstr ""

#: ../reference_lua/socket.rst:32
msgid ""
"The ``socket`` package allows exchanging data via BSD sockets with a "
"local or remote host in connection-oriented (TCP) or datagram-oriented "
"(UDP) mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""

#: ../reference_lua/socket.rst:38
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""

#: ../reference_lua/socket.rst:49
msgid "**Socket functions**"
msgstr ""

#: ../reference_lua/socket.rst:54
msgid "Purposes"
msgstr ""

#: ../reference_lua/socket.rst:54
msgid "Names"
msgstr ""

#: ../reference_lua/socket.rst:56
msgid "setup"
msgstr ""

#: ../reference_lua/socket.rst:56
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../reference_lua/socket.rst:58 ../reference_lua/socket.rst:60
#: ../reference_lua/socket.rst:62 ../reference_lua/socket.rst:64
#: ../reference_lua/socket.rst:68 ../reference_lua/socket.rst:70
#: ../reference_lua/socket.rst:74 ../reference_lua/socket.rst:76
#: ../reference_lua/socket.rst:80 ../reference_lua/socket.rst:82
#: ../reference_lua/socket.rst:86 ../reference_lua/socket.rst:90
#: ../reference_lua/socket.rst:94 ../reference_lua/socket.rst:98
#: ../reference_lua/socket.rst:100 ../reference_lua/socket.rst:102
#: ../reference_lua/socket.rst:106 ../reference_lua/socket.rst:108
msgid "\"\""
msgstr ""

#: ../reference_lua/socket.rst:58
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../reference_lua/socket.rst:60
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../reference_lua/socket.rst:62
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../reference_lua/socket.rst:64
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../reference_lua/socket.rst:66
msgid "sending"
msgstr ""

#: ../reference_lua/socket.rst:66
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../reference_lua/socket.rst:68
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../reference_lua/socket.rst:70
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../reference_lua/socket.rst:72
msgid "receiving"
msgstr ""

#: ../reference_lua/socket.rst:72
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../reference_lua/socket.rst:74
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../reference_lua/socket.rst:76
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../reference_lua/socket.rst:78
msgid "flag setting"
msgstr ""

#: ../reference_lua/socket.rst:78
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../reference_lua/socket.rst:80
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../reference_lua/socket.rst:82
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../reference_lua/socket.rst:84
msgid "client/server"
msgstr ""

#: ../reference_lua/socket.rst:84
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../reference_lua/socket.rst:86
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../reference_lua/socket.rst:88
msgid "teardown"
msgstr ""

#: ../reference_lua/socket.rst:88
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../reference_lua/socket.rst:90
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../reference_lua/socket.rst:92
msgid "error checking"
msgstr ""

#: ../reference_lua/socket.rst:92
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../reference_lua/socket.rst:94
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../reference_lua/socket.rst:96
msgid "information"
msgstr ""

#: ../reference_lua/socket.rst:96
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../reference_lua/socket.rst:98
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../reference_lua/socket.rst:100
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../reference_lua/socket.rst:102
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../reference_lua/socket.rst:104
msgid "state checking"
msgstr ""

#: ../reference_lua/socket.rst:104
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../reference_lua/socket.rst:106
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../reference_lua/socket.rst:108
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../reference_lua/socket.rst:111
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-the_implicit_yield_rules>` will cause a yield so that other "
"processes may take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../reference_lua/socket.rst:120
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../reference_lua/socket.rst:127
msgid ""
":codebold:`socket`:codenormal:`(`:codeitalic:`domain, type, "
"protocol`:codenormal:`)`"
msgstr ""

#: ../reference_lua/socket.rst:129
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""

#: ../reference_lua/socket.rst:132
msgid "an unconnected socket, or nil."
msgstr ""

#: ../reference_lua/socket.rst:135
msgid "Example: |br| :codenormal:`socket('AF_INET', 'SOCK_STREAM', 'tcp')`"
msgstr ""

#: ../reference_lua/socket.rst:142
msgid "Connect a socket to a remote host."
msgstr ""

#: ../reference_lua/socket.rst:144
msgid "URL or IP address"
msgstr ""

#: ../reference_lua/socket.rst:145
msgid "port number"
msgstr ""

#: ../reference_lua/socket.rst:146
msgid "a connected socket, if no error."
msgstr ""

#: ../reference_lua/socket.rst:149
msgid "Example: |br| :codenormal:`tcp_connect('127.0.0.1', 3301)`"
msgstr ""

#: ../reference_lua/socket.rst:156
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed."
msgstr ""

#: ../reference_lua/socket.rst:160 ../reference_lua/socket.rst:504
#: ../reference_lua/socket.rst:516
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""

#: ../reference_lua/socket.rst:163
msgid ""
"Example: |br| :codenormal:`socket.getaddrinfo('tarantool.org', 'http')` "
"|br| will return variable information such as"
msgstr ""

#: ../reference_lua/socket.rst:167
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../reference_lua/socket.rst:186
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
"``box.cfg{listen=...)``."
msgstr ""

#: ../reference_lua/socket.rst:190
msgid ""
"Example: |br| :codenormal:`socket.tcp_server('localhost', 3302, function "
"() end)`"
msgstr ""

#: ../reference_lua/socket.rst:199
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../reference_lua/socket.rst:206
msgid "Either:"
msgstr ""

#: ../reference_lua/socket.rst:205
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../reference_lua/socket.rst:207
msgid "port - a number."
msgstr ""

#: ../reference_lua/socket.rst:209 ../reference_lua/socket.rst:216
msgid "Or:"
msgstr ""

#: ../reference_lua/socket.rst:209
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../reference_lua/socket.rst:210
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../reference_lua/socket.rst:212
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../reference_lua/socket.rst:214
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""

#: ../reference_lua/socket.rst:218
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../reference_lua/socket.rst:221
msgid ""
"Example: |br| :codenormal:`socket = require('socket')` |br| "
":codenormal:`sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')` |br| "
":codenormal:`sock:sysconnect(0, 3301)`"
msgstr ""

#: ../reference_lua/socket.rst:231
msgid "Send data over a connected socket."
msgstr ""

#: ../reference_lua/socket.rst:234 ../reference_lua/socket.rst:348
msgid "the number of bytes sent."
msgstr ""

#: ../reference_lua/socket.rst:237
msgid "Possible errors: nil on error."
msgstr ""

#: ../reference_lua/socket.rst:243
msgid ""
"Write as much as possible data to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""

#: ../reference_lua/socket.rst:250
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""

#: ../reference_lua/socket.rst:254
msgid "a string of the requested length on success."
msgstr ""

#: ../reference_lua/socket.rst:257
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""

#: ../reference_lua/socket.rst:270
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../reference_lua/socket.rst:275
msgid ""
"maximum number of bytes to read for example 50 means \"stop after 50 "
"bytes\""
msgstr ""

#: ../reference_lua/socket.rst:277
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../reference_lua/socket.rst:279
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""

#: ../reference_lua/socket.rst:282
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../reference_lua/socket.rst:292
msgid ""
"Return all available data from the socket buffer if non-blocking. Rarely "
"used. For details see `this description`_."
msgstr ""

#: ../reference_lua/socket.rst:299
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""

#: ../reference_lua/socket.rst:307
msgid "a socket object on success"
msgstr ""

#: ../reference_lua/socket.rst:310
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../reference_lua/socket.rst:316
msgid "Start listening for incoming connections."
msgstr ""

#: ../reference_lua/socket.rst:318
msgid ""
"On Linux the listen ``backlog`` backlog may be from "
"/proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../reference_lua/socket.rst:322
msgid "true for success, false for error."
msgstr ""

#: ../reference_lua/socket.rst:323
msgid "boolean."
msgstr ""

#: ../reference_lua/socket.rst:329
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""

#: ../reference_lua/socket.rst:333
msgid "new socket if success."
msgstr ""

#: ../reference_lua/socket.rst:342
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../reference_lua/socket.rst:351 ../reference_lua/socket.rst:363
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../reference_lua/socket.rst:357
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../reference_lua/socket.rst:360
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../reference_lua/socket.rst:361
msgid "string, table"
msgstr ""

#: ../reference_lua/socket.rst:365
msgid ""
"Example: |br| After |br| :codenormal:`message_content, message_sender = "
"recvfrom(1)` |br| the value of ``message_content`` might be a string "
"containing 'X' and the value of ``message_sender`` might be a table "
"containing ``message_sender.host = '18.44.0.1'``, ``message_sender.family"
" = 'AF_INET'``, ``message_sender.port = 43065``."
msgstr ""

#: ../reference_lua/socket.rst:378
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../reference_lua/socket.rst:380
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../reference_lua/socket.rst:382 ../reference_lua/tap.rst:90
#: ../reference_lua/tap.rst:122 ../reference_lua/tap.rst:153
#: ../reference_lua/tap.rst:164 ../reference_lua/tap.rst:181
#: ../reference_lua/tap.rst:189
msgid "true or false."
msgstr ""

#: ../reference_lua/socket.rst:389
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when its userdata is garbage collected by "
"Lua."
msgstr ""

#: ../reference_lua/socket.rst:392
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""

#: ../reference_lua/socket.rst:401
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""

#: ../reference_lua/socket.rst:404
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../reference_lua/socket.rst:406
msgid "number, string"
msgstr ""

#: ../reference_lua/socket.rst:412
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../reference_lua/socket.rst:416
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../reference_lua/socket.rst:417
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../reference_lua/socket.rst:418
msgid "SO_BROADCAST"
msgstr ""

#: ../reference_lua/socket.rst:419
msgid "SO_DEBUG"
msgstr ""

#: ../reference_lua/socket.rst:420
msgid "SO_DOMAIN"
msgstr ""

#: ../reference_lua/socket.rst:421
msgid "SO_ERROR"
msgstr ""

#: ../reference_lua/socket.rst:422
msgid "SO_DONTROUTE"
msgstr ""

#: ../reference_lua/socket.rst:423
msgid "SO_KEEPALIVE"
msgstr ""

#: ../reference_lua/socket.rst:424
msgid "SO_MARK"
msgstr ""

#: ../reference_lua/socket.rst:425
msgid "SO_OOBINLINE"
msgstr ""

#: ../reference_lua/socket.rst:426
msgid "SO_PASSCRED"
msgstr ""

#: ../reference_lua/socket.rst:427
msgid "SO_PEERCRED"
msgstr ""

#: ../reference_lua/socket.rst:428
msgid "SO_PRIORITY"
msgstr ""

#: ../reference_lua/socket.rst:429
msgid "SO_PROTOCOL"
msgstr ""

#: ../reference_lua/socket.rst:430
msgid "SO_RCVBUF"
msgstr ""

#: ../reference_lua/socket.rst:431
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../reference_lua/socket.rst:432
msgid "SO_RCVLOWAT"
msgstr ""

#: ../reference_lua/socket.rst:433
msgid "SO_SNDLOWAT"
msgstr ""

#: ../reference_lua/socket.rst:434
msgid "SO_RCVTIMEO"
msgstr ""

#: ../reference_lua/socket.rst:435
msgid "SO_SNDTIMEO"
msgstr ""

#: ../reference_lua/socket.rst:436
msgid "SO_REUSEADDR"
msgstr ""

#: ../reference_lua/socket.rst:437
msgid "SO_SNDBUF"
msgstr ""

#: ../reference_lua/socket.rst:438
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../reference_lua/socket.rst:439
msgid "SO_TIMESTAMP"
msgstr ""

#: ../reference_lua/socket.rst:440
msgid "SO_TYPE"
msgstr ""

#: ../reference_lua/socket.rst:442
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../reference_lua/socket.rst:448
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../reference_lua/socket.rst:454
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../reference_lua/socket.rst:459
msgid "new active and timeout values."
msgstr ""

#: ../reference_lua/socket.rst:465
msgid ""
"``sock:nonblock()`` returns the current flag value. |br| "
"``sock:nonblock(false)`` sets the flag to false and returns false. |br| "
"``sock:nonblock(true)`` sets the flag to true and returns true. This "
"function may be useful before invoking a function which might otherwise "
"block indefinitely."
msgstr ""

#: ../reference_lua/socket.rst:475
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../reference_lua/socket.rst:477
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../reference_lua/socket.rst:483
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../reference_lua/socket.rst:485
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../reference_lua/socket.rst:491
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""

#: ../reference_lua/socket.rst:493
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""

#: ../reference_lua/socket.rst:499
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../reference_lua/socket.rst:511
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""

#: ../reference_lua/socket.rst:527
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../reference_lua/socket.rst:529
msgid ""
"In this example a connection is made over the internet between the "
"Tarantool server and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\". This is not a "
"useful way to communicate with this particular site, but shows that the "
"system works."
msgstr ""

#: ../reference_lua/socket.rst:534
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0rnHost: tarantool.orgrnrn\")\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- \"HTTP/1.1 200 OKrn\"\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/socket.rst:565
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../reference_lua/socket.rst:567
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../reference_lua/socket.rst:573
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/socket.rst:610
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../reference_lua/socket.rst:612
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../reference_lua/socket.rst:617
msgid ""
"Start two shells. The first shell will be the server. The second shell "
"will be the client."
msgstr ""

#: ../reference_lua/socket.rst:620
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../reference_lua/socket.rst:622
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../reference_lua/socket.rst:637
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""

#: ../reference_lua/socket.rst:644
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../reference_lua/socket.rst:649
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server's host and port:"
msgstr ""

#: ../reference_lua/socket.rst:652
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../reference_lua/socket.rst:656
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""

#: ../reference_lua/strict.rst:28
msgid "Package `strict`"
msgstr ""

#: ../reference_lua/strict.rst:32
msgid ""
"The :code:`strict` package has functions for turning \"strict mode\" on "
"or off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""

#: ../reference_lua/strict.rst:37
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../reference_lua/strict.rst:43
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/tap.rst:28
msgid "Package `tap`"
msgstr ""

#: ../reference_lua/tap.rst:30
msgid ""
"The tap package streamlines the testing of other packages. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""

#: ../reference_lua/tap.rst:39
msgid "Initialize."
msgstr ""

#: ../reference_lua/tap.rst:41
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""

#: ../reference_lua/tap.rst:45
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../reference_lua/tap.rst:46
msgid "taptest"
msgstr ""

#: ../reference_lua/tap.rst:49
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../reference_lua/tap.rst:58
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../reference_lua/tap.rst:65
msgid ""
"Checks the number of tests performed. This check should only be done "
"after all planned tests are complete, so ordinarily ``taptest:check()`` "
"will only appear at the end of a script."
msgstr ""

#: ../reference_lua/tap.rst:69
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not "
"equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../reference_lua/tap.rst:76
msgid "Display a diagnostic message."
msgstr ""

#: ../reference_lua/tap.rst:78
msgid "the message to be displayed."
msgstr ""

#: ../reference_lua/tap.rst:83
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""

#: ../reference_lua/tap.rst:87
msgid "an expression which is true or false"
msgstr ""

#: ../reference_lua/tap.rst:88 ../reference_lua/tap.rst:120
#: ../reference_lua/tap.rst:131 ../reference_lua/tap.rst:152
#: ../reference_lua/tap.rst:162 ../reference_lua/tap.rst:179
#: ../reference_lua/tap.rst:194
msgid "name of test"
msgstr ""

#: ../reference_lua/tap.rst:95
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/tap.rst:117
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""

#: ../reference_lua/tap.rst:127
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""

#: ../reference_lua/tap.rst:137
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../reference_lua/tap.rst:147
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""

#: ../reference_lua/tap.rst:150 ../reference_lua/tap.rst:160
#: ../reference_lua/tap.rst:192
msgid "actual result"
msgstr ""

#: ../reference_lua/tap.rst:151 ../reference_lua/tap.rst:161
#: ../reference_lua/tap.rst:193
msgid "expected result"
msgstr ""

#: ../reference_lua/tap.rst:158
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../reference_lua/tap.rst:175
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""

#: ../reference_lua/tap.rst:186
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""

#: ../reference_lua/tap.rst:204
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../reference_lua/tap.rst:208
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../reference_lua/tap.rst:222
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../reference_lua/tap.rst:224
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../reference_lua/tarantool.rst:28
msgid "Package `tarantool`"
msgstr ""

#: ../reference_lua/tarantool.rst:32
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""

#: ../reference_lua/tarantool.rst:38
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info <box_introspection-box_info>` but use of the tarantool "
"package is recommended."
msgstr ""

#: ../reference_lua/tarantool.rst:44
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../reference_lua/uuid.rst:28
msgid "Package `uuid`"
msgstr ""

#: ../reference_lua/uuid.rst:30
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../reference_lua/uuid.rst:36
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../reference_lua/uuid.rst:38
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../reference_lua/uuid.rst:39
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../reference_lua/uuid.rst:40
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../reference_lua/uuid.rst:42
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../reference_lua/uuid.rst:44
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../reference_lua/uuid.rst:45
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../reference_lua/uuid.rst:46
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../reference_lua/uuid.rst:47
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../reference_lua/uuid.rst:49
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../reference_lua/uuid.rst:51
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../reference_lua/uuid.rst:57
msgid "A nil object"
msgstr ""

#: ../reference_lua/uuid.rst:63 ../reference_lua/uuid.rst:70
#: ../reference_lua/uuid.rst:77
msgid "a UUID"
msgstr ""

#: ../reference_lua/uuid.rst:64 ../reference_lua/uuid.rst:86
#: ../reference_lua/uuid.rst:94
msgid "cdata"
msgstr ""

#: ../reference_lua/uuid.rst:71
msgid "16-byte string"
msgstr ""

#: ../reference_lua/uuid.rst:78
msgid "36-byte binary string"
msgstr ""

#: ../reference_lua/uuid.rst:84
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../reference_lua/uuid.rst:85 ../reference_lua/uuid.rst:93
msgid "converted UUID"
msgstr ""

#: ../reference_lua/uuid.rst:92
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../reference_lua/uuid.rst:102
msgid ""
"|br| 'l' - little-endian, |br| 'b' - big-endian, |br| 'h' - endianness "
"depends on host (default), |br| 'n' - endianness depends on network"
msgstr ""

#: ../reference_lua/uuid.rst:107 ../reference_lua/uuid.rst:114
msgid "UUID converted from cdata input value."
msgstr ""

#: ../reference_lua/uuid.rst:108
msgid "16-byte binary string"
msgstr ""

#: ../reference_lua/uuid.rst:115
msgid "36-byte hexadecimal string"
msgstr ""

#: ../reference_lua/uuid.rst:121
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""

#: ../reference_lua/uuid.rst:126
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../reference_lua/uuid.rst:127
msgid "bool"
msgstr ""

#: ../reference_lua/uuid.rst:133
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uui:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../reference_lua/yaml.rst:30
msgid "Package `yaml`"
msgstr ""

#: ../reference_lua/yaml.rst:32
msgid ""
"The ``yaml`` package takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""

#: ../reference_lua/yaml.rst:39
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../reference_lua/yaml.rst:42
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../reference_lua/yaml.rst:47
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../reference_lua/yaml.rst:49
msgid "a string formatted as YAML."
msgstr ""

#: ../reference_lua/yaml.rst:63
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../reference_lua/yaml.rst:86
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../reference_lua/yaml.rst:89
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../reference_lua/yaml.rst:90
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../reference_lua/yaml.rst:91
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../reference_lua/yaml.rst:92
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../reference_lua/yaml.rst:97
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../reference_lua/yaml.rst:133
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-package_cfg>`."
msgstr ""

#~ msgid ""
#~ "The contents of the ``box`` library "
#~ "can be inspected at runtime with "
#~ "``box``, with no arguments. The packages"
#~ " inside the box library are: "
#~ "``box.schema``, ``box.tuple``, ``box.space``, "
#~ "``box.index``, ``net.box``, ``box.cfg``, "
#~ "``box.info``, ``box.slab``, ``box.stat``. Every "
#~ "package contains one or more Lua "
#~ "functions. A few packages contain "
#~ "members as well as functions. The "
#~ "functions allow data definition (create "
#~ "alter drop), data manipulation (insert "
#~ "delete update upsert select replace), "
#~ "and introspection (inspecting contents of "
#~ "spaces, accessing server configuration)."
#~ msgstr ""

