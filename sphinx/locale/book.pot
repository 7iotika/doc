# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-06-23 13:32+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../book/administration.rst:28
msgid "Server administration"
msgstr ""

#: ../book/administration.rst:30
msgid "Typical server administration tasks include starting and stopping the server, reloading configuration, taking snapshots, log rotation."
msgstr ""

#: ../book/administration.rst:35
msgid "Server signal handling"
msgstr ""

#: ../book/administration.rst:37
msgid "The server processes these signals during the main thread event loop:"
msgstr ""

#: ../book/administration.rst:40
msgid "SIGHUP"
msgstr ""

#: ../book/administration.rst:42
msgid "may cause log file rotation, see :ref:`the example in section \"Logging\" <logging_example>`."
msgstr ""

#: ../book/administration.rst:44
msgid "SIGUSR1"
msgstr ""

#: ../book/administration.rst:46
msgid "may cause saving of a snapshot, see the description of :func:`box.snapshot`."
msgstr ""

#: ../book/administration.rst:48
msgid "SIGTERM"
msgstr ""

#: ../book/administration.rst:50
msgid "may cause graceful shutdown (information will be saved first)."
msgstr ""

#: ../book/administration.rst:51
msgid "SIGINT"
msgstr ""

#: ../book/administration.rst:53
msgid "(also known as keyboard interrupt) may cause graceful shutdown."
msgstr ""

#: ../book/administration.rst:54
msgid "SIGKILL"
msgstr ""

#: ../book/administration.rst:56
msgid "causes shutdown."
msgstr ""

#: ../book/administration.rst:58
msgid "Other signals will result in behavior defined by the operating system. Signals other than SIGKILL may be ignored, especially if the server is executing a long-running procedure which prevents return to the main thread event loop."
msgstr ""

#: ../book/administration.rst:65
msgid "Using ``tarantool`` as a client"
msgstr ""

#: ../book/administration.rst:69
msgid "If ``tarantool`` is started without an :ref:`initialization file <init-label>`, or if the initialization file contains :func:`console.start()`, then ``tarantool`` enters interactive mode. There will be a prompt (\"``tarantool>``\") and it will be possible to enter requests. When used this way, ``tarantool`` can be a client for a remote server."
msgstr ""

#: ../book/administration.rst:75
msgid "This section shows all legal syntax for the tarantool program, with short notes and examples. Other client programs may have similar options and request syntaxes. Some of the information in this section is duplicated in the :ref:`book-cfg` chapter."
msgstr ""

#: ../book/administration.rst:82
msgid "Conventions used in this section"
msgstr ""

#: ../book/administration.rst:84
msgid "Tokens are character sequences which are treated as syntactic units within requests. Square brackets [ and ] enclose optional syntax. Three dots in a row ... mean the preceding tokens may be repeated. A vertical bar | means the preceding and following tokens are mutually exclusive alternatives."
msgstr ""

#: ../book/administration.rst:91
msgid "Options when starting client from the command line"
msgstr ""

#: ../book/administration.rst:93
msgid "General form:"
msgstr ""

#: ../book/administration.rst:98
msgid "$ **tarantool**\n"
"OR\n"
"$ **tarantool** *options*\n"
"OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../book/administration.rst:104
msgid "*lua-initialization-file* can be any script containing code for initializing. Effect: The code in the file is executed during startup. Example: ``init.lua``. Notes: If a script is used, there will be no prompt. The script should contain configuration information including ``box.cfg{...listen=...}`` or ``box.listen(...)`` so that a separate program can connect to the server via one of the ports."
msgstr ""

#: ../book/administration.rst:111
msgid "Option is one of the following (in alphabetical order by the long form of the option):"
msgstr ""

#: ../book/administration.rst:116
msgid "Client displays a help message including a list of options. Example: ``tarantool --help``. The program stops after displaying the help."
msgstr ""

#: ../book/administration.rst:122
msgid "Client displays version information. Example: ``tarantool --version``. The program stops after displaying the version."
msgstr ""

#: ../book/administration.rst:128
msgid "Tokens, requests, and special key combinations"
msgstr ""

#: ../book/administration.rst:130
msgid "Procedure identifiers are: Any sequence of letters, digits, or underscores which is legal according to the rules for Lua identifiers. Procedure identifiers are also called function names. Notes: function names are case sensitive so ``insert`` and ``Insert`` are not the same thing."
msgstr ""

#: ../book/administration.rst:135
msgid "String literals are: Any sequence of zero or more characters enclosed in single quotes. Double quotes are legal but single quotes are preferred. Enclosing in double square brackets is good for multi-line strings as described in `Lua documentation`_. Examples: 'Hello, world', 'A', [[A\\\\B!]]."
msgstr ""

#: ../book/administration.rst:142
msgid "Numeric literals are: Character sequences containing only digits, optionally preceded by + or -. Large or floating-point numeric literals may include decimal points, exponential notation, or suffixes. Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL. Notes: Tarantool NUM data type is unsigned, so -1 is understood as a large unsigned number."
msgstr ""

#: ../book/administration.rst:148
msgid "Single-byte tokens are: , or ( or ) or arithmetic operators. Examples: * , ( )."
msgstr ""

#: ../book/administration.rst:150
msgid "Tokens must be separated from each other by one or more spaces, except that spaces are not necessary around single-byte tokens or string literals."
msgstr ""

#: ../book/administration.rst:157
msgid "Requests"
msgstr ""

#: ../book/administration.rst:159
msgid "Generally requests are entered following the prompt in interactive mode while ``tarantool`` is running. (A prompt will be the word tarantool and a greater-than sign, for example ``tarantool>``). The end-of-request marker is by default a newline (line feed)."
msgstr ""

#: ../book/administration.rst:164
msgid "For multi-line requests, it is possible to change the end-of-request marker. Syntax: :samp:`console = require('console'); console.delimiter({string-literal})`. The string-literal must be a value in single quotes. Effect: string becomes end-of-request delimiter, so newline alone is not treated as end of request. To go back to normal mode: :samp:`console.delimiter(''){string-literal}`. Delimiters are usually not necessary because Tarantool can tell when a multi-line request has not ended (for example, if it sees that a function declaration does not have an ``end`` keyword). Example:"
msgstr ""

#: ../book/administration.rst:173
msgid "console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"  statement_1 = 'a'\n"
"  statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""

#: ../book/administration.rst:182
msgid "For a condensed Backus-Naur Form [BNF] description of the suggested form of client requests, see http://tarantool.org/doc/box-protocol.html."
msgstr ""

#: ../book/administration.rst:185
msgid "In *interactive* mode, one types requests and gets results. Typically the requests are typed in by the user following prompts. Here is an example of an interactive-mode tarantool client session:"
msgstr ""

#: ../book/administration.rst:189
msgid "$ tarantool\n"
"[ tarantool will display an introductory message\n"
"  including version number here ]\n"
"tarantool> box.cfg{listen = 3301}\n"
"[ tarantool will display configuration information\n"
"  here ]\n"
"tarantool> s = box.schema.space.create('tester')\n"
"[ tarantool may display an in-progress message here ]\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{1,'My first tuple'}\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:select(1)\n"
"---\n"
"- - [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:drop()\n"
"---\n"
"...\n"
"tarantool> os.exit()\n"
"2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
"$"
msgstr ""

#: ../book/administration.rst:219
msgid "Explanatory notes about what tarantool displayed in the above example:"
msgstr ""

#: ../book/administration.rst:221
msgid "Many requests return typed objects. In the case of \"``box.cfg{listen=3301}``\", this result is displayed on the screen. If the request had assigned the result to a variable, for example \"``c = box.cfg{listen=3301}``\", then the result would not have been displayed on the screen."
msgstr ""

#: ../book/administration.rst:225
msgid "A display of an object always begins with \"``---``\" and ends with \"``...``\"."
msgstr ""

#: ../book/administration.rst:226
msgid "The insert request returns an object of type = tuple, so the object display line begins with a single dash ('``-``'). However, the select request returns an object of type = table of tuples, so the object display line begins with two dashes ('``- -``')."
msgstr ""

#: ../book/administration.rst:230
msgid "Utility ``tarantoolctl``"
msgstr ""

#: ../book/administration.rst:234
msgid "With ``tarantoolctl`` one can say: \"start an instance of the Tarantool server which runs a single user-written Lua program, allocating disk resources specifically for that program, via a standardized deployment method.\" If Tarantool was downloaded from source, then the script is in :file:`[tarantool]/extra/dist/tarantoolctl`. If Tarantool was installed with Debian or Red Hat installation packages, the script is renamed :program:`tarantoolctl` and is in :file:`/usr/bin/tarantoolctl`. The script handles such things as: starting, stopping, rotating logs, logging in to the application's console, and checking status."
msgstr ""

#: ../book/administration.rst:246
msgid "configuring for tarantoolctl"
msgstr ""

#: ../book/administration.rst:248
msgid "The :program:`tarantoolctl` script will read a configuration file named :file:`~/.config/tarantool/default`, or :file:`/etc/sysconfig/tarantool`, or :file:`/etc/default/tarantool`. Most of the settings are similar to the settings used by ``box.cfg{...};`` however, tarantoolctl adjusts some of them by adding an application name. A copy of :file:`/etc/sysconfig/tarantool`, with defaults for all settings, would look like this:"
msgstr ""

#: ../book/administration.rst:256
msgid "default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    sophia_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../book/administration.rst:268
msgid "The settings in the above script are:"
msgstr ""

#: ../book/administration.rst:272
msgid "``pid_file``"
msgstr ""

#: ../book/administration.rst:271
msgid "The directory for the pid file and control-socket file. The script will add \":samp:`/{instance-name}`\" to the directory name."
msgstr ""

#: ../book/administration.rst:276
msgid "``wal_dir``"
msgstr ""

#: ../book/administration.rst:275
msgid "The directory for the write-ahead :file:`*.xlog` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:280
msgid "``snap_dir``"
msgstr ""

#: ../book/administration.rst:279
msgid "The directory for the snapshot :file:`*.snap` files. The script will add \":samp:`/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:284
msgid "``sophia_dir``"
msgstr ""

#: ../book/administration.rst:283
msgid "The directory for the sophia-storage-engine files. The script will add \":samp:`/sophia/{instance-name}`\" to the directory-name."
msgstr ""

#: ../book/administration.rst:288
msgid "``logger``"
msgstr ""

#: ../book/administration.rst:287
msgid "The place where the application log will go. The script will add \":samp:`/{instance-name}.log`\" to the name."
msgstr ""

#: ../book/administration.rst:292
msgid "``username``"
msgstr ""

#: ../book/administration.rst:291
msgid "the user that runs the tarantool server. This is the operating-system user name rather than the Tarantool-client user name."
msgstr ""

#: ../book/administration.rst:300
msgid "``instance_dir``"
msgstr ""

#: ../book/administration.rst:295
msgid "the directory where all applications for this host are stored. The user who writes an application for :program:`tarantoolctl` must put the application's source code in this directory, or a symbolic link. For examples in this section the application name my_app will be used, and its source will have to be in :samp:`{instance_dir}/my_app.lua`."
msgstr ""

#: ../book/administration.rst:304
msgid "commands for tarantoolctl"
msgstr ""

#: ../book/administration.rst:306
msgid "The command format is :samp:`tarantoolctl {operation} {application_name}`, where operation is one of: start, stop, enter, logrotate, status, eval. Thus ..."
msgstr ""

#: ../book/administration.rst:311
msgid "Starts application *<application>*"
msgstr ""

#: ../book/administration.rst:315
msgid "Stops application"
msgstr ""

#: ../book/administration.rst:319
msgid "Show application's admin console"
msgstr ""

#: ../book/administration.rst:323
msgid "Rotate application's log files (make new, remove old)"
msgstr ""

#: ../book/administration.rst:327
msgid "Check application's status status"
msgstr ""

#: ../book/administration.rst:331
msgid "Execute code from *<scriptname>* on an instance of application"
msgstr ""

#: ../book/administration.rst:335
msgid "typical code snippets for tarantoolctl"
msgstr ""

#: ../book/administration.rst:337
msgid "A user can check whether my_app is running with these lines:"
msgstr ""

#: ../book/administration.rst:339
msgid "if tarantoolctl status my_app; then\n"
"...\n"
"fi"
msgstr ""

#: ../book/administration.rst:345
msgid "A user can initiate, for boot time, an init.d set of instructions:"
msgstr ""

#: ../book/administration.rst:347
msgid "for (each file mentioned in the instance_dir directory):\n"
"    tarantoolctl start `basename $ file .lua`"
msgstr ""

#: ../book/administration.rst:352
msgid "A user can set up a further configuration file for log rotation, like this:"
msgstr ""

#: ../book/administration.rst:357
msgid "/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"
msgstr ""

#: ../book/administration.rst:372
msgid "A detailed example for tarantoolctl"
msgstr ""

#: ../book/administration.rst:374
msgid "The example's objective is: make a temporary directory where tarantoolctl can start a long-running application and monitor it."
msgstr ""

#: ../book/administration.rst:377
msgid "The assumptions are: the root password is known, the computer is only being used for tests, the Tarantool server is ready to run but is not currently running, and there currently is no directory named :file:`tarantool_test`."
msgstr ""

#: ../book/administration.rst:381
msgid "Create a directory named /tarantool_test:"
msgstr ""

#: ../book/administration.rst:383
msgid "$ sudo mkdir /tarantool_test"
msgstr ""

#: ../book/administration.rst:387
msgid "Copy tarantoolctl to /tarantool_test. If you made a source download to ~/tarantool-master, then"
msgstr ""

#: ../book/administration.rst:390
msgid "$ sudo cp ~/tarantool-master/extra/dist/tarantoolctl /tarantool_test/tarantoolctl"
msgstr ""

#: ../book/administration.rst:394
msgid "If the file was named tarantoolctl and placed on :file:`/usr/bin/tarantoolctl`, then"
msgstr ""

#: ../book/administration.rst:396
msgid "$ sudo cp /usr/bin/tarantoolctl /tarantool_test/tarantoolctl"
msgstr ""

#: ../book/administration.rst:400
msgid "Check and possibly change the first line of :file:`code/tarantool_test/tarantoolctl`. Initially it says"
msgstr ""

#: ../book/administration.rst:403
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../book/administration.rst:407
msgid "If that is not correct, edit tarantoolctl and change the line. For example, if the Tarantool server is actually on :file:`/home/user/tarantool-master/src/tarantool`, change the line to"
msgstr ""

#: ../book/administration.rst:411
msgid "#!/usr/bin/env /home/user/tarantool-master/src/tarantool"
msgstr ""

#: ../book/administration.rst:415
msgid "Save a copy of :file:`/etc/sysconfig/tarantool`, if it exists."
msgstr ""

#: ../book/administration.rst:417
msgid "Edit /etc/sysconfig/tarantool. It might be necessary to say sudo mkdir /etc/sysconfig first. Let the new file contents be:"
msgstr ""

#: ../book/administration.rst:419
msgid "default_cfg = {\n"
"    pid_file = \"/tarantool_test/my_app.pid\",\n"
"    wal_dir = \"/tarantool_test\",\n"
"    snap_dir = \"/tarantool_test\",\n"
"    sophia_dir = \"/tarantool_test\",\n"
"    logger = \"/tarantool_test/log\",\n"
"    username = \"tarantool\",\n"
"}\n"
"instance_dir = \"/tarantool_test\""
msgstr ""

#: ../book/administration.rst:431
msgid "Make the my_app application file, that is, :file:`/tarantool_test/my_app.lua`. Let the file contents be:"
msgstr ""

#: ../book/administration.rst:433
msgid "box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""

#: ../book/administration.rst:449
msgid "Tell tarantoolctl to start the application ..."
msgstr ""

#: ../book/administration.rst:451
msgid "$ cd /tarantool_test\n"
"$ sudo ./tarantoolctl start my_app"
msgstr ""

#: ../book/administration.rst:456
msgid "... expect to see messages indicating that the instance has started. Then ..."
msgstr ""

#: ../book/administration.rst:458
msgid "$ ls -l /tarantool_test/my_app"
msgstr ""

#: ../book/administration.rst:462
msgid "... expect to see the .snap file, .xlog file, and sophia directory. Then ..."
msgstr ""

#: ../book/administration.rst:464
msgid "$ less /tarantool_test/log/my_app.log"
msgstr ""

#: ../book/administration.rst:468
msgid "... expect to see the contents of my_app's log, including error messages, if any. Then ..."
msgstr ""

#: ../book/administration.rst:470
msgid "$ cd /tarantool_test\n"
"$ # assume that 'tarantool' invokes the tarantool server\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/administration.rst:480
msgid "... expect to see several tuples that my_app has created."
msgstr ""

#: ../book/administration.rst:482
msgid "Stop. The only clean way to stop my_app is with tarantoolctl, thus:"
msgstr ""

#: ../book/administration.rst:484
msgid "$ sudo ./tarantoolctl stop my_app"
msgstr ""

#: ../book/administration.rst:488
msgid "Clean up. Restore the original contents of :file:`/etc/sysconfig/tarantool`, and ... .. code-block:: console"
msgstr ""

#: ../book/administration.rst:491
msgid "$ cd / $ sudo rm -R tarantool_test"
msgstr ""

#: ../book/administration.rst:496
msgid "System-specific administration notes"
msgstr ""

#: ../book/administration.rst:498
msgid "This section will contain information about issue or features which exist on some platforms but not others - for example, on certain versions of a particular Linux distribution."
msgstr ""

#: ../book/administration.rst:504
msgid "Administrating with Debian GNU/Linux and Ubuntu"
msgstr ""

#: ../book/administration.rst:506
msgid "Setting up an instance:"
msgstr ""

#: ../book/administration.rst:508
msgid "$ ln -s /etc/tarantool/instances.available/instance-name.cfg /etc/tarantool/instances.enabled/"
msgstr ""

#: ../book/administration.rst:512
msgid "Starting all instances:"
msgstr ""

#: ../book/administration.rst:514
msgid "$ service tarantool start"
msgstr ""

#: ../book/administration.rst:518
msgid "Stopping all instances:"
msgstr ""

#: ../book/administration.rst:520
msgid "$ service tarantool stop"
msgstr ""

#: ../book/administration.rst:524
msgid "Starting/stopping one instance:"
msgstr ""

#: ../book/administration.rst:526
msgid "$ service tarantool-instance-name start/stop"
msgstr ""

#: ../book/administration.rst:532
msgid "Fedora, RHEL, CentOS"
msgstr ""

#: ../book/administration.rst:534
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or \"Fedora\" or \"Red Hat\" in the search box."
msgstr ""

#: ../book/administration.rst:540
msgid "FreeBSD"
msgstr ""

#: ../book/administration.rst:542
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
msgstr ""

#: ../book/administration.rst:548
msgid "Mac OS X"
msgstr ""

#: ../book/administration.rst:550
msgid "There are no known permanent issues. For transient issues, go to http://github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
msgstr ""

#: ../book/administration.rst:556
msgid "Notes for systemd users"
msgstr ""

#: ../book/administration.rst:558
msgid "The Tarantool package fully supports :program:`systemd` for managing instances and supervising database daemons."
msgstr ""

#: ../book/administration.rst:563
msgid "Instance management"
msgstr ""

#: ../book/administration.rst:565
msgid "Tarantool package was designed to have multiple running instances of Tarantool on the same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@${MYAPP}` to manage your databases and Lua applications."
msgstr ""

#: ../book/administration.rst:571
msgid "creating instances"
msgstr ""

#: ../book/administration.rst:573
msgid "Simply put your Lua configuration to :file:`/etc/tarantool/instances.available/${MYAPP}.lua`:"
msgstr ""

#: ../book/administration.rst:575
msgid "box.cfg{listen = 3313}\n"
"require('myappcode').start()"
msgstr ""

#: ../book/administration.rst:580
msgid "(this minimal example is sufficient)."
msgstr ""

#: ../book/administration.rst:582
msgid "Another starting point could be the :file:`example.lua` script that ships with Tarantool and defines all options."
msgstr ""

#: ../book/administration.rst:587
msgid "starting instances"
msgstr ""

#: ../book/administration.rst:589
msgid "Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
msgstr ""

#: ../book/administration.rst:591
msgid "$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool example.lua <running>"
msgstr ""

#: ../book/administration.rst:597
msgid "(console examples here and further on are for Fedora)."
msgstr ""

#: ../book/administration.rst:599
msgid "Use :samp:`systemctl enable tarantool@${MYAPP}` to enable ``${MYAPP}`` instance for auto-load during system startup."
msgstr ""

#: ../book/administration.rst:604
msgid "monitoring instances"
msgstr ""

#: ../book/administration.rst:606
msgid "Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``${MYAPP}`` instance:"
msgstr ""

#: ../book/administration.rst:609
msgid "$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"
msgstr ""

#: ../book/administration.rst:622
msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
msgstr ""

#: ../book/administration.rst:624
msgid "$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database Server"
msgstr ""

#: ../book/administration.rst:636
msgid "attaching to instances"
msgstr ""

#: ../book/administration.rst:638
msgid "You can attach to a running Tarantool instance and evaluate some Lua code using the :program:`tarantoolctl` utility:"
msgstr ""

#: ../book/administration.rst:641
msgid "$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/example.control>"
msgstr ""

#: ../book/administration.rst:655
msgid "checking logs"
msgstr ""

#: ../book/administration.rst:657
msgid "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
msgstr ""

#: ../book/administration.rst:659
msgid "Let's write something to the log file:"
msgstr ""

#: ../book/administration.rst:661
msgid "$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for README.systemd readers\")\n"
"---\n"
"..."
msgstr ""

#: ../book/administration.rst:671
msgid "Then check the logs:"
msgstr ""

#: ../book/administration.rst:673
msgid "$ tail /var/log/tarantool/example.log\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
"2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
"2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept requests\n"
"2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead UNIX socket: /var/run/tarantool/example.control\n"
"2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> started\n"
"2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
"2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: connected\n"
"2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README.systemd readers\n"
"2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: disconnected"
msgstr ""

#: ../book/administration.rst:687
msgid "Log rotation is enabled by default if you have :program:`logrotate` installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the default behavior."
msgstr ""

#: ../book/administration.rst:692
msgid "stopping instances"
msgstr ""

#: ../book/administration.rst:694
msgid "Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the running ``${MYAPP}`` instance."
msgstr ""

#: ../book/administration.rst:697
msgid "$ systemctl stop tarantool@example"
msgstr ""

#: ../book/administration.rst:703
msgid "Daemon supervision"
msgstr ""

#: ../book/administration.rst:705
msgid "All instances are automatically restarted by :program:`systemd` in case of failure."
msgstr ""

#: ../book/administration.rst:707
msgid "Let's try to destroy an instance:"
msgstr ""

#: ../book/administration.rst:709
msgid "$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""

#: ../book/administration.rst:720
msgid "Now let's make sure that :program:`systemd` has revived our Tarantool instance:"
msgstr ""

#: ../book/administration.rst:722
msgid "$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""

#: ../book/administration.rst:727
msgid "Finally, let's check the boot logs:"
msgstr ""

#: ../book/administration.rst:729
msgid "$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database Server."
msgstr ""

#: ../book/administration.rst:744
msgid "Customizing the service file"
msgstr ""

#: ../book/administration.rst:746
msgid "Please don't modify the :file:`tarantool@.service` file in-place, because it will be overwritten during package upgrades. It is recommended to copy this file to :file:`/etc/systemd/system` and then modify the required settings. Alternatively, you can create a directory named :file:`unit.d/` within :file:`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that only changes the required settings. Please see ``systemd.unit(5)`` manual page for additional information."
msgstr ""

#: ../book/administration.rst:755
msgid "Debugging"
msgstr ""

#: ../book/administration.rst:757
msgid ":program:`coredumpctl` automatically saves core dumps and stack traces in case of a crash. Here is how it works:"
msgstr ""

#: ../book/administration.rst:760
msgid "$ # !!! please never do this on the production system !!!\n"
"$ tarantoolctl enter example\n"
"/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
"unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host closed connection"
msgstr ""

#: ../book/administration.rst:770
msgid ":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of the Tarantool daemon:"
msgstr ""

#: ../book/administration.rst:772
msgid "$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""

#: ../book/administration.rst:779
msgid ":samp:`coredumpctl info <pid>` shows the stack trace and other useful information:"
msgstr ""

#: ../book/administration.rst:781
msgid "$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c _ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""

#: ../book/administration.rst:816
msgid ":samp:`coredumpctl -o filename.core info <pid>` saves the core dump into a file."
msgstr ""

#: ../book/administration.rst:818
msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
msgstr ""

#: ../book/administration.rst:820
msgid "It is highly recommended to install the ``tarantool-debuginfo`` package to improve :program:`gdb` experience. Example:"
msgstr ""

#: ../book/administration.rst:823
msgid "$ dnf debuginfo-install tarantool"
msgstr ""

#: ../book/administration.rst:830
msgid ":program:`gdb` also provides information about the ``debuginfo`` packages you need to install:"
msgstr ""

#: ../book/administration.rst:832
msgid "$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""

#: ../book/administration.rst:843
msgid "Symbol names are present in stack traces even if you don't have the ``tarantool-debuginfo`` package installed."
msgstr ""

#: ../book/administration.rst:845
msgid "For additional information, please refer to the documentation provided with your Linux distribution."
msgstr ""

#: ../book/administration.rst:849
msgid "Precautions"
msgstr ""

#: ../book/administration.rst:851
msgid "Please don't use ``tarantoolctl {start,stop,restart}`` to control instances started by :program:`systemd`. It is still possible to use :program:`tarantoolctl` to start and stop instances from your local directories (e.g. :file:`${HOME}`) without obtaining ``ROOT`` access."
msgstr ""

#: ../book/administration.rst:855
msgid ":program:`tarantoolctl` is configured to work properly with ;program:`systemd`. Please don't modify system-wide settings of :program:`tarantoolctl`, such as paths, directory permissions and usernames. Otherwise, you have a chance to shoot yourself in the foot."
msgstr ""

#: ../book/administration.rst:859
msgid ":program:`systemd` scripts are maintained by the Tarantool Team (http://tarantool.org). Please file tickets directly to the upstream's bug tracker rather than to your Linux distribution."
msgstr ""

#: ../book/administration.rst:864
msgid "Updating Tarantool in production"
msgstr ""

#: ../book/administration.rst:866
msgid "First, put your application's business logic in a Tarantool-Lua module that exports its functions for CALL."
msgstr ""

#: ../book/administration.rst:868
msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
msgstr ""

#: ../book/administration.rst:870
msgid "local function start()\n"
"-- Initial version\n"
"box.once(\"myapp:.1.0\", function()\n"
"box.schema.space.create(\"somedata\")\n"
"box.space.somedata:create_index(\"primary\")\n"
"...\n"
"end\n"
"\n"
"-- migration code from 1.0 to 1.1\n"
"box.once(\"myapp:.v1.1\", function()\n"
"box.space.somedata.index.primary:alter(...)\n"
"...\n"
"end\n"
"\n"
"-- migration code from 1.1 to 1.2\n"
"box.once(\"myapp:.v1.2\", function()\n"
"box.space.somedata.space:alter(...)\n"
"box.space.somedata:insert(...)\n"
"...\n"
"end\n"
"\n"
"-- start some background fibers if you need\n"
"\n"
"local function stop()\n"
"-- stop all background fibers and cleanup resources\n"
"end\n"
"\n"
"local function api_for_call(xxx)\n"
"-- do some business\n"
"end\n"
"\n"
"return {\n"
"start = start;\n"
"stop = stop;\n"
"api_for_call = api_for_call;\n"
"}"
msgstr ""

#: ../book/administration.rst:909
msgid "This file is maintained by the application's developers. On its side, Tarantool Team provides templates for you to `assemble deb/rpm packages`_ and utilities to quickly `assemble packages for specific platforms`_. If needed, you can split applications into standalone files and/or modules."
msgstr ""

#: ../book/administration.rst:918
msgid "Second, put an initialization script to the :file:`/etc/tarantool/instances.available` directory."
msgstr ""

#: ../book/administration.rst:920
msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
msgstr ""

#: ../book/administration.rst:922
msgid "#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"listen = 3301;\n"
"}\n"
"\n"
"if myapp ~= nil then\n"
"-- hot code reload using tarantoolctl or dofile()\n"
"\n"
"-- unload old application\n"
"myapp.stop()\n"
"-- clear cache for loaded modules and dependencies\n"
"package.loaded['myapp'] = nil\n"
"package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
"end\n"
"\n"
"-- load a new version of app and all dependencies\n"
"myapp = require('myapp').start({some app options controlled by sysadmins})"
msgstr ""

#: ../book/administration.rst:944
msgid "As a more detailed example, you can take the :file:`example.lua` script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../book/administration.rst:947
msgid "This initialization script is actually a configuration file and should be maintained by system administrators, while developers only provide a template."
msgstr ""

#: ../book/administration.rst:951
msgid "Now update your app file in :file:`/usr/share/tarantool`. Replace your application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and manually reload the :file:`myappcfg.lua` initialization script using :program:`tarantoolctl`:"
msgstr ""

#: ../book/administration.rst:955
msgid "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"
msgstr ""

#: ../book/administration.rst:959
msgid "After that, you need to manually flush the cache of ``package.loaded`` modules."
msgstr ""

#: ../book/administration.rst:961
msgid "For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/debian` directory."
msgstr ""

#: ../book/administration.rst:964
msgid "Finally, clients make a CALL to ``myapp.api_for_call`` and other API functions."
msgstr ""

#: ../book/administration.rst:966
msgid "In case of ``tarantool-http``, there is no need to start the binary protocol at all."
msgstr ""

#: ../book/app/a_errcodes.rst:28
msgid "Appendix A. List of error codes"
msgstr ""

#: ../book/app/a_errcodes.rst:30
msgid "In the current version of the binary protocol, error message, which is normally more descriptive than error code, is not present in server response. The actual message may contain a file name, a detailed reason or operating system error code. All such messages, however, are logged in the error log. Below follow only general descriptions of some popular codes. A complete list of errors can be found in file `errcode.h`_ in the source tree."
msgstr ""

#: ../book/app/a_errcodes.rst:41
msgid "List of error codes"
msgstr ""

#: ../book/app/a_errcodes.rst:43
msgid ":errcode:`ER_NONMASTER`, |br| :errcode:`ER_ILLEGAL_PARAMS`, |br| :errcode:`ER_MEMORY_ISSUE`, |br| :errcode:`ER_WAL_IO`, |br| :errcode:`ER_KEY_PART_COUNT`, |br| :errcode:`ER_NO_SUCH_SPACE`, |br| :errcode:`ER_NO_SUCH_INDEX`, |br| :errcode:`ER_PROC_LUA`, |br| :errcode:`ER_FIBER_STACK`, |br| :errcode:`ER_UPDATE_FIELD`, |br| :errcode:`ER_TUPLE_FOUND` |br|"
msgstr ""

#: ../book/app/a_errcodes.rst:57
msgid "Can't modify data on a replication slave."
msgstr ""

#: ../book/app/a_errcodes.rst:61
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../book/app/a_errcodes.rst:65
msgid "Out of memory: :confval:`slab_alloc_arena` limit is reached."
msgstr ""

#: ../book/app/a_errcodes.rst:69
msgid "Failed to write to disk. May mean: failed to record a change in the write-ahead log. Some sort of disk error."
msgstr ""

#: ../book/app/a_errcodes.rst:74
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../book/app/a_errcodes.rst:78
msgid "Attempt to access a space that does not exist."
msgstr ""

#: ../book/app/a_errcodes.rst:82
msgid "The specified index does not exist for the specified space."
msgstr ""

#: ../book/app/a_errcodes.rst:86
msgid "An error inside a Lua procedure."
msgstr ""

#: ../book/app/a_errcodes.rst:90
msgid "Recursion limit reached when creating a new fiber. This is usually an indicator of a bug in a stored procedure, recursively invoking itself ad infinitum."
msgstr ""

#: ../book/app/a_errcodes.rst:96
msgid "An error occurred during update of a field."
msgstr ""

#: ../book/app/a_errcodes.rst:100
msgid "Duplicate key exists in unique index ..."
msgstr ""

#: ../book/app/b_proctitle.rst:30
msgid "Appendix B. Process title"
msgstr ""

#: ../book/app/b_proctitle.rst:32
msgid "Linux and FreeBSD operating systems allow a running process to modify its title, which otherwise contains the program name. Tarantool uses this feature to help meet the needs of system administration, such as figuring out what services are running on a host, their status, and so on."
msgstr ""

#: ../book/app/b_proctitle.rst:37
msgid "A Tarantool server's process title has these components:"
msgstr ""

#: ../book/app/b_proctitle.rst:42
msgid "**program_name** [**initialization_file_name**] **<role_name>** [**custom_proc_title**]"
msgstr ""

#: ../book/app/b_proctitle.rst:44
msgid "**program_name** is typically \"tarantool\"."
msgstr ""

#: ../book/app/b_proctitle.rst:45
msgid "**initialization_file_name** is the name of an :ref:`initialization file <init-label>` if one was specified."
msgstr ""

#: ../book/app/b_proctitle.rst:46
msgid "**role_name** is: - \"running\" (ordinary node \"ready to accept requests\"), - \"loading\" (ordinary node recovering from old snap and wal files), - \"orphan\" (not in a cluster), - \"hot_standby\" (see section :ref:`local hot standby <book-cfg-local_hot_standy>`), or - \"dumper\" + process-id (saving a snapshot)."
msgstr ""

#: ../book/app/b_proctitle.rst:52
msgid "**custom_proc_title** is taken from the :confval:`custom_proc_title` configuration parameter, if one was specified."
msgstr ""

#: ../book/app/b_proctitle.rst:54
#: ../book/app/d_plugins.rst:114
#: ../book/app/d_plugins.rst:461
msgid "For example:"
msgstr ""

#: ../book/app/b_proctitle.rst:56
msgid "$ ps -AF | grep tarantool\n"
"1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool script.lua <running>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:28
msgid "Appendix C. Lua tutorial"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:32
msgid "Insert one million tuples with a Lua stored procedure"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:34
msgid "This is an exercise assignment: “Insert one million tuples. Each tuple should have a constantly-increasing numeric primary-key field and a random alphabetic 10-character string field.”"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:38
msgid "The purpose of the exercise is to show what Lua functions look like inside Tarantool. It will be necessary to employ the Lua math library, the Lua string library, the Tarantool box library, the Tarantool box.tuple library, loops, and concatenations. It should be easy to follow even for a person who has not used either Lua or Tarantool before. The only requirement is a knowledge of how other programming languages work and a memory of the first two chapters of this manual. But for better understanding, follow the comments and the links, which point to the Lua manual or to elsewhere in this Tarantool manual. To further enhance learning, type the statements in with the tarantool client while reading along."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:50
msgid "Configure"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:52
msgid "We are going to use the \"tarantool_sandbox\" that was created in section :ref:`first database`. So there is a single space, and a numeric primary key, and a running tarantool server which also serves as a client."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:58
msgid "Delimiter"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:60
msgid "In earlier versions of Tarantool, multi-line functions had to be enclosed within \"delimiters\". They are no longer necessary, and so they will not be used in this tutorial. However, they are still supported. Users who wish to use delimiters, or users of older versions of Tarantool, should check the syntax description for :ref:`declaring a delimiter <setting delimiter>` before proceeding."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:69
msgid "Create a function that returns a string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:71
msgid "We will start by making a function that returns a fixed string, “Hello world”."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:73
msgid "function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:79
msgid "The word \"``function``\" is a Lua keyword -- we're about to go into Lua. The function name is string_function. The function has one executable statement, ``return \"hello world\"``. The string \"hello world\" is enclosed in double quotes here, although Lua doesn't care -- one could use single quotes instead. The word \"``end``\" means “this is the end of the Lua function declaration.” To confirm that the function works, we can say"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:86
msgid "string_function()"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:90
msgid "Sending ``function-name()`` means “invoke the Lua function.” The effect is that the string which the function returns will end up on the screen."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:93
msgid "For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:99
#: ../book/app/c_lua_tutorial.rst:143
#: ../book/app/c_lua_tutorial.rst:195
#: ../book/app/c_lua_tutorial.rst:251
#: ../book/app/c_lua_tutorial.rst:298
#: ../book/app/c_lua_tutorial.rst:356
#: ../book/app/c_lua_tutorial.rst:447
#: ../book/replication/index.rst:920
msgid "The screen now looks like this:"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:101
msgid "tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:116
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:118
msgid "Now that ``string_function`` exists, we can invoke it from another function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:121
msgid "function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:129
msgid "We begin by declaring a variable \"``string_value``\". The word \"``local``\" means that string_value appears only in ``main_function``. If we didn't use \"``local``\" then ``string_value`` would be visible everywhere - even by other users using other clients connected to this server! Sometimes that's a very desirable feature for inter-client communication, but not this time."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:135
msgid "Then we assign a value to ``string_value``, namely, the result of ``string_function()``. Soon we will invoke ``main_function()`` to check that it got the value."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:139
msgid "For more about Lua variables see Lua manual `chapter 4.2 \"Local Variables and Blocks\"`_ ."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:145
msgid "tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:162
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:164
msgid "Now that it's a bit clearer how to make a variable, we can change ``string_function()`` so that, instead of returning a fixed literal 'Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:168
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:178
msgid "It is not necessary to destroy the old ``string_function()`` contents, they're simply overwritten. The first assignment invokes a random-number function in Lua's math library; the parameters mean “the number must be an integer between 65 and 90.” The second assignment invokes an integer-to-character function in Lua's string library; the parameter is the code point of the character. Luckily the ASCII value of 'A' is 65 and the ASCII value of 'Z' is 90 so the result will always be a letter between A and Z."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:186
msgid "For more about Lua math-library functions see Lua users \"`Math Library Tutorial`_\". For more about Lua string-library functions see Lua users \"`String Library Tutorial`_\" ."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:192
msgid "Once again the ``string_function()`` can be invoked from main_function() which can be invoked with ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:197
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:214
msgid "... Well, actually it won't always look like this because ``math.random()`` produces random numbers. But for the illustration purposes it won't matter what the random string values are."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:220
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:222
msgid "Now that it's clear how to produce one-letter random strings, we can reach our goal of producing a ten-letter string by concatenating ten one-letter strings, in a loop."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:226
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:239
msgid "The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x equals 10, increment x by 1 for each iteration.” The symbol \"..\" means \"concatenate\", that is, add the string on the right of the \"..\" sign to the string on the left of the \"..\" sign. Since we start by saying that random_string is \"\" (a blank string), the end result is that random_string has 10 random letters. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:247
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:253
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:276
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:278
msgid "Now that it's clear how to make a 10-letter random string, it's possible to make a tuple that contains a number and a 10-letter random string, by invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:282
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:291
msgid "Once this is done, t will be the value of a new tuple which has two fields. The first field is numeric: 1. The second field is a random string. Once again the ``string_function()`` can be invoked from ``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:296
msgid "For more about Tarantool tuples see Tarantool manual section :mod:`Package box.tuple <box.tuple>`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:300
msgid "tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:318
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:320
msgid "Now that it's clear how to make a tuple that contains a number and a 10-letter random string, the only trick remaining is putting that tuple into tester. Remember that tester is the first space that was defined in the sandbox, so it's like a database table."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:325
msgid "function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:334
msgid "The new line here is ``box.space.tester:replace(t)``. The name contains 'tester' because the insertion is going to be to tester. The second parameter is the tuple value. To be perfectly correct we could have said ``box.space.tester:insert(t)`` here, rather than ``box.space.tester:replace(t)``, but \"replace\" means “insert even if there is already a tuple whose primary-key value is a duplicate”, and that makes it easier to re-run the exercise even if the sandbox database isn't empty. Once this is done, tester will contain a tuple with two fields. The first field will be 1. The second field will be a random 10-letter string. Once again the ``string_function(``) can be invoked from ``main_function()`` which can be invoked with ``main_function()``. But ``main_function()`` won't tell the whole story, because it does not return t, it only puts t into the database. To confirm that something got inserted, we'll use a SELECT request."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:348
msgid "main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:353
msgid "For more about Tarantool insert and replace calls, see Tarantool manual section :mod:`Package box.space <box.space>`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:358
msgid "tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:379
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:381
msgid "Now that it's clear how to insert one tuple into the database, it's no big deal to figure out how to scale up: instead of inserting with a literal value = 1 for the primary key, insert with a variable value = between 1 and 1 million, in a loop. Since we already saw how to loop, that's a simple thing. The only extra wrinkle that we add here is a timing function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:387
msgid "function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:402
msgid "The Lua ``os.clock()`` function will return the number of seconds since the start. Therefore, by getting start_time = number of seconds just before the inserting, and then getting end_time = number of seconds just after the inserting, we can calculate (end_time - start_time) = elapsed time in seconds. We will display that value by putting it in a request without any assignments, which causes Tarantool to send the value to the client, which prints it. (Lua's answer to the C ``printf()`` function, which is ``print()``, will also work.)"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:410
msgid "For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and Time\"`_. For more on Lua print() see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:416
msgid "Since this is the grand finale, we will redo the final versions of all the necessary requests: the request that created ``string_function()``, the request that created ``main_function()``, and the request that invokes ``main_function()``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:421
msgid "function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:449
msgid "tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:488
msgid "What has been shown is that Lua functions are quite expressive (in fact one can do more with Tarantool's Lua stored procedures than one can do with stored procedures in some SQL DBMSs), and that it's straightforward to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:493
msgid "What has also been shown is that inserting a million tuples took 37 seconds. The host computer was a Linux laptop. By changing :confval:`wal_mode <wal_mode>` to 'none' before running the test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:499
msgid "Sum a JSON field for all tuples"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:501
msgid "This is an exercise assignment: “Assume that inside every tuple there is a string formatted as JSON. Inside that string there is a JSON numeric field. For each tuple, find the numeric field's value and add it to a 'sum' variable. At end, return the 'sum' variable.” The purpose of the exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:507
msgid "json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:524
msgid "**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will be used in the function. Actually it's not necessary to declare all variables at the start, and in a long function it would be better to declare variables just before using them. In fact it's not even necessary to declare variables at all, but an undeclared variable is \"global\". That's not desirable for any of the variables that are declared in line 1, because all of them are for use only within the function."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:531
msgid "**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and there are two ways to do it: with :func:`box.space.space_object:pairs() <space_object.pairs>` or with ``variable = select(...)`` followed by :samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred ``pairs()`` for this example."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:536
msgid "**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop will be repeated as long as there is another index key. A tuple is fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:540
msgid "**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = json.decode(t[2]))``, then the function would abort with an error if it encountered something wrong with the JSON string - a missing colon, for example. By putting the function inside \"``pcall``\" (`protected call`_), we're saying: we want to intercept that sort of error, so if there's a problem just set ``is_valid_json = false`` and we will know what to do about it later."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:547
msgid "**LINE 6: MEANING.** The function is :func:`json.decode` which means decode a JSON string, and the parameter is t[2] which is a reference to a JSON string. There's a bit of hard coding here, we're assuming that the second field in the tuple is where the JSON string was inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:557
msgid "field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:560
msgid "meaning that the tuple's first field, the primary key field, is a number while the tuple's second field, the JSON string, is a string. Thus the entire statement means \"decode ``t[2]`` (the tuple's second field) as a JSON string; if there's an error set ``is_valid_json = false``; if there's no error set ``is_valid_json = true`` and set ``lua_table =`` a Lua table which has the decoded string\"."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:566
msgid "**LINE 8.** At last we are ready to get the JSON field value from the Lua table that came from the JSON string. The value in field_name, which is the parameter for the whole function, must be a name of a JSON field. For example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": 15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the whole function is invoked with ``sum_json_field(\"Quantity\")``, then ``field_value = lua_table[field_name]`` is effectively the same as ``field_value = lua_table[\"Quantity\"]`` or even ``field_value = lua_table.Quantity``. Those are just three different ways of saying: for the Quantity field in the Lua table, get the value and put it in variable :code:`field_value`."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:576
msgid "**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but the JSON field is not a number, or is missing. In that case, the function would be aborted when there was an attempt to add it to the sum. By first checking ``type(field_value) == \"number\"``, we avoid that abortion. Anyone who knows that the database is in perfect shape can skip this kind of thing."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:582
msgid "And the function is complete. Time to test it. Starting with an empty database, defined the same way as the sandbox database that was introduced in :ref:`first database`,"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:586
msgid "-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'NUM'}})"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:593
msgid "then add some tuples where the first field is a number and the second field is a string."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:596
msgid "box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": \"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": 3}'}"
msgstr ""

#: ../book/app/c_lua_tutorial.rst:603
msgid "Since this is a test, there are deliberate errors. The \"golf club\" and the \"waffle iron\" do not have numeric Quantity fields, so must be ignored. Therefore the real sum of the Quantity field in the JSON strings should be: 15 + 7 = 22."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:608
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:610
msgid "tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../book/app/c_lua_tutorial.rst:617
msgid "It works. We'll just leave, as exercises for future improvement, the possibility that the \"hard coding\" assumptions could be removed, that there might have to be an overflow check if some field values are huge, and that the function should contain a \"yield\" instruction if the count of tuples is huge."
msgstr ""

#: ../book/app/d_plugins.rst:30
msgid "Appendix D. Modules"
msgstr ""

#: ../book/app/d_plugins.rst:32
msgid "A module is an optional library which enhances Tarantool functionality."
msgstr ""

#: ../book/app/d_plugins.rst:34
msgid "For examples of creating one's own module with Lua or C, see `gist.github.com/rtsisyk/aa95cf9ed9bbb538ff80`_."
msgstr ""

#: ../book/app/d_plugins.rst:37
msgid "The discussion here in the user guide is about incorporating and using two modules that have already been created: the \"SQL DBMS rocks\" for MySQL and PostgreSQL."
msgstr ""

#: ../book/app/d_plugins.rst:43
msgid "SQL DBMS Modules"
msgstr ""

#: ../book/app/d_plugins.rst:45
msgid "To call another DBMS from Tarantool, the essential requirements are: another DBMS, and Tarantool. The module which connects Tarantool to another DBMS may be called a \"connector\". Within the module there is a shared library which may be called a \"driver\"."
msgstr ""

#: ../book/app/d_plugins.rst:50
msgid "Tarantool supplies DBMS connector modules with the package manager for Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../book/app/d_plugins.rst:53
msgid "The Tarantool rocks allow for connecting to an SQL server and executing SQL statements the same way that a MySQL or PostgreSQL client does. The SQL statements are visible as Lua methods. Thus Tarantool can serve as a \"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be useful even if that was all Tarantool could do. But of course Tarantool is also a DBMS, so the plugin also is useful for any operations, such as database copying and accelerating, which work best when the application can work on both SQL and Tarantool inside the same Lua routine. The methods for connect/select/insert/etc. are similar to the ones in the :ref:`net.box <package_net_box>` package."
msgstr ""

#: ../book/app/d_plugins.rst:64
msgid "From a user's point of view the MySQL and PostgreSQL rocks are very similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL Example\" -- contain some redundancy."
msgstr ""

#: ../book/app/d_plugins.rst:71
msgid "MySQL Example"
msgstr ""

#: ../book/app/d_plugins.rst:73
msgid "This example assumes that MySQL 5.5 or MySQL 5.6 has been installed. Recent MariaDB versions should also work. The package that matters most is the MySQL client developer package, typically named something like libmysqlclient-dev. The file that matters most from this package is libmysqlclient.so or a similar name. One can use :code:`find` or :code:`whereis` to see what directories these files are installed in."
msgstr ""

#: ../book/app/d_plugins.rst:80
msgid "It will be necessary to install Tarantool's MySQL driver shared library, load it, and use it to connect to a MySQL server. After that, one can pass any MySQL statement to the server and receive results, including multiple result sets."
msgstr ""

#: ../book/app/d_plugins.rst:86
#: ../book/app/d_plugins.rst:432
msgid "Installation"
msgstr ""

#: ../book/app/d_plugins.rst:88
msgid "Check the instructions for :ref:`Downloading and installing a binary package <downloading-and-installing-a-binary-package>` that apply for the environment where tarantool was installed. In addition to installing :code:`tarantool`, install :code:`tarantool-dev`. For example, on Ubuntu, add the line"
msgstr ""

#: ../book/app/d_plugins.rst:93
#: ../book/app/d_plugins.rst:440
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../book/app/d_plugins.rst:97
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../book/app/d_plugins.rst:101
#: ../book/app/d_plugins.rst:448
msgid "With LuaRocks"
msgstr ""

#: ../book/app/d_plugins.rst:103
#: ../book/app/d_plugins.rst:450
msgid "Begin by installing luarocks and making sure that tarantool is among the upstream servers, as in the instructions on `rocks.tarantool.org`_, the Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../book/app/d_plugins.rst:110
msgid "luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../book/app/d_plugins.rst:116
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../book/app/d_plugins.rst:122
#: ../book/app/d_plugins.rst:469
msgid "With GitHub"
msgstr ""

#: ../book/app/d_plugins.rst:124
msgid "Go the site `github.com/tarantool/mysql`_. Follow the instructions there, saying:"
msgstr ""

#: ../book/app/d_plugins.rst:126
msgid "git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../book/app/d_plugins.rst:133
#: ../book/app/d_plugins.rst:480
msgid "At this point it is a good idea to check that the installation produced a file named :code:`driver.so`, and to check that this file is on a directory that is searched by the :code:`require` request."
msgstr ""

#: ../book/app/d_plugins.rst:139
#: ../book/app/d_plugins.rst:486
msgid "Connecting"
msgstr ""

#: ../book/app/d_plugins.rst:141
msgid "Begin by making a :code:`require` request for the mysql driver. We will assume that the name is :code:`mysql` in further examples."
msgstr ""

#: ../book/app/d_plugins.rst:144
msgid "mysql = require('mysql')"
msgstr ""

#: ../book/app/d_plugins.rst:148
#: ../book/app/d_plugins.rst:495
msgid "Now, say:"
msgstr ""

#: ../book/app/d_plugins.rst:153
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../book/app/d_plugins.rst:155
#: ../book/app/d_plugins.rst:502
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../book/app/d_plugins.rst:157
#: ../book/app/d_plugins.rst:504
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../book/app/d_plugins.rst:158
#: ../book/app/d_plugins.rst:505
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../book/app/d_plugins.rst:159
#: ../book/app/d_plugins.rst:506
msgid ":samp:`user = {user-name}` - string, default value is operating-system user name"
msgstr ""

#: ../book/app/d_plugins.rst:160
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../book/app/d_plugins.rst:161
#: ../book/app/d_plugins.rst:508
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../book/app/d_plugins.rst:163
msgid "The names are similar to the names that MySQL's mysql client uses, for details see the MySQL manual at `dev.mysql.com/doc/refman/5.6/en/connecting.html`_. To connect with a Unix socket rather than with TCP, specify ``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../book/app/d_plugins.rst:168
#: ../book/app/d_plugins.rst:512
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../book/app/d_plugins.rst:170
msgid "conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../book/app/d_plugins.rst:185
#: ../book/app/d_plugins.rst:524
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../book/app/d_plugins.rst:187
msgid "tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:203
#: ../book/app/d_plugins.rst:543
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../book/app/d_plugins.rst:207
#: ../book/app/d_plugins.rst:547
msgid "How to ping"
msgstr ""

#: ../book/app/d_plugins.rst:209
#: ../book/app/d_plugins.rst:549
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../book/app/d_plugins.rst:214
#: ../book/app/d_plugins.rst:554
msgid "*connection-name*:ping()"
msgstr ""

#: ../book/app/d_plugins.rst:216
#: ../book/app/d_plugins.rst:240
#: ../book/app/d_plugins.rst:264
#: ../book/app/d_plugins.rst:557
#: ../book/app/d_plugins.rst:581
#: ../book/app/d_plugins.rst:604
#: ../book/box/admin.rst:64
#: ../book/box/authentication.rst:178
#: ../book/box/authentication.rst:302
#: ../book/box/box_index.rst:68
#: ../book/box/box_index.rst:315
#: ../book/box/box_index.rst:387
#: ../book/box/box_index.rst:525
#: ../book/box/box_index.rst:556
#: ../book/box/box_index.rst:585
#: ../book/box/box_index.rst:615
#: ../book/box/box_index.rst:684
#: ../book/box/box_index.rst:706
#: ../book/box/box_index.rst:727
#: ../book/box/box_introspection.rst:41
#: ../book/box/box_introspection.rst:82
#: ../book/box/box_introspection.rst:139
#: ../book/box/box_schema.rst:144
#: ../book/box/box_schema.rst:158
#: ../book/box/box_schema.rst:207
#: ../book/box/box_schema.rst:238
#: ../book/box/box_schema.rst:268
#: ../book/box/box_schema.rst:279
#: ../book/box/box_schema.rst:324
#: ../book/box/box_schema.rst:358
#: ../book/box/box_schema.rst:369
#: ../book/box/box_space.rst:148
#: ../book/box/box_space.rst:176
#: ../book/box/box_space.rst:252
#: ../book/box/box_space.rst:271
#: ../book/box/box_space.rst:288
#: ../book/box/box_space.rst:324
#: ../book/box/box_space.rst:392
#: ../book/box/box_space.rst:525
#: ../book/box/box_space.rst:546
#: ../book/box/box_space.rst:572
#: ../book/box/box_space.rst:608
#: ../book/box/box_space.rst:627
#: ../book/box/box_space.rst:646
#: ../book/box/box_space.rst:669
#: ../book/box/box_space.rst:698
#: ../book/box/box_space.rst:736
#: ../book/box/box_space.rst:782
#: ../book/box/box_space.rst:804
#: ../book/box/box_space.rst:838
#: ../book/box/box_space.rst:876
#: ../book/box/box_space.rst:920
#: ../book/box/box_tuple.rst:57
#: ../book/box/triggers.rst:82
#: ../book/box/triggers.rst:109
#: ../book/box/triggers.rst:179
#: ../book/box/triggers.rst:209
#: ../book/box/triggers.rst:227
msgid "**Example:**"
msgstr ""

#: ../book/app/d_plugins.rst:218
#: ../book/app/d_plugins.rst:559
msgid "tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:227
#: ../book/app/d_plugins.rst:568
msgid "Executing a statement"
msgstr ""

#: ../book/app/d_plugins.rst:229
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../book/app/d_plugins.rst:234
#: ../book/app/d_plugins.rst:575
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../book/app/d_plugins.rst:236
#: ../book/app/d_plugins.rst:577
msgid "where :code:`sql-statement` is a string, and the optional :code:`parameters` are extra values that can be plugged in to replace any question marks (\"?\"s) in the SQL statement."
msgstr ""

#: ../book/app/d_plugins.rst:242
msgid "tarantool> conn:execute('select table_name from information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:255
#: ../book/app/d_plugins.rst:595
msgid "Closing connection"
msgstr ""

#: ../book/app/d_plugins.rst:257
msgid "To end a session that began with :code:`mysql.connect`, the request is:"
msgstr ""

#: ../book/app/d_plugins.rst:262
#: ../book/app/d_plugins.rst:602
msgid "*connection-name*:close()"
msgstr ""

#: ../book/app/d_plugins.rst:266
msgid "tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:272
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../book/app/d_plugins.rst:277
#: ../book/app/d_plugins.rst:615
#: ../book/box/atomic.rst:116
#: ../book/box/box_schema.rst:89
#: ../book/box/box_session.rst:80
#: ../book/box/box_tuple.rst:304
#: ../book/box/index.rst:167
#: ../book/box/triggers.rst:120
#: ../book/box/triggers.rst:236
#: ../book/configuration/index.rst:119
msgid "Example"
msgstr ""

#: ../book/app/d_plugins.rst:279
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of MySQL had been installed on ~/mysql-5.5. The mysqld server is already running on the local host 127.0.0.1."
msgstr ""

#: ../book/app/d_plugins.rst:283
msgid "$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/master/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/master/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.6.6-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../book/app/d_plugins.rst:364
msgid "Configure tarantool and load mysql module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../book/app/d_plugins.rst:367
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:375
msgid "Create a Lua function that will connect to the MySQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../book/app/d_plugins.rst:380
msgid "tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:404
msgid "Observe the result. It contains \"MySQL row\". So this is the row that was inserted into the MySQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../book/app/d_plugins.rst:409
msgid "PostgreSQL Example"
msgstr ""

#: ../book/app/d_plugins.rst:411
msgid "This example assumes that PostgreSQL 8 or PostgreSQL 9 has been installed. More recent versions should also work. The package that matters most is the PostgreSQL developer package, typically named something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../book/app/d_plugins.rst:416
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../book/app/d_plugins.rst:420
msgid "However, because not all platforms are alike, for this example the assumption is that the user must check that the appropriate PostgreSQL files are present and must explicitly state where they are when building the Tarantool/PostgreSQL driver. One can use :code:`find` or :code:`whereis` to see what directories PostgreSQL files are installed in."
msgstr ""

#: ../book/app/d_plugins.rst:426
msgid "It will be necessary to install Tarantool's PostgreSQL driver shared library, load it, and use it to connect to a PostgreSQL server. After that, one can pass any PostgreSQL statement to the server and receive results."
msgstr ""

#: ../book/app/d_plugins.rst:434
msgid "Check the instructions for :ref:`Downloading and installing a binary package <downloading-and-installing-a-binary-package>` that apply for the environment where tarantool was installed. In addition to installing :code:`tarantool`, install :code:`tarantool-dev`. For example, on Ubuntu, add the line:"
msgstr ""

#: ../book/app/d_plugins.rst:444
msgid "Now, for the PostgreSQL driver shared library, there are two ways to install:"
msgstr ""

#: ../book/app/d_plugins.rst:457
msgid "luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../book/app/d_plugins.rst:463
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../book/app/d_plugins.rst:471
msgid "Go the site `github.com/tarantool/pg`_. Follow the instructions there, saying:"
msgstr ""

#: ../book/app/d_plugins.rst:473
msgid "git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../book/app/d_plugins.rst:488
msgid "Begin by making a :code:`require` request for the pg driver. We will assume that the name is :code:`pg` in further examples."
msgstr ""

#: ../book/app/d_plugins.rst:491
msgid "pg = require('pg')"
msgstr ""

#: ../book/app/d_plugins.rst:500
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../book/app/d_plugins.rst:507
msgid ":samp:`pass = {password}` or :samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../book/app/d_plugins.rst:510
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../book/app/d_plugins.rst:514
msgid "conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../book/app/d_plugins.rst:526
msgid "tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:570
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../book/app/d_plugins.rst:583
msgid "tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:597
msgid "To end a session that began with :code:`pg.connect`, the request is:"
msgstr ""

#: ../book/app/d_plugins.rst:606
msgid "tarantool> conn:close() --- ..."
msgstr ""

#: ../book/app/d_plugins.rst:610
msgid "For further information, including examples of rarely-used requests, see the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../book/app/d_plugins.rst:617
msgid "The example was run on an Ubuntu 12.04 (\"precise\") machine where tarantool had been installed in a /usr subdirectory, and a copy of PostgreSQL had been installed on /usr. The PostgreSQL server is already running on the local host 127.0.0.1."
msgstr ""

#: ../book/app/d_plugins.rst:621
msgid "$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/master/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/master/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server. Do not use a Lua initialization file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.6.8-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../book/app/d_plugins.rst:696
msgid "Configure tarantool and load pg module. Make sure that tarantool doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../book/app/d_plugins.rst:699
msgid "tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:707
msgid "Create a Lua function that will connect to the PostgreSQL server, (using some factory default values for the port and user and password), retrieve one row, and display the row. For explanations of the statement types used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../book/app/d_plugins.rst:713
msgid "tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../book/app/d_plugins.rst:738
msgid "Observe the result. It contains \"PostgreSQL row\". So this is the row that was inserted into the PostgreSQL database. And now it's been selected with the Tarantool client."
msgstr ""

#: ../book/app/e_sophia/index.rst:30
msgid "Appendix E. Sophia"
msgstr ""

#: ../book/app/e_sophia/index.rst:34
msgid "Introduction"
msgstr ""

#: ../book/app/e_sophia/index.rst:36
msgid "Sophia's features are:"
msgstr ""

#: ../book/app/e_sophia/index.rst:38
msgid "Full ACID compliance"
msgstr ""

#: ../book/app/e_sophia/index.rst:39
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../book/app/e_sophia/index.rst:40
msgid "Pure Append-Only"
msgstr ""

#: ../book/app/e_sophia/index.rst:41
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../book/app/e_sophia/index.rst:42
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../book/app/e_sophia/index.rst:43
msgid "Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), multi-databases)"
msgstr ""

#: ../book/app/e_sophia/index.rst:44
msgid "Asynchronous or synchronous transaction execution (Callback triggered versus blocking)"
msgstr ""

#: ../book/app/e_sophia/index.rst:45
msgid "Separate storage formats: key-value (Default), or document (Keys are part of value)"
msgstr ""

#: ../book/app/e_sophia/index.rst:46
msgid "Update without read"
msgstr ""

#: ../book/app/e_sophia/index.rst:47
msgid "Consistent Cursors"
msgstr ""

#: ../book/app/e_sophia/index.rst:48
msgid "Prefix search"
msgstr ""

#: ../book/app/e_sophia/index.rst:49
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../book/app/e_sophia/index.rst:50
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../book/app/e_sophia/index.rst:51
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../book/app/e_sophia/index.rst:52
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../book/app/e_sophia/index.rst:53
msgid "Metadata Compression (By default)"
msgstr ""

#: ../book/app/e_sophia/index.rst:54
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../book/app/e_sophia/index.rst:55
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../book/app/e_sophia/index.rst:56
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../book/app/e_sophia/index.rst:57
msgid "Easy to write bindings (Very FFI-friendly, API designed to be stable in future)"
msgstr ""

#: ../book/app/e_sophia/index.rst:58
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../book/app/e_sophia/index.rst:59
msgid "Event loop friendly"
msgstr ""

#: ../book/app/e_sophia/index.rst:60
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../book/app/e_sophia/index.rst:61
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../book/app/e_sophia/index.rst:62
msgid "BSD Licensed"
msgstr ""

#: ../book/app/e_sophia/index.rst:64
msgid "It is appropriate for databases that cannot fit in memory, where access via secondary keys is not required."
msgstr ""

#: ../book/app/e_sophia/index.rst:66
msgid "In sophia terminology:"
msgstr ""

#: ../book/app/e_sophia/index.rst:68
msgid "There is one **Environment**."
msgstr ""

#: ../book/app/e_sophia/index.rst:69
msgid "An Environment has N **Databases** - a sophia database is like a Tarantool `space`."
msgstr ""

#: ../book/app/e_sophia/index.rst:70
msgid "A Database has N **Nodes**."
msgstr ""

#: ../book/app/e_sophia/index.rst:71
msgid "A Node has one **Node File**."
msgstr ""

#: ../book/app/e_sophia/index.rst:72
msgid "A Node File has N **Branches**."
msgstr ""

#: ../book/app/e_sophia/index.rst:73
msgid "A Branch has N **Regions** - a sophia Region is like a B-tree `page`."
msgstr ""

#: ../book/app/e_sophia/index.rst:74
msgid "A Region has **keys** and **values** - a sophia key-value is like a Tarantool `tuple`."
msgstr ""

#: ../book/app/e_sophia/index.rst:76
msgid "A key and its associated value are together, so when one accesses a key one gets the whole tuple. In other words, in sophia the data is stored in the index. There are up to two in-memory copies of an index, as well as the copy in the Node File."
msgstr ""

#: ../book/app/e_sophia/index.rst:80
msgid "For operations that insert or update tuples - called Set operations in sophia - sophia makes changes to in-memory copies of the index, and writes to Tarantool's Write-ahead Log. A scheduler assigns tasks to multiple background threads for transferring index data from memory to disk, and for reorganizing Branches. To support transactions, Set operations can be delayed until an explicit commit. If multiple users access the same tuples simultaneously, the concurrency control method is `MVCC`_ and the isolation level is `Snapshot`_."
msgstr ""

#: ../book/app/e_sophia/index.rst:91
msgid "Formally, in terms of disk accesses, sophia has the following algorithmic complexity:"
msgstr ""

#: ../book/app/e_sophia/index.rst:93
msgid "**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead Log + in-memory node index searches + in-memory index inserts"
msgstr ""

#: ../book/app/e_sophia/index.rst:95
msgid "**Delete** - the worst case is O(*1*) key writes and in-memory index inserts (the same as **Set**)"
msgstr ""

#: ../book/app/e_sophia/index.rst:97
msgid "**Get** - the worst case is `amortized`_ O(*max\\_branch\\_count\\_per\\_node*) random Region reads from a single node file, which itself does in-memory index search + in-memory Region search"
msgstr ""

#: ../book/app/e_sophia/index.rst:100
msgid "**Range** - queries, the worst case of full Database scan is amortized O(*total\\_Region\\_count*) + in-memory key-index searches for each Node"
msgstr ""

#: ../book/app/e_sophia/index.rst:107
msgid "Under the hood"
msgstr ""

#: ../book/app/e_sophia/index.rst:109
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../book/app/e_sophia/index.rst:111
msgid "filling an empty database with one million tuples (we'll call them \"keys\" to emphasize the indexed nature)"
msgstr ""

#: ../book/app/e_sophia/index.rst:113
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../book/app/e_sophia/index.rst:117
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../book/app/e_sophia/index.rst:119
msgid "During the first 200,000 Set operations, inserted keys first go to the in-memory index. To maintain persistence, information about each Set operation is written to Tarantool's Write-ahead Log."
msgstr ""

#: ../book/app/e_sophia/index.rst:127
msgid "At this point we have keys in an in-memory index and records in the Write-ahead Log."
msgstr ""

#: ../book/app/e_sophia/index.rst:132
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../book/app/e_sophia/index.rst:134
msgid "As the in-memory index becomes too large for available memory, the index must be copied from memory to disk. The on-disk copy of the in-memory index is called a Branch. To save the Branch, a new file is created, the Node File. We will call it **db file** for this example."
msgstr ""

#: ../book/app/e_sophia/index.rst:139
msgid "The scheduler wakes a worker thread in the background, a Branch Creation Thread. The thread creates a second in-memory index. If there are Set operations taking place while the thread is working, their contention effect will be small because they will operate on the second in-memory index."
msgstr ""

#: ../book/app/e_sophia/index.rst:148
msgid "When the Branch Creation Thread finishes the task, the first in-memory index is freed."
msgstr ""

#: ../book/app/e_sophia/index.rst:157
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../book/app/e_sophia/index.rst:159
msgid "Several times, the in-memory index becomes too large and a Branch Creation Thread transfers the keys to a Branch. The Branches have been appended to the end of db file. The number of created Branches becomes large."
msgstr ""

#: ../book/app/e_sophia/index.rst:168
msgid "There is a user-settable maximum number of Branches per Node. When the number of Branches reaches this maximum, the sophia scheduler wakes a **Compaction Thread** for the db file. The Compaction Thread merges the keys in all the Branches, and creates one or more new db files."
msgstr ""

#: ../book/app/e_sophia/index.rst:177
msgid "Now there are multiple pairs of in-memory indexes, and each pair has an associated db file. The combination of the in-memory indexes and the db file is called a **Node**, and the db file is called a **Node File**."
msgstr ""

#: ../book/app/e_sophia/index.rst:185
msgid "Thus the contents of a Node are: a range of sorted key values, stored in Branches of a Node File and (when necessary) in memory. Since the ranges do not overlap, each Node can be handled independently. Therefore, while one of the background threads is working on Node 1, another background thread can be working on Node 2, without contention. That means that all the background operations (Branch Creation, Compaction, Garbage Collection, and Backup) can take place in parallel on multiple threads."
msgstr ""

#: ../book/app/e_sophia/index.rst:193
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../book/app/e_sophia/index.rst:195
msgid "Before the Compaction there was one Node, which was created automatically when the Database was initialized. The Node had:"
msgstr ""

#: ../book/app/e_sophia/index.rst:198
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../book/app/e_sophia/index.rst:199
msgid "a Node File with several Branches,"
msgstr ""

#: ../book/app/e_sophia/index.rst:200
msgid "a Write-Ahead Log file recording the Set operations, in the order they happened."
msgstr ""

#: ../book/app/e_sophia/index.rst:202
msgid "The number of branches became too big, so the sophia scheduler starts the Compaction Thread and creates two new Nodes."
msgstr ""

#: ../book/app/e_sophia/index.rst:209
msgid "So, each of the two new Node Files contains half of the keys that were in the original Node. The Node's in-memory indexes are split in the same way."
msgstr ""

#: ../book/app/e_sophia/index.rst:212
msgid "After the splitting, sophia must take into account that: while the Compaction was going on in the background, there might have been more Set operations taking place in parallel. These Set operations would have changed one of the in-memory indexes, and these changes too will be merged."
msgstr ""

#: ../book/app/e_sophia/index.rst:217
msgid "When the Compaction Thread finishes, the original Node is deleted, and information about the new Nodes is inserted into an in-memory **Node Index**."
msgstr ""

#: ../book/app/e_sophia/index.rst:224
msgid "This Node Index is used for all Set operations and all searches. Since the Node Index has the minimum and maximum key values that are in each Node, it is straightforward to scan it to find what Node would contain a particular key value."
msgstr ""

#: ../book/app/e_sophia/index.rst:234
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../book/app/e_sophia/index.rst:236
msgid "The final 300,000 Set operations take place; the background threads continue to create new Branches and do more Compactions. After the millionth insertion, the Database has four Nodes."
msgstr ""

#: ../book/app/e_sophia/index.rst:244
msgid "The inserting is done. Now, because the words \"memory\" and \"disk\" have appeared in this explanation several times, here are a few words about how sophia is designed to use these resources most efficiently:"
msgstr ""

#: ../book/app/e_sophia/index.rst:248
msgid "If there is more memory available, then Branch Creation and Compaction will be less frequent, and there will be fewer disk accesses."
msgstr ""

#: ../book/app/e_sophia/index.rst:250
msgid "The best sophia performance will occur if there is no setting of a memory limit, but this must be balanced against other considerations, such as requirements for the memtx storage engine. If there is a setting of a memory limit, the sophia scheduler will give priority to the Nodes that have the largest in-memory indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../book/app/e_sophia/index.rst:255
msgid "To make the most of hard drives and Flash, sophia will delay operations that require disk access (except the writing of the Write-ahead Log which is specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../book/app/e_sophia/index.rst:258
msgid "Overwriting does not occur; sophia is an \"append-only\" engine."
msgstr ""

#: ../book/app/e_sophia/index.rst:262
msgid "Reading million keys"
msgstr ""

#: ../book/app/e_sophia/index.rst:264
msgid "We will now start to read the million rows in the order that they were inserted, which was random."
msgstr ""

#: ../book/app/e_sophia/index.rst:271
msgid "During the Get (search), sophia first finds the correct Node by looking in the Node Index. Then it searches the Node's first in-memory index, and/or the Node's second in-memory index, and/or each Branch of the Node, starting from the end of the Node File."
msgstr ""

#: ../book/app/e_sophia/index.rst:276
msgid "Remember that a Branch is divided into Regions, which are like what would be called \"pages\" or \"blocks\" in a B-tree. For each Branch, there is a list of the Regions and their minimum/maximum key values - the Region Index - as well as some metadata."
msgstr ""

#: ../book/app/e_sophia/index.rst:285
msgid "Region Indexes are loaded into memory when the Database is opened. Since the Database's Node Index and the Region Indexes are normally in-memory, searching and retrieving a tuple might require only zero or one disk accesses. However, when memory is limited and there are many Branches, search time may rise. For each additional Branch there is a possible additional disk access during a search. Also, it is impossible to maintain memory limits without doing a Branch Creation process, because new Set operations might occur more quickly than the Compaction process can run."
msgstr ""

#: ../book/app/e_sophia/index.rst:298
msgid "Sophia is read optimized. It is very likely that the most recently created Branches (hot data) will be in the file system cache. The scheduler will give priority to the Nodes which have the largest in-memory indexes and the most Branches."
msgstr ""

#: ../book/app/e_sophia/index.rst:303
msgid "The scheduler may also try to arrange that a Node will have only one Branch, which will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../book/box/admin.rst:28
msgid "Administrative requests"
msgstr ""

#: ../book/box/admin.rst:30
msgid "To learn which functions are considered to be administrative, type ``help()``. A reference description also follows below:"
msgstr ""

#: ../book/box/admin.rst:35
msgid "Take a snapshot of all data and store it in :confval:`snap_dir`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool first enters the delayed garbage collection mode for all data. In this mode, tuples which were allocated before the snapshot has started are not freed until the snapshot has finished. To preserve consistency of the primary key, used to iterate over tuples, a copy-on-write technique is employed. If the master process changes part of a primary key, the corresponding process page is split, and the snapshot process obtains an old copy of the page. In effect, the snapshot process uses multi-version concurrency control in order to avoid copying changes which are superseded while it is running."
msgstr ""

#: ../book/box/admin.rst:46
msgid "Since a snapshot is written sequentially, one can expect a very high write performance (averaging to 80MB/second on modern disks), which means an average database instance gets saved in a matter of minutes. Note: as long as there are any changes to the parent index memory through concurrent updates, there are going to be page splits, and therefore one needs to have some extra free memory to run this command. 10% of :confval:`slab_alloc_arena` is, on average, sufficient. This statement waits until a snapshot is taken and returns operation result."
msgstr ""

#: ../book/box/admin.rst:55
msgid "Change Notice: prior to Tarantool version 1.6.6, the snapshot process caused a fork, which could cause occasional latency spikes. Starting with Tarantool version 1.6.6, the snapshot process creates a consistent read view and writes this view to the snapshot file from a separate thread."
msgstr ""

#: ../book/box/admin.rst:60
msgid "Although box.snapshot() does not cause a fork, there is a separate fiber which may produce snapshots at regular intervals -- see the discussion of the :ref:`snapshot daemon <book-cfg-snapshot_daemon>`."
msgstr ""

#: ../book/box/admin.rst:66
msgid "tarantool> box.info.version\n"
"---\n"
"- 1.6.8-66-g9093daa\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../book/box/admin.rst:81
msgid "Taking a snapshot does not cause the server to start a new write-ahead log. Once a snapshot is taken, old WALs can be deleted as long as all replicas are up to date. But the WAL which was current at the time ``box.snapshot()`` started must be kept for recovery, since it still contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../book/box/admin.rst:87
msgid "An alternative way to save a snapshot is to send the server SIGUSR1 UNIX signal. While this approach could be handy, it is not recommended for use in automation: a signal provides no way to find out whether the snapshot was taken successfully or not."
msgstr ""

#: ../book/box/admin.rst:94
msgid "Fork and dump a core. Since Tarantool stores all tuples in memory, it can take some time. Mainly useful for debugging."
msgstr ""

#: ../book/box/atomic.rst:30
msgid "Atomic execution"
msgstr ""

#: ../book/box/atomic.rst:32
msgid "In several places in this manual it's been noted that Lua processes occur in fibers on a single thread. That is why there can be a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../book/box/atomic.rst:41
msgid "Cooperative multitasking environment"
msgstr ""

#: ../book/box/atomic.rst:43
msgid "Tarantool uses cooperative multitasking: unless a running fiber deliberately yields control, it is not preempted by some other fiber. But a running fiber will deliberately yield when it encounters a \"yield point\": an explicit `yield()` request, or an implicit yield due to an operating-system call. Any system call which can block will be performed asynchronously, and any running fiber which must wait for a system call will be preempted so that another ready-to-run fiber takes its place and becomes the new running fiber. This model makes all programmatic locks unnecessary: cooperative multitasking ensures that there will be no concurrency around a resource, no race conditions, and no memory consistency issues."
msgstr ""

#: ../book/box/atomic.rst:54
msgid "When requests are small, for example simple UPDATE or INSERT or DELETE or SELECT, fiber scheduling is fair: it takes only a little time to process the request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../book/box/atomic.rst:58
msgid "However, a function might perform complex computations or might be written in such a way that yields do not occur for a long time. This can lead to unfair scheduling, when a single client throttles the rest of the system, or to apparent stalls in request processing. Avoiding this situation is the responsibility of the function's author. For the default memtx storage engine most of the box calls, including the data-change requests :func:`box.space...insert <space_object.insert>` or :func:`box.space...update <space_object.update>` or :func:`box.space...delete <space_object.delete>`, are yield points; however, :func:`box.space...select <space_object.select>` is not."
msgstr ""

#: ../book/box/atomic.rst:69
msgid "Note re storage engine: sophia has different rules: insert or update or delete will very rarely cause a yield, but select can cause a yield."
msgstr ""

#: ../book/box/atomic.rst:72
msgid "In the absence of transactions, any function that contains yield points may see changes in the database state caused by fibers that preempt. Then the only safe atomic functions for memtx databases would be functions which contain only one database request, or functions which contain a select request followed by a data-change request."
msgstr ""

#: ../book/box/atomic.rst:78
msgid "At this point an objection could arise: \"It's good that a single data-change request will commit and yield, but surely there are times when multiple data-change requests must happen without yielding.\" The standard example is the money-transfer, where $1 is withdrawn from account #1 and deposited into account #2. If something interrupted after the withdrawal, then the institution would be out of balance. For such cases, the ``begin ... commit|rollback`` block was designed."
msgstr ""

#: ../book/box/atomic.rst:88
msgid "Begin the transaction. Disable implicit yields until the transaction ends. Signal that writes to the write-ahead log will be deferred until the transaction ends. In effect the fiber which executes ``box.begin()`` is starting an \"active multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../book/box/atomic.rst:95
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../book/box/atomic.rst:100
msgid "End the transaction, but cancel all its data-change operations. An explicit call to functions outside ``box.space`` that always yield, such as ``fiber.yield`` or ``fiber.sleep``, will have the same effect."
msgstr ""

#: ../book/box/atomic.rst:104
msgid "The **requests in a transaction must be sent to the server as a single block**. It is not enough to enclose them between ``begin`` and ``commit`` or ``rollback``. To ensure they are sent as a single block: put them in a function, or put them all on one line, or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../book/box/atomic.rst:109
msgid "**All database operations in a transaction should use the same storage engine**. It is not safe to access tuple sets that are defined with ``{engine='sophia'}`` and also access tuple sets that are defined with ``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../book/box/atomic.rst:118
msgid "Assuming that in tuple set 'tester' there are tuples in which the third field represents a positive dollar amount ... Start a transaction, withdraw from tuple#1, deposit in tuple#2, and end the transaction, making its effects permanent."
msgstr ""

#: ../book/box/atomic.rst:122
msgid "tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:30
msgid "Access control"
msgstr ""

#: ../book/box/authentication.rst:32
msgid "Understanding the details of security is primarily an issue for administrators, but ordinary users should at least skim this section so that they will have an idea of how Tarantool makes it possible for administrators to prevent unauthorized access to the database and to certain functions."
msgstr ""

#: ../book/box/authentication.rst:37
msgid "Briefly: there is a method to guarantee with password checks that users really are who they say they are (\"authentication\"). There is a _user space where user names and password-hashes are stored. There are functions for saying that certain users are allowed to do certain things (\"privileges\"). There is a _priv space where privileges are stored. Whenever a user tries to do an operation, there is a check whether the user has the privilege to do the operation (\"access control\")."
msgstr ""

#: ../book/box/authentication.rst:47
msgid "Passwords"
msgstr ""

#: ../book/box/authentication.rst:49
msgid "Each user may have a password. The password is any alphanumeric string. Administrators should advise users to choose long unobvious passwords, but it is ultimately up to the users to choose or change their own passwords."
msgstr ""

#: ../book/box/authentication.rst:53
msgid "Tarantool passwords are stored in the _user space with a `Cryptographic hash function`_ so that, if the password is 'x', the stored hashed-password is a long string like '``lL3OvhkIPOKh+Vn9Avlkx69M/Ck=``'. When a client connects to a Tarantool server, the server sends a random `Salt Value`_ which the client must mix with the hashed-password before sending to the server. Thus the original value 'x' is never stored anywhere except in the user's head, and the hashed value is never passed down a network wire except when mixed with a random salt. This system prevents malicious onlookers from finding passwords by snooping in the log files or snooping on the wire. It is the same system that `MySQL introduced several years ago`_ which has proved adequate for medium-security installations. Nevertheless administrators should warn users that no system is foolproof against determined long-term attacks, so passwords should be guarded and changed occasionally."
msgstr ""

#: ../book/box/authentication.rst:66
msgid "Notes: To get the hash-password of a string 'X', say ``box.schema.user.password('X')``. To see more about the details of the algorithm for the purpose of writing a new client application, read the `scramble.h`_ header file."
msgstr ""

#: ../book/box/authentication.rst:79
msgid "Users and the _user space"
msgstr ""

#: ../book/box/authentication.rst:81
msgid "The fields in the _user space are:"
msgstr ""

#: ../book/box/authentication.rst:83
msgid "the numeric id of the tuple"
msgstr ""

#: ../book/box/authentication.rst:84
msgid "the numeric id of the tuple's creator"
msgstr ""

#: ../book/box/authentication.rst:85
msgid "the user name"
msgstr ""

#: ../book/box/authentication.rst:86
msgid "the type"
msgstr ""

#: ../book/box/authentication.rst:87
msgid "optional password"
msgstr ""

#: ../book/box/authentication.rst:89
msgid "There are four special tuples in the _user space: 'guest', 'admin', 'public', and 'replication'."
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_schema.rst:59
#: ../book/box/box_space.rst:97
msgid "Name"
msgstr ""

#: ../book/box/authentication.rst:99
msgid "ID"
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_index.rst:148
#: ../book/box/box_index.rst:203
#: ../book/box/box_index.rst:236
#: ../book/box/box_index.rst:272
#: ../book/box/box_schema.rst:59
#: ../book/box/box_space.rst:97
msgid "Type"
msgstr ""

#: ../book/box/authentication.rst:99
#: ../book/box/box_index.rst:148
#: ../book/box/box_index.rst:203
#: ../book/box/box_index.rst:236
#: ../book/box/box_index.rst:272
msgid "Description"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "guest"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "0"
msgstr ""

#: ../book/box/authentication.rst:101
#: ../book/box/authentication.rst:104
#: ../book/box/box_schema.rst:72
msgid "user"
msgstr ""

#: ../book/box/authentication.rst:101
msgid "Default when connecting remotely. Usually an untrusted user with few privileges."
msgstr ""

#: ../book/box/authentication.rst:104
msgid "admin"
msgstr ""

#: ../book/box/authentication.rst:104
msgid "1"
msgstr ""

#: ../book/box/authentication.rst:104
msgid "Default when using ``tarantool`` as a console. Usually an administrative user with all privileges."
msgstr ""

#: ../book/box/authentication.rst:107
msgid "public"
msgstr ""

#: ../book/box/authentication.rst:107
msgid "2"
msgstr ""

#: ../book/box/authentication.rst:107
#: ../book/box/authentication.rst:110
msgid "role"
msgstr ""

#: ../book/box/authentication.rst:107
#: ../book/box/authentication.rst:110
msgid "Not a user in the usual sense. Described later in section `Roles`_."
msgstr ""

#: ../book/box/authentication.rst:110
msgid "replication"
msgstr ""

#: ../book/box/authentication.rst:110
msgid "3"
msgstr ""

#: ../book/box/authentication.rst:115
msgid "To select a row from the _user space, use ``box.space._user:select``. For example, here is what happens with a select for user id = 0, which is the 'guest' user, which by default has no password:"
msgstr ""

#: ../book/box/authentication.rst:119
msgid "tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:126
msgid "To change tuples in the _user space, do not use ordinary ``box.space`` functions for insert or update or delete - the _user space is special so there are special functions which have appropriate error checking."
msgstr ""

#: ../book/box/authentication.rst:130
msgid "To create a new user, say:"
msgstr ""

#: ../book/box/authentication.rst:135
msgid "box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})."
msgstr ""

#: ../book/box/authentication.rst:139
msgid "The :samp:`password={password}` specification is good because in a :ref:`URI` (Uniform Resource Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../book/box/authentication.rst:142
msgid "To change the user's password, say:"
msgstr ""

#: ../book/box/authentication.rst:147
msgid "-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../book/box/authentication.rst:153
msgid "(Usually it is only the admin user who can change a different user's password.)"
msgstr ""

#: ../book/box/authentication.rst:155
msgid "To drop a user, say:"
msgstr ""

#: ../book/box/authentication.rst:160
msgid "box.schema.user.drop(*user-name*)."
msgstr ""

#: ../book/box/authentication.rst:162
msgid "To check whether a user exists, say:"
msgstr ""

#: ../book/box/authentication.rst:167
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:169
msgid "which returns true or false."
msgstr ""

#: ../book/box/authentication.rst:171
msgid "To find what privileges a user has, say:"
msgstr ""

#: ../book/box/authentication.rst:176
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../book/box/authentication.rst:180
msgid "Here is a session which creates a new user with a strong password, selects a tuple in the _user space, and then drops the user."
msgstr ""

#: ../book/box/authentication.rst:183
msgid "tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:198
msgid "The maximum number of users is 32."
msgstr ""

#: ../book/box/authentication.rst:204
msgid "Privileges and the _priv space"
msgstr ""

#: ../book/box/authentication.rst:206
msgid "The fields in the _priv space are:"
msgstr ""

#: ../book/box/authentication.rst:208
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../book/box/authentication.rst:209
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../book/box/authentication.rst:210
msgid "the type of object - \"space\" or \"function\" or \"universe\","
msgstr ""

#: ../book/box/authentication.rst:211
msgid "the numeric id of the object,"
msgstr ""

#: ../book/box/authentication.rst:212
msgid "the type of operation - \"read\" = 1, or \"write\" = 2, or \"execute\" = 4, or a combination such as \"read,write,execute\"."
msgstr ""

#: ../book/box/authentication.rst:215
msgid "The function for granting a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:221
msgid "box.schema.user.grant(*grantee*, *operation*, *object-type*, *obejct-name*[, *options*])\n"
"-- OR\n"
"box.schema.user.grant(*grantee*, *operation*, 'universe' [, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:225
#: ../book/box/authentication.rst:238
msgid "where 'universe' means 'all objects', and the optional grant-option can be:"
msgstr ""

#: ../book/box/authentication.rst:227
msgid ":samp:`grantor={grantor_name_or_id}` - string or number, for custom grantor"
msgstr ""

#: ../book/box/authentication.rst:228
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already has the privilege"
msgstr ""

#: ../book/box/authentication.rst:230
msgid "The function for revoking a privilege is:"
msgstr ""

#: ../book/box/authentication.rst:235
msgid "box.schema.user.revoke(*grantee*, *operation*, *object-type*, *object-name*[, *options*])\n"
"box.schema.user.revoke(*grantee*, *operation*, 'universe'[, nil, *options*])"
msgstr ""

#: ../book/box/authentication.rst:240
msgid ":samp:`if_not_exists=true|false` - bool, do not throw error if user already lacks the privilege"
msgstr ""

#: ../book/box/authentication.rst:242
msgid "For example, here is a session where the admin user gave the guest user the privilege to read from a space named ``space55``, and then took the privilege away:"
msgstr ""

#: ../book/box/authentication.rst:245
msgid "tarantool> box.schema.user.grant('guest', 'read', 'space', 'space55')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'read', 'space', 'space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:256
msgid "Generally privileges are granted or revoked by the owner of the object (the user who created it), or by the 'admin' user. Before dropping any objects or users, steps should be taken to ensure that all their associated privileges have been revoked."
msgstr ""

#: ../book/box/authentication.rst:263
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../book/box/authentication.rst:267
msgid "Only the creator of a space can drop, alter, or truncate the space. Only the creator of a user can change a different user's password."
msgstr ""

#: ../book/box/authentication.rst:274
msgid "Functions and the _func space"
msgstr ""

#: ../book/box/authentication.rst:276
msgid "The fields in the _func space are:"
msgstr ""

#: ../book/box/authentication.rst:278
msgid "the numeric function id, a number,"
msgstr ""

#: ../book/box/authentication.rst:279
msgid "the function name"
msgstr ""

#: ../book/box/authentication.rst:280
msgid "flag"
msgstr ""

#: ../book/box/authentication.rst:281
msgid "possibly a language name."
msgstr ""

#: ../book/box/authentication.rst:283
msgid "The _func space does not include the function's body. One continues to create Lua functions in the usual way, by saying \":samp:`function {function_name} () ... end`\", without adding anything in the _func space. The _func space only exists for storing function tuples so that their names can be used within grant/revoke functions."
msgstr ""

#: ../book/box/authentication.rst:289
msgid "The function for creating a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:294
msgid "box.schema.func.create(*function-name* [, *options*])"
msgstr ""

#: ../book/box/authentication.rst:296
msgid "The possible options are:"
msgstr ""

#: ../book/box/authentication.rst:298
msgid ":samp:`if_not_exists = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:299
msgid ":samp:`setuid = {true|false}` - default = false,"
msgstr ""

#: ../book/box/authentication.rst:300
msgid ":samp:`language = {'LUA'|'C'}` - default = 'LUA'."
msgstr ""

#: ../book/box/authentication.rst:304
msgid "box.schema.func.create('f', {language = 'C', setuid = false})"
msgstr ""

#: ../book/box/authentication.rst:308
msgid "Specifying :code:`if_not_exists=true` would cause ``error: Function '...' already exists`` if the function already exists."
msgstr ""

#: ../book/box/authentication.rst:311
msgid "Specifying :code:`setuid=true` would cause the setuid flag (the fourth field in the _func tuple) to have a value meaning \"true\", and the effect of that is that the function's caller is treated as the function's creator, with full privileges. The setuid behavior does not apply for users who connect via :code:`console.connect`."
msgstr ""

#: ../book/box/authentication.rst:316
msgid "Specifying :code:`language='C'` would cause the language field (the fifth field in the _func tuple) to have a value 'C', which means the function was written in C. Tarantool functions are normally written in Lua but can be written in C as well."
msgstr ""

#: ../book/box/authentication.rst:320
msgid "The function for dropping a _func tuple is:"
msgstr ""

#: ../book/box/authentication.rst:325
msgid "box.schema.func.drop(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:327
msgid "The function for checking whether a _func tuple exists is:"
msgstr ""

#: ../book/box/authentication.rst:332
msgid "box.schema.func.exists(*function-name*)"
msgstr ""

#: ../book/box/authentication.rst:335
msgid "In the following example, a function named 'f7' is created, then it is put in the _func space, then it is used in a ``box.schema.user.grant`` function, then it is dropped:"
msgstr ""

#: ../book/box/authentication.rst:339
msgid "tarantool> function f7()\n"
"         >   box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.func.drop('f7')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/authentication.rst:361
msgid "``box.session`` and security"
msgstr ""

#: ../book/box/authentication.rst:363
msgid "After a connection has taken place, the user has access to a \"session\" object which has several functions. The ones which are of interest for security purposes are:"
msgstr ""

#: ../book/box/authentication.rst:370
msgid "box.session.uid()         -- returns the id of the current user\n"
"box.session.user()        -- returns the name of the current user\n"
"box.session.su(*user-name*) -- allows changing current user to 'user-name'"
msgstr ""

#: ../book/box/authentication.rst:374
msgid "If a user types requests directly on the Tarantool server in its interactive mode, or if a user connects via telnet to the administrative port (using :ref:`admin <admin_port>` instead of listen), then the user by default is 'admin' and has many privileges. If a user connects from an application program via one of the :ref:`connectors <box-connectors>`, then the user by default is 'guest' and has few privileges. Typically an admin user will set up and configure objects, then grant privileges to appropriate non-admin users. Typically a guest user will use ``box.session.su()`` to change into a non-generic user to whom admin has granted more than the default privileges. For example, admin might say:"
msgstr ""

#: ../book/box/authentication.rst:386
msgid "box.space._user:insert{123456,0,'manager','user'}\n"
"box.schema.user.grant('manager', 'read', 'space', '_space')\n"
"box.schema.user.grant('manager', 'read', 'space', 'payroll')"
msgstr ""

#: ../book/box/authentication.rst:392
msgid "and later a guest user, who wishes to see the payroll, might say:"
msgstr ""

#: ../book/box/authentication.rst:394
msgid "box.session.su('manager')\n"
"box.space.payroll:select{'Jones'}"
msgstr ""

#: ../book/box/authentication.rst:403
msgid "Roles"
msgstr ""

#: ../book/box/authentication.rst:405
msgid "A role is a container for privileges which can be granted to regular users. Instead of granting and revoking individual privileges, one can put all the privileges in a role and then grant or revoke the role. Role information is in the _user space but the third field - the type field - is 'role' rather than 'user'."
msgstr ""

#: ../book/box/authentication.rst:413
msgid "If a role R1 is granted a privilege X, and user U1 is granted a privilege \"role R1\", then user U1 in effect has privilege X. Then if a role R2 is granted a privilege Y, and role R1 is granted a privilege \"role R2\", then user U1 in effect has both privilege X and privilege Y. In other words, a user gets all the privileges that are granted to a user's roles, directly or indirectly."
msgstr ""

#: ../book/box/authentication.rst:424
msgid "Create a new role."
msgstr ""

#: ../book/box/authentication.rst:428
msgid "Put a privilege in a role."
msgstr ""

#: ../book/box/authentication.rst:432
msgid "Take a privilege out of a role."
msgstr ""

#: ../book/box/authentication.rst:436
msgid "Drop a role."
msgstr ""

#: ../book/box/authentication.rst:440
msgid "Grant a role to a role."
msgstr ""

#: ../book/box/authentication.rst:444
msgid "Revoke a role from a role."
msgstr ""

#: ../book/box/authentication.rst:448
msgid "Check whether a role exists. Returns (type = boolean) true if role-name identifies a role, otherwise false."
msgstr ""

#: ../book/box/authentication.rst:455
msgid "Grant a role to a user."
msgstr ""

#: ../book/box/authentication.rst:459
msgid "Revoke a role from a user."
msgstr ""

#: ../book/box/authentication.rst:461
msgid "There are two predefined roles. The first predefined role, named 'public', is automatically assigned to new users when they are created with :samp:`box.schema.user.create({user-name})` - Therefore a convenient way to grant 'read' on space 't' to every user that will ever exist is: :code:`box.schema.role.grant('public','read','space','t')`. The second predefined role, named 'replication', can be assigned by the 'admin' user to users who need to use replication features."
msgstr ""

#: ../book/box/authentication.rst:471
msgid "Example showing a role within a role"
msgstr ""

#: ../book/box/authentication.rst:473
msgid "In this example, a new user named U1 will insert a new tuple into a new space named T, and will succeed even though user U1 has no direct privilege to do such an insert -- that privilege is inherited from role R1, which in turn inherits from role R2."
msgstr ""

#: ../book/box/authentication.rst:478
msgid "-- This example will work for a user with many privileges, such as 'admin'\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create a user U1 so that later it's possible to say box.session.su('U1')\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read and execute privileges to R2 (but not to R1 and not to U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"box.schema.role.grant('R2', 'execute', 'universe')\n"
"-- Use box.session.su to say \"now become user U1\"\n"
"box.session.su('U1')\n"
"-- Next insert succeeds because U1 in effect has write privilege on T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../book/box/box_index.rst:28
msgid "Package `box.index`"
msgstr ""

#: ../book/box/box_index.rst:30
msgid "The ``box.index`` package provides read-only access for index definitions and index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array within each space object. They provide an API for ordered iteration over tuples. This API is a direct binding to corresponding methods of index objects of type ``box.index`` in the storage engine."
msgstr ""

#: ../book/box/box_index.rst:42
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../book/box/box_index.rst:44
#: ../book/box/box_index.rst:54
#: ../book/box/box_index.rst:62
#: ../book/box/box_index.rst:106
#: ../book/box/box_index.rst:375
#: ../book/box/box_index.rst:509
#: ../book/box/box_index.rst:540
#: ../book/box/box_index.rst:573
#: ../book/box/box_index.rst:601
#: ../book/box/box_index.rst:636
#: ../book/box/box_index.rst:655
#: ../book/box/box_index.rst:670
#: ../book/box/box_index.rst:697
#: ../book/box/box_index.rst:718
#: ../book/box/box_index.rst:741
msgid "Parameters:"
msgstr ""

#: ../book/box/box_index.rst:46
#: ../book/box/box_index.rst:56
#: ../book/box/box_index.rst:64
#: ../book/box/box_index.rst:699
#: ../book/box/box_index.rst:743
msgid ":samp:`{index_object}` = an :ref:`object reference <object-reference>`."
msgstr ""

#: ../book/box/box_index.rst:48
#: ../book/box/box_schema.rst:61
#: ../book/box/box_schema.rst:67
#: ../book/box/box_space.rst:108
#: ../book/box/box_space.rst:110
#: ../book/box/index.rst:173
msgid "boolean"
msgstr ""

#: ../book/box/box_index.rst:52
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../book/box/box_index.rst:60
msgid "An array describing index key fields."
msgstr ""

#: ../book/box/box_index.rst:66
#: ../book/box/box_introspection.rst:80
#: ../book/box/box_schema.rst:74
#: ../book/box/box_space.rst:625
msgid "table"
msgstr ""

#: ../book/box/box_index.rst:70
msgid "tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: NUM\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:86
msgid "This method provides iteration support within an index. The :codeitalic:`bitset-value` or :codeitalic:`search-value` parameter specifies what must match within the index. The :codeitalic:`iterator-type` parameter specifies the rule for matching and ordering. Different index types support different iterators. For example, a TREE index maintains a strict order of keys and can return all tuples in ascending or descending order, starting from the specified key. Other index types, however, do not support ordering."
msgstr ""

#: ../book/box/box_index.rst:96
msgid "To understand consistency of tuples returned by an iterator, it's essential to know the principles of the Tarantool transaction processing subsystem. An iterator in Tarantool does not own a consistent read view. Instead, each procedure is granted exclusive access to all tuples and spaces until it encounters a \"context switch\": by causing a write to disk, network, or by an explicit call to :func:`fiber.yield`. When the execution flow returns to the yielded procedure, the data set could have changed significantly. Iteration, resumed after a yield point, does not preserve the read view, but continues with the new content of the database."
msgstr ""

#: ../book/box/box_index.rst:108
#: ../book/box/box_index.rst:377
#: ../book/box/box_index.rst:511
#: ../book/box/box_index.rst:542
#: ../book/box/box_index.rst:575
#: ../book/box/box_index.rst:603
#: ../book/box/box_index.rst:638
#: ../book/box/box_index.rst:657
#: ../book/box/box_index.rst:672
#: ../book/box/box_index.rst:720
msgid ":samp:`{index_object}` = an :ref:`object reference <object-reference>`;"
msgstr ""

#: ../book/box/box_index.rst:109
msgid ":samp:`{bitset-value} | {search-value...}` = what to search for"
msgstr ""

#: ../book/box/box_index.rst:110
msgid ":samp:`{iterator-type}` = as defined in tables below."
msgstr ""

#: ../book/box/box_index.rst:112
msgid "this method returns an iterator closure, i.e. a function which can be used to get the next value on each invocation"
msgstr ""

#: ../book/box/box_index.rst:114
#: ../book/box/box_space.rst:802
msgid "function, tuple"
msgstr ""

#: ../book/box/box_index.rst:116
msgid "Possible errors: Selected iteration type is not supported for the index type, or search value is not supported for the iteration type."
msgstr ""

#: ../book/box/box_index.rst:119
#: ../book/box/box_index.rst:735
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_index.rst:121
msgid "A search-value can be a number (for example ``1234``), a string (for example ``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). Each part of a search-value will be compared to each part of an index key."
msgstr ""

#: ../book/box/box_index.rst:128
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:130
msgid "Note: Formally the logic for TREE index searches is: |br| comparison-operator is = or >= or > or <= or < depending on iterator-type |br| for i = 1 to number-of-parts-of-search-value |br| |nbsp|  if (search-value-part[i] is ``nil`` and <comparison-operator> is \"=\") |br| |nbsp|  or (search-value-part[i] <comparison-operator> index-key-part[i] is true) |br| |nbsp|  then comparison-result[i] is true |br| if all comparison-results are true, then search-value \"matches\" index key. |br| Notice how, according to this logic, regardless what the index-key-part contains, the comparison-result for equality is always true when a search-value-part is ``nil`` or is missing. This behavior of searches with nil is subject to change."
msgstr ""

#: ../book/box/box_index.rst:141
msgid "Note re storage engine: sophia does not allow search-value-parts to be ``nil`` or missing."
msgstr ""

#: ../book/box/box_index.rst:148
#: ../book/box/box_index.rst:203
#: ../book/box/box_index.rst:236
#: ../book/box/box_index.rst:272
msgid "Arguments"
msgstr ""

#: ../book/box/box_index.rst:150
#: ../book/box/box_index.rst:210
#: ../book/box/box_index.rst:242
#: ../book/box/box_index.rst:277
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../book/box/box_index.rst:150
#: ../book/box/box_index.rst:156
#: ../book/box/box_index.rst:163
#: ../book/box/box_index.rst:170
#: ../book/box/box_index.rst:177
#: ../book/box/box_index.rst:181
#: ../book/box/box_index.rst:187
#: ../book/box/box_index.rst:210
#: ../book/box/box_index.rst:215
#: ../book/box/box_index.rst:277
#: ../book/box/box_index.rst:284
#: ../book/box/box_index.rst:289
#: ../book/box/box_index.rst:294
#: ../book/box/box_index.rst:299
#: ../book/box/box_index.rst:309
msgid "search value"
msgstr ""

#: ../book/box/box_index.rst:150
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:156
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../book/box/box_index.rst:156
msgid "Matching is the same as for ``box.index.EQ``. Tuples are returned in descending order by index key. Note re storage engine: sophia does not REQ."
msgstr ""

#: ../book/box/box_index.rst:163
#: ../book/box/box_index.rst:215
#: ../book/box/box_index.rst:284
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../book/box/box_index.rst:163
msgid "The comparison operator is '>' (greater than). If an index key is greater than a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:170
#: ../book/box/box_index.rst:289
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../book/box/box_index.rst:170
msgid "The comparison operator is '>=' (greater than or equal to). If an index key is greater than or equal to a search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../book/box/box_index.rst:177
#: ../book/box/box_index.rst:238
#: ../book/box/box_index.rst:274
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../book/box/box_index.rst:177
msgid "Same as box.index.GE."
msgstr ""

#: ../book/box/box_index.rst:181
#: ../book/box/box_index.rst:294
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../book/box/box_index.rst:181
msgid "The comparison operator is '<' (less than). If an index key is less than a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:187
#: ../book/box/box_index.rst:299
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../book/box/box_index.rst:187
msgid "The comparison operator is '<=' (less than or equal to). If an index key is less than or equal to a search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../book/box/box_index.rst:196
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../book/box/box_index.rst:205
msgid "box.index.ALL"
msgstr ""

#: ../book/box/box_index.rst:205
#: ../book/box/box_index.rst:238
#: ../book/box/box_index.rst:274
msgid "none"
msgstr ""

#: ../book/box/box_index.rst:205
msgid "All index keys match. Tuples are returned in ascending order by hash of index key, which will appear to be random."
msgstr ""

#: ../book/box/box_index.rst:210
msgid "The comparison operator is '==' (equal to). If an index key is equal to a search value, it matches. The number of returned tuples will be 0 or 1."
msgstr ""

#: ../book/box/box_index.rst:215
msgid "The comparison operator is '>' (greater than). If a hash of an index key is greater than a hash of a search value, it matches. Tuples are returned in ascending order by hash of index key, which will appear to be random. Provided that the space is not being updated, one can retrieve all the tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} in each search, and using the last returned value from the previous result as the start search value for the next search."
msgstr ""

#: ../book/box/box_index.rst:229
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../book/box/box_index.rst:238
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:242
#: ../book/box/box_index.rst:247
#: ../book/box/box_index.rst:252
#: ../book/box/box_index.rst:257
msgid "bitset value"
msgstr ""

#: ../book/box/box_index.rst:242
msgid "If an index key is equal to a bitset value, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:247
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../book/box/box_index.rst:247
msgid "If all of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:252
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../book/box/box_index.rst:252
msgid "If any of the bits which are 1 in the bitset value are 1 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:257
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../book/box/box_index.rst:257
msgid "If all of the bits which are 1 in the bitset value are 0 in the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:265
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../book/box/box_index.rst:274
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:277
msgid "If all points of the rectangle-or-box defined by the search value are the same as the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-or-box as explained in section RTREE_\"."
msgstr ""

#: ../book/box/box_index.rst:284
msgid "If all points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:289
msgid "If all points of the rectangle-or-box defined by the search value are within, or at the side of, the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:294
msgid "If all points of the rectangle-or-box defined by the index key are within the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:299
msgid "If all points of the rectangle-or-box defined by the index key are within, or at the side of, the rectangle-or-box defined by the search key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:304
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../book/box/box_index.rst:304
msgid "search values"
msgstr ""

#: ../book/box/box_index.rst:304
msgid "If some points of the rectangle-or-box defined by the search value are within the rectangle-or-box defined by the index key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../book/box/box_index.rst:309
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../book/box/box_index.rst:309
msgid "If some points of the rectangle-or-box defined by the defined by the key are within, or at the side of, defined by the index key, it matches. Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../book/box/box_index.rst:317
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../book/box/box_index.rst:319
msgid "tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'STR', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:369
msgid "This is an alternative to :func:`box.space...select() <space_object.select>` which goes via a particular index and can make use of additional parameters that specify the iterator type, and the limit (that is, the maximum number of tuples to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../book/box/box_index.rst:378
msgid ":samp:`field-value(s)` = values to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:382
msgid ":samp:`option(s)` any or all of"
msgstr ""

#: ../book/box/box_index.rst:380
msgid ":samp:`iterator = {iterator-type}`,"
msgstr ""

#: ../book/box/box_index.rst:381
msgid ":samp:`limit = {maximum-number-of-tuples}`,"
msgstr ""

#: ../book/box/box_index.rst:382
msgid ":samp:`offset = {start-tuple-number}`."
msgstr ""

#: ../book/box/box_index.rst:384
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../book/box/box_index.rst:385
msgid "tuple set as a Lua table"
msgstr ""

#: ../book/box/box_index.rst:389
msgid "-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'NUM' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'STR'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:415
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../book/box/box_index.rst:417
msgid "---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:426
msgid ":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index is the first (primary-key) index. Therefore, for the example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../book/box/box_index.rst:433
msgid ":samp:`iterator = {iterator-type}` is optional. If it is omitted, then ``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../book/box/box_index.rst:438
msgid ":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then every key in the index is considered to be a match, regardless of iterator type. Therefore, for the example above, ``box.space.tester:select{}`` will select every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../book/box/box_index.rst:446
msgid ":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, ``get`` can be used as a convenient shorthand to get the first tuple in the tuple set that would be returned by ``select``. However, if there is more than one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../book/box/box_index.rst:454
msgid "**Example with BITSET index:**"
msgstr ""

#: ../book/box/box_index.rst:456
msgid "The following script shows creation and search with a BITSET index. Notice: BITSET cannot be unique, so first a primary-key index is created. Notice: bit values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../book/box/box_index.rst:460
msgid "tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'STR'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'NUM'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:507
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:512
#: ../book/box/box_index.rst:543
msgid ":samp:`key-value`."
msgstr ""

#: ../book/box/box_index.rst:514
msgid "the tuple for the first key in the index. If optional ``key-value`` is supplied, returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:517
#: ../book/box/box_index.rst:548
#: ../book/box/box_index.rst:579
#: ../book/box/box_index.rst:645
#: ../book/box/box_index.rst:662
#: ../book/box/box_space.rst:141
#: ../book/box/box_space.rst:170
#: ../book/box/box_space.rst:237
#: ../book/box/box_space.rst:312
#: ../book/box/box_space.rst:371
#: ../book/box/box_space.rst:540
#: ../book/box/box_space.rst:775
#: ../book/box/box_tuple.rst:51
#: ../book/box/box_tuple.rst:195
#: ../book/box/box_tuple.rst:196
#: ../book/box/box_tuple.rst:287
#: ../book/box/index.rst:179
msgid "tuple"
msgstr ""

#: ../book/box/box_index.rst:519
#: ../book/box/box_index.rst:550
msgid "Possible errors: index is not of type 'TREE'."
msgstr ""

#: ../book/box/box_index.rst:521
#: ../book/box/box_index.rst:552
#: ../book/box/box_index.rst:581
msgid "Complexity Factors: Index size, Index type."
msgstr ""

#: ../book/box/box_index.rst:523
msgid "Note re storage engine: sophia does not support ``min()``."
msgstr ""

#: ../book/box/box_index.rst:527
msgid "tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:538
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../book/box/box_index.rst:545
msgid "the tuple for the last key in the index. If optional ``key-value`` is supplied, returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../book/box/box_index.rst:554
msgid "Note re storage engine: sophia does not support ``max()``."
msgstr ""

#: ../book/box/box_index.rst:558
msgid "tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:569
msgid "Find a random value in the specified index. This method is useful when it's important to get insight into data distribution in an index without having to iterate over the entire data set."
msgstr ""

#: ../book/box/box_index.rst:576
msgid ":samp:`random-value` (type = number) = an arbitrary non-negative integer."
msgstr ""

#: ../book/box/box_index.rst:578
msgid "the tuple for the random key in the index."
msgstr ""

#: ../book/box/box_index.rst:583
msgid "Note re storage engine: sophia does not support ``random()``."
msgstr ""

#: ../book/box/box_index.rst:587
msgid "tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:598
msgid "Iterate over an index, counting the number of tuples which equal the provided search criteria."
msgstr ""

#: ../book/box/box_index.rst:604
msgid ":samp:`{key-value}` (type = Lua table or scalar) = the value which must match the key(s) in the specified index. The type may be a list of field-values, or a tuple containing only the field-values; :samp:`{options}`."
msgstr ""

#: ../book/box/box_index.rst:609
msgid "the number of matching index keys. The ``count`` function is only applicable for the memtx storage engine."
msgstr ""

#: ../book/box/box_index.rst:611
#: ../book/box/box_index.rst:746
#: ../book/box/box_schema.rst:63
#: ../book/box/box_schema.rst:65
#: ../book/box/box_session.rst:41
#: ../book/box/box_session.rst:46
#: ../book/box/box_session.rst:71
#: ../book/box/box_space.rst:106
#: ../book/box/box_space.rst:694
#: ../book/box/box_space.rst:732
#: ../book/box/box_tuple.rst:83
#: ../book/box/box_tuple.rst:108
#: ../book/box/box_tuple.rst:157
#: ../book/box/index.rst:169
msgid "number"
msgstr ""

#: ../book/box/box_index.rst:613
msgid "Note re storage engine: sophia does not support ``count()``."
msgstr ""

#: ../book/box/box_index.rst:617
msgid "tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:630
#: ../book/box/box_space.rst:332
#: ../book/box/box_tuple.rst:272
msgid "Update a tuple."
msgstr ""

#: ../book/box/box_index.rst:632
msgid "Same as :func:`box.space...update() <space_object.update>`, but key is searched in this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:639
msgid ":samp:`{key}` (type = Lua table or scalar) = key to be matched against the index key;"
msgstr ""

#: ../book/box/box_index.rst:641
msgid ":samp:`{operator, field_no, value}` (type = Lua table) = update operations (see: :func:`box.space...update() <space_object.update>`)."
msgstr ""

#: ../book/box/box_index.rst:644
#: ../book/box/box_space.rst:370
msgid "the updated tuple."
msgstr ""

#: ../book/box/box_index.rst:649
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../book/box/box_index.rst:651
msgid "Same as :func:`box.space...delete() <space_object.delete>`, but key is searched in this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../book/box/box_index.rst:658
msgid ":samp:`key` (type = Lua table or scalar) = key to be matched against the index key."
msgstr ""

#: ../book/box/box_index.rst:661
msgid "the deleted tuple."
msgstr ""

#: ../book/box/box_index.rst:668
msgid "Alter an index."
msgstr ""

#: ../book/box/box_index.rst:673
msgid ":samp:`{options}` = options list, same as the options list for :func:`create_index <space_object.create_index>`."
msgstr ""

#: ../book/box/box_index.rst:676
#: ../book/box/box_index.rst:723
#: ../book/box/box_schema.rst:125
#: ../book/box/box_schema.rst:253
#: ../book/box/box_schema.rst:341
#: ../book/box/box_space.rst:264
#: ../book/box/box_space.rst:284
#: ../book/box/box_space.rst:665
#: ../book/box/index.rst:175
#: ../book/box/index.rst:175
#: ../book/box/triggers.rst:175
#: ../book/box/triggers.rst:225
msgid "nil"
msgstr ""

#: ../book/box/box_index.rst:678
msgid "Possible errors: Index does not exist, or the first index cannot be changed to {unique = false}, or the alter function is only applicable for the memtx storage engine."
msgstr ""

#: ../book/box/box_index.rst:682
msgid "Note re storage engine: sophia does not support ``alter()``."
msgstr ""

#: ../book/box/box_index.rst:686
msgid "tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:694
msgid "Drop an index. Dropping a primary-key index has a side effect: all tuples are deleted."
msgstr ""

#: ../book/box/box_index.rst:701
msgid "nil."
msgstr ""

#: ../book/box/box_index.rst:703
msgid "Possible errors: Index does not exist, or a primary-key index cannot be dropped while a secondary-key index exists."
msgstr ""

#: ../book/box/box_index.rst:708
msgid "tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:716
msgid "Rename an index."
msgstr ""

#: ../book/box/box_index.rst:721
msgid ":samp:`{index-name}` (type = string) = new name for index."
msgstr ""

#: ../book/box/box_index.rst:725
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../book/box/box_index.rst:729
msgid "tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:739
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../book/box/box_index.rst:745
#: ../book/box/box_tuple.rst:107
msgid "number of bytes"
msgstr ""

#: ../book/box/box_index.rst:750
msgid "Example showing use of the box functions"
msgstr ""

#: ../book/box/box_index.rst:752
msgid "This example will work with the sandbox configuration described in the preface. That is, there is a space named tester with a numeric primary key. The example function will:"
msgstr ""

#: ../book/box/box_index.rst:756
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../book/box/box_index.rst:757
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../book/box/box_index.rst:760
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../book/box/box_index.rst:759
msgid "field[1] = 1000"
msgstr ""

#: ../book/box/box_index.rst:760
msgid "field[2] = a uuid"
msgstr ""

#: ../book/box/box_index.rst:761
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../book/box/box_index.rst:762
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../book/box/box_index.rst:763
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../book/box/box_index.rst:764
msgid "Return the formatted value."
msgstr ""

#: ../book/box/box_index.rst:766
msgid "The function uses Tarantool box functions :func:`box.space...select <space_object.select>`, :func:`box.space...replace <space_object.replace>`, :func:`fiber.time`, :func:`uuid.str`. The function uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../book/box/box_index.rst:775
msgid "function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../book/box/box_index.rst:800
#: ../book/box/box_tuple.rst:335
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_index.rst:802
msgid "tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:821
msgid "Package `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../book/box/box_index.rst:823
msgid "The :mod:`box.index` package may be used for spatial searches if the index type is RTREE. There are operations for searching *rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects with more than 4 corners and more than 4 sides, sometimes called hyperrectangles). This manual uses the term *rectangle-or-box* for the whole class of objects that includes both rectangles and boxes. Only rectangles will be illustrated."
msgstr ""

#: ../book/box/box_index.rst:830
msgid "Rectangles are described according to their X-axis (horizontal axis) and Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a picture of four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../book/box/box_index.rst:836
msgid "           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../book/box/box_index.rst:850
msgid "The rectangles are defined according to this scheme: {X-axis coordinate of top left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../book/box/box_index.rst:860
msgid "Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../book/box/box_index.rst:863
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../book/box/box_index.rst:865
msgid "tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'NUM'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:878
msgid "Field#1 doesn't matter, we just make it because we need a primary-key index. (RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) The second field must be an \"array\", which means its values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../book/box/box_index.rst:884
msgid "tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../book/box/box_index.rst:889
msgid "And now, following the description of `RTREE iterator types`_, we can search the rectangles with these requests:"
msgstr ""

#: ../book/box/box_index.rst:894
msgid "tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../book/box/box_index.rst:910
msgid "Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator always returns all tuples, and the first returned tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../book/box/box_index.rst:918
msgid "Now let us create a space and index for cuboids, which are rectangle-or-boxes that have 6 corners and 6 sides."
msgstr ""

#: ../book/box/box_index.rst:921
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:932
msgid "The additional field here is ``dimension=3``. The default dimension is 2, which is why it didn't need to be specified for the examples of rectangle. The maximum dimension is 20. Now for insertions and selections there will usually be 6 coordinates. For example:"
msgstr ""

#: ../book/box/box_index.rst:936
msgid "tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../book/box/box_index.rst:941
msgid "Now let us create a space and index for Manhattan-style spatial objects, which are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../book/box/box_index.rst:944
msgid "tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../book/box/box_index.rst:955
msgid "The additional field here is ``distance='manhattan'``. The default distance calculator is 'euclid', which is the straightforward as-the-crow-flies method. The optional distance calculator is 'manhattan', which can be a more appropriate method if one is following the lines of a grid rather than traveling in a straight line."
msgstr ""

#: ../book/box/box_index.rst:960
msgid "tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../book/box/box_index.rst:966
msgid "More examples of spatial searching are online in the file `R tree index quick start and usage`_."
msgstr ""

#: ../book/box/box_introspection.rst:28
msgid "Server introspection"
msgstr ""

#: ../book/box/box_introspection.rst:32
msgid "Package `box.cfg`"
msgstr ""

#: ../book/box/box_introspection.rst:36
msgid "The ``box.cfg`` package is for administrators to specify all the server configuration parameters; the full description of the parameters is in section :ref:`book-cfg`. Use ``box.cfg`` without braces to get read-only access to those parameters."
msgstr ""

#: ../book/box/box_introspection.rst:43
msgid "tarantool> box.cfg\n"
"---\n"
"- snapshot_count: 6\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  slab_alloc_maximal: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:57
msgid "Package `box.info`"
msgstr ""

#: ../book/box/box_introspection.rst:61
msgid "The ``box.info`` package provides access to information about server variables. Some important ones:"
msgstr ""

#: ../book/box/box_introspection.rst:64
msgid "**server.uuid** holds the unique identifier of the server. This value is also in the :data:`box.space._cluster` system space."
msgstr ""

#: ../book/box/box_introspection.rst:66
msgid "**pid** is the process ID of the server. This value is also shown by the :ref:`tarantool <tarantool-build>` package."
msgstr ""

#: ../book/box/box_introspection.rst:68
msgid "**version** is the Tarantool version. This value is also shown by :ref:`tarantool --version <tarantool-version>`."
msgstr ""

#: ../book/box/box_introspection.rst:70
msgid "**uptime** is the number of seconds since the server started."
msgstr ""

#: ../book/box/box_introspection.rst:74
msgid "Since ``box.info`` contents are dynamic, it's not possible to iterate over keys with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and returns a Lua table with all keys and values provided in the package."
msgstr ""

#: ../book/box/box_introspection.rst:79
msgid "keys and values in the package."
msgstr ""

#: ../book/box/box_introspection.rst:84
msgid "tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.6.8-66-g9093daa\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.6.8-66-g9093daa\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:121
msgid "Package `box.slab`"
msgstr ""

#: ../book/box/box_introspection.rst:125
msgid "The ``box.slab`` package provides access to slab allocator statistics. The slab allocator is the main allocator used to store tuples. This can be used to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../book/box/box_introspection.rst:129
msgid "The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and so on. The example omits the slabs which are empty. The example display is saying that: there are 16 items stored in the 64-byte slab (and 16*64=102 so bytes_used = 1024); there is 1 item stored in the 136-byte slab (and 136*1=136 so bytes_used = 136); the arena_used value is the total of all the bytes_used values (1024+136 = 1160); the arena_size value is the arena_used value plus the total of all the bytes_free values (1160+4193200+4194088 = 8388448). The arena_size and arena_used values are the amount of the % of :confval:`slab_alloc_arena` that is already distributed to the slab allocator."
msgstr ""

#: ../book/box/box_introspection.rst:141
msgid "tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../book/box/box_introspection.rst:181
msgid "Package `box.stat`"
msgstr ""

#: ../book/box/box_introspection.rst:183
msgid "The ``box.stat`` package provides access to request and network statistics. Show the average number of requests per second, and the total number of requests since startup, broken down by request type and network events statistics."
msgstr ""

#: ../book/box/box_introspection.rst:187
msgid "tarantool> type(box.stat), type(box.stat.net) -- a virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../book/box/box_schema.rst:30
msgid "Package `box.schema`"
msgstr ""

#: ../book/box/box_schema.rst:34
msgid "The ``box.schema`` package has data-definition functions for spaces, users, roles, and function tuples."
msgstr ""

#: ../book/box/box_schema.rst:40
msgid "Create a space."
msgstr ""

#: ../book/box/box_schema.rst:42
msgid "name of space, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:44
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../book/box/box_schema.rst:46
msgid "space object"
msgstr ""

#: ../book/box/box_schema.rst:47
msgid "userdata"
msgstr ""

#: ../book/box/box_schema.rst:51
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../book/box/box_schema.rst:59
#: ../book/box/box_space.rst:97
msgid "Effect"
msgstr ""

#: ../book/box/box_schema.rst:59
#: ../book/box/box_space.rst:97
msgid "Default"
msgstr ""

#: ../book/box/box_schema.rst:61
msgid "temporary"
msgstr ""

#: ../book/box/box_schema.rst:61
msgid "space is temporary"
msgstr ""

#: ../book/box/box_schema.rst:61
#: ../book/box/box_schema.rst:67
#: ../book/box/box_space.rst:110
msgid "false"
msgstr ""

#: ../book/box/box_schema.rst:63
#: ../book/box/box_space.rst:106
msgid "id"
msgstr ""

#: ../book/box/box_schema.rst:63
#: ../book/box/box_space.rst:106
msgid "unique identifier"
msgstr ""

#: ../book/box/box_schema.rst:63
msgid "last space's id, +1"
msgstr ""

#: ../book/box/box_schema.rst:65
msgid "field_count"
msgstr ""

#: ../book/box/box_schema.rst:65
msgid "fixed field count"
msgstr ""

#: ../book/box/box_schema.rst:65
msgid "0 i.e. not fixed"
msgstr ""

#: ../book/box/box_schema.rst:67
#: ../book/box/box_schema.rst:251
#: ../book/box/box_space.rst:110
msgid "if_not_exists"
msgstr ""

#: ../book/box/box_schema.rst:67
#: ../book/box/box_space.rst:110
msgid "no error if duplicate name"
msgstr ""

#: ../book/box/box_schema.rst:70
msgid "engine"
msgstr ""

#: ../book/box/box_schema.rst:70
msgid "storage package"
msgstr ""

#: ../book/box/box_schema.rst:70
#: ../book/box/box_schema.rst:72
#: ../book/box/box_schema.rst:205
#: ../book/box/box_session.rst:61
#: ../book/box/index.rst:171
msgid "string"
msgstr ""

#: ../book/box/box_schema.rst:70
msgid "'memtx'"
msgstr ""

#: ../book/box/box_schema.rst:72
msgid "user name"
msgstr ""

#: ../book/box/box_schema.rst:72
msgid "current user's name"
msgstr ""

#: ../book/box/box_schema.rst:74
msgid "format"
msgstr ""

#: ../book/box/box_schema.rst:74
msgid "field names+types"
msgstr ""

#: ../book/box/box_schema.rst:74
msgid "(blank)"
msgstr ""

#: ../book/box/box_schema.rst:77
msgid "the numeric identifier established by box.schema.space.create"
msgstr ""

#: ../book/box/box_schema.rst:79
msgid "Note: for symmetry, there are other box.schema functions targeting space objects, for example :samp:`box.schema.space.drop({space-id})` will drop a space. However, the common approach is to use functions attached to the space objects, for example :func:`space_object:drop() <space_object.drop>`."
msgstr ""

#: ../book/box/box_schema.rst:85
msgid "Note re storage engine: sophia does not support temporary spaces."
msgstr ""

#: ../book/box/box_schema.rst:91
msgid "tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })"
msgstr ""

#: ../book/box/box_schema.rst:107
msgid "For an illustration with the :code:`format` clause, see :data:`box.space._space <box.space._space>` example."
msgstr ""

#: ../book/box/box_schema.rst:110
msgid "After a space is created, usually the next step is to :func:`create an index <space_object.create_index>` for it, and then it is available for insert, select, and all the other :mod:`box.space` functions."
msgstr ""

#: ../book/box/box_schema.rst:117
msgid "Create a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:121
msgid "name of user, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:123
msgid "if_not_exists, password"
msgstr ""

#: ../book/box/box_schema.rst:127
#: ../book/box/box_schema.rst:175
#: ../book/box/box_schema.rst:193
#: ../book/box/box_schema.rst:223
#: ../book/box/box_schema.rst:255
#: ../book/box/box_schema.rst:294
#: ../book/box/box_schema.rst:311
#: ../book/box/box_schema.rst:343
msgid "**Examples:**"
msgstr ""

#: ../book/box/box_schema.rst:129
msgid "box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:137
msgid "Drop a user. For explanation of how Tarantool maintains user data, see section :ref:`Users and the _user space <authentication-users>`."
msgstr ""

#: ../book/box/box_schema.rst:141
#: ../book/box/box_schema.rst:155
#: ../book/box/box_schema.rst:168
#: ../book/box/box_schema.rst:186
msgid "the name of the user"
msgstr ""

#: ../book/box/box_schema.rst:142
msgid "if_exists"
msgstr ""

#: ../book/box/box_schema.rst:146
msgid "box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../book/box/box_schema.rst:153
msgid "Return true if a user exists; return false if a user does not exist."
msgstr ""

#: ../book/box/box_schema.rst:156
#: ../book/box/box_schema.rst:277
#: ../book/box/box_schema.rst:367
msgid "bool"
msgstr ""

#: ../book/box/box_schema.rst:160
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:166
msgid "Grant :ref:`privileges <privileges>` to a user."
msgstr ""

#: ../book/box/box_schema.rst:169
#: ../book/box/box_schema.rst:187
#: ../book/box/box_schema.rst:288
msgid "either privilege,object-type,object-name or privilege,'universe' where privilege = 'read' or 'write' or 'execute' or a combination and object-type = 'space' or 'function'. Or: role-name."
msgstr ""

#: ../book/box/box_schema.rst:177
msgid "box.schema.user.grant('Lena', 'read', 'space', 'tester') box.schema.user.grant('Lena', 'execute', 'function', 'f') box.schema.user.grant('Lena', 'read,write', 'universe') box.schema.user.grant('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:184
msgid "Revoke :ref:`privileges <privileges>` from a user."
msgstr ""

#: ../book/box/box_schema.rst:195
msgid "box.schema.user.revoke('Lena', 'read', 'space', 'tester') box.schema.user.revoke('Lena', 'execute', 'function', 'f') box.schema.user.revoke('Lena', 'read,write', 'universe') box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:202
msgid "Return a hash of a password."
msgstr ""

#: ../book/box/box_schema.rst:204
#: ../book/box/box_schema.rst:221
msgid "password"
msgstr ""

#: ../book/box/box_schema.rst:209
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:213
msgid "Associate a password with the user who is currently logged in. or with another user. Users who wish to change their own passwords should use box.schema.user.passwd(password). Administrators who wish to change passwords of other users should use box.schema.user.passwd(user-name, password)."
msgstr ""

#: ../book/box/box_schema.rst:220
msgid "user-name"
msgstr ""

#: ../book/box/box_schema.rst:225
msgid "box.schema.user.passwd('ЛЕНА') box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../book/box/box_schema.rst:230
msgid "Return a description of a user's privileges."
msgstr ""

#: ../book/box/box_schema.rst:232
msgid "the name of the user. This is optional; if it is not supplied, then the information will be for the user who is currently logged in."
msgstr ""

#: ../book/box/box_schema.rst:240
msgid "box.schema.user.info() box.schema.user.info('Lena')"
msgstr ""

#: ../book/box/box_schema.rst:245
msgid "Create a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:249
msgid "name of role, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:257
msgid "box.schema.role.create('Accountant') box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../book/box/box_schema.rst:262
msgid "Drop a role. For explanation of how Tarantool maintains role data, see section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../book/box/box_schema.rst:266
#: ../book/box/box_schema.rst:276
#: ../book/box/box_schema.rst:287
#: ../book/box/box_schema.rst:305
msgid "the name of the role"
msgstr ""

#: ../book/box/box_schema.rst:270
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:274
msgid "Return true if a role exists; return false if a role does not exist."
msgstr ""

#: ../book/box/box_schema.rst:281
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:285
msgid "Grant :ref:`privileges <privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:296
msgid "box.schema.role.grant('Accountant', 'read', 'space', 'tester') box.schema.role.grant('Accountant', 'execute', 'function', 'f') box.schema.role.grant('Accountant', 'read,write', 'universe') box.schema.role.grant('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:303
msgid "Revoke :ref:`privileges <privileges>` to a role."
msgstr ""

#: ../book/box/box_schema.rst:306
msgid "either privilege,object-type,object-name or privilege,'universe' where privilege = 'read' or 'write' or 'execute' or a combination and object-type = 'space' or 'function'"
msgstr ""

#: ../book/box/box_schema.rst:313
msgid "box.schema.role.revoke('Accountant', 'read', 'space', 'tester') box.schema.role.revoke('Accountant', 'execute', 'function', 'f') box.schema.role.revoke('Accountant', 'read,write', 'universe') box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:320
msgid "Return a description of a role's privileges."
msgstr ""

#: ../book/box/box_schema.rst:322
msgid "the name of the role."
msgstr ""

#: ../book/box/box_schema.rst:326
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../book/box/box_schema.rst:330
msgid "Create a function tuple. This does not create the function itself -- that is done with Lua -- but if it is necessary to grant privileges for a function, box.schema.func.create must be done first. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:337
msgid "name of function, which should not be a number and should not contain special characters"
msgstr ""

#: ../book/box/box_schema.rst:339
msgid "if_not_exists, setuid, language"
msgstr ""

#: ../book/box/box_schema.rst:345
msgid "box.schema.func.create('calculate') box.schema.func.create('calculate', {if_not_exists = false}) box.schema.func.create('calculate', {setuid = false}) box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../book/box/box_schema.rst:352
msgid "Drop a function tuple. For explanation of how Tarantool maintains function data, see section :ref:`Functions and the _func space <authentication-funcs>`."
msgstr ""

#: ../book/box/box_schema.rst:356
#: ../book/box/box_schema.rst:366
msgid "the name of the function"
msgstr ""

#: ../book/box/box_schema.rst:360
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../book/box/box_schema.rst:364
msgid "Return true if a function tuple exists; return false if a function tuple does not exist."
msgstr ""

#: ../book/box/box_schema.rst:371
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../book/box/box_session.rst:28
msgid "Package `box.session`"
msgstr ""

#: ../book/box/box_session.rst:30
msgid "The ``box.session`` package allows querying the session state, writing to a session-specific temporary Lua table, or setting up triggers which will fire when a session starts or ends. A *session* is an object associated with each client connection."
msgstr ""

#: ../book/box/box_session.rst:39
msgid "the unique identifier (ID) for the current session. The result can be 0 meaning there is no session."
msgstr ""

#: ../book/box/box_session.rst:45
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../book/box/box_session.rst:50
msgid "This function works only if there is a peer, that is, if a connection has been made to a separate server."
msgstr ""

#: ../book/box/box_session.rst:53
msgid "The host address and port of the session peer, for example \"127.0.0.1:55457\". If the session exists but there is no connection to a separate server, the return is null. The command is executed on the server, so the \"local name\" is the server's host and administrative port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../book/box/box_session.rst:63
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../book/box/box_session.rst:67
msgid "the value of the :code:`sync` integer constant used in the `binary protocol <https://github.com/tarantool/tarantool/blob/master/src/box/iproto_constants.h>`_."
msgstr ""

#: ../book/box/box_session.rst:75
msgid "A Lua table that can hold arbitrary unordered session-specific names and values, which will last until the session ends."
msgstr ""

#: ../book/box/box_session.rst:82
msgid "tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../book/box/box_session.rst:107
msgid "See the section :ref:`Triggers <box-triggers>` for instructions about defining triggers for connect and disconnect events with ``box.session.on_connect()`` and ``box.session.on_disconnect()``. See the section :ref:`Access control <box-authentication>` for instructions about ``box.session`` functions that affect user identification and security."
msgstr ""

#: ../book/box/box_space.rst:28
msgid "Package `box.space`"
msgstr ""

#: ../book/box/box_space.rst:30
msgid "The ``box.space`` package has the data-manipulation functions ``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. It also has members, such as id, and whether or not a space is enabled. Package source code is available in file `src/box/lua/schema.lua <https://github.com/tarantool/tarantool/blob/master/src/box/lua/schema.lua>`_."
msgstr ""

#: ../book/box/box_space.rst:36
msgid "A list of all ``box.space`` functions follows, then comes a list of all ``box.space`` members."
msgstr ""

#: ../book/box/box_space.rst:39
msgid ":func:`space_object:create_index() <space_object.create_index>` |br| :func:`space_object:insert() <space_object.insert>` |br| :func:`space_object:select() <space_object.select>` |br| :func:`space_object:get() <space_object.get>` |br| :func:`space_object:drop() <space_object.drop>` |br| :func:`space_object:rename() <space_object.rename>` |br| :func:`space_object:replace() <space_object.replace>` |br| :func:`space_object:put() <space_object.replace>` |br| :func:`space_object:update() <space_object.update>` |br| :func:`space_object:upsert() <space_object.upsert>` |br| :func:`space_object:delete() <space_object.delete>` |br| :func:`space_object:len() <space_object.len>` |br| :func:`space_object:truncate() <space_object.truncate>` |br| :func:`space_object:inc{} <space_object.inc>` |br| :func:`space_object:dec{} <space_object.dec>` |br| :func:`space_object:auto_increment{} <space_object.auto_increment>` |br| :func:`space_object:pairs() <space_object.pairs>` :func:`space_object.id <space_object.id>` |br| :func:`space_object.enabled <space_object.enabled>` |br| :func:`space_object.field_count <space_object.field_count>` |br| :func:`space_object.index <space_object.index>` |br|"
msgstr ""

#: ../book/box/box_space.rst:61
msgid ":class:`box.space._schema` |br| :class:`box.space._space` |br| :class:`box.space._index` |br| :class:`box.space._user` |br| :class:`box.space._priv` |br| :class:`box.space._cluster`  |br|"
msgstr ""

#: ../book/box/box_space.rst:74
msgid "Create an index. It is mandatory to create an index for a tuple set before trying to insert tuples into it, or select tuples from it. The first created index, which will be used as the primary-key index, must be unique."
msgstr ""

#: ../book/box/box_space.rst:79
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`index_name` (type = string) = name of index, which should not be a number and should not contain special characters; :codeitalic:`options`."
msgstr ""

#: ../book/box/box_space.rst:84
msgid "index object"
msgstr ""

#: ../book/box/box_space.rst:85
msgid "index_object"
msgstr ""

#: ../book/box/box_space.rst:89
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../book/box/box_space.rst:99
msgid "type"
msgstr ""

#: ../book/box/box_space.rst:99
msgid "type of index"
msgstr ""

#: ../book/box/box_space.rst:99
msgid "string ('HASH',     'TREE', 'BITSET',   'RTREE')"
msgstr ""

#: ../book/box/box_space.rst:99
msgid "'TREE'"
msgstr ""

#: ../book/box/box_space.rst:106
msgid "last index's id, +1"
msgstr ""

#: ../book/box/box_space.rst:108
msgid "unique"
msgstr ""

#: ../book/box/box_space.rst:108
msgid "index is unique"
msgstr ""

#: ../book/box/box_space.rst:108
#: ../book/box/index.rst:173
msgid "true"
msgstr ""

#: ../book/box/box_space.rst:113
msgid "parts"
msgstr ""

#: ../book/box/box_space.rst:113
msgid "field-numbers  + types"
msgstr ""

#: ../book/box/box_space.rst:113
msgid "``{field_no, 'NUM'|'STR'}``"
msgstr ""

#: ../book/box/box_space.rst:113
msgid "``{1, 'NUM'}``"
msgstr ""

#: ../book/box/box_space.rst:117
msgid "Possible errors: too many parts."
msgstr ""

#: ../book/box/box_space.rst:119
msgid "Note re storage engine: sophia supports only the TREE index type, and supports only one index per space, and supports only the unique = true option, and requires that field numbers be in order starting with 1."
msgstr ""

#: ../book/box/box_space.rst:124
msgid "tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'NUM', 2, 'STR'}})\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:135
msgid "Insert a tuple into a space."
msgstr ""

#: ../book/box/box_space.rst:137
#: ../book/box/box_space.rst:308
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`tuple` (type = Lua table or tuple) = tuple to be inserted."
msgstr ""

#: ../book/box/box_space.rst:140
msgid "the inserted tuple"
msgstr ""

#: ../book/box/box_space.rst:143
msgid "Possible errors: If a tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../book/box/box_space.rst:146
#: ../book/box/box_space.rst:322
msgid "Note re storage engine: sophia will return nil, rather than the inserted tuple."
msgstr ""

#: ../book/box/box_space.rst:150
msgid "tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:159
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../book/box/box_space.rst:161
#: ../book/box/box_space.rst:232
#: ../book/box/box_space.rst:535
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`key` (type = Lua table or scalar) = key to be matched against the index key, which may be multi-part."
msgstr ""

#: ../book/box/box_space.rst:165
msgid "the tuples whose primary-key fields are equal to the passed field-values. If the number of passed field-values is less than the number of fields in the primary key, then only the passed field-values are compared, so ``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../book/box/box_space.rst:172
msgid "Possible errors: No such space; wrong type."
msgstr ""

#: ../book/box/box_space.rst:174
msgid "**Complexity Factors:** Index size, Index type."
msgstr ""

#: ../book/box/box_space.rst:178
msgid "tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'NUM', 2, 'STR'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:223
msgid "For examples of complex ``select`` requests, where one can specify which index to search and what condition to use (for example \"greater than\" instead of \"equal to\") and how many tuples to return, see the later section :ref:`index_object:select <index_object_select>`."
msgstr ""

#: ../book/box/box_space.rst:230
msgid "Search for a tuple in the given space."
msgstr ""

#: ../book/box/box_space.rst:236
msgid "the selected tuple."
msgstr ""

#: ../book/box/box_space.rst:239
#: ../book/box/box_space.rst:266
msgid "Possible errors: If space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:241
#: ../book/box/box_space.rst:268
#: ../book/box/box_space.rst:319
#: ../book/box/box_space.rst:777
msgid "**Complexity Factors:** Index size, Index type, Number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:244
msgid "The ``box.space...select`` function returns a set of tuples as a Lua table; the ``box.space...get`` function returns a single tuple. And it is possible to get the first tuple in a tuple set by appending ``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, and may serve as a convenient shorthand."
msgstr ""

#: ../book/box/box_space.rst:254
msgid "box.space.tester:get{1}"
msgstr ""

#: ../book/box/box_space.rst:260
msgid "Drop a space."
msgstr ""

#: ../book/box/box_space.rst:262
#: ../book/box/box_space.rst:570
#: ../book/box/box_space.rst:586
#: ../book/box/box_space.rst:606
#: ../book/box/box_space.rst:623
#: ../book/box/box_space.rst:642
#: ../book/box/box_space.rst:661
#: ../book/box/box_space.rst:799
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`."
msgstr ""

#: ../book/box/box_space.rst:273
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../book/box/box_space.rst:279
msgid "Rename a space."
msgstr ""

#: ../book/box/box_space.rst:281
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`space-name` (type = string) = new name for space."
msgstr ""

#: ../book/box/box_space.rst:286
msgid "Possible errors: space_object does not exist."
msgstr ""

#: ../book/box/box_space.rst:290
msgid "tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:302
msgid "Insert a tuple into a space. If a tuple with the same primary key already exists, ``box.space...:replace()`` replaces the existing tuple with a new one. The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have the same effect; the latter is sometimes used to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../book/box/box_space.rst:311
#: ../book/box/box_space.rst:774
msgid "the inserted tuple."
msgstr ""

#: ../book/box/box_space.rst:314
msgid "Possible errors: If a different tuple with the same unique-key value already exists, returns :errcode:`ER_TUPLE_FOUND`. (This would only happen if there was a secondary index. By default secondary indexes are unique)"
msgstr ""

#: ../book/box/box_space.rst:326
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../book/box/box_space.rst:334
msgid "The ``update`` function supports operations on fields — assignment, arithmetic (if the field is unsigned numeric), cutting and pasting fragments of a field, deleting or inserting a field. Multiple operations can be combined in a single update request, and in this case they are performed atomically and sequentially. Each operation requires specification of a field number. When multiple operations are present, the field number for each operation is assumed to be relative to the most recent state of the tuple, that is, as if all previous operations in a multi-operation update have already been applied. In other words, it is always safe to merge multiple ``update`` invocations into a single invocation, with no change in semantics."
msgstr ""

#: ../book/box/box_space.rst:346
msgid "Possible operators are:"
msgstr ""

#: ../book/box/box_space.rst:348
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:349
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../book/box/box_space.rst:350
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:351
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:352
msgid "``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../book/box/box_space.rst:353
msgid "``:`` for string splice"
msgstr ""

#: ../book/box/box_space.rst:354
msgid "``!`` for insertion"
msgstr ""

#: ../book/box/box_space.rst:355
msgid "``#`` for deletion"
msgstr ""

#: ../book/box/box_space.rst:356
msgid "``=`` for assignment"
msgstr ""

#: ../book/box/box_space.rst:358
msgid "For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last field in the tuple."
msgstr ""

#: ../book/box/box_space.rst:361
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`key` (type = Lua table or scalar) = primary-key field values, must be passed as a Lua table if key is multi-part; :codeitalic:`{operator, field_no, value}` (type = table): a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:373
#: ../book/box/box_space.rst:520
msgid "Possible errors: it is illegal to modify a primary-key field."
msgstr ""

#: ../book/box/box_space.rst:375
msgid "**Complexity Factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:378
msgid "Note re storage engine: sophia will return nil, rather than the updated tuple."
msgstr ""

#: ../book/box/box_space.rst:380
msgid "Thus, in the instruction:"
msgstr ""

#: ../book/box/box_space.rst:382
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../book/box/box_space.rst:386
msgid "the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning *add a value to a field and then assign a value to a field*, the first affected field is field ``1`` and the value which will be added to it is ``55``, the second affected field is field ``3`` and the value which will be assigned to it is ``'x'``."
msgstr ""

#: ../book/box/box_space.rst:394
msgid "Assume that the initial state of the database is ``tester`` that has one tuple set and one primary key whose type is ``NUM``. There is one tuple, with ``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../book/box/box_space.rst:398
#: ../book/box/box_space.rst:413
#: ../book/box/box_space.rst:424
#: ../book/box/box_space.rst:435
#: ../book/box/box_space.rst:447
#: ../book/box/box_space.rst:460
#: ../book/box/box_space.rst:472
msgid "In the update:"
msgstr ""

#: ../book/box/box_space.rst:400
msgid "box.space.tester:update(999, {{'=', 2, 'B'}})"
msgstr ""

#: ../book/box/box_space.rst:404
msgid "The first argument is ``tester``, that is, the affected space is ``tester``. The second argument is ``999``, that is, the affected tuple is identified by primary key value = 999. The third argument is ``=``, that is, there is one operation — *assignment to a field*. The fourth argument is ``2``, that is, the affected field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'``."
msgstr ""

#: ../book/box/box_space.rst:415
msgid "box.space.tester:update({999}, {{'=', 2, 'B'}})"
msgstr ""

#: ../book/box/box_space.rst:419
msgid "the arguments are the same, except that the key is passed as a Lua table (inside braces). This is unnecessary when the primary key has only one field, but would be necessary if the primary key had more than one field. Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../book/box/box_space.rst:426
msgid "box.space.tester:update({999}, {{'=', 3, 1}})"
msgstr ""

#: ../book/box/box_space.rst:430
msgid "the arguments are the same, except that the fourth argument is ``3``, that is, the affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../book/box/box_space.rst:437
msgid "box.space.tester:update({999}, {{'+', 3, 1}})"
msgstr ""

#: ../book/box/box_space.rst:441
msgid "the arguments are the same, except that the third argument is ``'+'``, that is, the operation is addition rather than assignment. Since ``field[3]`` previously contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../book/box/box_space.rst:449
msgid "box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})"
msgstr ""

#: ../book/box/box_space.rst:453
msgid "the idea is to modify two fields at once. The formats are ``'|'`` and ``=``, that is, there are two operations, OR and assignment. The fourth and fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../book/box/box_space.rst:462
msgid "box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})"
msgstr ""

#: ../book/box/box_space.rst:466
msgid "The idea is to delete ``field[2]``, then subtract ``3`` from ``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` becomes ``field[2]``` before we subtract ``3`` from it, and that's why the seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../book/box/box_space.rst:474
msgid "box.space.tester:update({999}, {{'=', 2, 'XYZ'}})"
msgstr ""

#: ../book/box/box_space.rst:478
msgid "we're making a long string so that splice will work in the next example. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../book/box/box_space.rst:481
msgid "In the update"
msgstr ""

#: ../book/box/box_space.rst:483
msgid "box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})"
msgstr ""

#: ../book/box/box_space.rst:487
msgid "The third argument is ``':'``, that is, this is the example of splice. The fourth argument is ``2`` because the change will occur in ``field[2]``. The fifth argument is 2 because deletion will begin with the second byte. The sixth argument is 1 because the number of bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../book/box/box_space.rst:496
msgid "Update or insert a tuple."
msgstr ""

#: ../book/box/box_space.rst:498
msgid "If there is an existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :func:`space_object:update() <space_object.update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If there is no existing tuple which matches the key fields of ``tuple_value``, then the request has the same effect as :func:`space_object:insert() <space_object.insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or ``update``, ``upsert`` will not read a tuple and perform error checks before returning -- this is a design feature which enhances throughput but requires more caution on the part of the user."
msgstr ""

#: ../book/box/box_space.rst:508
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :samp:`{tuple_value}` (type = Lua table or scalar) = field values, must be passed as a Lua table if tuple_value contains more than one field; :codeitalic:`{operator, field_no, value}` (type = Lua table) = a group of arguments for each operation, indicating what the operation is, what field the operation will apply to, and what value will be applied. The field number can be negative, meaning the position from the end of tuple (#tuple + negative field number + 1)."
msgstr ""

#: ../book/box/box_space.rst:518
msgid "null."
msgstr ""

#: ../book/box/box_space.rst:522
msgid "**Complexity factors:** Index size, Index type, number of indexes accessed, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:527
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../book/box/box_space.rst:533
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../book/box/box_space.rst:539
msgid "the deleted tuple"
msgstr ""

#: ../book/box/box_space.rst:542
msgid "**Complexity Factors:** Index size, Index type"
msgstr ""

#: ../book/box/box_space.rst:544
msgid "Note re storage engine: sophia will return nil, rather than the deleted tuple."
msgstr ""

#: ../book/box/box_space.rst:548
msgid "tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected NUM'\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:565
msgid "Ordinal space number. Spaces can be referenced by either name or number. Thus, if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../book/box/box_space.rst:574
msgid "tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:583
msgid "Whether or not this space is enabled. The value is ``false`` if the space has no index."
msgstr ""

#: ../book/box/box_space.rst:592
msgid "The required field count for all tuples in this space. The field_count can be set initially with:"
msgstr ""

#: ../book/box/box_space.rst:598
msgid "box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../book/box/box_space.rst:604
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../book/box/box_space.rst:610
msgid "tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:619
msgid "A container for all defined indexes. An index is a Lua object of type :mod:`box.index` with methods to search tuples and iterate over them in predefined order."
msgstr ""

#: ../book/box/box_space.rst:629
msgid "tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:644
msgid "Number of tuples in the space."
msgstr ""

#: ../book/box/box_space.rst:648
msgid "tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:659
msgid "Deletes all tuples."
msgstr ""

#: ../book/box/box_space.rst:663
msgid "**Complexity Factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../book/box/box_space.rst:667
msgid "Note re storage engine: sophia does not support ``truncate``."
msgstr ""

#: ../book/box/box_space.rst:671
msgid "tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:683
msgid "Increments a counter in a tuple whose primary key matches the field-value(s). The field following the primary-key fields will be the counter. If there is no tuple matching the ``field-value(s)``, a new one is inserted with initial counter value set to ``1``."
msgstr ""

#: ../book/box/box_space.rst:690
#: ../book/box/box_space.rst:728
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`field-value(s)` (type = Lua table or scalar) = values which must match the primary key."
msgstr ""

#: ../book/box/box_space.rst:693
#: ../book/box/box_space.rst:731
msgid "the new counter value"
msgstr ""

#: ../book/box/box_space.rst:696
msgid "**Complexity Factors:** Index size, Index type, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:700
msgid "tarantool> s = box.schema.space.create('forty_second_space')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   unique = true,\n"
"         >   parts = {1, 'NUM', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> box.space.forty_second_space:inc{1, 'a'}\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.forty_second_space:inc{1, 'a'}\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:722
msgid "Decrements a counter in a tuple whose primary key matches the ``field-value(s)``. The field following the primary-key fields will be the counter. If there is no tuple matching the ``field-value(s)``, a new one is not inserted. If the counter value drops to zero, the tuple is deleted."
msgstr ""

#: ../book/box/box_space.rst:734
msgid "**Complexity factors:** Index size, Index type, WAL settings."
msgstr ""

#: ../book/box/box_space.rst:738
msgid "tarantool> s = box.schema.space.create('space19')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   unique = true,\n"
"         >   parts = {1, 'NUM', 2, 'STR'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> box.space.space19:insert{1, 'a', 1000}\n"
"---\n"
"- [1, 'a', 1000]\n"
"...\n"
"tarantool> box.space.space19:dec{1, 'a'}\n"
"---\n"
"- 999\n"
"...\n"
"tarantool> box.space.space19:dec{1, 'a'}\n"
"---\n"
"- 998\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:766
msgid "Insert a new tuple using an auto-increment primary key. The space specified by space_object must have a ``NUM`` primary key index of type ``TREE``. The primary-key field will be incremented before the insert. Note re storage engine: sophia does not support auto_increment."
msgstr ""

#: ../book/box/box_space.rst:771
msgid "Parameters: :samp:`{space_object}` = an :ref:`object reference <object-reference>`; :codeitalic:`field-value(s)` (type = Lua table or scalar) = tuple's fields, other than the primary-key field."
msgstr ""

#: ../book/box/box_space.rst:780
msgid "Possible errors: index has wrong type or primary-key indexed field is not a number."
msgstr ""

#: ../book/box/box_space.rst:784
msgid "tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:797
msgid "A helper function to prepare for iterating over all tuples in a space."
msgstr ""

#: ../book/box/box_space.rst:801
msgid "function which can be used in a for/end loop. Within the loop, a value is returned for each iteration."
msgstr ""

#: ../book/box/box_space.rst:806
msgid "tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'NUM'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:835
msgid "``_schema`` is a system tuple set. Its single tuple contains these fields: ``'version', major-version-number, minor-version-number``."
msgstr ""

#: ../book/box/box_space.rst:840
msgid "The following function will display all fields in all tuples of ``_schema``:"
msgstr ""

#: ../book/box/box_space.rst:842
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._schema:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      line = line .. v[i] .. ' '\n"
"      i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:859
#: ../book/box/box_space.rst:899
#: ../book/box/box_space.rst:977
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../book/box/box_space.rst:861
msgid "tarantool> example()\n"
"---\n"
"- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '\n"
"  - 'max_id 520 '\n"
"  - 'version 1 6 '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:872
msgid "``_space`` is a system tuple set. Its tuples contain these fields: ``id``, ``uid``, ``space-name``, ``engine``, ``field_count``, ``temporary``, ``format``. These fields are established by :func:`space.create() <box.schema.space.create>`."
msgstr ""

#: ../book/box/box_space.rst:878
msgid "The following function will display all simple fields in all tuples of ``_space``."
msgstr ""

#: ../book/box/box_space.rst:880
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:901
msgid "tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin sophia 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:922
msgid "The following requests will create a space using ``box.schema.space.create`` with a ``format`` clause. Then it retrieves the _space tuple for the new space. This illustrates the typical use of the ``format`` clause, it shows the recommended names and data types for the fields."
msgstr ""

#: ../book/box/box_space.rst:928
msgid "tarantool> box.schema.space.create('TM', {\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field#1\"},\n"
"         >     [2] = {[\"type\"] = \"num\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 522\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(522)\n"
"---\n"
"- - [522, 1, 'TM', 'memtx', 0, '', [{'name': 'field#1'}, {'type': 'num'}]]\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:954
msgid "``_index`` is a system tuple set. Its tuples contain these fields: ``space-id index-id index-name index-type index-is-unique index-field-count [tuple-field-no, tuple-field-type ...]``."
msgstr ""

#: ../book/box/box_space.rst:958
msgid "The following function will display some fields in all tuples of ``_index``:"
msgstr ""

#: ../book/box/box_space.rst:960
msgid "function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._index:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= 4 do\n"
"        line = line .. v[i] .. ' '\n"
"        i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"    end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:979
msgid "tarantool> example()\n"
"---\n"
"- - '272 0 primary tree 1 1 0 str '\n"
"  - '280 0 primary tree 1 1 0 num '\n"
"  - '280 1 owner tree 0 1 1 num '\n"
"  - '280 2 name tree 1 1 2 str '\n"
"  - '288 0 primary tree 1 2 0 num 1 num '\n"
"  - '288 2 name tree 1 2 0 num 2 str '\n"
"  - '296 0 primary tree 1 1 0 num '\n"
"  - '296 1 owner tree 0 1 1 num '\n"
"  - '296 2 name tree 1 1 2 str '\n"
"  - '304 0 primary tree 1 1 0 num '\n"
"  - '304 1 owner tree 0 1 1 num '\n"
"  - '304 2 name tree 1 1 2 str '\n"
"  - '312 0 primary tree 1 3 1 num 2 str 3 num '\n"
"  - '312 1 owner tree 0 1 0 num '\n"
"  - '312 2 object tree 0 2 2 str 3 num '\n"
"  - '313 0 primary tree '\n"
"  - '313 1 owner tree '\n"
"  - '313 2 object tree '\n"
"  - '320 0 primary tree 1 1 0 num '\n"
"  - '320 1 uuid tree 1 1 1 str '\n"
"  - '512 0 primary tree 1 1 0 num '\n"
"  - '513 0 first tree 1 1 0 NUM '\n"
"  - '514 0 first tree 1 1 0 STR '\n"
"..."
msgstr ""

#: ../book/box/box_space.rst:1010
msgid "``_user`` is a system tuple set for support of the :ref:`authorization feature <box-authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1015
msgid "``_priv`` is a system tuple set for support of the :ref:`authorization feature <box-authentication>`."
msgstr ""

#: ../book/box/box_space.rst:1020
msgid "``_cluster`` is a system tuple set for support of the :ref:`replication feature <box-replication>`."
msgstr ""

#: ../book/box/box_space.rst:1025
msgid "Example showing use of the box.space functions"
msgstr ""

#: ../book/box/box_space.rst:1027
msgid "This function will illustrate how to look at all the spaces, and for each display: approximately how many tuples it contains, and the first field of its first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and ``pairs()``. The iteration through the spaces is coded as a scan of the ``_space`` system tuple set, which contains metadata. The third field in ``_space`` contains the space name, so the key instruction ``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../book/box/box_space.rst:1037
msgid "function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../book/box/box_space.rst:1061
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../book/box/box_space.rst:1063
msgid "tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:30
msgid "Package `box.tuple`"
msgstr ""

#: ../book/box/box_tuple.rst:34
msgid "The ``box.tuple`` package provides read-only access for the ``tuple`` userdata type. It allows, for a single tuple: selective retrieval of the field contents, retrieval of information about size, iteration over all the fields, and conversion to a Lua table."
msgstr ""

#: ../book/box/box_tuple.rst:41
msgid "Construct a new tuple from either a scalar or a Lua table. Alternatively, one can get new tuples from tarantool's :func:`select <space_object.select>` or :func:`insert <space_object.insert>` or :func:`replace <space_object.replace>` or :func:`update <space_object.update>` requests, which can be regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../book/box/box_tuple.rst:48
msgid "the value that will become the tuple contents."
msgstr ""

#: ../book/box/box_tuple.rst:50
msgid "a new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:53
msgid "In the following example, ``x`` will be a new table object containing one tuple and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple ``t``."
msgstr ""

#: ../book/box/box_tuple.rst:59
msgid "tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:80
msgid "The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../book/box/box_tuple.rst:85
msgid "In the following example, a tuple named ``t`` is created and then the number of fields in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:88
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:100
msgid "If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in the tuple. It is useful to check this number when making changes to data, because there is a fixed maximum: one megabyte. Every field has one or more \"length\" bytes preceding the actual contents, so ``bsize()`` returns a value which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../book/box/box_tuple.rst:110
msgid "In the following example, a tuple named ``t`` is created which has three fields, and for each field it takes one byte to store the length and three bytes to store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../book/box/box_tuple.rst:115
msgid "tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:127
msgid "If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../book/box/box_tuple.rst:130
msgid "field value."
msgstr ""

#: ../book/box/box_tuple.rst:131
msgid "lua-value"
msgstr ""

#: ../book/box/box_tuple.rst:133
msgid "In the following example, a tuple named ``t`` is created and then the second field in ``t`` is returned."
msgstr ""

#: ../book/box/box_tuple.rst:136
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:149
msgid "If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of the first field in ``t`` that matches the search value, and ``t:findall(search-value [, search-value ...])`` will return numbers of all fields in ``t`` that match the search value. Optionally one can put a numeric argument ``field-number`` before the search-value to indicate “start searching at field number ``field-number``.”"
msgstr ""

#: ../book/box/box_tuple.rst:156
msgid "the number of the field in the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:159
msgid "In the following example, a tuple named ``t`` is created and then: the number of the first field in ``t`` which matches 'a' is returned, then the numbers of all the fields in ``t`` which match 'a' are returned, then the numbers of all the fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../book/box/box_tuple.rst:165
msgid "tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:186
msgid "If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-remove})` will return a tuple where, starting from field ``start-field-number``, a number of fields (``fields-to-remove``) are removed. Optionally one can add more arguments after ``fields-to-remove`` to indicate new values that will replace what was removed."
msgstr ""

#: ../book/box/box_tuple.rst:192
msgid "base 1, may be negative"
msgstr ""

#: ../book/box/box_tuple.rst:198
msgid "In the following example, a tuple named ``t`` is created and then, starting from the second field, two fields are removed but one new one is added, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:202
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:214
msgid "If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:unpack(1)`` will return all fields starting with field number 1, ``t:unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../book/box/box_tuple.rst:218
msgid "field(s) from the tuple."
msgstr ""

#: ../book/box/box_tuple.rst:219
msgid "lua-value(s)"
msgstr ""

#: ../book/box/box_tuple.rst:221
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected, then the result is returned."
msgstr ""

#: ../book/box/box_tuple.rst:224
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:240
msgid "In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, ``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua iterators, because Lua iterators traverse a value's components until an end marker is reached."
msgstr ""

#: ../book/box/box_tuple.rst:246
msgid "function, tuple-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:247
msgid "function, lua-value, nil"
msgstr ""

#: ../book/box/box_tuple.rst:249
msgid "In the following example, a tuple named ``t`` is created and then all its fields are selected using a Lua for-end loop."
msgstr ""

#: ../book/box/box_tuple.rst:252
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:274
msgid "This function updates a tuple which is not in a space. Compare the function :code:`box.space.`:samp:`{space-name}`:code:`:update{`:samp:`{key}, {format},` :code:`{`:samp:`{field_number}, {value}`:code:`}...)`, which updates a tuple in a space."
msgstr ""

#: ../book/box/box_tuple.rst:278
msgid "Parameters: briefly: ``format`` indicates the type of update operation such as '``=``' for 'assign new value', ``field_number`` indicates the field number to change such as 2 for field number 2, ``value`` indicates the string which operates on the field such as 'B' for a new assignable value = 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:283
msgid "For details: see the description for ``format``, ``field_number``, and ``value`` in the section :func:`box.space.space-name:update{key, format, {field_number, value}...) <space_object.update>`."
msgstr ""

#: ../book/box/box_tuple.rst:286
msgid "new tuple"
msgstr ""

#: ../book/box/box_tuple.rst:289
msgid "In the following example, a tuple named ``t`` is created and then its second field is updated to equal 'B'."
msgstr ""

#: ../book/box/box_tuple.rst:292
msgid "tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=',2,'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../book/box/box_tuple.rst:306
msgid "This function will illustrate how to convert tuples to/from Lua tables and lists of scalars:"
msgstr ""

#: ../book/box/box_tuple.rst:309
msgid "tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../book/box/box_tuple.rst:316
msgid "Then it will find the field that contains 'b', remove that field from the tuple, and display how many bytes remain in the tuple. The function uses Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, ``bsize()``."
msgstr ""

#: ../book/box/box_tuple.rst:321
msgid "function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = {tuple1:unpack()}\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1)\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../book/box/box_tuple.rst:337
msgid "tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../book/box/index.rst:30
msgid "Database"
msgstr ""

#: ../book/box/index.rst:32
msgid "This chapter describes how Tarantool stores values and what operations with data it supports."
msgstr ""

#: ../book/box/index.rst:37
msgid "Document data model"
msgstr ""

#: ../book/box/index.rst:39
msgid "If you tried out the :ref:`Starting Tarantool and making your first database <first database>` exercise from the last chapter, then your database looks like this:"
msgstr ""

#: ../book/box/index.rst:43
msgid "+--------------------------------------------+\n"
"|                                            |\n"
"| SPACE 'tester'                             |\n"
"| +----------------------------------------+ |\n"
"| |                                        | |\n"
"| | TUPLE SET 'tester'                     | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Tuple: [ 1 ]                      |  | |\n"
"| | | Tuple: [ 2, 'Music' ]             |  | |\n"
"| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| | INDEX 'primary'                        | |\n"
"| | +-----------------------------------+  | |\n"
"| | | Key: 1                            |  | |\n"
"| | | Key: 2                            |  | |\n"
"| | | Key: 3                            |  | |\n"
"| | +-----------------------------------+  | |\n"
"| |                                        | |\n"
"| +----------------------------------------+ |\n"
"+--------------------------------------------+"
msgstr ""

#: ../book/box/index.rst:69
msgid "Space"
msgstr ""

#: ../book/box/index.rst:71
msgid "A *space* -- 'tester' in the example -- is a container."
msgstr ""

#: ../book/box/index.rst:73
msgid "When Tarantool is being used to store data, there is always at least one space. There can be many spaces. Each space has a unique name specified by the user. Each space has a unique numeric identifier which can be specified by the user but usually is assigned automatically by Tarantool. Spaces always contain one tuple set and one or more indexes."
msgstr ""

#: ../book/box/index.rst:83
msgid "Tuple Set"
msgstr ""

#: ../book/box/index.rst:85
msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
msgstr ""

#: ../book/box/index.rst:87
msgid "There is always one tuple set in a space. The identifier of a tuple set is the same as the space name -- 'tester' in the example."
msgstr ""

#: ../book/box/index.rst:91
msgid "A tuple fills the same role as a “row” or a “record”, and the components of a tuple (which we call “fields”) fill the same role as a “row column” or “record field”, except that: the fields of a tuple can be composite structures, such as arrays or maps and don't need to have names. That's why there was no need to pre-define the tuple set when creating the space, and that's why each tuple can have a different number of elements. Tuples are stored as `MsgPack`_ arrays."
msgstr ""

#: ../book/box/index.rst:103
msgid "Any given tuple may have any number of fields and the fields may have a variety of types. The identifier of a field is the field's number, base 1. For example “1” can be used in some contexts to refer to the first field of a tuple."
msgstr ""

#: ../book/box/index.rst:108
msgid "When Tarantool returns a tuple value, it surrounds strings with single quotes, separates fields with commas, and encloses the tuple inside square brackets. For example: ``[ 3, 'length', 93 ]``."
msgstr ""

#: ../book/box/index.rst:117
msgid "Index"
msgstr ""

#: ../book/box/index.rst:119
msgid "An *index* -- 'primary' in the example -- is a group of key values and pointers."
msgstr ""

#: ../book/box/index.rst:121
msgid "In order for a tuple set to be useful, there must always be at least one index in a space. There can be many. As with spaces, the user can and should specify the index name, and let Tarantool come up with a unique numeric identifier (the \"index id\"). In our example there is one index and its name is “primary”."
msgstr ""

#: ../book/box/index.rst:128
msgid "An index may be *multi-part*, that is, the user can declare that an index key value is taken from two or more fields in the tuple, in any order. An index may be *unique*, that is, the user can declare that it would be illegal to have the same key value twice. An index may have *one of four types*: HASH which is fastest and uses the least memory but must be unique, TREE which allows partial-key searching and ordered results, BITSET which can be good for searches that contain '=' and multiple ANDed conditions, and RTREE for spatial coordinates. The first index is called the “*primary key*” index and it must be unique; all other indexes are called “secondary” indexes."
msgstr ""

#: ../book/box/index.rst:140
msgid "An index definition may include identifiers of tuple fields and their expected types. The allowed types for indexed fields are NUM (unsigned integer between 0 and 18,446,744,073,709,551,615), or STR (string, any sequence of octets), or ARRAY (a series of numbers for use with :ref:`RTREE indexes <RTREE>`. Take our example, which has the request:"
msgstr ""

#: ../book/box/index.rst:147
msgid "tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})"
msgstr ""

#: ../book/box/index.rst:151
msgid "The effect is that, for all tuples in tester, field number 1 must exist and must contain an unsigned integer."
msgstr ""

#: ../book/box/index.rst:154
msgid "Space definitions and index definitions are stored permanently in system spaces. It is possible to add, drop, or alter the definitions at runtime, with some restrictions. The syntax details for defining spaces and indexes are in section :ref:`The box library <box-library>`."
msgstr ""

#: ../book/box/index.rst:162
msgid "Data types"
msgstr ""

#: ../book/box/index.rst:164
msgid "Tarantool can work with numbers, strings, booleans, tables, and userdata."
msgstr ""

#: ../book/box/index.rst:167
msgid "General type"
msgstr ""

#: ../book/box/index.rst:167
msgid "Specific type"
msgstr ""

#: ../book/box/index.rst:167
msgid "What Lua type()|would return"
msgstr ""

#: ../book/box/index.rst:169
#: ../book/box/index.rst:171
#: ../book/box/index.rst:173
#: ../book/box/index.rst:175
msgid "scalar"
msgstr ""

#: ../book/box/index.rst:169
msgid "\"`number`_\""
msgstr ""

#: ../book/box/index.rst:169
msgid "12345"
msgstr ""

#: ../book/box/index.rst:171
msgid "\"`string`_\""
msgstr ""

#: ../book/box/index.rst:171
msgid "'A B C'"
msgstr ""

#: ../book/box/index.rst:173
msgid "\"`boolean`_\""
msgstr ""

#: ../book/box/index.rst:175
msgid "\"`nil`_\""
msgstr ""

#: ../book/box/index.rst:177
#: ../book/box/index.rst:179
msgid "compound"
msgstr ""

#: ../book/box/index.rst:177
msgid "Lua table"
msgstr ""

#: ../book/box/index.rst:177
msgid "\"`table`_\""
msgstr ""

#: ../book/box/index.rst:177
msgid "table: 0x410f8b10"
msgstr ""

#: ../book/box/index.rst:179
msgid "\"`Userdata`_\""
msgstr ""

#: ../book/box/index.rst:179
msgid "12345: {'A B C'}"
msgstr ""

#: ../book/box/index.rst:189
msgid "In Lua a *number* is double-precision floating-point, but Tarantool allows both integer and floating-point values. Tarantool will try to store a number as floating-point if the value contains a decimal point or is very large (greater than 100 quadrillion = 1e14), otherwise Tarantool will store it as an integer. To ensure that even very large numbers will be treated as integers, use the :func:`tonumber64 <tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular notation, exponential notation, the ULL suffix, and the tonumber64 function: -55,  -2.7e+20, 100000000000000ULL, tonumber64('18446744073709551615')."
msgstr ""

#: ../book/box/index.rst:202
msgid "For database storage Tarantool uses MsgPack rules. Storage is variable-length, so the smallest number requires only one byte but the largest number requires nine bytes. When a field has a 'NUM' index, all values must be unsigned integers between 0 and 18,446,744,073,709,551,615."
msgstr ""

#: ../book/box/index.rst:208
msgid "A *string* is a variable-length sequence of bytes, usually represented with alphanumeric characters inside single quotes."
msgstr ""

#: ../book/box/index.rst:211
msgid "A *boolean* is either ``true`` or ``false``."
msgstr ""

#: ../book/box/index.rst:213
msgid "A *nil* type has only one possible value, also called *nil*, but often displayed as *null*. Nils may be compared to values of any types with == (is-equal) or ~= (is-not-equal), but other operations will not work. Nils may not be used in Lua tables; the workaround is to use :data:`yaml.NULL` or :data:`json.NULL` or :data:`msgpack.NULL`."
msgstr ""

#: ../book/box/index.rst:219
msgid "A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few functions may return tables with multiple tuples. A scalar may be converted to a tuple with only one field. A Lua table may contain all of a tuple's fields, but not nil."
msgstr ""

#: ../book/box/index.rst:224
msgid "For more tuple examples see :ref:`box.tuple <box-tuple>`."
msgstr ""

#: ../book/box/index.rst:228
msgid "Operations"
msgstr ""

#: ../book/box/index.rst:230
msgid "The basic operations are: the five data-change operations (insert, update, upsert, delete, replace), and the data-retrieval operation (select). There are also minor operations like “ping” which can only be used with the binary protocol. Also, there are :func:`index iterator <index_object.pairs>` operations, which can only be used with Lua code. (Index iterators are for traversing indexes one key at a time, taking advantage of features that are specific to an index type, for example evaluating Boolean expressions when traversing BITSET indexes, or going in descending order when traversing TREE indexes.)"
msgstr ""

#: ../book/box/index.rst:241
msgid "Six examples of basic operations:"
msgstr ""

#: ../book/box/index.rst:243
msgid "-- Add a new tuple to tuple set tester.\n"
"-- The first field, field[1], will be 999 (type is NUM).\n"
"-- The second field, field[2], will be 'Taranto' (type is STR).\n"
"tarantool> box.space.tester:insert{999, 'Taranto'}\n"
"\n"
"-- Update the tuple, changing field field[2].\n"
"-- The clause \"{999}\", which has the value to look up in\n"
"-- the index of the tuple's primary-key field, is mandatory\n"
"-- because update() requests must always have a clause that\n"
"-- specifies the primary key, which in this case is field[1].\n"
"-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
"-- will happen to field[2] with the new value.\n"
"tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
"\n"
"-- Upsert the tuple, changing field field[2] again.\n"
"-- The syntax of upsert is the same as the syntax of update,\n"
"-- but the return value will be different.\n"
"tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
"\n"
"-- Replace the tuple, adding a new field.\n"
"-- This is also possible with the update() request but\n"
"-- the update() request is usually more complicated.\n"
"tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
"\n"
"-- Retrieve the tuple.\n"
"-- The clause \"{999}\" is still mandatory, although it does not have to\n"
"-- mention the primary key.\n"
"tarantool> box.space.tester:select{999}\n"
"\n"
"-- Delete the tuple.\n"
"-- Once again the clause to identify the primary-key field is mandatory.\n"
"tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../book/box/index.rst:278
msgid "How does Tarantool do a basic operation? Let's take this example:"
msgstr ""

#: ../book/box/index.rst:280
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""

#: ../book/box/index.rst:284
msgid "which, for those who know SQL, is equivalent to a statement like"
msgstr ""

#: ../book/box/index.rst:286
msgid "UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"
msgstr ""

#: ../book/box/index.rst:290
msgid "**STEP #1**: if this is happening on a remote client, then the client parses the statement and changes it to a binary-protocol instruction which has already been checked, and which the server can understand without needing to parse everything again. The client ships a packet to the server."
msgstr ""

#: ../book/box/index.rst:296
msgid "**STEP #2**: the server's “transaction processor” thread uses the primary-key index on field[1] to find the location of the tuple in memory. It determines that the tuple can be updated (not much can go wrong when you're merely changing an unindexed field value to something shorter)."
msgstr ""

#: ../book/box/index.rst:302
msgid "**STEP #3**: the transaction processor thread sends a message to the write-ahead logging (WAL) thread."
msgstr ""

#: ../book/box/index.rst:305
msgid "At this point a *yield* takes place. To know the significance of that -- and it's quite significant -- you have to know a few facts and a few new words."
msgstr ""

#: ../book/box/index.rst:309
msgid "**FACT #1**: there is only one transaction processor thread. Some people are used to the idea that there can be multiple threads operating on the database, with (say) thread #1 reading row #x while thread#2 writes row#y. With Tarantool no such thing ever happens. Only the transaction processor thread can access the database, and there is only one transaction processor thread for each instance of the server."
msgstr ""

#: ../book/box/index.rst:317
msgid "**FACT #2**: the transaction processor thread can handle many *fibers*. A fiber is a set of computer instructions that may contain \"yield\" signals. The transaction processor thread will execute all computer instructions until a yield, then switch to execute the instructions of a different fiber. Thus (say) the thread reads row#x for the sake of fiber#1, then writes row#y for the sake of fiber#2."
msgstr ""

#: ../book/box/index.rst:326
msgid "**FACT #3**: yields must happen, otherwise the transaction processor thread would stick permanently on the same fiber. There are implicit yields: every data-change operation or network-access causes an implicit yield, and every statement that goes through the tarantool client causes an implicit yield. And there are explicit yields: in a Lua function one can and should add “yield” statements to prevent hogging. This is called *cooperative multitasking*."
msgstr ""

#: ../book/box/index.rst:335
msgid "Since all data-change operations end with an implicit yield and an implicit commit, and since no data-change operation can change more than one tuple, there is no need for any locking. Consider, for example, a Lua function that does three Tarantool operations:"
msgstr ""

#: ../book/box/index.rst:340
msgid "s:select{999}             -- this does not yield and does not commit\n"
"s:update({...},{{...}})   -- this yields and commits\n"
"s:select{999}             -- this does not yield and does not commit"
msgstr ""

#: ../book/box/index.rst:346
msgid "The combination “SELECT plus UPDATE” is an atomic transaction: the function holds a consistent view of the database until the UPDATE ends. For the combination “UPDATE plus SELECT” the view is not consistent, because after the UPDATE the transaction processor thread can switch to another fiber, and delete the tuple that was just updated. Note re storage engine: sophia handles yields differently, see :ref:`differences between memtx and sophia <sophia_diff>`. Note re multi-request transactions: there is a way to delay yields, see :ref:`Atomic execution <atomic_execution>`."
msgstr ""

#: ../book/box/index.rst:356
msgid "Since locks don't exist, and disk writes only involve the write-ahead log, transactions are usually fast. Also the Tarantool server may not be using up all the threads of a powerful multi-core processor, so advanced users may be able to start a second Tarantool server on the same processor without ill effects."
msgstr ""

#: ../book/box/index.rst:361
msgid "Additional examples of requests can be found in the `Tarantool regression test suite`_. A complete grammar of supported data-manipulation functions will come later in this chapter."
msgstr ""

#: ../book/box/index.rst:366
msgid "Since not all Tarantool operations can be expressed with the data-manipulation functions, or with Lua, to gain complete access to data manipulation functionality one must use a :ref:`Perl, PHP, Python or other programming language connector <box-connectors>`. The client/server protocol is open and documented: an annotated BNF can be found in the source tree, file `doc/box-protocol.html`_."
msgstr ""

#: ../book/box/index.rst:376
msgid "Data persistence"
msgstr ""

#: ../book/box/index.rst:378
msgid "To maintain data persistence, Tarantool writes each data change request (INSERT, UPDATE, DELETE, REPLACE) into a write-ahead log (WAL) file in the :confval:`wal_dir <wal_dir>` directory. A new WAL file is created for every :confval:`rows_per_wal <rows_per_wal>` records. Each data change request gets assigned a continuously growing 64-bit log sequence number. The name of the WAL file is based on the log sequence number of the first record in the file, plus an extension ``.xlog``."
msgstr ""

#: ../book/box/index.rst:386
msgid "Apart from a log sequence number and the data change request (its format is the same as in the binary protocol and is described in `doc/box-protocol.html`_), each WAL record contains a header, some metadata, and then the data formatted according to `msgpack`_ rules. For example this is what the WAL file looks like after the first INSERT request (\"s:insert({1})\") for the introductory sandbox exercise \":ref:`Starting Tarantool and making your first database <first database>` “. On the left are the hexadecimal bytes that one would see with:"
msgstr ""

#: ../book/box/index.rst:394
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../book/box/index.rst:398
msgid "and on the right are comments."
msgstr ""

#: ../book/box/index.rst:400
msgid "Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             File header: \"XLOG\\n\"\n"
"30 2e 31 32 0a             File header: \"0.12\\n\" = version\n"
"...                        (not shown = more header + tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5 if version 0.12\n"
"19 00                      Length, not including length of header, = 25 bytes\n"
"ce 16 a4 38 6f             Record header: previous crc32, current crc32,\n"
"a7 cc 73 7f 00 00 66 39\n"
"84                         msgpack code meaning \"Map of 4 elements\" follows\n"
"00 02                         element#1: tag=request type, value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte \"Double\"\n"
"82                         msgpack code meaning \"map of 2 elements\" follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed array={1}"
msgstr ""

#: ../book/box/index.rst:420
msgid "Tarantool processes requests atomically: a change is either accepted and recorded in the WAL, or discarded completely. Let's clarify how this happens, using the REPLACE request as an example:"
msgstr ""

#: ../book/box/index.rst:424
msgid "The server attempts to locate the original tuple by primary key. If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../book/box/index.rst:426
msgid "The new tuple is validated. If for example it does not contain an indexed field, or it has an indexed field whose type does not match the type according to the index definition, the change is aborted."
msgstr ""

#: ../book/box/index.rst:429
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../book/box/index.rst:430
msgid "A message is sent to WAL writer running in a separate thread, requesting that the change be recorded in the WAL. The server switches to work on the next request until the write is acknowledged."
msgstr ""

#: ../book/box/index.rst:433
msgid "On success, a confirmation is sent to the client. On failure, a rollback procedure is begun. During the rollback procedure, the transaction processor rolls back all changes to the database which occurred after the first failed change, from latest to oldest, up to the first failed change. All rolled back requests are aborted with :errcode:`ER_WAL_IO <ER_WAL_IO>` error. No new change is applied while rollback is in progress. When the rollback procedure is finished, the server restarts the processing pipeline."
msgstr ""

#: ../book/box/index.rst:441
msgid "One advantage of the described algorithm is that complete request pipelining is achieved, even for requests on the same value of the primary key. As a result, database performance doesn't degrade even if all requests refer to the same key in the same space."
msgstr ""

#: ../book/box/index.rst:446
msgid "The transaction processor thread communicates with the WAL writer thread using asynchronous (yet reliable) messaging; the transaction processor thread, not being blocked on WAL tasks, continues to handle requests quickly even at high volumes of disk I/O. A response to a request is sent as soon as it is ready, even if there were earlier incomplete requests on the same connection. In particular, SELECT performance, even for SELECTs running on a connection packed with UPDATEs and DELETEs, remains unaffected by disk load."
msgstr ""

#: ../book/box/index.rst:454
msgid "The WAL writer employs a number of durability modes, as defined in configuration variable :confval:`wal_mode <wal_mode>`. It is possible to turn the write-ahead log completely off, by setting :confval:`wal_mode <wal_mode>` to *none*. Even without the write-ahead log it's still possible to take a persistent copy of the entire data set with the :func:`box.snapshot() <box.snapshot()>` request."
msgstr ""

#: ../book/box/index.rst:462
msgid "Data manipulation"
msgstr ""

#: ../book/box/index.rst:464
msgid "The basic *data-manipulation* requests are: ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``select``. All of them are part of the ``box`` library. Most of them may return data. Usually both inputs and outputs are Lua tables."
msgstr ""

#: ../book/box/index.rst:468
msgid "The Lua syntax for data-manipulation functions can vary. Here are examples of the variations with ``select`` requests; the same rules exist for the other data-manipulation functions. Every one of the examples does the same thing: select a tuple set from a space named tester where the primary-key field value equals 1. For the examples there is an assumption that the numeric id of 'tester' is 512, which happens to be the case in our sandbox example only."
msgstr ""

#: ../book/box/index.rst:477
msgid "First, there are five *object reference variations*:"
msgstr ""

#: ../book/box/index.rst:479
msgid "-- #1 package . sub-package . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 replace name with a numeric id in square brackets\n"
"tarantool> box.space[512]:select{1}\n"
"-- #4 use a variable instead of a literal for the name\n"
"tarantool> variable = 'tester'\n"
"tarantool> box.space[variable]:select{1}\n"
"-- #5 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../book/box/index.rst:494
msgid "Later examples in this manual will usually have the \":samp:`box.space.{tester}:`\" form (#1); however, this is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../book/box/index.rst:498
msgid "Later descriptions in this manual will use the syntax \":code:`space_object:`\" for references to objects which are spaces as in the above examples, and \":code:`index_object:`\" for references to objects which are indexes (for example :samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../book/box/index.rst:504
msgid "Then, there are six *parameter variations*:"
msgstr ""

#: ../book/box/index.rst:506
msgid "-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #5\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #6\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../book/box/index.rst:523
msgid "The primary-key value is enclosed in braces, and if it was a multi-part primary key then the value would be multi-part, for example ``...select{1,2,3}``. The braces can be enclosed inside parentheses — ``...select({...})`` — which is optional unless it is necessary to pass something besides the primary-key value, as in the fourth example. Literal values such as 1 (a scalar value) or {1} (a Lua table value) may be replaced by variable names, as in examples ``#5`` and ``#6``. Although there are special cases where braces can be omitted, they are preferable because they signal \"Lua table\". Examples and descriptions in this manual have the \"{1}\" form; however, this too is a matter of user preference and all the variations exist in the wild."
msgstr ""

#: ../book/box/index.rst:537
msgid "All the data-manipulation functions operate on tuple sets but, since primary keys are unique, the number of tuples in the tuple set is always 0 or 1. The only exception is ``box.space...select``, which may accept either a primary-key value or a secondary-key value."
msgstr ""

#: ../book/box/index.rst:546
msgid "The box library"
msgstr ""

#: ../book/box/index.rst:548
msgid "As well as executing Lua chunks or defining their own functions, users can exploit the Tarantool server's storage functionality with the ``Lua library``."
msgstr ""

#: ../book/box/index.rst:553
msgid "Packages of the box library"
msgstr ""

#: ../book/box/index.rst:555
msgid "The contents of the ``box`` library can be inspected at runtime with ``box``, with no arguments. The packages inside the box library are: ``box.schema``, ``box.tuple``, ``box.space``, ``box.index``, ``net.box``, ``box.cfg``, ``box.info``, ``box.slab``, ``box.stat``. Every package contains one or more Lua functions. A few packages contain members as well as functions. The functions allow data definition (create alter drop), data manipulation (insert delete update upsert select replace), and introspection (inspecting contents of spaces, accessing server configuration)."
msgstr ""

#: ../book/box/index.rst:567
msgid "**Complexity Factors that may affect data manipulation functions in the box library**"
msgstr ""

#: ../book/box/index.rst:574
msgid "Index size"
msgstr ""

#: ../book/box/index.rst:574
msgid "The number of index keys is the same as the number of tuples in the data set. For a TREE index, if there are more keys then the lookup time will be greater, although of course the effect is not linear. For a HASH index, if there are more keys then there is more RAM use, but the number of low-level steps tends to remain constant."
msgstr ""

#: ../book/box/index.rst:582
msgid "Index type"
msgstr ""

#: ../book/box/index.rst:582
msgid "Typically a HASH index is faster than a TREE index if the number of tuples in the tuple set is greater than one."
msgstr ""

#: ../book/box/index.rst:586
msgid "Number of indexes accessed"
msgstr ""

#: ../book/box/index.rst:586
msgid "Ordinarily only one index is accessed to retrieve one tuple. But to update the tuple, there must be N accesses if the tuple set has N different indexes."
msgstr ""

#: ../book/box/index.rst:590
msgid "Number of tuples accessed"
msgstr ""

#: ../book/box/index.rst:590
msgid "A few requests, for example select, can retrieve multiple tuples. This factor is usually less important than the others."
msgstr ""

#: ../book/box/index.rst:594
msgid "WAL settings"
msgstr ""

#: ../book/box/index.rst:594
msgid "The important setting for the write-ahead log is :ref:`wal_mode <wal_mode>`. If the setting causes no writing or delayed writing, this factor is unimportant. If the setting causes every data-change request to wait for writing to finish on a slow device, this factor is more important than all the others."
msgstr ""

#: ../book/box/index.rst:603
msgid "In the discussion of each data-manipulation function there will be a note about which Complexity Factors might affect the function's resource usage."
msgstr ""

#: ../book/box/index.rst:608
msgid "The two storage engines: memtx and sophia"
msgstr ""

#: ../book/box/index.rst:610
msgid "A storage engine is a set of very-low-level routines which actually store and retrieve tuple values. Tarantool offers a choice of two storage engines: memtx (the in-memory storage engine) and sophia (the on-disk storage engine). To specify that the engine should be sophia, add a clause: ``engine = 'sophia'``. The manual concentrates on memtx because it is the default and has been around longer. But sophia is a working key-value engine and will especially appeal to users who like to see data go directly to disk, so that recovery time might be shorter and database size might be larger. For architectural explanations and benchmarks, see `sphia.org`_ and Appendix E: :ref:`sophia <sophia>`. On the other hand, sophia lacks some functions and options that are available with memtx. Where that is the case, the relevant description will contain a note beginning with the words \"Note re storage engine: sophia\". The end of this chapter has coverage for all :ref:`the differeences between memtx and sophia <sophia_diff>`."
msgstr ""

#: ../book/box/index.rst:629
msgid "Library Reference"
msgstr ""

#: ../book/box/limitations.rst:28
msgid "Limitations"
msgstr ""

#: ../book/box/limitations.rst:32
msgid "**Number of parts in an index**"
msgstr ""

#: ../book/box/limitations.rst:34
msgid "For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but the field is an ARRAY. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../book/box/limitations.rst:39
msgid "Note re storage engine: sophia allows 8 parts in an index."
msgstr ""

#: ../book/box/limitations.rst:43
msgid "**Number of indexes in a space**"
msgstr ""

#: ../book/box/limitations.rst:45
msgid "10 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:49
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:51
msgid "The theoretical maximum is 2147483647 (``box.schema.FIELD_MAX``). The practical maximum is whatever is specified by the space's :ref:`field_count <space-object-field-count>` member, or the maximum tuple length."
msgstr ""

#: ../book/box/limitations.rst:58
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../book/box/limitations.rst:60
msgid "By default the value of :confval:`slab_alloc_maximal` is 1048576, and the maximum tuple length is approximately one quarter of that: approximately 262,000 bytes. To increase it, when starting the server, specify a larger value. For example :code:`box.cfg{slab_alloc_maximal=2*1048576}`."
msgstr ""

#: ../book/box/limitations.rst:68
msgid "**Number of spaces**"
msgstr ""

#: ../book/box/limitations.rst:70
msgid "The theoretical maximum is 2147483647 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:74
msgid "**Number of connections**"
msgstr ""

#: ../book/box/limitations.rst:76
msgid "The practical limit is the number of file descriptors that one can set with the operating system."
msgstr ""

#: ../book/box/limitations.rst:81
msgid "**Space size**"
msgstr ""

#: ../book/box/limitations.rst:83
msgid "The total maximum size for all spaces is in effect set by :confval:`slab_alloc_arena`, which in turn is limited by the total available memory."
msgstr ""

#: ../book/box/limitations.rst:89
msgid "**Update operations count**"
msgstr ""

#: ../book/box/limitations.rst:91
msgid "The maximum number of operations that can be in a single update is 4000 (``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:96
msgid "**Number of users and roles**"
msgstr ""

#: ../book/box/limitations.rst:98
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../book/box/limitations.rst:102
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../book/box/limitations.rst:104
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../book/box/limitations.rst:108
msgid "For additional limitations which apply only to the sophia storage engine, see section :ref:`Differences between memtx and sophia <sophia_diff>`."
msgstr ""

#: ../book/box/sophia_diff.rst:30
msgid "Differences between memtx and sophia storage engines"
msgstr ""

#: ../book/box/sophia_diff.rst:32
msgid "The primary difference between memtx and sophia is that memtx is an \"in-memory\" engine while sophia is an \"on-disk\" engine. An in-memory storage engine is generally faster, and the memtx engine is justifiably the default for Tarantool, but there are two situations where an on-disk engine such as sophia would be preferable: (1) when the database is larger than the available memory and adding more memory is not a realistic option; (2) when the server frequently goes down due to errors or a simple desire to save power -- bringing the server back up and restoring a memtx database into memory takes time."
msgstr ""

#: ../book/box/sophia_diff.rst:44
msgid "Here are behavior differences which affect programmers. All of these differences have been noted elsewhere in sentences that begin with the words \"Note re storage engine: sophia\"."
msgstr ""

#: ../book/box/sophia_diff.rst:48
msgid "With memtx, the maximum number of indexes per space is 10. |br| With sophia, the maximum is 1, that is, only primary indexes are supported. Since primary indexes are always unique, it follows that sophia indexes must be unique."
msgstr ""

#: ../book/box/sophia_diff.rst:52
msgid "With memtx, the maximum number of (TREE) index-key parts is 255. |br| With sophia, the maximum is 8."
msgstr ""

#: ../book/box/sophia_diff.rst:55
msgid "With memtx, the index type can be TREE or HASH or RTREE or BITSET. |br| With sophia, the only index type is TREE."
msgstr ""

#: ../book/box/sophia_diff.rst:58
msgid "With memtx, field numbers for index parts may be in any order. |br| With sophia, they must be in order, with no gaps, starting with field number 1."
msgstr ""

#: ../book/box/sophia_diff.rst:61
msgid "With memtx, for index searches, ``nil`` is considered to be equal to any scalar key-part. |br| With memtx, ``nil`` or missing parts are not allowed."
msgstr ""

#: ../book/box/sophia_diff.rst:64
msgid "With memtx, temporary spaces are supported. |br| With sophia, they are not."
msgstr ""

#: ../book/box/sophia_diff.rst:67
msgid "With memtx, the :ref:`alter() <index_alter>` and :ref:`count() <index_count>` and :ref:`min() <index_min>` and :ref:`max() <index_max>` and :ref:`random() <index_random>` and :ref:`auto_increment() <space_auto_increment>` and :ref:`truncate() <space_truncate>` functions are supported. |br| With sophia, they are not."
msgstr ""

#: ../book/box/sophia_diff.rst:73
msgid "With memtx, insert and replace and update will return a tuple, if successful. |br| With sophia, insert and replace and update will return nil."
msgstr ""

#: ../book/box/sophia_diff.rst:76
msgid "With memtx, the REQ (reverse equality) comparison-operator is supported. |br| With sophia, it is not. (This is a minor matter because on a unique index EQ and REQ do the same thing.)"
msgstr ""

#: ../book/box/sophia_diff.rst:80
msgid "It was explained :ref:`earlier <yields_must_happen>` that memtx does not \"yield\" on a select request, it yields only on data-change requests. However, sophia does yield on a select request, or on an equivalent such as get() or pairs(). This has significance for :ref:`cooperative multitasking <cooperative_multitasking>`."
msgstr ""

#: ../book/box/sophia_diff.rst:85
msgid "For more about sophia, see Appendix E :ref:`sophia <sophia>`."
msgstr ""

#: ../book/box/triggers.rst:30
msgid "Triggers"
msgstr ""

#: ../book/box/triggers.rst:32
msgid "Triggers, also known as callbacks, are functions which the server executes when certain events happen. Currently the main types of triggers are `connection triggers`_, which are executed when a session begins or ends, and `replace triggers`_ which are for database events."
msgstr ""

#: ../book/box/triggers.rst:37
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../book/box/triggers.rst:39
msgid "They associate a `function` with an `event`. The request to \"define a trigger\" consists of passing the name of the trigger's function to one of the \":samp:`on_{event-name}()`\" functions: :code:`on_connect()`, :code:`on_auth()`, :code:`on_disconnect()`, or :code:`on_replace()`."
msgstr ""

#: ../book/box/triggers.rst:43
msgid "They are `defined by any user`. There are no privilege requirements for defining triggers."
msgstr ""

#: ../book/box/triggers.rst:45
msgid "They are called `after` the event. They are not called if the event ends prematurely due to an error. (Exception: :code:`on_auth()` is called before the event.)"
msgstr ""

#: ../book/box/triggers.rst:47
msgid "They are in `server memory`. They are not stored in the database. Triggers disappear when the server is shut down. If there is a requirement to make them permanent, then the function definitions and trigger settings should be part of an initialization script."
msgstr ""

#: ../book/box/triggers.rst:51
msgid "They have `low overhead`. If a trigger is not defined, then the overhead is minimal: merely a pointer dereference and check. If a trigger is defined, then its overhead is equivalent to the overhead of calling a stored procedure."
msgstr ""

#: ../book/box/triggers.rst:54
msgid "They can be `multiple` for one event. Triggers are executed in the reverse order that they were defined in."
msgstr ""

#: ../book/box/triggers.rst:56
msgid "They must work `within the event context`. If the function contains requests which normally could not occur immediately after the event but before the return from the event, effects are undefined. For example, putting ``os.exit()`` or ``box.rollback()`` in a trigger function would be bringing in requests outside the event context."
msgstr ""

#: ../book/box/triggers.rst:61
msgid "They are `replaceable`. The request to \"redefine a trigger\" consists of passing the names of a new trigger function and an old trigger function to one of the \"on `event-name` ...\" functions."
msgstr ""

#: ../book/box/triggers.rst:67
msgid "Connection triggers"
msgstr ""

#: ../book/box/triggers.rst:71
msgid "Define a trigger for execution when a new session is created due to an event such as :func:`console.connect`. The trigger function will be the first thing executed after a new session is created. If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:76
#: ../book/box/triggers.rst:103
#: ../book/box/triggers.rst:173
#: ../book/box/triggers.rst:203
msgid "function which will become the trigger function"
msgstr ""

#: ../book/box/triggers.rst:77
#: ../book/box/triggers.rst:104
#: ../book/box/triggers.rst:174
#: ../book/box/triggers.rst:204
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../book/box/triggers.rst:78
#: ../book/box/triggers.rst:105
#: ../book/box/triggers.rst:205
msgid "nil or function list"
msgstr ""

#: ../book/box/triggers.rst:80
#: ../book/box/triggers.rst:107
#: ../book/box/triggers.rst:177
#: ../book/box/triggers.rst:207
msgid "If the parameters are (nil, old-trigger-function-name), then the old trigger is deleted."
msgstr ""

#: ../book/box/triggers.rst:84
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../book/box/triggers.rst:93
msgid "If a trigger always results in an error, it may become impossible to connect to the server to reset it."
msgstr ""

#: ../book/box/triggers.rst:98
msgid "Define a trigger for execution after a client has disconnected. If the trigger function causes an error, the error is logged but otherwise is ignored. The trigger is invoked while the session associated with the client still exists and can access session properties, such as box.session.id."
msgstr ""

#: ../book/box/triggers.rst:111
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../book/box/triggers.rst:122
msgid "After the following series of requests, the server will write a message using the :mod:`log` package whenever any user connects or disconnects."
msgstr ""

#: ../book/box/triggers.rst:125
msgid "function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box.session.id()\n"
"  log.info(m)\n"
"end\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../book/box/triggers.rst:140
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../book/box/triggers.rst:142
msgid "2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../book/box/triggers.rst:151
msgid "Authentication triggers"
msgstr ""

#: ../book/box/triggers.rst:155
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../book/box/triggers.rst:157
msgid "The on_auth trigger function is invoked in these circumstances: (1) The :func:`console.connect` function includes an authentication check for all users except 'guest'; for this case the on_auth trigger function is invoked after the on_connect trigger function, if and only if the connection has succeeded so far. (2) The binary protocol has a separate :ref:`authentication packet <iproto-authentication>` -- for this case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../book/box/triggers.rst:164
msgid "Unlike other trigger types, on_auth trigger functions are invoked `before` the event. Therefore a trigger function like :code:`function auth_function () v = box.session.user(); end` will set :code:`v` to \"guest\", the user name before the authentication is done. To get the user name after the authentication is done, use the special syntax: :code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../book/box/triggers.rst:170
msgid "If the trigger fails by raising an error, the error is sent to the client and the connection is closed."
msgstr ""

#: ../book/box/triggers.rst:181
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../book/box/triggers.rst:191
msgid "Replace triggers"
msgstr ""

#: ../book/box/triggers.rst:199
msgid "Create a \"``replace trigger``\". The ``function-name`` will be executed whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../book/box/triggers.rst:211
msgid "tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../book/box/triggers.rst:220
msgid "At the time that a trigger is defined, it is automatically enabled - that is, it will be executed. Replace triggers can be disabled with :samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../book/box/triggers.rst:229
msgid "tarantool> box.space.X:run_triggers(false)"
msgstr ""

#: ../book/box/triggers.rst:238
msgid "The following series of requests will create a space, create an index, create a function which increments a counter, create a trigger, do two inserts, drop the space, and display the counter value - which is 2, because the function is executed once after each insert."
msgstr ""

#: ../book/box/triggers.rst:243
msgid "tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'NUM'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../book/box/triggers.rst:259
msgid "Another Example"
msgstr ""

#: ../book/box/triggers.rst:261
msgid "The following series of requests will associate an existing function named F with an existing space named T, associate the function a second time with the same space (so it will be called twice), disable all triggers of T, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../book/box/triggers.rst:266
msgid "tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../book/box/triggers.rst:276
msgid "Getting a list of triggers"
msgstr ""

#: ../book/box/triggers.rst:278
msgid "The code :code:`on_connect()` -- with no arguments -- returns a table of all connect-trigger functions; :code:`on_auth()` returns all authentication-trigger functions; :code:`on_disconnect()` returns all disconnect-trigger functions; :code:`on_replace()` returns all replace-trigger functions. In the following example a user finds that there are three functions associated with :code:`on_connect` triggers, and executes the third function, which happens to contain the line \"print('function #3')\". Then it deletes the third trigger."
msgstr ""

#: ../book/box/triggers.rst:289
msgid "tarantool> box.session.on_connect()\n"
"---\n"
"- - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ab6f8'\n"
"  - 'function: 0x416ad800'\n"
"...\n"
"\n"
"tarantool> box.session.on_connect()[3]()\n"
"function #3\n"
"---\n"
"...\n"
"tarantool> box.session.on_connect(nil, box.session.on_connect()[3])\n"
"---\n"
"..."
msgstr ""

#: ../book/configuration/index.rst:30
msgid "Configuration reference"
msgstr ""

#: ../book/configuration/index.rst:32
msgid "This chapter provides a reference of options which can be set on the command line or in an initialization file."
msgstr ""

#: ../book/configuration/index.rst:38
msgid "Tarantool is started by entering the command:"
msgstr ""

#: ../book/configuration/index.rst:43
msgid "$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../book/configuration/index.rst:51
msgid "Command options"
msgstr ""

#: ../book/configuration/index.rst:55
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../book/configuration/index.rst:61
msgid "Print product name and version, for example:"
msgstr ""

#: ../book/configuration/index.rst:63
msgid "$ ./tarantool --version\n"
"Tarantool 1.6.8-235-gb948587\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../book/configuration/index.rst:70
msgid "In this example:"
msgstr ""

#: ../book/configuration/index.rst:72
msgid "“Tarantool” is the name of the reusable asynchronous networking programming framework."
msgstr ""

#: ../book/configuration/index.rst:75
msgid "The 3-number version follows the standard ``<major>-<minor>-<patch>`` scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` is incremented for each new milestone and indicates possible incompatible changes, and ``<patch>`` stands for the number of bug fix releases made after the start of the milestone. For non-released versions only, there may be a commit number and commit SHA1 to indicate how much this particular build has diverged from the last release."
msgstr ""

#: ../book/configuration/index.rst:83
msgid "“Target” is the platform tarantool was built on. Some platform-specific details may follow this line."
msgstr ""

#: ../book/configuration/index.rst:88
msgid "Tarantool uses `git describe`_ to produce its version id, and this id can be used at any time to check out the corresponding source from our `git repository`_."
msgstr ""

#: ../book/configuration/index.rst:99
msgid "URI"
msgstr ""

#: ../book/configuration/index.rst:101
msgid "Some configuration parameters and some functions depend on a URI, or \"Universal Resource Identifier\". The URI string format is similar to the `generic syntax for a URI schema`_. So it may contain (in order) a user name for login, a password, a host name or host IP address, and a port number. Only the port number is always mandatory. The password is mandatory if the user name is specified, unless the user name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or ``[username:password@]host:port``. If host is omitted, then 'localhost' is assumed. If username:password is omitted, then 'guest' is assumed. Some examples:"
msgstr ""

#: ../book/configuration/index.rst:119
msgid "URI fragment"
msgstr ""

#: ../book/configuration/index.rst:121
msgid "port"
msgstr ""

#: ../book/configuration/index.rst:121
msgid "3301"
msgstr ""

#: ../book/configuration/index.rst:123
msgid "host:port"
msgstr ""

#: ../book/configuration/index.rst:123
msgid "127.0.0.1:3301"
msgstr ""

#: ../book/configuration/index.rst:125
msgid "username:password@host:port"
msgstr ""

#: ../book/configuration/index.rst:125
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../book/configuration/index.rst:128
msgid "In certain circumstances a Unix domain socket may be used where a URI is expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply \"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../book/configuration/index.rst:136
msgid "Initialization file"
msgstr ""

#: ../book/configuration/index.rst:138
msgid "If the command to start Tarantool includes :codeitalic:`lua-initialization-file`, then Tarantool begins by invoking the Lua program in the file, which by convention may have the name \"``script.lua``\". The Lua program may get further arguments from the command line or may use operating-system functions, such as ``getenv()``. The Lua program almost always begins by invoking ``box.cfg()``, if the database server will be used or if ports need to be opened. For example, suppose ``script.lua`` contains the lines"
msgstr ""

#: ../book/configuration/index.rst:146
msgid "#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../book/configuration/index.rst:157
msgid "and suppose the environment variable LISTEN_URI contains 3301, and suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``. Then the screen might look like this:"
msgstr ""

#: ../book/configuration/index.rst:161
msgid "$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.6.3-439-g7e1011b\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../book/configuration/index.rst:175
msgid "If one wishes to start an interactive session on the same terminal after initialization is complete, one can use :func:`console.start()`."
msgstr ""

#: ../book/configuration/index.rst:190
msgid "Configuration parameters"
msgstr ""

#: ../book/configuration/index.rst:192
msgid "Configuration parameters have the form:"
msgstr ""

#: ../book/configuration/index.rst:197
msgid "box.cfg{ *key = value* [, *key = value* ...]]"
msgstr ""

#: ../book/configuration/index.rst:199
msgid "Since ``box.cfg`` may contain many configuration parameters and since some of the parameters (such as directory addresses) are semi-permanent, it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../book/configuration/index.rst:204
msgid "Most configuration parameters are for allocating resources, opening ports, and specifying database behavior. All parameters are optional. A few parameters are dynamic, that is, they can be changed at runtime by calling ``box.cfg{}`` a second time."
msgstr ""

#: ../book/configuration/index.rst:209
msgid "To see all the non-null parameters, say ``box.cfg`` (no parentheses). To see a particular parameter, for example the listen address, say ``box.cfg.listen``."
msgstr ""

#: ../book/configuration/index.rst:212
msgid "The following sections describe all parameters for basic operation, for storage, for binary logging and snapshots, for replication, for networking, and for logging."
msgstr ""

#: ../book/configuration/index.rst:217
msgid "Basic parameters"
msgstr ""

#: ../book/configuration/cfg-basic.rst:1
msgid ":confval:`username`, |br| :confval:`work_dir`, |br| :confval:`wal_dir`, |br| :confval:`snap_dir`, |br| :confval:`sophia_dir`, |br| :confval:`coredump`, |br| :confval:`listen`, |br| :confval:`coredump`, |br| :confval:`pid_file`, |br| :confval:`custom_proc_title`, |br| :confval:`background` |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:15
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../book/configuration/cfg-basic.rst:17
#: ../book/configuration/cfg-basic.rst:28
#: ../book/configuration/cfg-basic.rst:95
#: ../book/configuration/cfg-logging.rst:44
msgid "Type: string |br| Default: null |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:23
msgid "A directory where database working files will be stored. The server switches to work_dir with :manpage:`chdir(2)` after start. Can be relative to the current directory. If not specified, defaults to the current directory."
msgstr ""

#: ../book/configuration/cfg-basic.rst:34
msgid "A directory where write-ahead log (.xlog) files are stored. Can be relative to work_dir. Most commonly used so that snapshot files and write-ahead log files can be stored on separate disks. If not specified, defaults to work_dir."
msgstr ""

#: ../book/configuration/cfg-basic.rst:39
#: ../book/configuration/cfg-basic.rst:48
msgid "Type: string |br| Default: \".\" |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:45
msgid "A directory where snapshot (.snap) files will be stored. Can be relative to work_dir. If not specified, defaults to work_dir. See also :confval:`wal_dir`."
msgstr ""

#: ../book/configuration/cfg-basic.rst:54
msgid "A directory where sophia files will be stored. Can be relative to :confval:`work_dir`. If not specified, defaults to :file:`work_dir`."
msgstr ""

#: ../book/configuration/cfg-basic.rst:57
msgid "Type: string |br| Default: \"sophia\" |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:63
msgid "Deprecated. Do not use."
msgstr ""

#: ../book/configuration/cfg-basic.rst:65
#: ../book/configuration/cfg-basic.rst:128
msgid "Type: boolean |br| Default: false |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:73
msgid "The read/write data port number or :ref:`URI` (Universal Resource Identifier) string. Has no default value, so **must be specified** if connections will occur from remote clients that do not use “admin address” (the administrative host and port)."
msgstr ""

#: ../book/configuration/cfg-basic.rst:78
msgid "A typical value is 3301. The listen parameter may also be set for :ref:`local hot standby <book-cfg-local_hot_standy>`."
msgstr ""

#: ../book/configuration/cfg-basic.rst:83
msgid "A replica also binds to this port, and accepts connections, but these connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../book/configuration/cfg-basic.rst:86
msgid "Type: integer or string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:92
msgid "Store the process id in this file. Can be relative to :confval:`work_dir`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../book/configuration/cfg-basic.rst:101
msgid "Add the given string to the server's :ref:`Process title <book-proctitle>` (what’s shown in the COMMAND column for :samp:`ps -ef` and :samp:`top -c` commands)."
msgstr ""

#: ../book/configuration/cfg-basic.rst:104
msgid "For example, ordinarily :samp:`ps` shows the Tarantool server process thus:"
msgstr ""

#: ../book/configuration/cfg-basic.rst:106
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../book/configuration/cfg-basic.rst:111
msgid "But if the configuration parameters include ``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../book/configuration/cfg-basic.rst:114
msgid "$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: sessions"
msgstr ""

#: ../book/configuration/cfg-basic.rst:119
msgid "Type: string |br| Default: null |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg-basic.rst:125
msgid "Run the server as a background task. The :ref:`logger <log-label>` and :confval:`pid_file` parameters must be non-null for this to work."
msgstr ""

#: ../book/configuration/index.rst:223
msgid "Configuring the storage"
msgstr ""

#: ../book/configuration/cfg-storage.rst:1
msgid ":confval:`slab_alloc_arena`, |br| :confval:`slab_alloc_minimal`, |br| :confval:`slab_alloc_maximal`, |br| :confval:`slab_alloc_factor`, |br| :confval:`sophia` |br|"
msgstr ""

#: ../book/configuration/cfg-storage.rst:9
msgid "How much memory Tarantool allocates to actually store tuples, in gigabytes. When the limit is reached, INSERT or UPDATE requests begin failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the defined limit to allocate tuples, there is additional memory used to store indexes and connection information. Depending on actual configuration and workload, Tarantool can consume up to 20% more than the limit set here."
msgstr ""

#: ../book/configuration/cfg-storage.rst:16
msgid "Type: float |br| Default: 1.0 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-storage.rst:22
msgid "Size of the smallest allocation unit. It can be tuned down if most of the tuples are very small"
msgstr ""

#: ../book/configuration/cfg-storage.rst:25
msgid "Type: integer |br| Default: 64 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-storage.rst:31
msgid "Size of the largest allocation unit. It can be tuned up if it is necessary to store large tuples."
msgstr ""

#: ../book/configuration/cfg-storage.rst:34
msgid "Type: integer |br| Default: 1048576 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-storage.rst:40
msgid "Use slab_alloc_factor as the multiplier for computing the sizes of memory chunks that tuples are stored in. A lower value may result in less wasted memory depending on the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../book/configuration/cfg-storage.rst:45
msgid "Type: float |br| Default: 1.1 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-storage.rst:51
msgid "The default sophia configuration can be changed with"
msgstr ""

#: ../book/configuration/cfg-storage.rst:415
msgid "sophia = {\n"
"  page_size = *number*,\n"
"  threads = *number*,\n"
"  node_size = *number*,\n"
"  memory_limit = *number*,\n"
"}"
msgstr ""

#: ../book/configuration/cfg-storage.rst:63
msgid "This method may change in the future."
msgstr ""

#: ../book/configuration/cfg-storage.rst:65
msgid "Type: table |br| Default: (see above) |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/index.rst:231
msgid "Snapshot daemon"
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:4
msgid "The snapshot daemon is a fiber which is constantly running. At intervals, it may make new snapshot (.snap) files and then may remove old snapshot files. If the snapshot daemon removes an old snapshot file, it will also remove any write-ahead log (.xlog) files that are older than the snapshot file and contain information that is present in the snapshot file."
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:12
msgid "The :confval:`snapshot_period` and :confval:`snapshot_count` configuration settings determine how long the intervals are, and how many snapshots should exist before removals occur."
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:18
msgid "The interval between actions by the snapshot daemon, in seconds. If ``snapshot_period`` is set to a value greater than zero, and there is activity which causes change to a database, then the snapshot daemon will call :func:`box.snapshot` every ``snapshot_period`` seconds, creating a new snapshot file each time."
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:24
msgid "For example: ``box.cfg{snapshot_period=3600}`` will cause the snapshot daemon to create a new database snapshot once per hour."
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:28
msgid "Type: integer |br| Default: 0 |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:34
msgid "The maximum number of snapshots that may exist on the snap_dir directory before the snapshot daemon will remove old snapshots. If snapshot_count equals zero, then the snapshot daemon does not remove old snapshots. For example:"
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:40
msgid "box.cfg{\n"
"    snapshot_period = 3600,\n"
"    snapshot_count  = 10\n"
"}"
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:47
msgid "will cause the snapshot daemon to create a new snapshot each hour until it has created ten snapshots. After that, it will remove the oldest snapshot (and any associated write-ahead-log files) after creating a new one."
msgstr ""

#: ../book/configuration/cfg-snapshot_daemon.rst:52
msgid "Type: integer |br| Default: 6 |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/index.rst:237
msgid "Binary logging and snapshots"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:1
msgid ":confval:`panic_on_snap_error`, |br| :confval:`panic_on_wal_error`, |br| :confval:`rows_per_wal`, |br| :confval:`snap_io_rate_limit`, |br| :confval:`wal_mode`, |br| :confval:`wal_dir_rescan_delay` |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:10
msgid "If there is an error while reading the snapshot file (at server start), abort."
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:13
#: ../book/configuration/cfg-logging.rst:56
msgid "Type: boolean |br| Default: true |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:19
msgid "If there is an error while reading a write-ahead log file (at server start or to relay to a replica), abort."
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:22
msgid "Type: boolean |br| Default: true |br| Dynamic: yes |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:28
msgid "How many log records to store in a single write-ahead log file. When this limit is reached, Tarantool creates another WAL file named :samp:`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based backups."
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:33
msgid "Type: integer |br| Default: 500000 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:39
msgid "Reduce the throttling effect of :func:`box.snapshot` on INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes per second it can write to disk. The same can be achieved by splitting :confval:`wal_dir` and :confval:`snap_dir` locations and moving snapshots to a separate disk."
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:45
#: ../book/configuration/cfg-networking.rst:11
msgid "Type: float |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:51
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:53
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:54
msgid "``write``: fibers wait for their data to be written to the write-ahead log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:56
msgid "``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each :manpage:`write(2)`;"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:59
msgid "Type: string |br| Default: \"write\" |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:65
msgid "Number of seconds between periodic scans of the write-ahead-log file directory, when checking for changes to write-ahead-log files for the sake of replication or local hot standby."
msgstr ""

#: ../book/configuration/cfg-binary_logging_snapshots.rst:69
msgid "Type: float |br| Default: 2 |br| Dynamic: no |br|"
msgstr ""

#: ../book/configuration/index.rst:243
#: ../book/replication/index.rst:30
msgid "Replication"
msgstr ""

#: ../book/configuration/cfg-replication.rst:3
msgid "If replication_source is not an empty string, the server is considered to be a Tarantool replica. The replica server will try to connect to the master which replication_source specifies with a :ref:`URI` (Universal Resource Identifier), for example :samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`."
msgstr ""

#: ../book/configuration/cfg-replication.rst:8
msgid "The default user name is ‘guest’. A replica server does not accept data-change requests on the :confval:`listen` port. The replication_source parameter is dynamic, that is, to enter master mode, simply set replication_source to an empty string and issue :code:`box.cfg{replication_source=`:samp:`{new-value}`:code:`}`."
msgstr ""

#: ../book/configuration/cfg-replication.rst:14
msgid "Type: string |br| Default: null |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/index.rst:249
msgid "Networking"
msgstr ""

#: ../book/configuration/cfg-networking.rst:1
msgid ":confval:`io_collect_interval`, |br| :confval:`readahead`  |br|"
msgstr ""

#: ../book/configuration/cfg-networking.rst:6
msgid "The server will sleep for io_collect_interval seconds between iterations of the event loop. Can be used to reduce CPU load in deployments in which the number of client connections is large, but requests are not so frequent (for example, each connection issues just a handful of requests per second)."
msgstr ""

#: ../book/configuration/cfg-networking.rst:17
msgid "The size of the read-ahead buffer associated with a client connection. The larger the buffer, the more memory an active connection consumes and the more requests can be read from the operating system buffer in a single system call. The rule of thumb is to make sure the buffer can contain at least a few dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few kilobytes or even megabytes, the read-ahead buffer size should be increased. If batched request processing is not used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../book/configuration/cfg-networking.rst:26
msgid "Type: integer |br| Default: 16320 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/index.rst:255
msgid "Logging"
msgstr ""

#: ../book/configuration/cfg-logging.rst:1
msgid ":confval:`log_level`, |br| :confval:`logger`, |br| :confval:`logger_nonblock`, |br| :confval:`too_long_threshold` |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:8
msgid "How verbose the logging is. There are six log verbosity classes:"
msgstr ""

#: ../book/configuration/cfg-logging.rst:10
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:11
msgid "2 – ``ERROR``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:12
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:13
msgid "4 – ``WARNING``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:14
msgid "5 – ``INFO``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:15
msgid "6 – ``DEBUG``"
msgstr ""

#: ../book/configuration/cfg-logging.rst:17
msgid "By setting log_level, one can enable logging of all classes below or equal to the given level. Tarantool prints its logs to the standard error stream by default, but this can be changed with the :ref:`logger <log-label>` configuration parameter."
msgstr ""

#: ../book/configuration/cfg-logging.rst:22
msgid "Type: integer |br| Default: 5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:30
msgid "By default, the log is sent to the standard error stream (``stderr``). If ``logger`` is specified, the log is sent to the file named in the string. Example setting: |br| box.cfg{logger = 'tarantool.log' } |br| This will open :file:`tarantool.log` for output on the server’s default directory. If ``logger`` string begins with a pipe, for example |br| box.cfg{logger = '| cronolog tarantool.log' } |br| the program specified in the option (in this case, cronolog) is executed at server start and all log messages are sent to the standard input (``stdin``) of cronolog."
msgstr ""

#: ../book/configuration/cfg-logging.rst:40
msgid "When logging to a file, tarantool reopens the log on SIGHUP. When log is a program, its pid is saved in :func:`log.logger_pid` variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../book/configuration/cfg-logging.rst:50
msgid "If ``logger_nonblock`` equals true, Tarantool does not block on the log file descriptor when it’s not ready for write, and drops the message instead. If :confval:`log_level` is high, and a lot of messages go to the log file, setting ``logger_nonblock`` to true may improve logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../book/configuration/cfg-logging.rst:62
msgid "If processing a request takes longer than the given value (in seconds), warn about it in the log. Has effect only if :confval:`log_level` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../book/configuration/cfg-logging.rst:66
msgid "Type: float |br| Default: 0.5 |br| Dynamic: **yes** |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:72
msgid "**Logging Example:**"
msgstr ""

#: ../book/configuration/cfg-logging.rst:74
msgid "This will illustrate how \"rotation\" works, that is, what happens when the server is writing to a log and signals are used when archiving it."
msgstr ""

#: ../book/configuration/cfg-logging.rst:77
msgid "Start with two terminal shells, Terminal #1 and Terminal#2."
msgstr ""

#: ../book/configuration/cfg-logging.rst:79
msgid "On Terminal#1: start an interactive Tarantool session, then say the logging will go to \"Log_file\", then put a message \"Log Line #1\" in the log file:"
msgstr ""

#: ../book/configuration/cfg-logging.rst:82
msgid "box.cfg{logger='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../book/configuration/cfg-logging.rst:88
msgid "On Terminal#2: use :codenormal:`mv` so the log file is now named \"Log_file.bak\". The result of this is: the next log message will go to Log_file.bak. |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:731
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../book/configuration/cfg-logging.rst:96
msgid "On Terminal#1: put a message \"Log Line #2\" in the log file. |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:98
msgid "log.info('Log Line #2')"
msgstr ""

#: ../book/configuration/cfg-logging.rst:102
msgid "On Terminal#2: use :codenormal:`ps` to find the process ID of the Tarantool server. |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:744
msgid "ps -A | grep tarantool"
msgstr ""

#: ../book/configuration/cfg-logging.rst:109
msgid "On Terminal#2: use 'kill -HUP' to send a SIGHUP signal to the Tarantool server. The result of this is: Tarantool will open Log_file again, and the next log message will go to Log_file. (The same effect could be accomplished by executing log.rotate() on the server.) |br|"
msgstr ""

#: ../book/configuration/cfg-logging.rst:754
msgid "kill -HUP *process_id*"
msgstr ""

#: ../book/configuration/cfg-logging.rst:119
msgid "On Terminal#1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../book/configuration/cfg-logging.rst:121
msgid "log.info('Log Line #3')"
msgstr ""

#: ../book/configuration/cfg-logging.rst:125
msgid "On Terminal#2: use 'less' to examine files. Log_file.bak will have these lines, except that the date and time will depend on when the example is done:"
msgstr ""

#: ../book/configuration/cfg-logging.rst:768
msgid "2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../book/configuration/cfg-logging.rst:134
msgid "and Log_file will have"
msgstr ""

#: ../internal padding after book/configuration/cfg-logging.rst:776
msgid "log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../book/configuration/index.rst:263
msgid "Local hot standby"
msgstr ""

#: ../book/configuration/index.rst:265
msgid "Local hot standby is a feature which provides a simple form of failover without replication. To initiate it, start a second instance of the Tarantool server on the same computer with the same :func:`box.cfg` configuration settings - including the same directories and same non-null URIs. A warning should appear with a message like"
msgstr ""

#: ../book/configuration/index.rst:271
msgid "W> primary: [URI] is already in use, will retry binding after [n] seconds"
msgstr ""

#: ../book/configuration/index.rst:275
msgid "This is fine. It means that the second instance is ready to take over if the first instance goes down."
msgstr ""

#: ../book/configuration/index.rst:278
msgid "The expectation is that there will be two instances of the server using the same configuration. The first one to start will be the \"primary\" instance. The second one to start will be the \"standby\" instance. The standby instance will initialize and will try to connect on listen address, but will fail because the primary instance has already taken it. So the standby instance goes into a loop, reading the write ahead log which the primary instance is writing (so the two instances are always in synch), and trying to connect on the port. If the primary instance goes down for any reason, the port will become free so the standby instance will succeed in connecting, and will become the primary instance. Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../book/configuration/index.rst:290
msgid "If this local_hot_standby feature is being used, then wal_mode should not be equal to \"none\"."
msgstr ""

#: ../book/connectors/index.rst:30
msgid "Connectors"
msgstr ""

#: ../book/connectors/index.rst:32
msgid "This chapter documents APIs for various programming languages."
msgstr ""

#: ../book/connectors/index.rst:36
msgid "Protocol"
msgstr ""

#: ../book/connectors/index.rst:38
msgid "Tarantool protocol was designed with a focus on asynchronous I/O and easy integration with proxies. Each client request starts with a variable-length binary header, containing request id, request type, server id, log sequence number, and so on."
msgstr ""

#: ../book/connectors/index.rst:42
msgid "The mandatory length, present in request header simplifies client or proxy I/O. A response to a request is sent to the client as soon as it is ready. It always carries in its header the same type and id as in the request. The id makes it possible to match a request to a response, even if the latter arrived out of order."
msgstr ""

#: ../book/connectors/index.rst:47
msgid "Unless implementing a client driver, one needn't concern oneself with the complications of the binary protocol. Language-specific drivers provide a friendly way to store domain language data structures in Tarantool. A complete description of the binary protocol is maintained in annotated Backus-Naur form in the source tree: please see :ref:`iproto protocol`."
msgstr ""

#: ../book/connectors/index.rst:55
msgid "Packet example"
msgstr ""

#: ../book/connectors/index.rst:57
msgid "The Tarantool API exists so that a client program can send a request packet to the server, and receive a response. Here is an example of a what the client would send for :code:`box.space[513]:insert{'A', 'BB'}`. The BNF description of the components is in file :ref:`iproto protocol`."
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Component"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #0"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #1"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #2"
msgstr ""

#: ../book/connectors/index.rst:72
msgid "Byte #3"
msgstr ""

#: ../book/connectors/index.rst:74
msgid "code for insert"
msgstr ""

#: ../book/connectors/index.rst:74
#: ../book/connectors/index.rst:78
msgid "02"
msgstr ""

#: ../book/connectors/index.rst:76
msgid "rest of header"
msgstr ""

#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
#: ../book/connectors/index.rst:76
#: ../book/user_guide_getting_started.rst:233
msgid "..."
msgstr ""

#: ../book/connectors/index.rst:78
msgid "2-digit number: space id"
msgstr ""

#: ../book/connectors/index.rst:78
msgid "cd"
msgstr ""

#: ../book/connectors/index.rst:78
msgid "01"
msgstr ""

#: ../book/connectors/index.rst:80
msgid "code for tuple"
msgstr ""

#: ../book/connectors/index.rst:80
msgid "21"
msgstr ""

#: ../book/connectors/index.rst:82
msgid "1-digit number: field count = 2"
msgstr ""

#: ../book/connectors/index.rst:82
msgid "92"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "1-character string: field[1]"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "a1"
msgstr ""

#: ../book/connectors/index.rst:84
msgid "41"
msgstr ""

#: ../book/connectors/index.rst:86
msgid "2-character string: field[2]"
msgstr ""

#: ../book/connectors/index.rst:86
msgid "a2"
msgstr ""

#: ../book/connectors/index.rst:86
#: ../book/connectors/index.rst:86
msgid "42"
msgstr ""

#: ../book/connectors/index.rst:89
msgid "Now, one could send that packet to the tarantool server, and interpret the response (:ref:`iproto protocol` has a description of the packet format for responses as well as requests). But it would be easier, and less error-prone, if one could invoke a routine that formats the packet according to typed parameters. Something like :code:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. And that is why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""

#: ../book/connectors/index.rst:100
msgid "Setting up the server for connector examples"
msgstr ""

#: ../book/connectors/index.rst:102
msgid "This chapter has examples that show how to connect to the Tarantool server via the Perl, PHP, Python, and C connectors. The examples contain hard code that will work if and only if the server (tarantool) is running on localhost (127.0.0.1) and is listening on port 3301 (:code:`box.cfg.listen = '3301'`) and space 'examples' has id = 999 (:code:`box.space.examples.id = 999`), and space 'examples' has a primary-key index for a numeric field (:code:`box.space[999].index[0].parts[1].type = \"NUM\"`) and user 'guest' has privileges for reading and writing."
msgstr ""

#: ../book/connectors/index.rst:110
msgid "It is easy to meet all the conditions by starting the server and executing this script:"
msgstr ""

#: ../book/connectors/index.rst:113
msgid "box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""

#: ../book/connectors/__java.rst:3
msgid "Java"
msgstr ""

#: ../book/connectors/__java.rst:5
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr ""

#: ../book/connectors/__go.rst:3
msgid "Go"
msgstr ""

#: ../book/connectors/__go.rst:5
msgid "Please see https://github.com/mialinx/go-tarantool-1.6."
msgstr ""

#: ../book/connectors/__perl.rst:3
msgid "Perl"
msgstr ""

#: ../book/connectors/__perl.rst:5
msgid "The most commonly used Perl driver is `DR::Tarantool`_. It is not supplied as part of the Tarantool repository; it must be installed separately. The most common way to install it is with `CPAN, the Comprehensive Perl Archive Network`_. `DR::Tarantool`_ requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr ""

#: ../book/connectors/__perl.rst:11
msgid "$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""

#: ../book/connectors/__perl.rst:22
msgid "Here is a complete Perl program that inserts [99999,'BB'] into space[999] via the Perl API. Before trying to run, check that the server is listening and that :code:`examples` exists, as :ref:`described earlier <connector-setting>`. To run, paste the code into a file named example.pl and say :code:`perl example.pl`. The program will connect using an application-specific definition of the space. The program will open a socket connection with the tarantool server at localhost:3301, then send an INSERT request, then — if all is well — end without displaying any messages. If tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”."
msgstr ""

#: ../book/connectors/__perl.rst:32
msgid "#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is 'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""

#: ../book/connectors/__perl.rst:56
msgid "The example program only shows one command and does not show all that's necessary for good practice. For that, please see `DR::Tarantool`_ CPAN repository."
msgstr ""

#: ../book/connectors/__php.rst:3
msgid "PHP"
msgstr ""

#: ../book/connectors/__php.rst:5
msgid "The PHP driver is `tarantool-php`_. It is not supplied as part of the Tarantool repository; it must be installed separately. It can be installed with git. It requires other modules which should be installed first. For example, on Ubuntu, the installation could look like this:"
msgstr ""

#: ../book/connectors/__php.rst:10
msgid "$ sudo apt-get install php5-cli\n"
"$ sudo apt-get install php5-dev\n"
"$ sudo apt-get install php-pear\n"
"$ cd ~\n"
"$ git clone https://github.com/tarantool/tarantool-php.git\n"
"$ cd tarantool-php\n"
"$ phpize\n"
"$ ./configure\n"
"$ make\n"
"$ # make install is optional"
msgstr ""

#: ../book/connectors/__php.rst:24
msgid "At this point there is a file named :code:`~/tarantool-php/modules/tarantool.so`. PHP will only find it if the PHP initialization file :code:`php.ini` contains a line like :code:`extension=./tarantool.so`, or if PHP is started with the option :code:`-d extension=~/tarantool-php/modules/tarantool.so`."
msgstr ""

#: ../book/connectors/__php.rst:29
msgid "Here is a complete PHP program that inserts [99999,'BB'] into a space named 'examples' via the PHP API. Before trying to run, check that the server is listening and that :code:`examples` exists, as :ref:`described earlier <connector-setting>`. To run, paste the code into a file named example.php and say :code:`php -d extension=~/tarantool-php/modules/tarantool.so example.php`. The program will open a socket connection with the tarantool server at localhost:3301, then send an INSERT request, then — if all is well — print \"Insert succeeded\". If the tuple already exists, the program will print “Duplicate key exists in unique index 'primary' in space 'examples'”."
msgstr ""

#: ../book/connectors/__php.rst:37
msgid "<?php\n"
"$tarantool = new Tarantool(\"localhost\", 3301);\n"
"try {\n"
"  $tarantool->insert(\"examples\", array(99999, \"BB\"));\n"
"  print \"Insert succeeded\\n\";\n"
"  }\n"
"catch (Exception $e) {\n"
"  echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"  }\n"
"?>"
msgstr ""

#: ../book/connectors/__php.rst:50
msgid "The example program only shows one command and does not show all that's necessary for good practice. For that, please see `tarantool-php`_ project at GitHub."
msgstr ""

#: ../book/connectors/__python.rst:3
msgid "Python"
msgstr ""

#: ../book/connectors/__python.rst:5
msgid "Here is a complete Python program that inserts :code:`[99999,'Value','Value']` into space :code:`examples` via the high-level Python API."
msgstr ""

#: ../book/connectors/__python.rst:8
msgid "#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""

#: ../book/connectors/__python.rst:17
msgid "To prepare, paste the code into a file named example.py and install tarantool-python with either :code:`pip install tarantool\\>0.4` to install in :code:`/usr` (requires **root** privilege) or :code:`pip install tarantool\\>0.4 --user` to install in :code:`~` i.e. user's default directory. Before trying to run, check that the server is listening and that examples exists, as :ref:`described earlier <connector-setting>`. To run the program, say :code:`python example.py`. The program will connect to the server, will send the request, and will not throw an exception if all went well. If the tuple already exists, the program will throw :code:`tarantool.error.DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space 'examples'\")`."
msgstr ""

#: ../book/connectors/__python.rst:27
msgid "The example program only shows one request and does not show all that's necessary for good practice. For that, see http://github.com/tarantool/tarantool-python. For an example of a Python API for `Queue managers on Tarantool`_, see https://github.com/tarantool/tarantool-queue-python."
msgstr ""

#: ../book/connectors/__c.rst:3
msgid "C"
msgstr ""

#: ../book/connectors/__c.rst:5
msgid "Here is a complete C program that inserts :code:`[99999,'B']` into space :code:`examples` via the high-level C API."
msgstr ""

#: ../book/connectors/__c.rst:8
msgid "#include <stdio.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../book/connectors/__c.rst:36
msgid "To prepare, paste the code into a file named example.c and install tarantool-c. One way to install tarantool-c (using Ubuntu) is:"
msgstr ""

#: ../book/connectors/__c.rst:39
msgid "$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../book/connectors/__c.rst:49
msgid "To compile and link the program, say:"
msgstr ""

#: ../book/connectors/__c.rst:51
msgid "$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool -ltarantoolnet"
msgstr ""

#: ../book/connectors/__c.rst:57
msgid "Before trying to run, check that the server is listening and that :code:`examples` exists, as :ref:`described earlier <connector-setting>`. To run the program, say :code:`./example`. The program will connect to the server, and will send the request. If tarantool is not running on localhost with listen address = 3301, the program will print “Connection refused”. If the insert fails, the program will print \"Insert failed\" and an error number."
msgstr ""

#: ../book/connectors/__c.rst:64
msgid "Here are notes corresponding to comments in the example program."
msgstr ""

#: ../book/connectors/__c.rst:66
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""

#: ../book/connectors/__c.rst:68
msgid "struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""

#: ../book/connectors/__c.rst:73
msgid "In this program the stream will be named :code:`tnt`. Before connecting on the tnt stream, some options may have to be set. The most important option is TNT_OPT_URI. In this program the URI is ``localhost:3301``, since that is where the Tarantool server is supposed to be listening."
msgstr ""

#: ../book/connectors/__c.rst:79
#: ../book/connectors/__c.rst:95
#: ../book/connectors/__c.rst:123
#: ../book/connectors/__c.rst:142
#: ../book/connectors/__c.rst:167
#: ../book/connectors/__c.rst:186
msgid "Function description:"
msgstr ""

#: ../book/connectors/__c.rst:384
msgid "`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""

#: ../book/connectors/__c.rst:87
msgid "**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a URI, this example program can connect to the server."
msgstr ""

#: ../book/connectors/__c.rst:90
msgid "if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""

#: ../book/connectors/__c.rst:400
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr ""

#: ../book/connectors/__c.rst:102
msgid "The connect might fail for a variety of reasons, such as: the server is not running, or the URI contains an invalid password. If the connect fails, the return value will be -1."
msgstr ""

#: ../book/connectors/__c.rst:106
msgid "**MAKE REQUEST:** Most requests require passing a structured value, such as the contents of a tuple."
msgstr ""

#: ../book/connectors/__c.rst:109
msgid "struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""

#: ../book/connectors/__c.rst:114
msgid "In this program the request will be an insert, and the tuple contents will be an integer and a string. This is a simple serial set of values, that is, there are no sub-structures or arrays. Therefore it is easy in this case to format what will be passed using the same sort of arguments that one would use with a C ``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the integer value, then a pointer to the string value."
msgstr ""

#: ../book/connectors/__c.rst:428
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr ""

#: ../book/connectors/__c.rst:130
msgid "**SEND REQUEST:** The database-manipulation requests are analogous to the requests in the box library."
msgstr ""

#: ../book/connectors/__c.rst:133
msgid "tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""

#: ../book/connectors/__c.rst:138
msgid "In this program the choice is to do an insert request, so the program passes the tnt_stream that was used for connection (:code:`tnt`) and the stream that was set up with tnt_object_format (:code:`tuple`)."
msgstr ""

#: ../book/connectors/__c.rst:447
msgid "ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""

#: ../book/connectors/__c.rst:155
msgid "**GET REPLY:** For most requests the client will receive a reply containing some indication whether the result was successful, and a set of tuples."
msgstr ""

#: ../book/connectors/__c.rst:158
msgid "struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""

#: ../book/connectors/__c.rst:165
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""

#: ../book/connectors/__c.rst:472
msgid "struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""

#: ../book/connectors/__c.rst:176
msgid "**TEARDOWN:** When a session ends, the connection that was made with tnt_connect() should be closed and the objects that were made in the setup should be destroyed."
msgstr ""

#: ../book/connectors/__c.rst:180
msgid "tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""

#: ../book/connectors/__c.rst:491
msgid "void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""

#: ../book/connectors/__c.rst:194
msgid "A second example. Here is a complete C program that selects, using index key :code:`[99999]`, from space :code:`examples` via the high-level C API. To display the results the program uses functions in the `MsgPuck`_ library which allow decoding of `MessagePack`_  arrays."
msgstr ""

#: ../book/connectors/__c.rst:200
msgid "#include <stdio.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../book/connectors/__c.rst:263
msgid "The example programs only shows two requests and do not show all that's necessary for good practice. For that, see http://github.com/tarantool/tarantool-c."
msgstr ""

#: ../book/index.rst:28
msgid "User Guide"
msgstr ""

#: ../book/intro.rst:28
msgid "Preface"
msgstr ""

#: ../book/intro.rst:32
msgid "Tarantool: an overview"
msgstr ""

#: ../book/intro.rst:34
msgid "Tarantool is a Lua application server integrated with a database management system. It has a \"fiber\" model which means that many applications can run simultaneously on a single thread, while the Tarantool server can run multiple threads for input-output and background maintenance. It integrates the LuaJIT -- \"Just In Time\" -- Lua compiler, Lua libraries for most common applications, and the Tarantool Database Server which is an established NoSQL DBMS. Thus it serves all the purposes that have made node.js and Twisted popular in other environments, with the additional twist that it has a data persistence level."
msgstr ""

#: ../book/intro.rst:43
msgid "The code is free. The open-source license is `BSD license`_. The supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""

#: ../book/intro.rst:46
msgid "Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet company in Russia, with 30 million users, 25 million emails per day, and a web site whose Alexa global rank is in the `top 40`_ worldwide. Tarantool services Mail.Ru's hottest data, such as the session data of online users, the properties of online applications, the caches of the underlying data, the distribution and sharding algorithms, and much more. Outside Mail.Ru the software is used by a growing number of projects in online gaming, digital marketing, and social media industries. While product development is sponsored by Mail.Ru, the roadmap and the bugs database and the development process are fully open. The software incorporates patches from dozens of community contributors. The Tarantool community writes and maintains most of the drivers for programming languages.  The greater Lua community has hundreds of useful packages most of which can become Tarantool extensions."
msgstr ""

#: ../book/intro.rst:60
msgid "Users can create, modify and drop **Lua functions** at runtime. Or they can define **Lua programs** that are loaded during startup for triggers, background tasks, and interacting with networked peers. Unlike popular application development frameworks based on a \"reactor\" pattern, networking in server-side Lua is sequential, yet very efficient, as it is built on top of the **cooperative multitasking** environment that Tarantool itself uses. A key feature is that the functions can access and modify databases atomically.  Thus some developers look at it as a DBMS with a popular stored procedure language, while others look at it as a replacement for multiple components of multi-tier Web application architectures. Performance can be a few hundred thousand transactions per second on a laptop, scalable upwards or outwards to server farms."
msgstr ""

#: ../book/intro.rst:73
msgid "**Tarantool is lock-free** in typical situations. Instead of the operating system's concurrency primitives, such as mutexes, Tarantool uses cooperative multitasking to handle thousands of connections simultaneously. There is a fixed number of independent execution threads. The threads do not share state. Instead they exchange data using low-overhead message queues. While this approach limits the number of cores that the server will use, it removes competition for the memory bus and ensures peak scalability of memory access and network throughput. CPU utilization of a typical highly-loaded Tarantool server is under 10%."
msgstr ""

#: ../book/intro.rst:82
msgid "Although Tarantool can run without it, the database management component is a strong distinguishing feature. (On the surface Tarantool is simply a Lua language interpreter and the DBMS server is one of many built-in Lua packages.) So here is a closer look at \"The Box\", or DBMS server."
msgstr ""

#: ../book/intro.rst:88
msgid "The database API allows for persisting Lua objects to disk, managing object collections, creating or dropping secondary keys, configuring and monitoring replication, performing controlled fail-over, and executing Lua code triggered by database events. Remote database instances are accessible transparently via a remote procedure invocation API."
msgstr ""

#: ../book/intro.rst:95
msgid "Tarantool's DBMS server uses the **storage engine** concept, where different sets of algorithms and data structures can be used for different collections of objects. Two storage engines are built-in: an in-memory engine which has all the data and indexes in RAM, and a two-level B-tree engine for data sets whose size is 10 to 1000 times the amount of available RAM. All storage engines in Tarantool support transactions and replication by using a common **write ahead log** (WAL). This ensures consistency and crash safety of the persistent state. The server performs inserts and updates atomically -- changes are not considered complete until the WAL is written. The logging subsystem supports group commit."
msgstr ""

#: ../book/intro.rst:107
msgid "**Tarantool in-memory storage engine** (memtx) keeps all the data in random-access memory, and therefore has very low read latency. It also keeps persistent copies of the data in non-volatile storage, such as disk, when users request \"snapshots\". If a server stops and the random-access memory is lost, then restarts, it reads the latest snapshot and then replays the transactions that are in the log -- therefore no data is lost."
msgstr ""

#: ../book/intro.rst:116
msgid "**Tarantool disk-based storage engine** is a fusion of ideas from modern filesystems, log-structured merge trees and classical B-trees. All data is organized into **branches**. Each branch is represented by a file on disk. Branch size is a configuration option and normally is around 64MB. Each branch is a collection of pages, serving different purposes. Pages in a fully merged branch contain non-overlapping ranges of keys. A branch can be partially merged if there were a lot of changes in its key range recently. In that case some pages represent new keys and values in the branch. The disk-based storage engine is append only: new data never overwrites old data."
msgstr ""

#: ../book/intro.rst:127
msgid "Unlike most NoSQL DBMSs, Tarantool supports **secondary index keys** as well as primary keys, and **multi-part index keys**. The possible index types are HASH, TREE, BITSET, and RTREE."
msgstr ""

#: ../book/intro.rst:131
msgid "Tarantool supports **asynchronous replication**, locally or to remote hosts. The replication architecture can be **master-master**, that is, many nodes may both handle the loads and receive what others have handled, for the same data sets."
msgstr ""

#: ../book/intro.rst:138
msgid "Conventions"
msgstr ""

#: ../book/intro.rst:140
msgid "This manual is written with `Sphinx`_ markup and uses standard formatting conventions:"
msgstr ""

#: ../book/intro.rst:143
msgid "UNIX shell command input is prefixed with '``$``' and is in a fixed-width font:"
msgstr ""

#: ../book/intro.rst:145
msgid "$ tarantool --help"
msgstr ""

#: ../book/intro.rst:149
msgid "File names are also in a fixed-width font:"
msgstr ""

#: ../book/intro.rst:151
msgid ":codenormal:`/path/to/var/dir`"
msgstr ""

#: ../book/intro.rst:153
msgid "Text that represents user input is in boldface:"
msgstr ""

#: ../book/intro.rst:155
msgid ":codebold:`$ your input here`"
msgstr ""

#: ../book/intro.rst:157
msgid "Within user input, replaceable items are in italics:"
msgstr ""

#: ../book/intro.rst:159
msgid ":codebold:`$ tarantool` :codebolditalic:`--option`"
msgstr ""

#: ../book/intro.rst:163
msgid "How to read the documentation"
msgstr ""

#: ../book/intro.rst:165
msgid "To get started, one can either download the whole package as described in the first part of Chapter 2 \"Getting started\", or one can initially skip the download and connect to the online Tarantool server running on the web at http://try.tarantool.org. Either way, the first tryout can be a matter of following the example in the second part of chapter 2: \"Starting Tarantool and making your first database\"."
msgstr ""

#: ../book/intro.rst:172
msgid "Chapter 3 \"Database\" is about the Tarantool NoSQL DBMS. If the only intent is to use Tarantool as a Lua application server, most of the material in this chapter and in the following chapter (Chapter 4 \"Replication\") will not be necessary. Once again, the detailed instructions about each package can be regarded as reference material."
msgstr ""

#: ../book/intro.rst:178
msgid "Chapter 6 \"Server administration\" and Chapter 5 \"Configuration reference\" are primarily for administrators; however, every user should know something about how the server is configured so the section about box.cfg is not skippable. Chapter 7 \"Connectors\" is strictly for users who are connecting from a different language such as C or Perl or Python -- other users will find no immediate need for this chapter."
msgstr ""

#: ../book/intro.rst:184
msgid "The two long tutorials in Appendix C -- \"Insert one million tuples with a Lua stored procedure\" and \"Sum a JSON field for all tuples\" -- start slowly and contain commentary that is especially aimed at users who may not consider themselves experts at either Lua or NoSQL database management."
msgstr ""

#: ../book/intro.rst:188
msgid "Finally, Appendix D \"Modules\" has examples that will be essential for those users who want to connect the Tarantool server to another DBMS: MySQL or PostgreSQL."
msgstr ""

#: ../book/intro.rst:191
msgid "For experienced users, there is also a developer's guide and an extensive set of comments in the source code."
msgstr ""

#: ../book/intro.rst:195
msgid "Reporting bugs"
msgstr ""

#: ../book/intro.rst:197
msgid "Please report bugs in Tarantool at http://github.com/tarantool/tarantool/issues. You can contact developers directly on the `#tarantool` IRC channel on freenode.net, or via a mailing list, `Tarantool Google group`_."
msgstr ""

#: ../book/replication/index.rst:32
msgid "Replication allows multiple Tarantool servers to work on copies of the same databases. The databases are kept in synch because each server can communicate its changes to all the other servers. Servers which share the same databases are a \"cluster\". Each server in a cluster also has a numeric identifier which is unique within the cluster, known as the \"server id\"."
msgstr ""

#: ../book/replication/index.rst:38
msgid "To set up replication, it's necessary to set up the master servers which make the original data-change requests, set up the replica servers which copy data-change requests from masters, and establish procedures for recovery from a degraded state."
msgstr ""

#: ../book/replication/index.rst:45
msgid "Replication architecture"
msgstr ""

#: ../book/replication/index.rst:47
msgid "A replica gets all updates from the master by continuously fetching and applying its write-ahead log (WAL). Each record in the WAL represents a single Tarantool data-change request such as INSERT or UPDATE or DELETE, and is assigned a monotonically growing log sequence number (LSN). In essence, Tarantool replication is row-based: each data change command is fully deterministic and operates on a single tuple."
msgstr ""

#: ../book/replication/index.rst:54
msgid "A stored program invocation is not written to the write-ahead log. Instead, log events for actual data-change requests, performed by the Lua code, are written to the log. This ensures that possible non-determinism of Lua does not cause replication to go out of sync."
msgstr ""

#: ../book/replication/index.rst:61
msgid "Setting up the master"
msgstr ""

#: ../book/replication/index.rst:63
msgid "To prepare the master for connections from the replica, it's only necessary to include \":ref:`listen <box-cfg-listen>`\" in the initial ``box.cfg`` request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen\" URI can accept connections from as many replicas as necessary on that URI. Each replica has its own replication state."
msgstr ""

#: ../book/replication/index.rst:71
msgid "Setting up a replica"
msgstr ""

#: ../book/replication/index.rst:73
msgid "A server requires a valid snapshot (.snap) file. A snapshot file is created for a server the first time that ``box.cfg`` occurs for it. If this first ``box.cfg`` request occurs without a \"replication source\" clause, then the server is a master and starts its own new cluster with a new unique UUID. If this first ``box.cfg`` request occurs with a \"replication source\" clause, then the server is a replica and its snapshot file, along with the cluster information, is constructed from the write-ahead logs of the master. Therefore, to start replication, specify :confval:`replication_source` in a ``box.cfg`` request. When a replica contacts a master for the first time, it becomes part of a cluster. On subsequent occasions, it should always contact a master in the same cluster."
msgstr ""

#: ../book/replication/index.rst:85
msgid "Once connected to the master, the replica requests all changes that happened after the latest local LSN. It is therefore necessary to keep WAL files on the master host as long as there are replicas that haven't applied them yet. A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap file and the WAL .xlog files), then starting replication again - the replica will then catch up with the master by retrieving all the master's tuples. Again, this procedure works only if the master's WAL files are present."
msgstr ""

#: ../book/replication/index.rst:93
msgid "NOTE: Replication parameters are \"dynamic\", which allows the replica to become a master and vice versa with the help of the :func:`box.cfg` statement."
msgstr ""

#: ../book/replication/index.rst:97
msgid "NOTE: The replica does not inherit the master's configuration parameters, such as the ones that cause the :ref:`snapshot daemon <book-cfg-snapshot_daemon>` to run on the master. To get the same behavior, one would have to set the relevant parameters explicitly so that they are the same on both master and replica."
msgstr ""

#: ../book/replication/index.rst:103
msgid "NOTE: Replication requires privileges. Privileges for accessing spaces could be granted directly to the user who will start the replica. However, it is more usual to grant privileges for accessing spaces to a :ref:`role <rep-role>`, and then grant the role to the user who will start the replica."
msgstr ""

#: ../book/replication/index.rst:111
msgid "Recovering from a degraded state"
msgstr ""

#: ../book/replication/index.rst:113
msgid "\"Degraded state\" is a situation when the master becomes unavailable - due to hardware or network failure, or due to a programming bug. There is no automatic way for a replica to detect that the master is gone forever, since sources of failure and replication environments vary significantly. So the detection of degraded state requires a human inspection."
msgstr ""

#: ../book/replication/index.rst:119
msgid "However, once a master failure is detected, the recovery is simple: declare that the replica is now the new master, by saying :codenormal:`box.cfg{... listen=`:codeitalic:`URI`:codenormal:`}`. Then, if there are updates on the old master that were not propagated before the old master went down, they would have to be re-applied manually."
msgstr ""

#: ../book/replication/index.rst:127
msgid "Instructions for quick startup of a new two-server simple cluster"
msgstr ""

#: ../book/replication/index.rst:129
msgid "Step 1. Start the first server thus:"
msgstr ""

#: ../book/replication/index.rst:134
msgid "box.cfg{listen = *uri#1*}\n"
"-- replace with more restrictive request\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
"box.snapshot()"
msgstr ""

#: ../book/replication/index.rst:139
msgid "... Now a new cluster exists."
msgstr ""

#: ../book/replication/index.rst:141
msgid "Step 2. Check where the second server's files will go by looking at its directories (:confval:`snap_dir` for snapshot files, :confval:`wal_dir` for .xlog files). They must be empty - when the second server joins for the first time, it has to be working with a clean slate so that the initial copy of the first server's databases can happen without conflicts."
msgstr ""

#: ../book/replication/index.rst:147
msgid "Step 3. Start the second server thus:"
msgstr ""

#: ../book/replication/index.rst:152
msgid "box.cfg{\n"
"  listen = *uri#2*,\n"
"  replication_source = *uri#1*\n"
"}"
msgstr ""

#: ../book/replication/index.rst:157
msgid "... where ``uri#1`` = the :ref:`URI` that the first server is listening on."
msgstr ""

#: ../book/replication/index.rst:159
msgid "That's all."
msgstr ""

#: ../book/replication/index.rst:161
msgid "In this configuration, the first server is the \"master\" and the second server is the \"replica\". Henceforth every change that happens on the master will be visible on the replica. A simple two-server cluster with the master on one computer and the replica on a different computer is very common and provides two benefits: FAILOVER (because if the master goes down then the replica can take over), or LOAD BALANCING (because clients can connect to either the master or the replica for select requests)."
msgstr ""

#: ../book/replication/index.rst:171
msgid "Monitoring a Replica's Actions"
msgstr ""

#: ../book/replication/index.rst:173
msgid "In :func:`box.info` there is a :code:`box.info.replication.status` field: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", then there will be two more fields: |br| :code:`box.info.replication.idle` = the number of seconds the replica has been idle, |br| :code:`box.info.replication.lag` = the number of seconds the replica is behind the master."
msgstr ""

#: ../book/replication/index.rst:179
msgid "In the :mod:`log` there is a record of replication activity. If a primary server is started with:"
msgstr ""

#: ../book/replication/index.rst:185
msgid "box.cfg{\n"
"  <...>,\n"
"  logger = *log file name*,\n"
"  <...>\n"
"}"
msgstr ""

#: ../book/replication/index.rst:191
msgid "then there will be lines in the log file, containing the word \"relay\", when a replica connects or disconnects."
msgstr ""

#: ../book/replication/index.rst:196
msgid "Preventing Duplicate Actions"
msgstr ""

#: ../book/replication/index.rst:198
msgid "Suppose that the replica tries to do something that the master has already done. For example: |br| :code:`box.schema.space.create('X')` |br| This would cause an error, \"Space X exists\". For this particular situation, the code could be changed to: |br| :code:`box.schema.space.create('X', {if_not_exists=true})` |br| But there is a more general solution: the :samp:`box.once({key}, {function})` method. If :code:`box.once()` has been called before with the same :samp:`{key}` value, then :samp:`{function}` is ignored; otherwise :samp:`{function}` is executed. Therefore, actions which should only occur once during the life of a replicated session should be placed in a function which is executed via :code:`box.once()`. For example:"
msgstr ""

#: ../book/replication/index.rst:213
msgid "function f()\n"
"  box.schema.space.create('X')\n"
"end\n"
"box.once('space_creator', f)"
msgstr ""

#: ../book/replication/index.rst:222
msgid "Master-Master Replication"
msgstr ""

#: ../book/replication/index.rst:224
msgid "In the simple master-replica configuration, the master's changes are seen by the replica, but not vice versa, because the master was specified as the sole replication source. In the master-master configuration, it's possible to go both ways. Starting with the simple configuration, the first server has to say:"
msgstr ""

#: ../book/replication/index.rst:232
msgid "box.cfg{ replication_source = *uri#2* }"
msgstr ""

#: ../book/replication/index.rst:234
msgid "This request can be performed at any time."
msgstr ""

#: ../book/replication/index.rst:236
msgid "In this configuration, both servers are \"masters\" and both servers are \"replicas\". Henceforth every change that happens on either server will be visible on the other. The failover benefit is still present, and the load-balancing benefit is enhanced (because clients can connect to either server for data-change requests as well as select requests)."
msgstr ""

#: ../book/replication/index.rst:242
msgid "If two operations for the same tuple take place \"concurrently\" (which can involve a long interval because replication is asynchronous), and one of the operations is ``delete`` or ``replace``, there is a possibility that servers will end up with different contents."
msgstr ""

#: ../book/replication/index.rst:250
msgid "All the \"What If?\" Questions"
msgstr ""

#: ../book/replication/index.rst:253
msgid "What if there are more than two servers with master-master?"
msgstr ""

#: ../book/replication/index.rst:254
msgid "On each server, specify the :confval:`replication_source` for all the others. For example, server #3 would have a request:"
msgstr ""

#: ../book/replication/index.rst:264
msgid "What if a server should be taken out of the cluster?"
msgstr ""

#: ../book/replication/index.rst:265
msgid "Run ``box.cfg{}`` again specifying a blank replication source: ``box.cfg{replication_source=''}``"
msgstr ""

#: ../book/replication/index.rst:268
msgid "What if a server leaves the cluster?"
msgstr ""

#: ../book/replication/index.rst:269
msgid "The other servers carry on. If the wayward server rejoins, it will receive all the updates that the other servers made while it was away."
msgstr ""

#: ../book/replication/index.rst:272
msgid "What if two servers both change the same tuple?"
msgstr ""

#: ../book/replication/index.rst:273
msgid "The last changer wins. For example, suppose that server#1 changes the tuple, then server#2 changes the tuple. In that case server#2's change overrides whatever server#1 did. In order to keep track of who came last, Tarantool implements a `vector clock`_."
msgstr ""

#: ../book/replication/index.rst:278
msgid "What if two servers both insert the same tuple?"
msgstr ""

#: ../book/replication/index.rst:279
msgid "If a master tries to insert a tuple which a replica has inserted already, this is an example of a severe error. Replication stops. It will have to be restarted manually."
msgstr ""

#: ../book/replication/index.rst:283
msgid "What if a master disappears and the replica must take over?"
msgstr ""

#: ../book/replication/index.rst:284
msgid "A message will appear on the replica stating that the connection is lost. The replica must now become independent, which can be done by saying ``box.cfg{replication_source=''}``."
msgstr ""

#: ../book/replication/index.rst:288
msgid "What if it's necessary to know what cluster a server is in?"
msgstr ""

#: ../book/replication/index.rst:289
msgid "The identification of the cluster is a UUID which is generated when the first master starts for the first time. This UUID is stored in a tuple of the :data:`box.space._schema` system space. So to see it, say: ``box.space._schema:select{'cluster'}``"
msgstr ""

#: ../book/replication/index.rst:294
msgid "What if it's necessary to know what other servers belong in the cluster?"
msgstr ""

#: ../book/replication/index.rst:295
msgid "The universal identification of a server is a UUID in ``box.info.server.uuid``. The ordinal identification of a server within a cluster is a number in ``box.info.server.id``. To see all the servers in the cluster, say: ``box.space._cluster:select{}``. This will return a table with all {server.id, server.uuid} tuples for every server that has ever joined the cluster."
msgstr ""

#: ../book/replication/index.rst:302
msgid "What if one of the server's files is corrupted or deleted?"
msgstr ""

#: ../book/replication/index.rst:303
msgid "Stop the server, destroy all the database files (the ones with extension \"snap\" or \"xlog\" or \".inprogress\"), restart the server, and catch up with the master by contacting it again (just say ``box.cfg{...replication_source=...}``)."
msgstr ""

#: ../book/replication/index.rst:308
msgid "What if replication causes security concerns?"
msgstr ""

#: ../book/replication/index.rst:309
msgid "Prevent unauthorized replication sources by associating a password with every user that has access privileges for the relevant spaces, and every user that has a replication :ref:`role <rep-role>`. That way, the :ref:`URI` for the :confval:`replication_source` parameter will always have to have the long form ``replication_source='username:password@host:port'``"
msgstr ""

#: ../book/replication/index.rst:320
msgid "Hands-On Replication Tutorial"
msgstr ""

#: ../book/replication/index.rst:322
msgid "After following the steps here, an administrator will have experience creating a cluster and adding a replica."
msgstr ""

#: ../book/replication/index.rst:325
msgid "Start two shells. Put them side by side on the screen. (This manual has a tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to switch to the display of the other shell.)"
msgstr ""

#: ../book/replication/index.rst:351
#: ../book/replication/index.rst:358
#: ../book/replication/1-2.rst:1
msgid "$"
msgstr ""

#: ../book/replication/index.rst:392
msgid "On the first shell, which we'll call Terminal #1, execute these commands:"
msgstr ""

#: ../book/replication/index.rst:394
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_1/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"tarantool> box.schema.role.grant('replication','read,write','universe')\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/index.rst:407
msgid "The result is that a new cluster is set up, and the server's UUID is displayed. Now the screen looks like this: (except that UUID values are always different):"
msgstr ""

#: ../book/replication/1-1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.6.3-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.role.grant('replication','read,write','universe')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:469
msgid "On the second shell, which we'll call Terminal #2, execute these commands:"
msgstr ""

#: ../book/replication/index.rst:471
msgid "$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ~/tarantool_test_node_2/*\n"
"$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/index.rst:484
msgid "The result is that a replica is set up. Messages appear on Terminal #1 confirming that the replica has connected and that the WAL contents have been shipped to the replica. Messages appear on Terminal #2 showing that replication is starting. Also on Terminal#2 the _cluster UUID values are displayed, and one of them is the same as the _cluster UUID value that was displayed on Terminal #1, because both servers are in the same cluster."
msgstr ""

#: ../book/replication/2-1.rst:1
msgid "$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [25020] main/101/spawner I> created a replication relay: pid = 25583\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> recovery start\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> recovering from ./00000000000000000000.snap'\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> snapshot sent\n"
"<...> [25020] main/101/spawner I> created a replication relay: pid = 25585\n"
"<...> [25585] main/101/relay/127.0.0.1:50884 I> recover from ./00000000000000000000.xlog'"
msgstr ""

#: ../book/replication/2-2.rst:1
#: ../book/replication/3-2.rst:1
msgid "$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.6.3-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<... ...>\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"<...> [25579] main/103/replica/localhost:3301 C> connected to 127.0.0.1:3301\n"
"<...> [25579] main/103/replica/localhost:3301 I> authenticated\n"
"<...> [25579] wal I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:550
msgid "On Terminal #1, execute these requests:"
msgstr ""

#: ../book/replication/index.rst:552
msgid "tarantool> s = box.schema.space.create('tester')\n"
"tarantool> i = s:create_index('primary', {})\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
msgstr ""

#: ../book/replication/index.rst:558
msgid "Now the screen looks like this:"
msgstr ""

#: ../book/replication/3-1.rst:1
#: ../book/replication/4-1.rst:1
msgid "<... ...>\n"
"tarantool>\n"
"<...> [25020] main/101/spawner I> created a replication relay: pid = 25583\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> recovery start\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> recovering from ./00000000000000000000.snap'\n"
"<...> [25583] main/101/relay/127.0.0.1:50883 I> snapshot sent\n"
"<...> [25020] main/101/spawner I> created a replication relay: pid = 25585\n"
"<...> [25585] main/101/relay/127.0.0.1:50884 I> recover from ./00000000000000000000.xlog'\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:619
msgid "The creation and insertion were successful on Terminal #1. Nothing has happened on Terminal #2."
msgstr ""

#: ../book/replication/index.rst:622
msgid "On Terminal #2, execute these requests:"
msgstr ""

#: ../book/replication/index.rst:624
msgid "tarantool> s = box.space.tester\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
msgstr ""

#: ../book/replication/index.rst:630
msgid "Now the screen looks like this (remember to click on the \"Terminal #2\" tab when looking at Terminal #2 results):"
msgstr ""

#: ../book/replication/4-2.rst:1
msgid "<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"<...> [25579] main/103/replica/localhost:3301 C> connected to 127.0.0.1:3301\n"
"<...> [25579] main/103/replica/localhost:3301 I> authenticated\n"
"<...> [25579] wal I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:691
msgid "The selection and insertion were successful on Terminal #2. Nothing has happened on Terminal #1."
msgstr ""

#: ../book/replication/index.rst:694
msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
msgstr ""

#: ../book/replication/index.rst:696
msgid "$ os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"$ ls -l ~/tarantool_test_node_2"
msgstr ""

#: ../book/replication/index.rst:702
msgid "Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that fact. The ``ls -l`` commands show that both servers have made snapshots, which have similar sizes because they both contain the same tuples."
msgstr ""

#: ../book/replication/5-1.rst:1
#: ../book/replication/6-1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"<...> [25585] main/101/relay/127.0.0.1:50884 I> done ./00000000000000000000.xlog'\n"
"<...> [25020] main/101/spawner I> Exiting: master shutdown\n"
"<...> [25020] main/101/spawner I> sending signal 15 to 1 children\n"
"<...> [25020] main/101/spawner I> waiting for children for up to 5 seconds\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  1781 Oct 13 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   518 Oct 13 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  1781 Oct 13 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   588 Oct 13 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""

#: ../book/replication/5-2.rst:1
msgid "<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""

#: ../book/replication/index.rst:765
msgid "On Terminal #2, ignore the repeated messages saying \"failed to connect\", and execute these requests:"
msgstr ""

#: ../book/replication/index.rst:768
msgid "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"tarantool> box.space.tester:insert{3, 'Another'}"
msgstr ""

#: ../book/replication/index.rst:773
msgid "Now the screen looks like this (ignoring the repeated messages saying \"failed to connect\"):"
msgstr ""

#: ../book/replication/6-2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""

#: ../book/replication/index.rst:835
msgid "Terminal #2 has done a select and an insert, even though Terminal #1 is down."
msgstr ""

#: ../book/replication/index.rst:837
msgid "On Terminal #1 execute these commands:"
msgstr ""

#: ../book/replication/index.rst:839
msgid "$ ~/tarantool/src/tarantool\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.space.tester:select({0}, {iteratir = 'GE'})"
msgstr ""

#: ../book/replication/index.rst:845
msgid "Now the screen looks like this (ignoring the repeated messages on terminal #2 saying \"failed to connect\"):"
msgstr ""

#: ../book/replication/7-1.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"<...> [25585] main/101/relay/127.0.0.1:50884 I> done ./00000000000000000000.xlog'\n"
"<...> [25020] main/101/spawner I> Exiting: master shutdown\n"
"<...> [25020] main/101/spawner I> sending signal 15 to 1 children\n"
"<...> [25020] main/101/spawner I> waiting for children for up to 5 seconds\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  1781 Oct 13 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   518 Oct 13 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  1781 Oct 13 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   588 Oct 13 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.6.3-515-g0a06cce\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"<...> [28989] main/101/spawner I> created a replication relay: pid = 28992\n"
"<...> [28992] main/101/relay/127.0.0.1:51892 I> recover from ./00000000000000000000.xlog'\n"
"<...> [28992] main/101/relay/127.0.0.1:51892 I> done ./00000000000000000000.xlog'\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../book/replication/7-2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [25579] main/103/replica/localhost:3301 C> connected to 127.0.0.1:3301\n"
"<...> [25579] main/103/replica/localhost:3301 I> authenticated"
msgstr ""

#: ../book/replication/index.rst:907
msgid "The master has reconnected to the cluster, and has NOT found what the replica wrote while the master was away. That is not a surprise -- the replica has not been asked to act as a replication source."
msgstr ""

#: ../book/replication/index.rst:911
msgid "On Terminal #1, say:"
msgstr ""

#: ../book/replication/index.rst:913
msgid "tarantool> box.cfg{\n"
"         >   replication_source = 'replicator:password@localhost:3302'\n"
"         > }\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../book/replication/8-1.rst:1
msgid "<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.6.3-515-g0a06cce\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"<...> [28989] main/101/spawner I> created a replication relay: pid = 28992\n"
"<...> [28992] main/101/relay/127.0.0.1:51892 I> recover from ./00000000000000000000.xlog'\n"
"<...> [28992] main/101/relay/127.0.0.1:51892 I> done ./00000000000000000000.xlog'\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
" [28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"<...> [28987] main/104/replica/localhost:3302 C> connected to 127.0.0.1:3302\n"
"<...> [28987] main/104/replica/localhost:3302 I> authenticated\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"<...> [28987] wal I> creating ./00000000000000000006.xlog.inprogress'\n"
"<...> [28992] main/101/relay/127.0.0.1:51892 I> recover from ./00000000000000000006.xlog'\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""

#: ../book/replication/8-2.rst:1
msgid "<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [25579] main/103/replica/localhost:3301 C> connected to 127.0.0.1:3301\n"
"<...> [25579] main/103/replica/localhost:3301 I> authenticated\n"
"<...> [25581] main/101/spawner I> created a replication relay: pid = 29632\n"
"<...> [29632] main/101/relay/127.0.0.1:45908 I> recover from ./00000000000000000000.xlog'"
msgstr ""

#: ../book/replication/index.rst:981
msgid "This shows that the two servers are once again in synch, and that each server sees what the other server wrote."
msgstr ""

#: ../book/replication/index.rst:984
msgid "To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and then on either terminal say:"
msgstr ""

#: ../book/replication/index.rst:987
msgid "$ cd ~\n"
"$ rm -R ~/tarantool_test_node_1\n"
"$ rm -R ~/tarantool_test_node_2"
msgstr ""

#: ../book/user_guide_getting_started.rst:28
msgid "Getting started"
msgstr ""

#: ../book/user_guide_getting_started.rst:30
msgid "UGGS - This chapter shows how to download, how to install, and how to start Tarantool for the first time."
msgstr ""

#: ../book/user_guide_getting_started.rst:33
msgid "For production, if possible, you should download a binary (executable) package. This will ensure that you have the same build of the same version that the developers have. That makes analysis easier if later you need to report a problem, and avoids subtle problems that might happen if you used different tools or different parameters when building from source. The section about binaries is “`Downloading and installing a binary package`_”."
msgstr ""

#: ../book/user_guide_getting_started.rst:40
msgid "For development, you will want to download a source package and make the binary by yourself using a C/C++ compiler and common tools. Although this is a bit harder, it gives more control. And the source packages include additional files, for example the Tarantool test suite. The section about source is “:ref:`building-from-source`”."
msgstr ""

#: ../book/user_guide_getting_started.rst:45
msgid "If the installation has already been done, then you should try it out. So we've provided some instructions that you can use to make a temporary “sandbox”. In a few minutes you can start the server and type in some database-manipulation statements. The section about the sandbox is “`Starting Tarantool and making your first database`_”."
msgstr ""

#: ../book/user_guide_getting_started.rst:54
msgid "Downloading and installing a binary package"
msgstr ""

#: ../book/user_guide_getting_started.rst:56
msgid "Binary packages for the stable 1.6.x release are provided at http://tarantool.org/download.html. An automatic build system creates, tests and publishes packages for every push into the 1.6 branch."
msgstr ""

#: ../book/user_guide_getting_started.rst:60
msgid "To download and install the package that's appropriate for your OS, start a shell (terminal) and enter the command-line instructions provided for your OS at http://tarantool.org/download.html."
msgstr ""

#: ../book/user_guide_getting_started.rst:69
msgid "Starting Tarantool and making your first database"
msgstr ""

#: ../book/user_guide_getting_started.rst:71
#: ../book/user_guide_getting_started.rst:80
msgid "Here is how to create a simple test database after installing."
msgstr ""

#: ../book/user_guide_getting_started.rst:73
msgid "Create a new directory. It's just for tests, you can delete it when the tests are over."
msgstr ""

#: ../book/user_guide_getting_started.rst:75
msgid "$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""

#: ../book/user_guide_getting_started.rst:82
msgid "Start the server. The server name is tarantool."
msgstr ""

#: ../book/user_guide_getting_started.rst:84
msgid "$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary\n"
"$ # tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""

#: ../book/user_guide_getting_started.rst:94
msgid "The server starts in interactive mode and outputs a command prompt. To turn on the database, :mod:`configure <box.cfg>` it. This minimal example is sufficient:"
msgstr ""

#: ../book/user_guide_getting_started.rst:97
msgid "tarantool> box.cfg{listen = 3301}"
msgstr ""

#: ../book/user_guide_getting_started.rst:101
msgid "If all goes well, you will see the server displaying progress as it initializes, something like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:104
msgid "tarantool> box.cfg{listen = 3301}\n"
"2015-08-07 09:41:41.077 ... version 1.6.7-439-g7e1011b\n"
"2015-08-07 09:41:41.077 ... log level 5\n"
"2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
"2015-08-07 09:41:41.079 ... initialized\n"
"2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
"2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap.inprogress'\n"
"2015-08-07 09:41:41.127 ... done\n"
"2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
"2015-08-07 09:41:41.128 ... ready to accept requests"
msgstr ""

#: ../book/user_guide_getting_started.rst:118
msgid "Now that the server is up, you could start up a different shell and connect to its primary port with:"
msgstr ""

#: ../book/user_guide_getting_started.rst:121
msgid "$ telnet 0 3301"
msgstr ""

#: ../book/user_guide_getting_started.rst:125
msgid "but for example purposes it is simpler to just leave the server running in \"interactive mode\". On production machines the interactive mode is just for administrators, but because it's convenient for learning it will be used for most examples in this manual. Tarantool is waiting for the user to type instructions."
msgstr ""

#: ../book/user_guide_getting_started.rst:131
msgid "To create the first space and the first :ref:`index <box.index>`, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:133
msgid "tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'NUM'}\n"
"         > })"
msgstr ""

#: ../book/user_guide_getting_started.rst:141
msgid "To insert three “tuples” (our name for “records”) into the first “space” of the database try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:143
msgid "tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"
msgstr ""

#: ../book/user_guide_getting_started.rst:149
msgid "To select a tuple from the first space of the database, using the first defined key, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:151
msgid "tarantool> s:select{3}"
msgstr ""

#: ../book/user_guide_getting_started.rst:155
msgid "Your terminal screen should now look like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:157
msgid "tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'NUM'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"
msgstr ""

#: ../book/user_guide_getting_started.rst:181
msgid "Now, to prepare for the example in the next section, try this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:183
msgid "tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../book/user_guide_getting_started.rst:193
msgid "Starting another Tarantool instance and connecting remotely"
msgstr ""

#: ../book/user_guide_getting_started.rst:195
msgid "In the previous section the first request was with :code:`box.cfg{listen = 3301}`. The :code:`listen` value can be any form of URI (uniform resource identifier); in this case it's just a local port: port 3301. It's possible to send requests to the listen URI via (a) telnet, (b) a connector (which will be the subject of the :ref:`Connectors <box-connectors>` chapter), or (c) another instance of Tarantool. Let's try (c)."
msgstr ""

#: ../book/user_guide_getting_started.rst:202
msgid "Switch to another terminal. On Linux, for example, this means starting another instance of a Bash shell. There is no need to use cd to switch to the :code:`~/tarantool_sandbox` directory."
msgstr ""

#: ../book/user_guide_getting_started.rst:206
msgid "Start the second instance of Tarantool. The server name is tarantool."
msgstr ""

#: ../book/user_guide_getting_started.rst:208
msgid "$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a\n"
"$ # binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # if you built from a source download, say this:\n"
"$ ~/tarantool/src/tarantool"
msgstr ""

#: ../book/user_guide_getting_started.rst:218
msgid "Try these requests:"
msgstr ""

#: ../book/user_guide_getting_started.rst:220
msgid "tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select{2}"
msgstr ""

#: ../book/user_guide_getting_started.rst:226
msgid "The requests are saying \"use the :ref:`console package <package-console>` to connect to the Tarantool server that's listening on ``localhost:3301``, send a request to that server, and display the result.\" The result in this case is one of the tuples that was inserted earlier. Your terminal screen should now look like this:"
msgstr ""

#: ../book/user_guide_getting_started.rst:235
msgid "tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool: connected to localhost:3301\n"
"---\n"
"- true\n"
"...\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"localhost:3301>"
msgstr ""

#: ../book/user_guide_getting_started.rst:251
msgid "You can repeat :code:`box.space...:insert{}` and :code:`box.space...:select{}` indefinitely, on either Tarantool instance. When the testing is over: To drop the space: :code:`s:drop()`. To stop tarantool: Ctrl+C. To stop tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool (from another terminal): :code:`sudo pkill -f tarantool`. To destroy the test: :code:`rm -r ~/tarantool_sandbox`."
msgstr ""

#: ../book/user_guide_getting_started.rst:259
msgid "To review ... If you followed all the instructions in this chapter, then so far you have: installed Tarantool from either a binary or a source repository, started up the Tarantool server, inserted and selected tuples."
msgstr ""

